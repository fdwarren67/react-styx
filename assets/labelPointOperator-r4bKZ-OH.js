import{eC as H,gw as J,gs as K,gx as $,go as M,gy as w,gA as v,hh as W,gB as Z,v4 as ee,kr as k,gn as y,v5 as X,kw as G,v6 as te,gS as ne,hr as re,qg as R,qf as U,v3 as V}from"./index-5Uv45sI4.js";import{u as se}from"./Centroid-DZi-eb9F-sZaMwpMU.js";import{m as A}from"./OperatorProximity-C4gYWLc6.js";class oe{getOperatorType(){return 10203}accelerateGeometry(e,o,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,o){return new I(e,o)}execute(e,o){return new I(null,o).labelPoint(e)}}class I extends J{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,o){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=o,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(K(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(e===null&&$("null pointer is not allowed"),e.getGeometryType()===M.enumPoint)return e;if(e.isEmpty())return new w({vd:e.getDescription()});switch(e.getGeometryType()){case M.enumPolygon:return this.labelPointPolygon(e);case M.enumPolyline:return this.labelPointPolyline(e);case M.enumMultiPoint:return this.labelPointMultiPoint(e);case M.enumEnvelope:return this.labelPointEnvelope(e);default:$("geometry is not supported")}}labelPointPolygon(e){const o=new v;e.queryEnvelope(o);const s=W(null,o,!0).total();let l=null,r=e;if(e.hasNonLinearSegments()){const t=new Z({copy:e}),m=ee(t,.25*s,s);k(m!==e),l=m,r=l}let u=0,P=0;for(let t=0,m=r.getPathCount();t<m;++t){const E=Math.abs(r.calculateRingArea2D(t));E>P&&(P=E,u=t)}const a=new y;if(Math.abs(P)<=2*s*s?a.setNAN():a.assign(se(r,u)),Number.isNaN(a.x)){const t=new v;return r.queryPathEnvelope(u,t),new w({pt:t.getCenter()})}if(r.getPointCount()<4)return new w({x:a.x,y:a.y});const h=y.getNAN(),n=[h.clone(),h.clone(),h.clone(),h.clone()],g=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],f=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let D=!1,p=new A().getNearestCoordinate(r,a,!0,!1);if(p.m_distance===0&&(D=!0,n[0]=a,p=new A().getNearestCoordinate(r,a,!1,!1),p.m_distance>.25*o.minDimension()*1.66666666))return new w({x:a.x,y:a.y});g[0]=p.m_distance,f[0]=0;const d=new y;let c=!1,i=.25,N=-1;const _=new v;r.queryPathEnvelope(u,_);do{let t=Number.NaN;if(n[1]=this.calculateParacentroid_(r,X(_.xmin,_.xmax,i),s),n[1].isNAN()||(p=new A().getNearestCoordinate(r,n[1],!1,!1),t=p.m_distance),t>s&&G(r,n[1],s)===1)c=!0,g[1]=t,f[1]=y.sqrDistance(n[1],a);else if(t>N&&(N=t,d.setCoordsPoint2D(n[1])),i-=.01,i<.1){if(!(N>=0))break;c=!0,g[1]=N,n[1]=d,f[1]=y.sqrDistance(n[1],a)}}while(!c);c=!1,i=.5,N=-1;let T=.01,j=1;do{let t=Number.NaN;if(n[2]=this.calculateParacentroid_(r,X(_.xmin,_.xmax,i),s),n[2].isNAN()||(p=new A().getNearestCoordinate(r,n[2],!1,!1),t=p.m_distance),t>s&&G(r,n[2],s)===1)c=!0,g[2]=t,f[2]=y.sqrDistance(n[2],a);else if(t>N&&(N=t,d.setCoordsPoint2D(n[2])),i=.5+T*j,T+=.01,j*=-1,i<.3||i>.7){if(!(N>=0))break;c=!0,g[2]=N,n[2]=d,f[2]=y.sqrDistance(n[2],a)}}while(!c);c=!1,i=.75,N=-1;do{let t=Number.NaN;if(n[3]=this.calculateParacentroid_(r,X(_.xmin,_.xmax,i),s),n[3].isNAN()||(p=new A().getNearestCoordinate(r,n[3],!1,!1),t=p.m_distance),t>s&&G(r,n[3],s)===1)c=!0,g[3]=t,f[3]=y.sqrDistance(n[3],a);else if(t>N&&(N=t,d.setCoordsPoint2D(n[3])),i+=.01,i>.9){if(!(N>=0))break;c=!0,g[3]=N,n[3]=d,f[3]=y.sqrDistance(n[3],a)}}while(!c);const b=[0,1,2,3],q=D?0:1;for(let t=q;t<4;t++)for(let m=q;m<3;m++){const E=f[m],Y=f[m+1];if(te(E,Y)>0){const F=b[m];b[m]=b[m+1],b[m+1]=F,f[m]=Y,f[m+1]=E}}let S=q,O=0,C=0;for(let t=q;t<4;t++){switch(t){case 0:C=2*g[b[t]];break;case 1:C=1.66666666*g[b[t]];break;case 2:C=1.33333333*g[b[t]];break;case 3:C=g[b[t]]}C>O&&(O=C,S=b[t])}return k(!n[S].isNAN()),new w({x:n[S].x,y:n[S].y})}labelPointPolyline(e){const o=new y;if(e.getPointCount()>2*e.getPathCount()){let s=-1,l=-Number.MAX_VALUE;for(let a=0,h=e.getPathCount();a<h;a++)if(e.getPathSize(a)>2){const n=e.calculatePathLength2D(a);n>l&&(l=n,s=a)}const r=e.getPathStart(s),u=e.getPathEnd(s),P=Math.trunc((r+u)/2);o.assign(e.getXY(P))}else{let s=-Number.MAX_VALUE;const l=e.querySegmentIterator();for(;l.nextPath();)if(l.hasNextSegment()){const r=l.nextSegment(),u=r.calculateLength2D();u>s&&(s=u,o.assign(r.getCoord2D(r.lengthToT(.5*u))))}}return new w({x:o.x,y:o.y})}labelPointMultiPoint(e){const o=new v;e.queryEnvelope(o);const s=o.getCenter(),l=new A().getNearestCoordinate(e,s,!1,!1).m_coordinate;return new w({x:l.x,y:l.y})}labelPointEnvelope(e){const o=e.getCenterXY();return new w({x:o.x,y:o.y})}calculateParacentroid_(e,o,s){const l=new v;e.queryEnvelope(l);const r=new y(o,0);let u=Number.MAX_VALUE,P=Number.MAX_VALUE,a=!1,h=!1;const n=new ne;n.setStartXYCoords(r.x,l.ymin-1),n.setEndXYCoords(r.x,l.ymax+1);const g=new v,f=new y,D=new y,p=re(y,2),d=e.querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const c=d.nextSegment();if(c.queryEnvelope(g),k(c.isMonotoneQuickAndDirty()),f.setCoordsPoint2D(n.getStartXY()),D.setCoordsPoint2D(n.getEndXY()),g.clipLine(f,D)===0||n.intersect(c,p,null,null,s)!==1)continue;const i=p[0].y;u>P?i<u&&(u=i,a=!0):i<P&&(P=i,h=!0)}return a&&h?r.y=(u+P)/2:r.setNAN(),r}}const L=new oe;function ae(x){return L.execute(x,null)}function ie(x){const e=L.executeMany(new H(x),null);return Array.from(e)}function le(){return L.supportsCurves()}function z(x){return V(ae(R(x)),U(x))}function Q(x){const e=x.map(R),o=U(x);return ie(e).map(s=>V(s,o))}const B=le(),ge=Object.freeze(Object.defineProperty({__proto__:null,execute:z,executeMany:Q,supportsCurves:B},Symbol.toStringTag,{value:"Module"})),fe=Object.freeze(Object.defineProperty({__proto__:null,execute:z,executeMany:Q,supportsCurves:B},Symbol.toStringTag,{value:"Module"}));export{ge as c,fe as l};
