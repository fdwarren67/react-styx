const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-5Uv45sI4.js","assets/index-CF9pwba9.css"])))=>i.map(i=>d[i]);
import{_ as q,cS as _,G as y,qf as a,h9 as $,qg as r,qh as u,qi as G,gd as D,qj as p,ge as L,h8 as N,qk as E,ql as A}from"./index-5Uv45sI4.js";import{u as I,a as k,s as V,c as X,i as B}from"./operatorGeodesicBuffer-5SgsxPio.js";import{e as T}from"./geodeticCurveType-CirnHLSB.js";import{m as F}from"./geodeticAreaOperator-BbQQfqZQ.js";import{f as Yt}from"./geodeticAreaOperator-BbQQfqZQ.js";import{l as H}from"./geodeticDensifyOperator-Ct34f8EM.js";import{g as tr}from"./geodeticDensifyOperator-Ct34f8EM.js";import{m as Z}from"./geodeticLengthOperator-C31HLpNI.js";import{f as or}from"./geodeticLengthOperator-C31HLpNI.js";import{i as sr}from"./areaOperator-Bg4HZbYt.js";import{x as J,l as K,f as Q}from"./operatorBuffer-Dc5ElrTF.js";import{p as ar}from"./centroidOperator-ypYEJY6c.js";import{i as ir}from"./clipOperator-DaiXAjbV.js";import{X as U,_ as W,v as Y,M as ee}from"./operatorConvexHull-ohvbursl.js";import{t as te}from"./OperatorCrosses-DVNTdVL5.js";import{i as pr}from"./cutOperator-BbA_Pg1S.js";import{l as mr}from"./densifyOperator-C4ZWN8CN.js";import{m as _r}from"./differenceOperator-BQXbjC3g.js";import{i as xr}from"./distanceOperator-hlpkxYWp.js";import{l as br}from"./equalsOperator-DfphV5O8.js";import{c as vr}from"./generalizeOperator-u1YZs3hp.js";import{s as re,u as oe,o as ne,t as se}from"./operatorIntersection-DGChqSwa.js";import{t as ue}from"./OperatorIntersects-DQHv6XIe.js";import{c as Sr}from"./labelPointOperator-r4bKZ-OH.js";import{D as ae,j as ce,w as ie}from"./operatorOffset-7_ae1WMS.js";import{t as le}from"./OperatorOverlaps-DfrSTCbu.js";import{g as Cr}from"./proximityOperator-CRKKJcYw.js";import{f as Pr}from"./relateOperator-Dft6XL2Z.js";import{s as pe,u as fe,o as me,t as $e}from"./operatorSimplify-3BczAW-7.js";import{i as Tr}from"./symmetricDifferenceOperator-DIpbLGEo.js";import{t as _e}from"./OperatorTouches-CNFsnMF7.js";import{s as ye,t as xe,o as de}from"./operatorUnion-DcJGm0wZ.js";import{t as be}from"./OperatorWithin-CKhgMKe0.js";import"./operatorGeodeticDensify-DnFJpqvM.js";import"./GeometryCleaner-BEJM7I4l-BpQXwbJ9.js";import"./OperatorGeneralize-DMnxcmtT.js";import"./Centroid-DZi-eb9F-sZaMwpMU.js";import"./OperatorProximity-C4gYWLc6.js";let x,d,b,g,z;function w(){return!!x&&V()}async function R(){if(!w()){const[e]=await Promise.all([q(()=>import("./index-5Uv45sI4.js").then(t=>t.wb),__vite__mapDeps([0,1])),I()]);x=e.fromGeometry,d=e.fromSpatialReference,b=e.getSpatialReference,g=e.toPolygon,z=k()}}function ge(e,t,o={}){let{curveType:n="geodesic",maxDeviation:s=NaN,unit:l}=o;l&&(t=_(t,l,"meters"),s&&(s=_(s,l,"meters")));const c=b(e);return g(B(x(e),d(c),T[n],t,s),c)}function ve(e,t,o={}){let{curveType:n="geodesic",maxDeviation:s=NaN,union:l=!1,unit:c}=o;c&&(t=t.map(f=>_(f,c,"meters")),s&&(s=_(s,c,"meters")));const i=e.map(x),m=b(e);return X(i,d(m),T[n],t,s,l).map(f=>g(f,m)).filter(y)}const qt=Object.freeze(Object.defineProperty({__proto__:null,execute:ge,executeMany:ve,isLoaded:w,load:R,get supportsCurves(){return z}},Symbol.toStringTag,{value:"Module"}));function je(e,t,o={}){const{unit:n}=o,s=a(e);return n&&(t=$(t,n,s)),G(Q(r(e),u(s),t),s)}function Se(e,t,o={}){let{maxDeviation:n=NaN,maxVerticesInFullCircle:s=96,union:l=!1,unit:c}=o;const i=a(e);c&&(t=t.map(f=>$(f,c,i)),n&&(n=$(n,c,i)));const m=e.map(r);return K(m,u(i),t,n,s,l).map(f=>G(f,i)).filter(y)}const Oe=J(),Dt=Object.freeze(Object.defineProperty({__proto__:null,execute:je,executeMany:Se,supportsCurves:Oe},Symbol.toStringTag,{value:"Module"})),v=new D;function Ce(e){const t=a(e);return v.accelerateGeometry(r(e),u(t),1)}function Me(e,t){return v.execute(r(e),r(t),u(e.spatialReference),null)}const Pe=v.supportsCurves(),Lt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ce,execute:Me,supportsCurves:Pe},Symbol.toStringTag,{value:"Module"}));function Ge(e){const t=a(e);return p(ee(r(e)),t)}function Te(e,t={}){const{merge:o=!1}=t,n=e.map(r),s=a(e);return Y(n,o).map(l=>p(l,s))}function ze(e){return W(r(e))}const we=U(),Nt=Object.freeze(Object.defineProperty({__proto__:null,execute:Ge,executeMany:Te,isConvex:ze,supportsCurves:we},Symbol.toStringTag,{value:"Module"})),j=new te;function Re(e){const t=a(e);return j.accelerateGeometry(r(e),u(t),1)}function he(e,t){return j.execute(r(e),r(t),u(e.spatialReference),null)}const qe=j.supportsCurves(),Et=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Re,execute:he,supportsCurves:qe},Symbol.toStringTag,{value:"Module"})),S=new L;function De(e){const t=a(e);return S.accelerateGeometry(r(e),u(t),1)}function Le(e,t){return S.execute(r(e),r(t),u(e.spatialReference))}const Ne=S.supportsCurves(),At=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:De,execute:Le,supportsCurves:Ne},Symbol.toStringTag,{value:"Module"}));function Ee(e){const t=a(e);return se(r(e),u(t))}function Ae(e,t){const o=a(e);return p(ne(r(e),r(t),u(o)),o)}function Ie(e,t){const o=e.map(r),n=a(e);return oe(o,r(t),u(n),7).map(s=>p(s,n)).filter(y)}const ke=re(),It=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ee,execute:Ae,executeMany:Ie,supportsCurves:ke},Symbol.toStringTag,{value:"Module"})),O=new ue;function Ve(e){const t=a(e);return O.accelerateGeometry(r(e),u(t),1)}function Xe(e,t){return O.execute(r(e),r(t),u(e.spatialReference),null)}const Be=O.supportsCurves(),kt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ve,execute:Xe,supportsCurves:Be},Symbol.toStringTag,{value:"Module"}));function Fe(e,t={}){const{unit:o}=t;let n=r(e).calculateLength2D();if(n&&o){const s=a(e);n=N(n,s,o)}return n}const He=!0,Vt=Object.freeze(Object.defineProperty({__proto__:null,execute:Fe,supportsCurves:He},Symbol.toStringTag,{value:"Module"})),h={round:0,bevel:1,miter:2,square:3};function Ze(e,t,o={}){const{miterLimit:n=10,flattenError:s=0,joins:l="round",unit:c}=o,i=a(e);return c&&(t=$(t,c,i)),p(ie(r(e),u(i),t,h[l],n,s),i)}function Je(e,t,o={}){const{miterLimit:n=10,flattenError:s=0,joins:l="round",unit:c}=o,i=a(e);c&&(t=$(t,c,i));const m=e.map(r);return ce(m,u(i),t,h[l],n,s).map(f=>p(f,i)).filter(y)}const Ke=ae(),Xt=Object.freeze(Object.defineProperty({__proto__:null,execute:Ze,executeMany:Je,supportsCurves:Ke},Symbol.toStringTag,{value:"Module"})),C=new le;function Qe(e){const t=a(e);return C.accelerateGeometry(r(e),u(t),1)}function Ue(e,t){return C.execute(r(e),r(t),u(e.spatialReference),null)}const We=C.supportsCurves(),Bt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Qe,execute:Ue,supportsCurves:We},Symbol.toStringTag,{value:"Module"}));function Ye(e){const t=a(e);return p($e(r(e),u(t),!1),t)}function et(e){const t=e.map(r),o=a(e);return me(t,u(o),!1).map(n=>p(n,o))}function tt(e){return fe(r(e),u(a(e)),!1)}const rt=pe(),Ft=Object.freeze(Object.defineProperty({__proto__:null,execute:Ye,executeMany:et,isSimple:tt,supportsCurves:rt},Symbol.toStringTag,{value:"Module"})),M=new _e;function ot(e){const t=a(e);return M.accelerateGeometry(r(e),u(t),1)}function nt(e,t){return M.execute(r(e),r(t),u(e.spatialReference),null)}const st=M.supportsCurves(),Ht=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:ot,execute:nt,supportsCurves:st},Symbol.toStringTag,{value:"Module"}));function ut(e,t){const o=a(e);return p(de(r(e),r(t),u(o)),o)}function at(e){const t=e.map(r),o=a(e);return p(xe(t,u(o)),o)}const ct=ye(),Zt=Object.freeze(Object.defineProperty({__proto__:null,execute:ut,executeMany:at,supportsCurves:ct},Symbol.toStringTag,{value:"Module"})),P=new be;function it(e){const t=a(e);return P.accelerateGeometry(r(e),u(t),1)}function lt(e,t){return P.execute(r(e),r(t),u(e.spatialReference),null)}const pt=P.supportsCurves(),Jt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:it,execute:lt,supportsCurves:pt},Symbol.toStringTag,{value:"Module"}));function Kt(e,t,o,n){const s=new E().rotate(t,o,n);return A(e,s)}async function Qt(){await Promise.all([F(),R(),H(),Z()])}export{sr as area,Dt as buffer,ar as centroid,ir as clip,Lt as contains,Nt as convexHull,Et as crosses,pr as cut,mr as densify,_r as difference,At as disjoint,xr as distance,br as equals,vr as generalize,qt as geodesicBuffer,Yt as geodeticArea,tr as geodeticDensify,or as geodeticLength,It as intersection,kt as intersects,Sr as labelPoint,Vt as length,Qt as loadAll,Xt as offset,Bt as overlaps,Cr as proximity,Pr as relate,Kt as rotate,Ft as simplify,Tr as symmetricDifference,Ht as touches,Zt as union,Jt as within};
