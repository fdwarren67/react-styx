import {
  p
} from "./chunk-QNWGXX56.js";
import "./chunk-XIL65DCI.js";
import "./chunk-3TEY2BPT.js";
import {
  h
} from "./chunk-G4TWQWZ5.js";
import "./chunk-EKEKHPBG.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import {
  l
} from "./chunk-WOB72RZU.js";
import {
  j
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  b
} from "./chunk-C6YDI6QX.js";
import {
  y
} from "./chunk-DJ5HVIE7.js";
import {
  S
} from "./chunk-KPY4ZIC2.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  v as v2
} from "./chunk-WO43UGNC.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-GSNLF6RP.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import {
  v
} from "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a,
  s as s2,
  t
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/ElevationTileData.js
var a3 = class {
  constructor(a4, t3, s4, e) {
    this._hasNoDataValues = null, this._minValue = null, this._maxValue = null, "pixelData" in a4 ? (this.values = a4.pixelData, this.width = a4.width, this.height = a4.height, this.noDataValue = a4.noDataValue) : (this.values = a4, this.width = t3, this.height = s4, this.noDataValue = e);
  }
  get hasNoDataValues() {
    if (null == this._hasNoDataValues) {
      const a4 = this.noDataValue;
      this._hasNoDataValues = this.values.includes(a4);
    }
    return this._hasNoDataValues;
  }
  get minValue() {
    return this._ensureBounds(), this._minValue;
  }
  get maxValue() {
    return this._ensureBounds(), this._maxValue;
  }
  get cachedMemory() {
    return this.values.byteLength + 256;
  }
  _ensureBounds() {
    if (null != this._minValue) return;
    const { noDataValue: a4, values: t3 } = this;
    let s4 = 1 / 0, e = -1 / 0, i = true;
    for (const h2 of t3) h2 === a4 ? this._hasNoDataValues = true : (s4 = h2 < s4 ? h2 : s4, e = h2 > e ? h2 : e, i = false);
    i ? (this._minValue = 0, this._maxValue = 0) : (this._minValue = s4, this._maxValue = e > -3e38 ? e : 0);
  }
};

// node_modules/@arcgis/core/layers/support/LercDecoder.js
var r2 = class extends h {
  constructor(e = null) {
    super("LercWorker", "_decode", { _decode: (e2) => [e2.buffer] }, e, { strategy: "dedicated" }), this.schedule = e, this.ref = 0;
  }
  decode(e, r3, t3) {
    return e && 0 !== e.byteLength ? this.invoke({ buffer: e, options: r3 }, t3) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (t2.forEach((e, r3) => {
      e === this && t2.delete(r3);
    }), this.destroy());
  }
};
var t2 = /* @__PURE__ */ new Map();
function s3(e = null) {
  let s4 = t2.get(e);
  return s4 || (null != e ? (s4 = new r2((r3) => e.immediate.schedule(r3)), t2.set(e, s4)) : (s4 = new r2(), t2.set(null, s4))), ++s4.ref, s4;
}

// node_modules/@arcgis/core/layers/ElevationLayer.js
var S2 = class extends p(l(b(j(S(f))))) {
  constructor(...e) {
    super(...e), this.capabilities = { operations: { supportsTileMap: false } }, this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = s3();
  }
  normalizeCtorArgs(e, r3) {
    return "string" == typeof e ? { url: e, ...r3 } : e;
  }
  destroy() {
    this._lercDecoder = t(this._lercDecoder);
  }
  readCapabilities(e, r3) {
    const t3 = r3.capabilities && r3.capabilities.split(",").map((e2) => e2.toLowerCase().trim());
    if (!t3) return { operations: { supportsTileMap: false } };
    return { operations: { supportsTileMap: t3.includes("tilemap") } };
  }
  readVersion(e, r3) {
    let t3 = r3.currentVersion;
    return t3 || (t3 = 9.3), t3;
  }
  load(e) {
    const r3 = null != e ? e.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e2) => {
      if (e2.typeKeywords) {
        for (let r4 = 0; r4 < e2.typeKeywords.length; r4++) if ("elevation 3d layer" === e2.typeKeywords[r4].toLowerCase()) return true;
      }
      throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e).catch(a).then(() => this._fetchImageService(r3))), Promise.resolve(this);
  }
  fetchTile(e, t3, i, o2) {
    const s4 = o2 == null ? void 0 : o2.signal, a4 = { responseType: "array-buffer", signal: s4 }, p2 = { noDataValue: o2 == null ? void 0 : o2.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e, t3, i, o2)).then(() => P(this.getTileUrl(e, t3, i), a4)).then((e2) => this._lercDecoder.decode(e2.data, p2, s4)).then((e2) => new a3(e2));
  }
  getTileUrl(e, r3, t3) {
    const i = !this.capabilities.operations.supportsTileMap && this.supportsBlankTile, o2 = v({ ...this.parsedUrl.query, blankTile: !i && null });
    return `${this.parsedUrl.path}/tile/${e}/${r3}/${t3}${o2 ? "?" + o2 : ""}`;
  }
  async queryElevation(e, r3) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-5ZJRFFOS.js");
    s2(r3);
    return new t3().query(this, e, r3);
  }
  async createElevationSampler(e, r3) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-5ZJRFFOS.js");
    s2(r3);
    return new t3().createSampler(this, e, r3);
  }
  _fetchTileAvailability(e, r3, t3, i) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e, r3, t3, i) : Promise.resolve("unknown");
  }
  async _fetchImageService(e) {
    var _a;
    if (this.sourceJSON) return this.sourceJSON;
    const t3 = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e }, i = await P(this.parsedUrl.path, t3);
    i.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = i.data, this.read(i.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile[w];
  }
};
r([m({ readOnly: true })], S2.prototype, "capabilities", void 0), r([o("service", "capabilities", ["capabilities"])], S2.prototype, "readCapabilities", null), r([m({ json: { read: { source: "copyrightText" } } })], S2.prototype, "copyright", void 0), r([m({ readOnly: true, type: v2 })], S2.prototype, "heightModelInfo", void 0), r([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], S2.prototype, "path", void 0), r([m({ type: ["show", "hide"] })], S2.prototype, "listMode", void 0), r([m({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], S2.prototype, "minScale", void 0), r([m({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], S2.prototype, "maxScale", void 0), r([m({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], S2.prototype, "opacity", void 0), r([m({ type: ["ArcGISTiledElevationServiceLayer"] })], S2.prototype, "operationalLayerType", void 0), r([m()], S2.prototype, "sourceJSON", void 0), r([m({ json: { read: false }, value: "elevation", readOnly: true })], S2.prototype, "type", void 0), r([m(y)], S2.prototype, "url", void 0), r([m()], S2.prototype, "version", void 0), r([o("version", ["currentVersion"])], S2.prototype, "readVersion", null), S2 = r([a2("esri.layers.ElevationLayer")], S2);
var w = Symbol("default-fetch-tile");
S2.prototype.fetchTile[w] = true;
var T = S2;
export {
  T as default
};
//# sourceMappingURL=ElevationLayer-UMU7VOOH.js.map
