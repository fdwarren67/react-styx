import {
  F,
  r as r6
} from "./chunk-ASXBCL66.js";
import "./chunk-DEMYZR3T.js";
import "./chunk-Z2KLKHIE.js";
import {
  M as M2,
  a as a7,
  i as i7,
  n as n4,
  n2 as n5,
  p as p2,
  p2 as p3,
  r2 as r7,
  s as s9,
  u as u7,
  x as x2
} from "./chunk-V7SQVFRS.js";
import "./chunk-3YC3Z7OQ.js";
import {
  Jt
} from "./chunk-4SAKF7Y6.js";
import {
  t as t6
} from "./chunk-355MBCYM.js";
import {
  d as d4
} from "./chunk-KFLWTVQX.js";
import "./chunk-BXTQHJJG.js";
import "./chunk-T5R43RTD.js";
import "./chunk-7NXOMMLC.js";
import "./chunk-F6YRPEY7.js";
import "./chunk-CCPDXL7V.js";
import "./chunk-2TACZL27.js";
import {
  _ as _2,
  e as e5,
  i as i6,
  r as r5,
  s as s8,
  t as t5
} from "./chunk-PKIZUJIH.js";
import {
  a as a8
} from "./chunk-LL7BB425.js";
import {
  $
} from "./chunk-74G4LVU3.js";
import "./chunk-CUWQEJ5X.js";
import "./chunk-MVYDN2TM.js";
import "./chunk-B7S3HUFO.js";
import "./chunk-6VF5U3IZ.js";
import "./chunk-E7IFPXEX.js";
import "./chunk-OK5AUMBT.js";
import {
  r as r8
} from "./chunk-GCCOZPS7.js";
import "./chunk-OBVDE24U.js";
import {
  S,
  c as c3,
  d as d3
} from "./chunk-36CN7JP2.js";
import "./chunk-WX3BOMD3.js";
import {
  b as b2,
  h
} from "./chunk-TSFKACKN.js";
import {
  a as a4
} from "./chunk-W5QWJI4E.js";
import "./chunk-5LCZI6ZH.js";
import "./chunk-GWOCGJJE.js";
import "./chunk-DAFTSB3S.js";
import "./chunk-CDBQ673E.js";
import {
  e as e3
} from "./chunk-N6TERPCK.js";
import {
  L as L2
} from "./chunk-SEOVQLIZ.js";
import "./chunk-EUB5OBXG.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-2UD6J77T.js";
import "./chunk-YYDDGFL6.js";
import {
  j as j2,
  x
} from "./chunk-SNZZPKBU.js";
import {
  Mt,
  N,
  U as U2,
  W,
  X,
  dt,
  ft,
  ht,
  pt,
  rt,
  ut,
  w
} from "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import {
  s as s4
} from "./chunk-3HA4XA2C.js";
import {
  e
} from "./chunk-H2OC77GP.js";
import {
  s as s3
} from "./chunk-RDHJUEBL.js";
import "./chunk-6ZI2HC5K.js";
import "./chunk-WESTCUBG.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-BG4U4RTY.js";
import {
  a as a3,
  i as i5,
  s as s6,
  u as u6
} from "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import {
  i as i4,
  s as s5,
  u as u4
} from "./chunk-QQKMDF7C.js";
import {
  e as e2
} from "./chunk-YZEE5Z3S.js";
import "./chunk-2ZAGB4JV.js";
import "./chunk-B2CK3GCY.js";
import "./chunk-NINPG5JV.js";
import {
  _
} from "./chunk-32RP26YL.js";
import {
  e as e6,
  r as r9
} from "./chunk-KHEAC7YP.js";
import {
  i as i8
} from "./chunk-6ZLHM6GW.js";
import "./chunk-74GH4Z6V.js";
import {
  h as h2
} from "./chunk-PXBFVQ6M.js";
import "./chunk-TYJV2BHR.js";
import "./chunk-I6H2R562.js";
import {
  e as e4
} from "./chunk-WMLTK6KE.js";
import "./chunk-SURICA27.js";
import "./chunk-PBHST2SF.js";
import {
  a as a5
} from "./chunk-PONPGREB.js";
import "./chunk-QNYMCEB7.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-VPRLLNNO.js";
import "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import {
  P as P2
} from "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import {
  z
} from "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import "./chunk-YUQ6PSJ2.js";
import "./chunk-SB6LU3VH.js";
import {
  c as c4
} from "./chunk-4GBYHIKO.js";
import "./chunk-ZDLUQDDX.js";
import {
  a as a6,
  s as s7,
  y
} from "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-5T3XQRJL.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  O,
  c as c5
} from "./chunk-FVMWI3UB.js";
import {
  b
} from "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import {
  n as n3
} from "./chunk-BBPRJCMB.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-T52X5K2I.js";
import "./chunk-5E5JYM5A.js";
import {
  p
} from "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-2SOWSOAE.js";
import {
  u as u3
} from "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import {
  r as r4
} from "./chunk-RAVPBO4Z.js";
import {
  n as n6
} from "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-D3P3E2RE.js";
import {
  d as d2
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import {
  i as i3
} from "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import {
  u as u5
} from "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import {
  H,
  R,
  U,
  a as a2,
  c as c2,
  f as f2
} from "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import {
  g as g3
} from "./chunk-4GOW35CM.js";
import {
  Q,
  l
} from "./chunk-TEJXT4W6.js";
import {
  t as t2
} from "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  M,
  r
} from "./chunk-VSLEAHOZ.js";
import "./chunk-FQILN67Z.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  g2
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g,
  i as i2,
  m as m2,
  u3 as u2
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import {
  t as t4
} from "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  L,
  c2 as c,
  d,
  f2 as f,
  k,
  m,
  n as n2,
  s as s2,
  t2 as t3,
  u
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r as r3
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  r as r2
} from "./chunk-7LCEUMDD.js";
import {
  i,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import {
  G,
  has,
  t
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t7 = class {
  constructor(e13) {
    this._client = e13, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t20) {
    O(this._eventLog.onEvent(t20));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var i9 = 1;
var r10 = 2;
var n7 = 4;
var h3 = 8;
var o = 16;
var c6 = 32;
var a9 = 64;
var l2 = 128;
function f3(e13) {
  switch (e13) {
    case i9:
    case h3:
    case c6:
      return -1;
    case r10:
    case a9:
      return 0;
    case n7:
    case o:
    case l2:
      return 1;
  }
}
function u8(e13) {
  switch (e13) {
    case i9:
    case r10:
    case n7:
      return -1;
    case h3:
    case o:
      return 0;
    case c6:
    case a9:
    case l2:
      return 1;
  }
}
var d5 = i9 | h3 | c6;
var _3 = n7 | o | l2;
var m3 = i9 | r10 | n7;
var p4 = c6 | a9 | l2;
var g4 = class {
  constructor(e13, s20, i19, r17, n14 = 0) {
    this.tileKey = e13, this._bufferingEnabled = s20, this._sizeHint = n14, this._meshes = { self: new n4(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0;
    const h8 = r17 ? 1 : 0;
    this._copyBufferedDataIntoSelf = i19 && this._bufferingEnabled && e13.level === h8;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e13) {
    this._meshes.self.indexEnsureSize(e13);
  }
  entityStart(e13, s20 = e13) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e13, s20);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e13 = 0; e13 < 8; e13++) {
        const s20 = 1 << e13;
        !!(this._currentEntityOverlaps & s20) && this._meshes.neighbors[e13].entityEnd();
      }
    }
  }
  recordStart(e13, s20, t20) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e13, s20, t20);
  }
  recordEnd(e13 = 0) {
    const s20 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return s20 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : s20;
  }
  recordBounds(e13, s20, t20, i19) {
    this._bufferingEnabled && this._addOverlap(e13, s20, t20, i19);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e13) {
    this._meshes.self.metricStart(e13);
  }
  metricBoxWrite(e13) {
    this._meshes.self.metricBoxWrite(e13);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e13) {
    this._meshes.self.vertexWrite(e13);
  }
  vertexWriteF32(e13) {
    this._meshes.self.vertexWriteF32(e13);
  }
  vertexWriteRegion(e13) {
    this._meshes.self.vertexWriteRegion(e13);
  }
  indexWrite(e13) {
    this._meshes.self.indexWrite(e13);
  }
  serialize(s20) {
    const t20 = { message: [], transferList: [] }, i19 = this._meshes.self.serialize();
    return t20.message.push({ tileId: this.tileKey.id, ...i19.message }), t20.transferList.push(...i19.transferList), this._meshes.neighbors.forEach((i20, r17) => {
      const n14 = i20.serialize(), h8 = 1 << r17, o13 = f3(h8), c10 = u8(h8), a16 = new e4(this.tileKey).getNormalizedNeighbor(o13, c10, s20);
      t20.message.push({ tileId: a16.id, ...n14.message }), t20.transferList.push(...n14.transferList);
    }), t20;
  }
  _addOverlap(e13, t20, i19, r17) {
    const n14 = Math.min(a5 / 2, i19), h8 = Math.min(a5 / 2, r17), o13 = 255 ^ ((e13 < 0 + n14 ? _3 : e13 >= a5 - n14 ? d5 : _3 | d5) | (t20 < 0 + h8 ? p4 : t20 >= a5 - h8 ? m3 : p4 | m3));
    this._currentRecordOverlaps |= o13;
  }
  _copyIntoNeighbors() {
    for (let e13 = 0; e13 < 8; e13++) {
      const i19 = 1 << e13;
      if (!!(this._currentRecordOverlaps & i19)) {
        if (this._copyBufferedDataIntoSelf) {
          const e14 = -f3(i19) * a5, t20 = -u8(i19) * a5;
          if (0 !== t20) continue;
          this._meshes.self.copyLast(e14, t20);
          continue;
        }
        if (!this._meshes.neighbors[e13]) {
          const s20 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e13] = new n4(i19, s20);
        }
        const r17 = this._meshes.neighbors[e13], n14 = -f3(i19) * a5, h8 = -u8(i19) * a5;
        r17.copyLastFrom(this._meshes.self, n14, h8);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s10 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t8 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(e13, s20) {
    const l10 = new _t();
    return l10.setDefault(await e13.createMeshWriters(s20.meshes)), l10;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t20) {
    this._defaultResult = t20;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t20) {
    this._backgroundFillResult = t20;
  }
  hasArcadeDependency(t20) {
    var _a;
    return ((_a = this._defaultResult) == null ? void 0 : _a.some((e13) => e13.hasArcadeDependency(t20))) ?? false;
  }
  match(t20, e13, s20) {
    const l10 = this.doMatch(t20, e13) || this.getDefault();
    if (l10 && l10.length > 0) {
      const t21 = this.getBackgroundFill();
      if (t21) return [...t21, ...l10];
    }
    return l10;
  }
  getSortKey(t20, e13) {
    return 0;
  }
  doMatch(t20, e13) {
    return null;
  }
  async fetchResources(t20, e13) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e7 = class _e extends t8 {
  static async fromDictionaryRenderer(t20, s20) {
    return new _e(t20, s20);
  }
  constructor(t20, e13) {
    super(), this._context = t20, this._schema = e13, this._hashToGroup = /* @__PURE__ */ new Map();
  }
  get fieldMap() {
    return this._schema.fieldMap;
  }
  async fetchResources(t20, e13) {
    const s20 = e13.getCursor(), r17 = [];
    for (; s20.next(); ) r17.push(this._updateMeshWriterGroup(t20, s20));
    await Promise.all(r17);
  }
  match(t20, e13) {
    const s20 = t20.getAttributeHash();
    return this._hashToGroup.get(s20);
  }
  async _updateMeshWriterGroup(t20, e13) {
    const s20 = e13.readLegacyFeatureForDisplay(), r17 = e13.getAttributeHash();
    if (this._hashToGroup.has(r17)) return;
    this._hashToGroup.set(r17, null);
    const a16 = await t20.fetchDictionaryResourceImmediate({ type: "dictionary-request", feature: s20 });
    if (!a16) return;
    const h8 = await this._context.createMeshWriters(a16.meshes);
    this._hashToGroup.set(r17, h8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var t9 = class _t extends t8 {
  constructor(e13, t20) {
    super(), this._intervals = [], this._isMaxInclusive = t20, this._field = e13;
  }
  static async fromIntervalSchema(e13, s20) {
    const r17 = await e13.storage.createComputedField(s20), a16 = new _t(r17, s20.isMaxInclusive);
    await Promise.all(s20.intervals.map(async (t20) => {
      const s21 = await e13.createMeshWriters(t20.meshes);
      a16.add(t20, s21);
    }));
    const i19 = await e13.createMeshWriters(s20.defaultSymbol);
    a16.setDefault(i19);
    const n14 = await e13.createMeshWriters(s20.backgroundFill);
    return a16.setBackgroundFill(n14), a16;
  }
  add(e13, t20) {
    this._intervals.push({ interval: e13, result: t20 }), this._intervals.sort((e14, t21) => e14.interval.min - t21.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  hasArcadeDependency(e13) {
    var _a;
    return ((_a = this._field) == null ? void 0 : _a.hasArcadeDependency(e13)) || this._intervals.some((t20) => t20.result.some((t21) => t21.hasArcadeDependency(e13)));
  }
  doMatch(e13, t20) {
    var _a;
    const s20 = (_a = this._field) == null ? void 0 : _a.read(e13, t20);
    if (null == s20 || isNaN(s20) || s20 === 1 / 0 || s20 === -1 / 0) return null;
    for (let r17 = 0; r17 < this._intervals.length; r17++) {
      const { interval: e14, result: t21 } = this._intervals[r17], a16 = s20 >= e14.min, i19 = this._isMaxInclusive ? s20 <= e14.max : s20 < e14.max;
      if (a16 && i19) return t21;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var s11 = class _s extends t8 {
  static async fromLabelSchema(e13, a16) {
    const r17 = a16.classes.map(async (s20) => {
      const a17 = await e13.createMeshWriters(s20.meshes);
      return { minScale: s20.minScale, maxScale: s20.maxScale, meshes: a17, expression: null, where: await e13.storage.createWhereClause(s20.where) };
    }), t20 = await Promise.all(r17);
    return new _s(t20);
  }
  constructor(e13) {
    super(), this._labels = e13;
  }
  match(e13, s20, a16) {
    if (!this._labels.length) return null;
    const r17 = this._getLabels(s20.$view.scale), t20 = [];
    for (const l10 of r17) l10.where && !l10.where(e13, a16) || t20.push(...l10.meshes);
    return t20;
  }
  hasArcadeDependency(e13) {
    return this._labels.some((s20) => s20.meshes.some((s21) => s21.hasArcadeDependency(e13)));
  }
  _getLabels(e13) {
    return this._labels.filter((s20) => this._validForTileScale(s20, e13));
  }
  _validForTileScale(e13, s20) {
    const a16 = s20 - s20 / 4, r17 = s20 + s20 / 2;
    return (!e13.minScale || e13.minScale >= a16) && (!e13.maxScale || e13.maxScale <= r17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t10 = class _t extends t8 {
  constructor(e13, t20) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e13, this._separator = t20 || "";
  }
  static async fromMatcherSchema(e13, s20) {
    const l10 = s20.expression ? [e13.storage.createComputedField({ expression: s20.expression })] : [s20.field ? e13.storage.createComputedField({ field: s20.field }) : null, s20.field2 ? e13.storage.createComputedField({ field: s20.field2 }) : null, s20.field3 ? e13.storage.createComputedField({ field: s20.field3 }) : null], r17 = (await Promise.all(l10)).filter((e14) => !!e14), i19 = new _t(r17, s20.fieldDelimiter), a16 = await e13.createMeshWriters(s20.defaultSymbol);
    i19.setDefault(a16);
    const u13 = await e13.createMeshWriters(s20.backgroundFill);
    return i19.setBackgroundFill(u13), await Promise.all(s20.map.map(async (t20, s21) => {
      const l11 = await e13.createMeshWriters(t20.symbol);
      "<Null>" === t20.value ? i19.setNullResult(l11) : i19.add(t20.value, l11, s21 + 1);
    })), i19;
  }
  setNullResult(e13) {
    this._nullResult = e13;
  }
  getSortKey(e13, t20) {
    const s20 = this._getValueFromFields(e13, t20);
    if (null == s20 || "" === s20 || "<Null>" === s20) return 0;
    const l10 = this._resultsMap.get(s20.toString());
    return l10 ? l10.sortKey : this._defaultSymbolSortKey;
  }
  add(e13, t20, s20) {
    this._resultsMap.set(e13.toString(), { meshWriters: t20, sortKey: s20 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, s20 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  hasArcadeDependency(e13) {
    var _a;
    return this._fields.some((t20) => t20.hasArcadeDependency(e13)) || [...this._resultsMap.values()].some((t20) => t20.meshWriters.some((t21) => t21.hasArcadeDependency(e13))) || ((_a = this._nullResult) == null ? void 0 : _a.some((t20) => t20.hasArcadeDependency(e13))) || false;
  }
  doMatch(e13, t20) {
    var _a;
    const s20 = this._getValueFromFields(e13, t20);
    if (null !== this._nullResult && (null == s20 || "" === s20 || "<Null>" === s20)) return this._nullResult;
    if (null == s20) return null;
    const l10 = s20.toString();
    return (_a = this._resultsMap.get(l10)) == null ? void 0 : _a.meshWriters;
  }
  _getValueFromFields(e13, t20) {
    const s20 = [];
    for (const l10 of this._fields) {
      const r17 = l10.read(e13, t20);
      null == r17 || "" === r17 ? s20.push("<Null>") : s20.push(r17);
    }
    return s20.join(this._separator);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function i10(e13, t20) {
  switch (t20.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return t8.from(e13, t20);
    case "interval":
      return t9.fromIntervalSchema(e13, t20);
    case "dictionary":
      return e7.fromDictionaryRenderer(e13, t20);
    case "label":
      return s11.fromLabelSchema(e13, t20);
    case "map":
      return t10.fromMatcherSchema(e13, t20);
    case "subtype":
      return h4.fromSubtypes(e13, t20);
    case "cluster":
      return o2.fromClusterSchema(e13, t20);
    case "track":
      return u9.fromTrackSchema(e13, t20);
    default:
      throw new Error("Impl");
  }
}
var h4 = class _h extends t8 {
  constructor(e13, t20) {
    super(), this._subMatchers = e13, this._subtypeField = t20;
  }
  static async fromSubtypes(e13, t20) {
    const r17 = /* @__PURE__ */ new Map(), a16 = [];
    for (const s20 in t20.renderers) {
      const c10 = parseInt(s20, 10), n14 = i10(e13, t20.renderers[s20]).then((e14) => r17.set(c10, e14));
      a16.push(n14);
    }
    return await Promise.all(a16), new _h(r17, t20.subtypeField);
  }
  match(e13, t20, r17) {
    const a16 = e13.readAttribute(this._subtypeField), s20 = this._subMatchers.get(a16);
    return s20 ? s20.match(e13, t20, r17) : null;
  }
  hasArcadeDependency(e13) {
    for (const t20 of this._subMatchers.values()) if (t20.hasArcadeDependency(e13)) return true;
    return false;
  }
};
var o2 = class _o extends t8 {
  static async fromClusterSchema(e13, t20) {
    const [r17, a16] = await Promise.all([i10(e13, t20.feature), i10(e13, t20.cluster)]);
    return new _o(r17, a16);
  }
  constructor(e13, t20) {
    super(), this._featureMatcher = e13, this._clusterMatcher = t20;
  }
  match(e13, t20, r17) {
    return 1 === e13.readAttribute("cluster_count") ? this._featureMatcher.match(e13, t20, r17) : this._clusterMatcher.match(e13, t20, r17);
  }
  hasArcadeDependency(e13) {
    return this._featureMatcher.hasArcadeDependency(e13) || this._clusterMatcher.hasArcadeDependency(e13);
  }
};
var u9 = class _u extends t8 {
  static async fromTrackSchema(e13, t20) {
    const [r17, a16, s20] = await Promise.all([i10(e13, t20.previousObservation), i10(e13, t20.latestObservation), i10(e13, t20.trackLine)]);
    return new _u(r17, a16, s20);
  }
  constructor(e13, t20, r17) {
    super(), this._previousObservationMatcher = e13, this._latestObservationMatcher = t20, this._trackLineMatcher = r17;
  }
  match(r17, a16, s20) {
    switch (r17.readAttribute(r5)) {
      case s8.TrackLine:
        return this._trackLineMatcher.match(r17, a16, s20);
      case s8.LatestObservation:
        return this._latestObservationMatcher.match(r17, a16, s20);
      case s8.PreviousObservation:
        return this._previousObservationMatcher.match(r17, a16, s20);
    }
    return null;
  }
  hasArcadeDependency(e13) {
    return this._trackLineMatcher.hasArcadeDependency(e13) || this._latestObservationMatcher.hasArcadeDependency(e13) || this._previousObservationMatcher.hasArcadeDependency(e13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s12 = class _s extends s10 {
  static async create(e13, o13) {
    const r17 = await i10(e13, o13.symbology), c10 = o13.labels ? await i10(e13, o13.labels) : null;
    return new _s(r17, c10);
  }
  constructor(e13, t20) {
    super(), this._symbology = e13, this._labels = t20;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e13, t20) {
    var _a;
    await Promise.all([this._symbology.fetchResources(e13, t20), (_a = this._labels) == null ? void 0 : _a.fetchResources(e13, t20)]);
  }
  enqueueWriterRequests(e13, t20, s20, o13) {
    const r17 = this._symbology.match(t20, s20, o13);
    if (r17) {
      for (const o14 of r17) o14.enqueueRequest(e13, t20, s20);
      if (this._labels) {
        const r18 = this._labels.match(t20, s20, o13);
        if (!r18) return;
        for (const o14 of r18) o14.enqueueRequest(e13, t20, s20);
      }
    }
  }
  write(e13, t20, s20, o13, r17, c10) {
    const a16 = this._symbology.match(s20, o13, r17);
    if (!a16) return;
    for (const n14 of a16) n14.write(e13, t20, s20, o13, c10);
    if (e13.entityRecordCount() >= 1 && this._labels) {
      const n14 = this._labels.match(s20, o13, r17);
      if (!n14) return;
      for (const r18 of n14) r18.setReferences(a16), r18.write(e13, t20, s20, o13, c10);
    }
  }
  getSortKey(e13, t20) {
    return this._symbology.getSortKey(e13, t20);
  }
  hasArcadeDependency(e13) {
    var _a;
    return !(!this._symbology.hasArcadeDependency(e13) && !((_a = this._labels) == null ? void 0 : _a.hasArcadeDependency(e13)));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s13 = class {
  constructor(s20, r17, t20, e13) {
    this.storage = s20, this.proxy = r17, this.viewParams = t20, this.registry = e13;
  }
  async createMeshWriters(s20) {
    const r17 = s20.map((s21) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s21));
    return Promise.all(r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e8 = class {
  constructor(e13) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e13.concurrency, process: (s20) => e13.process(s20) });
  }
  async push(s20) {
    if (s20.end) return await Promise.all(this._outstandingMessages), await this._queue.push(s20), void (this._outstandingMessages = []);
    const e13 = this._queue.push(s20);
    return this._outstandingMessages.push(e13), e13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s14 = class _s {
  static async create(i19, e13) {
    var _a;
    if ("count" === e13.statisticType) {
      const i20 = new r6(1);
      return new _s(e13.name, e13.alias, e13.type, e13.statisticType, i20);
    }
    const a16 = await i19.createComputedField({ expression: (_a = e13.onStatisticExpression) == null ? void 0 : _a.expression, field: e13.onStatisticField });
    return new _s(e13.name, e13.alias, e13.type, e13.statisticType, a16);
  }
  constructor(t20, s20, i19, e13, a16) {
    this.name = t20, this.alias = s20, this.type = i19, this.statisticType = e13, this.computed = a16;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t11 = class {
  constructor(t20) {
    this.subscription = t20, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e9 = class {
  constructor(t20, e13, s20) {
    this._source = t20, this._attributeStore = e13, this._sqlOptions = s20, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  onSubscribe(t20) {
    const e13 = this.createState(t20);
    this._sendStates.set(t20.key.id, e13), this.updateChunks();
  }
  onUnsubscribe(t20) {
    var _a;
    (_a = this._sendStates.get(t20.key.id)) == null ? void 0 : _a.destroy(), this._sendStates.delete(t20.key.id);
  }
  invalidate() {
    const t20 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e13 of t20) e13.destroy(), this.onSubscribe(e13.subscription);
  }
  invalidateAttributeData(t20) {
  }
  hasArcadeDependency(t20) {
    return false;
  }
  getFeatureObjectIdsForAggregate(t20) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t20) {
    return this.displayMap(t20, (t21) => t21, (t21) => t21);
  }
  getDisplayAndObjectIds(t20) {
    return this.displayMap(t20, (t21) => t21, (t21, e13, s20) => [t21, s20]);
  }
  afterUpdateChunks() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i11 = class extends e9 {
  constructor(r17, t20, s20, n14, i19) {
    super(r17, t20, i19), this.spatialReference = s20, this.aggregateFields = n14, this._arcadeDependencies = /* @__PURE__ */ new Set(), this.events = new i3(), this.featureAdapter = e3;
    for (const e13 of n14) n6(this._arcadeDependencies, e13.computed);
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new L2({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, objectIdField: this._metadata.objectIdField, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  get isAggregate() {
    return true;
  }
  removeChunks(e13) {
  }
  hasArcadeDependency(e13) {
    return this._arcadeDependencies.has(e13);
  }
  forEach(e13) {
    return this.forEachAggregateWorldSpace(e13);
  }
  forEachInBounds(e13, r17) {
  }
  forEachBounds(e13, a16) {
    const s20 = u3();
    for (const r17 of e13) {
      const e14 = pt(s20, r17.geometry, false, false);
      e14 && a16(e14);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e10 = class {
  constructor(e13, i19, t20, s20, r17) {
    this.subscription = e13, this.reader = i19, this.clear = t20, this.end = s20, this.debugInfo = r17, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e13, i19, t20) {
    return { type: "append", clear: this.clear, id: this.id, append: e13, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i19, attributeEpoch: t20 };
  }
};
var i12 = class {
  constructor(e13, i19, t20, s20, r17) {
    this.subscription = e13, this.reader = i19, this.remove = t20, this.end = s20, this.debugInfo = r17, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e13, i19, t20) {
    return { type: "update", id: this.id, modify: e13, debugInfo: this.debugInfo, remove: this.remove, version: i19, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t20 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var g5 = class extends t11 {
  constructor(e13, t20) {
    super(e13), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t20;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  destroy() {
    const e13 = this.subscription.tile.key.level;
    for (const t20 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t20}.${e13}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const e13 of this.featureCache.values()) {
      const s20 = e13.clone();
      s20.geometry && Mt(s20.geometry, s20.geometry, false, false, this.subscription.tile.transform), yield s20;
    }
  }
};
var y2 = class _y extends i11 {
  static async create(t20, s20, a16, i19, n14, l10) {
    const d11 = new p2({ spatialReference: s20 }), c10 = await Promise.all(t20.fields.map(async (e13) => s14.create(d11, e13))), f6 = t20.featureFilter ? await p3.create({ geometryType: a16.metadata.geometryType, hasM: false, hasZ: false, timeInfo: a16.metadata.timeInfo, fieldsIndex: a16.metadata.fieldsIndex, spatialReference: s20, filterJSON: t20.featureFilter }) : null;
    return "geohash" === t20.index.type && await x(s20, g3.WGS84), new _y(t20, f6, n14, c10, s20, a16, i19, l10);
  }
  constructor(e13, t20, s20, a16, r17, o13, n14, l10) {
    super(o13, n14, r17, a16, l10), this._schema = e13, this._featureFilter = t20, this._arcadeContextInfo = s20, this._metadata = i7.createFeature({ geometryType: "esriGeometryPolygon", objectIdField: "aggregateId", fieldsIndex: new Z(e13.fields).toJSON(), globalIdField: null, spatialReference: o13.metadata.spatialReference, outSpatialReference: o13.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  createState(e13) {
    return new g5(e13, this._attributeStore);
  }
  async *applyOverrideUpdate(e13) {
    for (const t20 of this._sendStates.values()) {
      t20.reset();
      const e14 = new e10(t20.subscription, u7.empty(this._source.metadata), true, false, {});
      yield e14;
    }
  }
  displayMap(e13, t20, s20) {
    const a16 = new Map(e13.map((e14) => [t20(e14), e14])), r17 = [];
    for (const i19 of this._sendStates.values()) for (const e14 of i19.featuresWorldSpace()) {
      const { objectId: t21, displayId: i20 } = e14, o13 = a16.get(t21);
      if (null != o13) {
        const e15 = s20(i20, o13, t21);
        r17.push(e15), a16.delete(t21);
      }
    }
    return r17;
  }
  getDisplayFeatures(e13) {
    const t20 = new Set(e13), a16 = /* @__PURE__ */ new Set(), r17 = [];
    for (const i19 of this._sendStates.values()) for (const e14 of i19.featuresWorldSpace()) t20.has(e14.displayId) && !a16.has(e14.objectId) && (e14.geometry && r17.push({ ...rt(e14, this._metadata.geometryType, false, false), displayId: e14.displayId }), a16.add(e14.objectId));
    return { features: [], aggregates: r17, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e13) {
    for (const t20 of this._sendStates.values()) for (const s20 of t20.bins.values()) if (s20.id === e13) return Array.from(s20.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    for (const e13 of this._sendStates.values()) yield* this._update(e13, this._source);
  }
  forEachAggregateWorldSpace(e13) {
    const t20 = /* @__PURE__ */ new Set();
    for (const s20 of this._sendStates.values()) for (const a16 of s20.featuresWorldSpace()) t20.has(a16.objectId) || (e13(a16), t20.add(a16.objectId));
  }
  _createIndexOptions(e13) {
    switch (this._schema.index.type) {
      case "geohash":
        return { type: "geohash", fields: this.aggregateFields, featureFilter: this._featureFilter, geohashLevel: this._schema.index.fixBinLevel, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: e13.scale, sqlOptions: this._sqlOptions };
      case "grid": {
        const t20 = this._schema.index.fixedBinLevel, s20 = null != t20 ? e13.tileInfoView.getLODInfoAt(t20).scale : e13.scale;
        return { type: "grid", fields: this.aggregateFields, cellSize: this._schema.index.size, featureFilter: this._featureFilter, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: s20, sqlOptions: this._sqlOptions };
      }
    }
  }
  async *_update(e13, t20) {
    const { handledChunks: s20, subscription: r17, bins: i19, featureCache: o13 } = e13, n14 = r17.tile;
    if (e13.done) return;
    for (const a16 of t20.chunks()) {
      if (s20.has(a16.chunkId)) continue;
      s20.add(a16.chunkId);
      const t21 = a16.queryInfo;
      if ("tileId" in t21) {
        const e14 = new e4(t21.tileId);
        if (e14.level !== n14.level || e14.world !== n14.key.world) continue;
      }
      a16.getAggregateIndex(this._createIndexOptions(e13.tile)).putBounded(i19, e13.tile.extent, e13.tile.resolution);
    }
    const l10 = [], d11 = r17.tile.transform, u13 = r17.tile.key.level;
    for (const c10 of i19.values()) {
      let e14 = o13.get(c10.id);
      if (e14) e14.attributes = c10.getAttributes();
      else {
        const t21 = c10.getGeometry(this.spatialReference, d11);
        e14 = new s4(t21, c10.getAttributes(), null, c10.id), t21 || (e14.centroid = c10.getGeometricCentroid(this.spatialReference, d11)), e14.displayId = this._attributeStore.createDisplayIdForObjectId(`${e14.objectId}.${u13}`), o13.set(c10.id, e14);
      }
      l10.push(e14);
    }
    this.events.emit("changed"), e13.done = !t20.updateTracking.updating;
    const p8 = u7.fromOptimizedFeatures(l10, this._metadata, d11), f6 = p8.getCursor(), g7 = e13.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
    for (; f6.next(); ) this._attributeStore.setAttributeData(f6.getDisplayId(), f6, g7, this._sqlOptions);
    const y7 = new i12(e13.subscription, p8, [], e13.done, {});
    yield y7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t12 = class {
  constructor(t20) {
    this._statistics = t20;
  }
  get statistics() {
    return this._statistics;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e11 = Math.PI / 180;
var s15 = class _s {
  static create(t20) {
    return new _s(t20.map((t21) => i13(t21)));
  }
  constructor(t20) {
    this._statistics = t20;
  }
  values() {
    return this._statistics.values();
  }
  insert(t20, e13) {
    for (const s20 of this._statistics) s20.insert(t20, e13);
  }
  merge(t20) {
    for (let e13 = 0; e13 < this._statistics.length; e13++) {
      const s20 = this._statistics[e13], i19 = t20._statistics[e13];
      if (s20.field.name !== i19.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s20.merge(i19);
    }
  }
  clone() {
    return new _s(this._statistics.map((t20) => t20.clone()));
  }
};
function i13(t20) {
  switch (t20.statisticType) {
    case "min":
      return new r11(t20);
    case "max":
      return new u10(t20);
    case "avg":
      return new c7(t20);
    case "avg_angle":
      return new h5(t20);
    case "sum":
    case "count":
      return new a10(t20);
    case "mode":
      return new o3(t20);
  }
}
var n8 = class {
  constructor(t20) {
    this.field = t20;
  }
  insert(e13, s20) {
    if (!this.field.computed) return;
    const i19 = this.field.computed.read(e13, s20);
    n5(i19) || this._insertValue(i19);
  }
};
var r11 = class _r extends n8 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t20) {
    this.value = Math.min(this.value, t20);
  }
  merge(t20) {
    this.value = Math.min(this.value, t20.value);
  }
  clone() {
    const t20 = new _r(this.field);
    return t20.value = this.value, t20;
  }
};
var u10 = class _u extends n8 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t20) {
    this.value = Math.max(this.value, t20);
  }
  merge(t20) {
    this.value = Math.max(this.value, t20.value);
  }
  clone() {
    const t20 = new _u(this.field);
    return t20.value = this.value, t20;
  }
};
var a10 = class _a extends n8 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t20) {
    this.value += t20;
  }
  merge(t20) {
    this.value += t20.value;
  }
  clone() {
    const t20 = new _a(this.field);
    return t20.value = this.value, t20;
  }
};
var c7 = class _c extends n8 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t20) {
    this._total += t20, this._count += 1;
  }
  merge(t20) {
    this._total += t20._total, this._count += t20._count;
  }
  clone() {
    const t20 = new _c(this.field);
    return t20._total = this._total, t20._count = this._count, t20;
  }
};
var h5 = class _h extends n8 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t20 = this._x / this._count, e13 = this._y / this._count, s20 = 180 / Math.PI;
    return Math.atan2(e13, t20) * s20;
  }
  _insertValue(t20) {
    this._x = this._x + Math.cos(t20 * e11), this._y = this._y + Math.sin(t20 * e11), this._count += 1;
  }
  merge(t20) {
    this._x += t20._x, this._y += t20._y, this._count += t20._count;
  }
  clone() {
    const t20 = new _h(this.field);
    return t20._x = this._x, t20._y = this._y, t20._count = this._count, t20;
  }
};
var o3 = class _o extends n8 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t20, e13 = 0;
    for (const [s20, i19] of this._frequencies.entries()) i19 > e13 && (e13 = i19, t20 = s20);
    return t20;
  }
  _insertValue(t20) {
    const e13 = this._frequencies.get(t20);
    null != e13 ? this._frequencies.set(t20, e13 + 1) : this._frequencies.set(t20, 1);
  }
  merge(t20) {
    for (const [e13, s20] of t20._frequencies.entries()) {
      const t21 = this._frequencies.get(e13);
      null != t21 ? this._frequencies.set(e13, t21 + s20) : this._frequencies.set(e13, s20);
    }
  }
  clone() {
    const t20 = new _o(this.field);
    return t20._frequencies = new Map(this._frequencies), t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l3 = class _l extends t12 {
  static createId(t20, e13) {
    return `${t20}.${e13}`;
  }
  static create(t20, e13, r17, i19) {
    return new _l(t20, e13, s15.create(r17), i19);
  }
  constructor(t20, e13, r17, i19) {
    super(r17), this.gridX = t20, this.gridY = e13, this._worldUnitsPerCell = i19, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t20 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t20._count = this._count, t20._xWorldTotal = this._xWorldTotal, t20._yWorldTotal = this._yWorldTotal, t20._firstFeatureAttributes = this._firstFeatureAttributes, t20._objectIds = new Set(this._objectIds), t20;
  }
  insert(t20, e13, r17, i19) {
    0 === this._count ? this._firstFeatureAttributes = t20.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r17, this._yWorldTotal += i19, this._statistics.insert(t20, e13), this._objectIds.add(t20.getObjectId());
  }
  merge(t20) {
    if (0 !== t20._count) {
      this._count += t20._count, this._firstFeatureAttributes = t20._firstFeatureAttributes, this._xWorldTotal += t20._xWorldTotal, this._yWorldTotal += t20._yWorldTotal, this._statistics.merge(t20._statistics);
      for (const e13 of t20._objectIds.values()) this._objectIds.add(e13);
    }
  }
  getCentroidX(e13) {
    return null == e13 ? this.centroidXWorld : w(e13, this.centroidXWorld);
  }
  getCentroidY(t20) {
    return null == t20 ? this.centroidYWorld : N(t20, this.centroidYWorld);
  }
  getGeometry(t20, e13) {
    const s20 = this.gridX * this._worldUnitsPerCell, o13 = this.gridY * this._worldUnitsPerCell, l10 = new e([4], [s20, o13, s20 + this._worldUnitsPerCell, o13, s20 + this._worldUnitsPerCell, o13 + this._worldUnitsPerCell, s20, o13 + this._worldUnitsPerCell]);
    if (null != e13) {
      const t21 = new e();
      return dt(t21, l10, false, false, "esriGeometryPolygon", e13);
    }
    return l10;
  }
  getCentroid(t20) {
    const e13 = new e([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t20) {
      const s20 = new e();
      return dt(s20, e13, false, false, "esriGeometryPoint", t20);
    }
    return e13;
  }
  getGeometricCentroid(t20, e13) {
    const s20 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o13 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l10 = new e([], [s20, o13]);
    if (null != e13) {
      const t21 = new e();
      return dt(t21, l10, false, false, "esriGeometryPoint", e13);
    }
    return l10;
  }
  getAttributes() {
    const t20 = { aggregateId: this.id };
    for (const e13 of this._statistics.values()) t20[e13.field.name] = e13.value;
    return null != this._firstFeatureAttributes ? { ...t20, ...this._firstFeatureAttributes } : t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var r12 = class {
  constructor(t20) {
    this._options = t20;
  }
  insert(t20, r17) {
    const o13 = t20.getCursor(), { arcadeContextInfo: s20, scale: i19 } = this._options, n14 = e6(i19, s20);
    for (; o13.next(); ) this._insertFeature(o13, n14, this._options.sqlOptions, r17);
  }
  _insertFeature(e13, r17, o13, s20) {
    const { featureFilter: i19 } = this._options;
    if (null !== i19 && !i19.check(e13, o13)) return;
    let n14 = 0, c10 = 0;
    if ("esriGeometryPoint" === e13.geometryType) n14 = e13.readXWorldSpace(), c10 = e13.readYWorldSpace();
    else {
      if (s20) {
        const r19 = e13.readCentroidForDisplay();
        if (null == r19) return;
        const [o14, s21] = r19.coords;
        if (o14 < 0 || o14 > a5 || s21 < 0 || s21 > a5) return;
      }
      const r18 = e13.readCentroidWorldSpace();
      if (null == r18) return;
      n14 = r18.coords[0], c10 = r18.coords[1];
    }
    this._insert(e13, n14, c10, r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var l4 = 96;
function o4(i19, s20) {
  return Q(i19) * l * l4 / s20;
}
var n9 = class extends r12 {
  constructor(t20) {
    super(t20), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = o4(t20.spatialReference, t20.scale);
  }
  put(t20) {
    for (const e13 of this._cells.values()) {
      const i19 = t20.get(e13.id);
      i19 ? i19.merge(e13) : t20.set(e13.id, e13.clone());
    }
  }
  putBounded(t20, e13, i19) {
    const s20 = [e13.xmin, e13.ymin, e13.xmax, e13.ymax], [l10, o13, n14, r17] = s20, c10 = Math.floor(l10 * this._pixelsPerMapUnit / this._options.cellSize), p8 = Math.floor(o13 * this._pixelsPerMapUnit / this._options.cellSize), a16 = Math.ceil(n14 * this._pixelsPerMapUnit / this._options.cellSize), h8 = Math.ceil(r17 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _5 = p8; _5 <= h8; _5++) for (let e14 = c10; e14 <= a16; e14++) {
      const i20 = `${e14}.${_5}`, s21 = this._cells.get(i20);
      if (!s21) continue;
      const l11 = t20.get(s21.id);
      l11 ? s21 && !t20.has(s21.id) && l11.merge(s21) : t20.set(s21.id, s21.clone());
    }
  }
  _insert(t20, e13, i19, s20) {
    const l10 = e13 * this._pixelsPerMapUnit, o13 = i19 * this._pixelsPerMapUnit, n14 = Math.floor(l10 / this._options.cellSize), r17 = Math.floor(o13 / this._options.cellSize);
    this._getCellOrCreate(n14, r17).insert(t20, s20, e13, i19);
  }
  _getCellOrCreate(t20, e13) {
    const i19 = l3.createId(t20, e13);
    let l10 = this._cells.get(i19);
    if (!l10) {
      const o13 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      l10 = l3.create(t20, e13, this._options.fields, o13), this._cells.set(i19, l10);
    }
    return l10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s16 = class {
  constructor(s20, t20) {
    this.inner = s20, this.displayId = t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var m4 = 128;
var y3 = class extends t11 {
  constructor(e13) {
    super(e13), this.didSend = false, this.done = false;
  }
};
var S2 = class {
  constructor(e13, t20, s20, i19, r17) {
    this._level = e13, this._scale = t20, this._indexOptions = s20, this._clusterRadius = i19, this._store = r17, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e13 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e13.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e13 of this._clusters.values()) {
      const s20 = e13.inner.getCentroid(null), i19 = new s4(s20, e13.inner.getAttributes(), null, e13.inner.id, e13.displayId);
      yield i19;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e13, t20) {
    let s20 = false;
    for (const a16 of e13) {
      const e14 = a16.queryInfo;
      if ("tileId" in e14) {
        if (new e4(e14.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a16.normalizedChunkId)) {
        this._handledChunks.add(a16.normalizedChunkId), s20 = true;
        a16.getAggregateIndex({ ...this._indexOptions, scale: this._scale }).put(this._cells);
      }
    }
    const i19 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r17 = o4(this._indexOptions.spatialReference, this._scale), n14 = this._indexOptions.cellSize;
    for (const { subscription: a16 } of t20) {
      const e14 = a16.tile.bounds, t21 = Math.floor(e14[0] * r17 / n14), s21 = Math.floor(e14[1] * r17 / n14), l10 = Math.ceil(e14[2] * r17 / n14), o13 = Math.ceil(e14[3] * r17 / n14);
      i19.xMin = Math.min(i19.xMin, t21), i19.yMin = Math.min(i19.yMin, s21), i19.xMax = Math.max(i19.xMax, l10), i19.yMax = Math.max(i19.yMax, o13);
    }
    return null != this._lastCellBounds && i19.xMin === this._lastCellBounds.xMin && i19.yMin === this._lastCellBounds.yMin && i19.yMin === this._lastCellBounds.yMin && i19.yMax === this._lastCellBounds.yMax || (s20 = true, this._lastCellBounds = i19), s20 && this._clusterCells(i19), s20;
  }
  async updateStatistics(e13) {
    let t20 = false;
    for (const s20 of this._clusters.values()) s20.inner.count > 1 && (t20 = this._updateAggregateStatistics(this._statistics, s20.inner) || t20);
    if (t20) {
      const t21 = Array.from(this._statistics.entries()).map(([e14, t22]) => ({ fieldName: e14, minValue: t22.minValue, maxValue: t22.maxValue }));
      await e13.container.updateStatistics(this._level, t21);
    }
  }
  createAggregateFeatures(e13, i19) {
    const n14 = e13.subscription, a16 = [], l10 = n14.tile.transform;
    for (const o13 of this._clusters.values()) {
      let e14 = o13.inner.getCentroidX(l10);
      const i20 = o13.inner.getCentroidY(l10), d11 = n14.tile.lod, u13 = d11.wrap ? d11.worldSize[0] : null, c10 = 1 === o13.inner.count ? o13.inner.firstObjectId : o13.inner.id, h8 = o13.displayId;
      if (null != u13) if (1 === u13) {
        const n15 = new e([], [e14, i20]), l11 = new s4(n15, o13.inner.getAttributes(), null, c10, h8);
        l11.geometry.coords[0] -= a5, a16.push(l11);
        const d12 = new e([], [e14, i20]), u14 = new s4(d12, o13.inner.getAttributes(), null, c10, h8);
        u14.geometry.coords[0] += a5, a16.push(u14);
      } else e14 > a5 + a5 / 2 ? e14 -= u13 * a5 : e14 < -256 && (e14 += u13 * a5);
      if (e14 < a5 + m4 && e14 >= -128 && i20 < a5 + m4 && i20 >= -128) {
        const r17 = new e([], [e14, i20]), n15 = new s4(r17, o13.inner.getAttributes(), null, c10, h8);
        a16.push(n15);
      }
    }
    return u7.fromOptimizedFeatures(a16, i19, n14.tile.transform);
  }
  _clusterCells(e13) {
    let t20 = Array.from(this._cells.values());
    t20 = t20.sort((e14, t21) => t21.count - e14.count);
    const s20 = [];
    for (const a16 of this._clusters.values()) s20.push(a16.inner.id);
    this._clusters.clear();
    const i19 = this._clusterRadius * (1 / o4(this._indexOptions.spatialReference, this._scale)), r17 = 1 + this._clusterRadius / this._indexOptions.cellSize, n14 = /* @__PURE__ */ new Set();
    for (const l10 of t20) {
      if (n14.has(l10.id)) continue;
      if (l10.gridX < e13.xMin || l10.gridX > e13.xMax || l10.gridY < e13.yMin || l10.gridY > e13.yMax) continue;
      const t21 = this._store.createDisplayIdForObjectId(l10.id), s21 = new s16(l10.clone(), t21);
      n14.add(l10.id), this._clusters.set(l10.id, s21);
      const o13 = l10.centroidXWorld, d11 = l10.centroidYWorld;
      for (let e14 = l10.gridY - r17; e14 <= l10.gridY + r17; e14++) for (let t22 = l10.gridX - r17; t22 <= l10.gridX + r17; t22++) {
        if (e14 === l10.gridY && t22 === l10.gridX) continue;
        const r18 = this._cells.get(l3.createId(t22, e14));
        if (!r18 || n14.has(r18.id)) continue;
        const u13 = Math.abs(r18.centroidXWorld - o13), c10 = Math.abs(r18.centroidYWorld - d11);
        u13 < i19 && c10 < i19 && (s21.inner.merge(r18), n14.add(r18.id));
      }
    }
    for (const a16 of s20) this._store.releaseDisplayIdForObjectId(a16);
  }
  _updateAggregateStatistics(e13, t20) {
    let s20 = false;
    for (const i19 of t20.statistics.values()) {
      if ("esriFieldTypeString" === i19.field.type) continue;
      const t21 = i19.value, r17 = i19.field, n14 = e13.get(r17.name);
      if (n14) {
        const { minValue: e14, maxValue: i20 } = n14, r18 = Math.min(n14.minValue, t21), a16 = Math.max(n14.maxValue, t21);
        e14 === r18 && i20 === a16 || (n14.minValue = r18, n14.maxValue = a16, s20 = true);
      } else e13.set(r17.name, { minValue: t21, maxValue: t21 }), s20 = true;
    }
    return s20;
  }
};
var x3 = class _x extends i11 {
  static async create(e13, t20, s20, i19, r17, a16, l10) {
    const o13 = new p2({ spatialReference: s20 }), d11 = { type: "grid", fields: await Promise.all(t20.fields.map(async (e14) => s14.create(o13, e14))), spatialReference: s20, featureFilter: t20.featureFilter ? await p3.create({ geometryType: i19.metadata.geometryType, hasM: false, hasZ: false, timeInfo: i19.metadata.timeInfo, fieldsIndex: i19.metadata.fieldsIndex, spatialReference: s20, filterJSON: t20.featureFilter }) : null, cellSize: t20.clusterRadius / 4, arcadeContextInfo: a16, sqlOptions: l10 };
    return new _x(e13, t20.clusterRadius, d11, t20.fields, i19, r17, l10);
  }
  constructor(e13, t20, s20, r17, n14, a16, l10) {
    super(n14, a16, s20.spatialReference, s20.fields, l10), this._connection = e13, this._clusterRadius = t20, this._indexOptions = s20, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = i7.createFeature({ geometryType: "esriGeometryPoint", objectIdField: "aggregateId", fieldsIndex: new Z([...r17, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }]).toJSON(), globalIdField: null, spatialReference: n14.metadata.spatialReference, outSpatialReference: n14.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e13 of this._cellsPerScale.values()) e13.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e13) {
    super.onSubscribe(e13), this._requiredLevel = e13.tile.level, this._requiredScale = e13.tile.scale;
  }
  createState(e13) {
    return new y3(e13);
  }
  async *applyOverrideUpdate(e13) {
    for (const t20 of this._cellsPerScale.values()) t20.destroy();
    this._cellsPerScale.clear();
    for (const t20 of this._sendStates.values()) t20.done = false;
  }
  displayMap(e13, t20, s20) {
    const i19 = new Map(e13.map((e14) => [t20(e14), e14])), r17 = [], n14 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a16 of n14.clusters()) {
      const e14 = i19.get(a16.inner.id);
      if (null == e14) {
        if (1 === a16.inner.count) {
          const { firstObjectId: e15 } = a16.inner, t21 = e15 ? i19.get(e15) : null;
          if (null != t21) {
            const n15 = s20(a16.displayId, t21, e15);
            r17.push(n15), i19.delete(e15);
          }
        }
      } else {
        const t21 = s20(a16.displayId, e14, a16.inner.id);
        r17.push(t21), i19.delete(a16.inner.id);
      }
    }
    return r17;
  }
  getDisplayFeatures(t20) {
    const s20 = new Set(t20), i19 = /* @__PURE__ */ new Set(), r17 = [], n14 = [], a16 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l10 of a16.aggregatesWorldSpace()) if (s20.has(l10.displayId) && !i19.has(l10.displayId)) {
      const t21 = rt(l10, this._metadata.geometryType, false, false);
      if (i19.add(l10.displayId), 1 === t21.attributes.cluster_count) {
        r17.push({ ...t21, displayId: l10.displayId });
        continue;
      }
      n14.push({ ...t21, displayId: l10.displayId });
    }
    return { features: r17, aggregates: n14, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e13) {
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s20 of t20.clusters()) if (s20.inner.id === e13) return Array.from(s20.inner.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    const e13 = this._source.chunks();
    if (!e13.length) return;
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale), s20 = Array.from(this._sendStates.values()).filter((e14) => e14.subscription.tile.level === this._requiredLevel);
    if (t20.updateChunks(e13, s20) || !this._source.updateTracking.updating) for (const n14 of s20) n14.subscription.tile.level === this._requiredLevel && (n14.didSend = false, n14.done = false);
    const i19 = Array.from(this._sendStates.values()).filter((e14) => e14.done).map((e14) => e14.subscription.tile.key), r17 = new Set(i19);
    for (const n14 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i19.some((e14) => e14.containsChild(n14.subscription.tile.key))) continue;
        if (n14.subscription.tile.key.getChildKeys().every((e14) => r17.has(e14))) continue;
      }
      n14.didSend || n14.subscription.tile.level !== this._requiredLevel || (n14.didSend = true, yield* this._update(n14, t20, this._source));
    }
    await t20.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e13) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t20 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s20 of t20.aggregatesWorldSpace()) e13(s20);
  }
  _getClusterState(e13, t20) {
    if (null == e13 || null == t20) throw new Error("InternalError: Level and scale must be defined");
    let s20 = this._cellsPerScale.get(t20);
    return s20 || (s20 = new S2(e13, t20, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t20, s20)), s20;
  }
  async *_update(e13, t20, s20) {
    if (e13.done) return;
    const i19 = t20.createAggregateFeatures(e13, this._metadata);
    this.events.emit("changed"), e13.done = !s20.updateTracking.updating;
    const r17 = i19.getCursor(), n14 = e13.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);
    for (; r17.next(); ) this._attributeStore.setAttributeData(r17.getDisplayId(), r17, n14, this._sqlOptions);
    const a16 = new e10(e13.subscription, i19, true, e13.done, {});
    yield a16;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t13 = class _t {
  static fromReader(o13) {
    const e13 = [], r17 = o13.copy(), a16 = u3();
    for (; r17.next(); ) {
      r17.getBounds(a16) && e13.push(r17.getIndex());
    }
    const i19 = i8(9, (n14) => (r17.setIndex(n14), { minX: r17.getBoundsXMin(), minY: r17.getBoundsYMin(), maxX: r17.getBoundsXMax(), maxY: r17.getBoundsYMax() }));
    return i19.load(e13), new _t(i19);
  }
  constructor(n14) {
    this._index = n14;
  }
  search(n14) {
    const s20 = { minX: n14[0], minY: n14[1], maxX: n14[2], maxY: n14[3] };
    return this._index.search(s20);
  }
};

// node_modules/@arcgis/core/geohash/geohashUtils.js
var m5 = new Float64Array(2);
var p5 = new Float64Array(2);
var j3 = 64;
function S3(t20, e13, f6, a16) {
  const l10 = [t20.xmin, t20.ymin, t20.xmax, t20.ymax], u13 = j.fromExtent(c2(l10, a16)), h8 = j2(u13, a16, g3.WGS84, { densificationStep: e13 * j3 });
  if (!h8) return null;
  const m11 = W(new e(), h8, false, false), p8 = m11.coords.filter((t21, o13) => !(o13 % 2)), g7 = m11.coords.filter((t21, o13) => o13 % 2), y7 = Math.min(...p8), d11 = Math.min(...g7), x5 = Math.max(...p8), M4 = Math.max(...g7), S5 = A(y7, d11, f6, g3.WGS84), G2 = A(x5, M4, f6, g3.WGS84);
  return S5 && G2 ? { bounds: l10, geohashBounds: { xLL: S5[0], yLL: S5[1], xTR: G2[0], yTR: G2[1] }, level: f6 } : null;
}
function A(o13, n14, s20, c10) {
  if (c10.isWebMercator) {
    const r17 = M(o13 / t2.radius), c11 = r17 - 360 * Math.floor((r17 + 180) / 360), i19 = [0, 0];
    return z2(i19, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-n14 / t2.radius))), c11, s20), i19;
  }
  const f6 = j2({ x: o13, y: n14 }, c10, g3.WGS84);
  if (!f6) return null;
  const a16 = [0, 0];
  return z2(a16, 0, f6.y, f6.x, s20), a16;
}
function X2(t20, o13) {
  let r17 = -90, n14 = 90, e13 = -180, s20 = 180;
  for (let c10 = 0; c10 < o13; c10++) {
    const o14 = Math.ceil((c10 + 1) / 2), i19 = Math.floor((c10 + 1) / 2), f6 = 1 - c10 % 2, a16 = 30 - (3 * o14 + 2 * i19), l10 = 30 - (2 * o14 + 3 * i19), u13 = 3 * f6 + 2 * (1 - f6), h8 = 2 * f6 + 3 * (1 - f6), m11 = 3 * f6 + 7 * (1 - f6) << l10, p8 = (7 * f6 + 3 * (1 - f6) << a16 & t20.geohashX) >> a16, g7 = (m11 & t20.geohashY) >> l10;
    for (let t21 = u13 - 1; t21 >= 0; t21--) {
      const o15 = (e13 + s20) / 2, r18 = p8 & 1 << t21 ? 1 : 0;
      e13 = (1 - r18) * e13 + r18 * o15, s20 = (1 - r18) * o15 + r18 * s20;
    }
    for (let t21 = h8 - 1; t21 >= 0; t21--) {
      const o15 = (r17 + n14) / 2, e14 = g7 & 1 << t21 ? 1 : 0;
      r17 = (1 - e14) * r17 + e14 * o15, n14 = (1 - e14) * o15 + e14 * n14;
    }
  }
  return [e13, r17, s20, n14];
}
function z2(t20, o13, r17, n14, e13) {
  e13 % 2 && (e13 += 1);
  let s20 = 0, c10 = 0, i19 = -90, f6 = 90, a16 = -180, l10 = 180;
  for (let u13 = 0; u13 < e13 / 2; u13++) {
    for (let t21 = 0; t21 < 5; t21++) {
      const o14 = (a16 + l10) / 2, r18 = n14 > o14 ? 1 : 0;
      s20 |= r18 << 29 - (t21 + 5 * u13), a16 = (1 - r18) * a16 + r18 * o14, l10 = (1 - r18) * o14 + r18 * l10;
    }
    for (let t21 = 0; t21 < 5; t21++) {
      const o14 = (i19 + f6) / 2, n15 = r17 > o14 ? 1 : 0;
      c10 |= n15 << 29 - (t21 + 5 * u13), i19 = (1 - n15) * i19 + n15 * o14, f6 = (1 - n15) * o14 + n15 * f6;
    }
  }
  t20[2 * o13] = s20, t20[2 * o13 + 1] = c10;
}

// node_modules/@arcgis/core/geohash/GeohashCell.js
var l5 = class _l extends t12 {
  static create(t20, e13, o13, s20) {
    const r17 = s15.create(t20), i19 = new Array(32);
    for (let h8 = 0; h8 < i19.length; h8++) i19[h8] = null;
    return new _l(r17, e13, o13, s20, i19);
  }
  constructor(t20, e13, o13, s20, r17) {
    super(t20), this.xNode = e13, this.yNode = o13, this.depth = s20, this.children = r17, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t20 = new _l(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t20._count = this._count, t20._xWorldTotal = this._xWorldTotal, t20._yWorldTotal = this._yWorldTotal, t20._xGeohashTotal = this._xGeohashTotal, t20._yGeohashTotal = this._yGeohashTotal, t20.next = this.next, t20._objectIds = new Set(this._objectIds), t20;
  }
  insert(t20, e13, o13, s20, r17, i19) {
    this._count += 1, this._xWorldTotal += e13, this._yWorldTotal += o13, this._xGeohashTotal += s20, this._yGeohashTotal += r17, this._statistics.insert(t20, i19), this._objectIds.add(t20.getObjectId());
  }
  merge(t20) {
    if (0 !== t20._count) {
      this._count += t20._count, this._xWorldTotal += t20._xWorldTotal, this._yWorldTotal += t20._yWorldTotal, this._xGeohashTotal += t20._xWorldTotal, this._yGeohashTotal += t20._yWorldTotal, this._statistics.merge(t20._statistics);
      for (const e13 of t20._objectIds.values()) this._objectIds.add(e13);
    }
  }
  getCentroid(t20) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t20, r17) {
    const a16 = this._getLngLatBounds(), [n14, l10, d11, c10] = a16, _5 = j2({ rings: [[[n14, l10], [n14, c10], [d11, c10], [d11, l10], [n14, l10]]] }, g3.WGS84, t20), u13 = W(new e(), _5, false, false);
    if (null != r17) {
      return dt(new e(), u13, false, false, "esriGeometryPolygon", r17, false, false);
    }
    return u13;
  }
  getGeometricCentroid(t20, o13) {
    const a16 = this._getLngLatBounds(), [n14, l10, d11, c10] = a16, _5 = j2({ x: (n14 + d11) / 2, y: (l10 + c10) / 2 }, g3.WGS84, t20), u13 = U2(new e(), _5);
    if (null != o13) {
      return dt(new e(), u13, false, false, "esriGeometryPoint", o13, false, false);
    }
    return u13;
  }
  getAttributes() {
    const t20 = { aggregateId: this.id };
    for (const e13 of this._statistics.values()) t20[e13.field.name] = e13.value;
    return t20.aggregateCount = this._count, t20;
  }
  find(t20, e13, o13, s20, r17, i19) {
    if (s20 >= o13) return this;
    const h8 = 1 - s20 % 2, a16 = 3 * h8 + 2 * (1 - h8), n14 = 2 * h8 + 3 * (1 - h8), l10 = 30 - r17 - a16, d11 = 30 - i19 - n14, c10 = ((t20 & 7 * h8 + 3 * (1 - h8) << l10) >> l10) + ((e13 & 3 * h8 + 7 * (1 - h8) << d11) >> d11) * (8 * h8 + 4 * (1 - h8)), _5 = this.children[c10];
    return null == _5 ? null : _5.find(t20, e13, o13, s20 + 1, r17 + a16, i19 + n14);
  }
  _getLngLatBounds() {
    const e13 = this.depth, o13 = Math.ceil(e13 / 2), s20 = Math.floor(e13 / 2), r17 = 30 - (3 * o13 + 2 * s20), i19 = 30 - (2 * o13 + 3 * s20), h8 = this.xNode << r17, a16 = this.yNode << i19;
    return X2({ geohashX: h8, geohashY: a16 }, this.depth);
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var e12 = class {
  constructor(e13) {
    this._fields = e13, this._size = 0, this._depth = 0, this._root = l5.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  find(t20, e13, s20) {
    return this._root.find(t20, e13, s20, 0, 0, 0);
  }
  insert(e13, s20, i19, n14, o13, h8, r17) {
    let l10 = this._root, d11 = 0, c10 = 0, a16 = 0;
    for (; null !== l10; ) {
      if (l10.insert(e13, s20, i19, n14, o13, r17), d11 >= h8) return;
      const f6 = Math.ceil((d11 + 1) / 2), u13 = Math.floor((d11 + 1) / 2), x5 = 1 - d11 % 2, _5 = 30 - (3 * f6 + 2 * u13), p8 = 30 - (2 * f6 + 3 * u13), M4 = (n14 & 7 * x5 + 3 * (1 - x5) << _5) >> _5, m11 = (o13 & 3 * x5 + 7 * (1 - x5) << p8) >> p8, g7 = M4 + m11 * (8 * x5 + 4 * (1 - x5));
      c10 = c10 << 3 * x5 + 2 * (1 - x5) | M4, a16 = a16 << 2 * x5 + 3 * (1 - x5) | m11, null == l10.children[g7] && (l10.children[g7] = l5.create(this._fields, c10, a16, d11 + 1), this._depth = Math.max(this._depth, d11 + 1), this._size += 1), d11 += 1, l10 = l10.children[g7];
    }
  }
  putBins(t20, e13) {
    for (const s20 of this.getNodes(e13)) {
      const e14 = t20.get(s20.id);
      e14 ? e14.merge(s20) : t20.set(s20.id, s20.clone());
    }
  }
  getNodes(t20) {
    const e13 = [], { geohashBounds: s20, level: i19 } = t20;
    let n14 = this._root;
    for (; null !== n14; ) {
      const t21 = n14.depth, o13 = n14.xNode, h8 = n14.yNode;
      if (t21 >= i19) {
        e13.push(n14), n14 = n14.next;
        continue;
      }
      const r17 = Math.ceil((t21 + 1) / 2), l10 = Math.floor((t21 + 1) / 2), d11 = 1 - t21 % 2, c10 = 30 - (3 * r17 + 2 * l10), a16 = 30 - (2 * r17 + 3 * l10), f6 = ~((1 << c10) - 1), u13 = ~((1 << a16) - 1), x5 = (s20.xLL & f6) >> c10, _5 = (s20.yLL & u13) >> a16, p8 = (s20.xTR & f6) >> c10, M4 = (s20.yTR & u13) >> a16, m11 = o13 << 3 * d11 + 2 * (1 - d11), g7 = h8 << 2 * d11 + 3 * (1 - d11), y7 = m11 + 8 * d11 + 4 * (1 - d11), z4 = g7 + 4 * d11 + 8 * (1 - d11), L3 = Math.max(m11, x5), N2 = Math.max(g7, _5), B = Math.min(y7, p8), R2 = Math.min(z4, M4);
      let T = null, j4 = null;
      for (let e14 = N2; e14 <= R2; e14++) for (let t22 = L3; t22 <= B; t22++) {
        const s21 = t22 - m11 + (e14 - g7) * (8 * d11 + 4 * (1 - d11)), i20 = n14.children[s21];
        i20 && (T || (T = i20, T.next = n14.next), j4 && (j4.next = i20), j4 = i20, i20.next = n14.next);
      }
      n14 = T || n14.next;
    }
    return e13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r13 = class extends r12 {
  constructor(t20) {
    super(t20), this._tree = new e12(this._options.fields);
  }
  put(e13) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e13, s20, o13) {
    const { geohashLevel: r17, spatialReference: h8 } = this._options, i19 = S3(s20, o13, r17, h8);
    null != i19 && this._tree.putBins(e13, i19);
  }
  _insert(e13, t20, o13, r17) {
    const { geohashLevel: h8, spatialReference: i19 } = this._options, n14 = A(t20, o13, h8, i19);
    n14 && this._tree.insert(e13, t20, o13, n14[0], n14[1], h8, r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var d6 = class _d extends M2 {
  static from(r17, e13) {
    if (r17 instanceof this) {
      const t20 = new Set(e13), s20 = r17._indices.filter((r18) => t20.has(r18));
      return new _d(r17._reader, s20);
    }
    return new _d(r17.copy(), e13);
  }
  constructor(r17, e13) {
    super(r17.metadata), this._currentIndex = -1, this._displayTransform = null, this._reader = r17, this._indices = e13;
  }
  setTransformForDisplay(r17) {
    const t20 = this._reader.getInTransform();
    if (null == t20) return void (this._displayTransform = u6(r17));
    const s20 = u6(t20), a16 = u6(r17), [i19, d11] = s20.scale, [n14, o13] = s20.translate, [h8, u13] = a16.scale, [_5, l10] = a16.translate, y7 = i19 / h8, c10 = d11 / u13, p8 = (n14 - _5) / h8, m11 = (o13 - l10) / u13;
    this._displayTransform = { originPosition: "lowerLeft", scale: [1 / y7, 1 / c10, 1, 1], translate: [-p8 / y7, -m11 / c10, 0, 0] };
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r17 = new _d(this._reader.copy(), this._indices);
    return r17._currentIndex = this._currentIndex, r17._displayTransform = this._displayTransform, r17._processorAttributes = this._processorAttributes, r17;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(r17) {
    this._reader.contextTimeZone = r17;
  }
  get usedMemory() {
    return s3 + this._reader.usedMemory;
  }
  setProcessorAttributes(r17) {
    this._processorAttributes = Object.assign(this._processorAttributes ?? {}, r17);
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._displayTransform ? i5(this._displayTransform, this._reader.readXForDisplay()) : this._reader.readXForDisplay();
  }
  readYForDisplay() {
    return this._displayTransform ? a3(this._displayTransform, this._reader.readYForDisplay()) : this._reader.readYForDisplay();
  }
  readGeometryForDisplay() {
    return this._displayTransform ? this._reader.readGeometryForDisplayTransformed(this._displayTransform) : this._reader.readGeometryForDisplay();
  }
  readCentroidForDisplay() {
    var _a;
    const r17 = (_a = this._reader.readCentroidForDisplay()) == null ? void 0 : _a.clone();
    if (r17) {
      const [e13, a16] = r17.coords;
      this._displayTransform ? (r17.coords[0] = i5(this._displayTransform, e13), r17.coords[1] = a3(this._displayTransform, a16)) : (r17.coords[0] = e13, r17.coords[1] = a16);
    }
    return r17;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(r17, e13 = false) {
    var _a;
    return this._reader.readAttribute(r17, e13) ?? ((_a = this._processorAttributes) == null ? void 0 : _a[r17]);
  }
  readAttributes() {
    return { ...this._processorAttributes ?? {}, ...this._reader.readAttributes() };
  }
  joinAttributes(r17) {
    return this._reader.joinAttributes(r17);
  }
  getBounds(r17) {
    return this._reader.getBounds(r17);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(r17) {
    return this._reader.setDisplayId(r17);
  }
  setIndex(r17) {
    return this._reader.setIndex(r17);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const r17 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (r17 && { x: r17.coords[0], y: r17.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const r17 = this.readGeometryForDisplay();
    return ut(r17, this.geometryType, false, false);
  }
  readGeometryArea() {
    var _a;
    return this._displayTransform ? ((_a = this._reader.readGeometryForDisplayTransformed(this._displayTransform)) == null ? void 0 : _a.area()) ?? 0 : this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(r17, e13) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(r17) {
    return this._reader.field(r17);
  }
  hasField(r17) {
    return this._reader.hasField(r17);
  }
  setField(r17, e13) {
    return this._reader.setField(r17, e13);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(r17 = false) {
    return this._reader.castToText(r17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i14 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  registerOverrides(e13) {
    this.reader.registerOverrides(e13), this.invalidate();
  }
  queryFeaturesInBounds(e13) {
    const t20 = this._getSpatialIndex().search(e13);
    return d6.from(this.reader, t20);
  }
  getAggregateIndex(e13) {
    const a16 = JSON.stringify(e13);
    if (a16 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = a16, e13.type) {
        case "grid":
          this._aggregateIndex = new n9(e13);
          break;
        case "geohash":
          this._aggregateIndex = new r13(e13);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t13.fromReader(this.reader)), this._spatialIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/Overrides.js
var s17 = 1e4;
var r14 = 1e3;
var i15 = class {
  constructor() {
    this.modified = [], this.removed = [];
  }
  modify(e13) {
    this.modified.push(e13);
  }
  remove(e13) {
    this.removed.push(e13);
  }
  get isEmpty() {
    return 0 === this.modified.length && 0 === this.removed.length;
  }
};
var o5 = class _o extends i14 {
  constructor(e13) {
    super(), this._reader = e13, this.chunkId = "override", this.normalizedChunkId = "override";
  }
  static fromFeatures(e13, s20) {
    const r17 = u7.fromOptimizedFeatures(e13, s20);
    return new _o(r17);
  }
  get reader() {
    return this._reader;
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  getTileReader(e13) {
    if (!this._reader.getSize()) return null;
    const t20 = this.queryFeaturesInBounds(e13.bounds);
    return t20.setTransformForDisplay(e13.transform), t20;
  }
};
var n10 = class {
  constructor(e13, t20) {
    this.inner = e13, this.isWeak = t20, this.lastWeak = null;
  }
  get isStrong() {
    return !this.isWeak;
  }
};
var a11 = class {
  constructor() {
    this._overrides = /* @__PURE__ */ new Map(), this._update = new i15(), this._lastCleanup = 0;
  }
  hasOverride(e13) {
    return this._overrides.has(e13);
  }
  onChunkInsert(e13) {
    if (this._overrides.size) {
      const t20 = e13.reader.getCursor();
      for (; t20.next(); ) {
        const e14 = t20.getObjectId(), s20 = this._overrides.get(e14);
        if ((s20 == null ? void 0 : s20.lastWeak) && (s20.lastWeak = null), s20 == null ? void 0 : s20.isWeak) {
          const e15 = t20.readOptimizedFeatureWorldSpace();
          s20.inner = e15, this._update.modify(e15), this.invalidate();
        }
      }
    }
    e13.registerOverrides(this);
  }
  apply(e13, t20) {
    const { updateWeak: s20, removeWeak: r17, update: i19, remove: o13, release: a16 } = e13.commands;
    this.invalidate();
    for (const d11 of s20) {
      const e14 = new n10(d11, true), t21 = this._overrides.get(d11.objectId);
      (t21 == null ? void 0 : t21.isStrong) ? t21.lastWeak = e14 : (this._overrides.set(d11.objectId, e14), this._update.modify(d11));
    }
    for (const d11 of i19) {
      const e14 = new n10(d11, false), t21 = this._overrides.get(d11.objectId);
      e14.lastWeak = (t21 == null ? void 0 : t21.isWeak) ? t21 : (t21 == null ? void 0 : t21.lastWeak) ?? null, this._overrides.set(d11.objectId, e14), this._update.modify(d11);
    }
    for (const d11 of r17) {
      const e14 = new n10(null, true), t21 = this._overrides.get(d11);
      (t21 == null ? void 0 : t21.isStrong) ? t21.lastWeak = e14 : (this._overrides.set(d11, e14), this._update.remove(d11));
    }
    for (const d11 of o13) {
      const e14 = new n10(null, false), t21 = this._overrides.get(d11);
      e14.lastWeak = (t21 == null ? void 0 : t21.isWeak) ? t21 : (t21 == null ? void 0 : t21.lastWeak) ?? null, this._overrides.set(d11, e14), this._update.remove(d11);
    }
    if (a16.length) {
      const e14 = /* @__PURE__ */ new Set();
      for (const t21 of a16) {
        const s21 = this._overrides.get(t21);
        (s21 == null ? void 0 : s21.lastWeak) ? (this._overrides.set(t21, s21.lastWeak), null == s21.lastWeak.inner ? this._update.remove(t21) : this._update.modify(s21.lastWeak.inner)) : s21 && !s21.isWeak && (this._overrides.delete(t21), e14.add(t21));
      }
      t20.forEachUnsafe((t21) => {
        const s21 = t21.getObjectId();
        e14.has(s21) && (this._update.modify(t21.readOptimizedFeatureWorldSpace()), e14.delete(s21));
      });
      for (const t21 of e14.values()) this._update.remove(t21);
    }
  }
  clearWeakOverrides() {
    for (const [e13, t20] of this._overrides.entries()) t20.isWeak && this._overrides.delete(e13);
    this.invalidate();
  }
  cleanup(e13) {
    if (this._overrides.size < s17) return;
    const t20 = performance.now();
    if (t20 - this._lastCleanup < r14) return;
    this._lastCleanup = t20;
    const i19 = this._getWeakDeletions();
    if (!(i19.size < s17)) {
      for (const t21 of e13) {
        const e14 = t21.reader.withoutOverrides().getCursor();
        for (; e14.next(); ) {
          const t22 = e14.getObjectId();
          i19.delete(t22);
        }
      }
      for (const e14 of i19) this._overrides.delete(e14);
      i19.size && this.invalidate();
    }
  }
  takeOverrideUpdate() {
    const e13 = this._update;
    return e13.isEmpty ? null : (this._update = new i15(), e13);
  }
  asChunk(e13) {
    if (!this._chunk) {
      const t20 = [];
      for (const e14 of this._overrides.values()) null != e14.inner && t20.push(e14.inner);
      this._chunk = o5.fromFeatures(t20, e13);
    }
    return this._chunk;
  }
  invalidate() {
    this._chunk = null;
  }
  putWeakObjectIdsFromGlobalIds(e13, t20, s20) {
    for (const [r17, i19] of this._overrides.entries()) if (i19.isWeak && null != i19.inner) {
      const o13 = i19.inner.attributes[s20];
      o13 && t20.has(o13) && !e13.has(o13) && e13.set(o13, r17);
    } else if (null != i19.lastWeak && null != i19.lastWeak.inner) {
      const o13 = i19.lastWeak.inner.attributes[s20];
      o13 && t20.has(o13) && !e13.has(o13) && e13.set(o13, r17);
    }
  }
  _getWeakDeletions() {
    const e13 = /* @__PURE__ */ new Set();
    for (const [t20, s20] of this._overrides.entries()) s20.isWeak && null == s20.inner && e13.add(t20);
    return e13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var d7 = class extends t11 {
};
var i16 = class extends e9 {
  constructor(e13, t20, s20, r17) {
    super(e13, t20, r17), this._arcadeContextInfo = s20, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e13 of this._source.chunks()) this._cleanupChunkIds(e13);
  }
  invalidateAttributeData(e13) {
    this.handledChunksForAttributeData.clear(), this._arcadeContextInfo = e13, null != this._evalOptions && (this._evalOptions = e6(this._evalOptions.$view.scale, e13));
  }
  onSubscribe(e13) {
    super.onSubscribe(e13), this._evalOptions = e13.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
  }
  createState(e13) {
    return new d7(e13);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e13, t20, s20) {
    const r17 = new Map(e13.map((e14) => [t20(e14), e14])), o13 = [];
    for (const a16 of this._source.chunks()) {
      const e14 = a16.reader.getCursor();
      for (; e14.next(); ) {
        const t21 = e14.getObjectId(), a17 = e14.getDisplayId(), n14 = r17.get(t21);
        if (null != n14) {
          const e15 = s20(a17, n14, t21);
          o13.push(e15), r17.delete(t21);
        }
      }
    }
    return o13;
  }
  getDisplayFeatures(e13) {
    const t20 = new Set(e13), s20 = /* @__PURE__ */ new Set(), r17 = [];
    for (const o13 of this._source.chunks()) {
      const e14 = o13.reader.getCursor();
      for (; e14.next(); ) {
        const o14 = e14.getObjectId(), a16 = e14.getDisplayId();
        t20.has(a16) && !s20.has(o14) && (r17.push({ ...e14.readLegacyFeatureWorldSpace(), displayId: a16 }), s20.add(o14));
      }
    }
    return { features: r17, aggregates: [], tracks: [] };
  }
  async *applyOverrideUpdate(e13) {
    const t20 = [];
    for (const s20 of e13.modified) {
      const e14 = this._attributeStore.createDisplayIdForObjectId(s20.objectId);
      s20.displayId = e14, t20.push(e14);
    }
    const r17 = u7.fromOptimizedFeatures(e13.modified, this._source.metadata).getCursor();
    for (; r17.next(); ) this._attributeStore.setAttributeData(r17.getDisplayId(), r17, this._evalOptions, this._sqlOptions);
    const a16 = [];
    for (const s20 of e13.removed) {
      const e14 = this._attributeStore.getDisplayIdForObjectId(s20);
      null != e14 && a16.push(e14);
    }
    has("esri-2d-update-debug") && console.debug("FeatureUpdateStrategy.applyLocalEdit", { message: e13, modifiedDisplayIds: t20, removedDisplayIds: a16 });
    const d11 = o5.fromFeatures(e13.modified, this._source.metadata);
    this.handledChunks.add(d11.chunkId), this.handledChunksForAttributeData.add(d11.chunkId), this.handledChunksForIdCreation.add(d11.chunkId);
    for (const o13 of this._sendStates.values()) o13.handledChunks.add(d11.chunkId), yield new i12(o13.subscription, null, t20, false, d11.queryInfo);
    for (const o13 of this._sendStates.values()) {
      const e14 = d11.getTileReader(o13.subscription.tile);
      yield new i12(o13.subscription, e14, a16, false, d11.queryInfo);
    }
    for (const s20 of e13.removed) this._attributeStore.releaseDisplayIdForObjectId(s20);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      await this._updateAttributeData();
      for (const e13 of this._sendStates.values()) yield* this._update(e13);
    }
  }
  removeChunks(e13) {
    for (const t20 of e13) this.handledChunks.delete(t20.chunkId), this.handledChunksForAttributeData.delete(t20.chunkId), this._cleanupChunkIds(t20);
  }
  afterUpdateChunks() {
    for (const e13 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e13);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e13) {
    if (this.handledChunksForIdCreation.has(e13.chunkId)) {
      const t20 = e13.reader.getCursor();
      for (; t20.next(); ) {
        const e14 = t20.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e14) : this._attributeStore.releaseDisplayIdForObjectId(e14);
      }
      this.handledChunksForIdCreation.delete(e13.chunkId);
    }
  }
  async _updateAttributeData() {
    for (const e13 of this._source.chunks()) {
      const { chunkId: t20, reader: s20 } = e13;
      if (!this.handledChunksForIdCreation.has(t20)) {
        this.handledChunksForIdCreation.add(t20);
        const e14 = s20.getCursor();
        for (; e14.next(); ) {
          const t21 = this._attributeStore.createDisplayIdForObjectId(e14.getObjectId());
          e14.setDisplayId(t21);
        }
      }
    }
    for (const e13 of this._source.chunks()) if (!this.handledChunksForAttributeData.has(e13.chunkId)) {
      this.handledChunksForAttributeData.add(e13.chunkId);
      const t20 = e13.reader.getCursor();
      for (; t20.next(); ) {
        const e14 = t20.getDisplayId();
        this._attributeStore.setAttributeData(e14, t20, this._evalOptions, this._sqlOptions);
      }
    }
  }
  *_update(e13) {
    const { subscription: t20, handledChunks: s20 } = e13;
    for (const o13 of this._source.chunks()) {
      const { chunkId: a16 } = o13;
      if (s20.has(a16)) continue;
      s20.add(a16);
      const n14 = o13.getTileReader(t20.tile);
      n14 && (yield new e10(e13.subscription, n14, false, o13.end, o13.queryInfo));
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/TrackStrategy.js
var P3;
var C = () => n.getLogger("esri.views.2d.layers.features.processor.TrackStrategy");
var M3 = 32;
var W2 = class {
  constructor(t20, e13, s20, r17, i19) {
    this.chunkIndex = t20, this.featureIndex = e13, this.objectId = s20, this.displayId = r17, this.time = i19;
  }
};
var z3 = class {
  static getOid(t20) {
    return t5 + t20;
  }
  constructor(t20, e13, s20, r17, i19, a16, o13, n14) {
    this._schema = t20, this.trackId = e13, this.objectId = s20, this.displayId = r17, this._fields = i19, this._spatialReference = a16, this._metadata = o13, this._isStream = n14, this._maxDisplayDuration = this._schema.maxDisplayDuration > 0 ? this._schema.maxDisplayDuration : 1 / 0, this._maxDisplayObservationsPerTrack = this._schema.maxDisplayObservationsPerTrack >= 1 ? this._schema.maxDisplayObservationsPerTrack : 1 / 0, this._observationRecords = [], this._nextObservationRecords = [], this._trackLinePath = [], this._bounds = [], this._trackLineGeometry = new e();
  }
  get _trackLineAttributes() {
    var _a;
    const t20 = { ...((_a = this._latestObservationFeature) == null ? void 0 : _a.attributes) ?? {}, aggregateId: this.objectId, [r5]: s8.TrackLine };
    if (null != this._statistics) for (const e13 of this._statistics.values()) t20[e13.field.name] = e13.value;
    return t20;
  }
  get _startTimeField() {
    var _a;
    return (_a = this._metadata.timeInfo) == null ? void 0 : _a.startTimeField;
  }
  get length() {
    return this._observationRecords.length;
  }
  *observations() {
    yield* this._observationRecords;
  }
  *previousObservations() {
    for (let t20 = 0; t20 < this._observationRecords.length - 1; t20++) yield this._observationRecords[t20];
  }
  stageObservation(t20, e13) {
    this._nextObservationRecords.push(new W2(t20, e13.getIndex(), e13.getObjectId(), e13.getDisplayId(), null != this._startTimeField ? e13.readAttributeAsTimestamp(this._startTimeField) : null));
  }
  commitObservations(t20, e13) {
    var _a, _b;
    const r17 = new Set(this._nextObservationRecords.map((t21) => t21.objectId)), i19 = this._observationRecords.filter((t21) => !r17.has(t21.objectId)).map((t21) => t21.objectId);
    let a16, o13;
    switch (this._observationRecords = [], this._trackLinePath = [], this._isStream || null == this._startTimeField || this._nextObservationRecords.sort((t21, e14) => {
      const s20 = t21.time, r18 = e14.time;
      return null != s20 && null != r18 ? s20 - r18 : 0;
    }), this._schema.timeField) {
      case "startTimeField":
        a16 = (_a = this._metadata.timeInfo) == null ? void 0 : _a.startTimeField;
        break;
      case "endTimeField":
        a16 = (_b = this._metadata.timeInfo) == null ? void 0 : _b.endTimeField;
        break;
      case "timeReceived":
        a16 = this._isStream ? i6 : null;
    }
    o13 = this._isStream ? (e13 == null ? void 0 : e13.end) ?? Date.now() : (e13 == null ? void 0 : e13.end) ?? -1 / 0;
    const n14 = t20.map((t21) => t21.reader.getCursor());
    let l10;
    for (let c10 = this._nextObservationRecords.length - 1; c10 >= 0 && !(this._observationRecords.length >= this._maxDisplayObservationsPerTrack); c10--) {
      const t21 = this._nextObservationRecords[c10], e14 = n14[t21.chunkIndex];
      n2(e14), e14.setIndex(t21.featureIndex);
      const r18 = null != a16 ? e14.readAttributeAsTimestamp(a16) : null;
      (null != r18 ? o13 - r18 : 0) >= this._maxDisplayDuration || (this._commitObservation(t21, e14), l10 ?? (l10 = t21));
    }
    if (null != l10) {
      const { chunkIndex: t21, featureIndex: e14, objectId: r18, displayId: i20 } = l10, a17 = n14[t21];
      n2(a17), a17.setIndex(e14);
      const o14 = new s4(a17.readGeometryWorldSpace(), { ...a17.readAttributes(), [r5]: s8.LatestObservation }, null, r18, i20);
      this._latestObservationFeature = o14;
    } else this._latestObservationFeature = null;
    return this._trackLineGeometry = E(this._trackLineGeometry, this._trackLinePath, this._spatialReference), this._bounds = Z2(this._trackLineGeometry), this._nextObservationRecords = [], i19;
  }
  updateStatistics(t20, e13) {
    this._statistics = s15.create(this._fields);
    const r17 = t20.map((t21) => t21.reader.getCursor());
    for (const { chunkIndex: i19, featureIndex: a16 } of this._observationRecords) {
      const t21 = r17[i19];
      n2(t21), t21.setIndex(a16), this._statistics.insert(t21, e13);
    }
  }
  overlapsTile(t20) {
    for (const e13 of this._bounds) if (U(e13, t20.bounds, M3)) return true;
    return false;
  }
  getLatestObservationFeatureForTile(t20) {
    if (null == this._latestObservationFeature) return null;
    const { objectId: e13, displayId: s20, geometry: r17, attributes: i19 } = this._latestObservationFeature, a16 = new e();
    dt(a16, r17, false, false, this._metadata.geometryType, t20.subscription.tile.transform);
    const o13 = a2(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    X3(a16, (t21, e14) => f2(o13, [t21, e14]));
    if (!R(o13, a2(0, 0, a5, a5))) return null;
    return new s4(a16, i19, null, e13, s20);
  }
  getTrackLineFeatureForTile(t20) {
    const e13 = new e();
    dt(e13, this._trackLineGeometry, false, false, "esriGeometryPolyline", t20.subscription.tile.transform);
    return new s4(e13, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineOptimizedFeature() {
    return new s4(this._trackLineGeometry, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineDisplayFeature() {
    const { _trackLineGeometry: t20, _trackLineAttributes: e13, displayId: s20 } = this;
    return { geometry: ut(t20, "esriGeometryPolyline", false, false), attributes: e13, displayId: s20 };
  }
  _commitObservation(t20, e13) {
    const s20 = e13.readCentroidWorldSpace();
    let r17 = s20 == null ? void 0 : s20.coords[0], i19 = s20 == null ? void 0 : s20.coords[1];
    null == s20 && (r17 = e13.readXWorldSpace(), i19 = e13.readYWorldSpace()), null != r17 && null != i19 && (this._observationRecords.unshift(t20), this._trackLinePath.unshift([r17, i19]));
  }
};
var U3 = class extends t11 {
  constructor(t20) {
    super(t20), this.done = false;
  }
};
var q = class _q extends i11 {
  static async create(t20, e13, s20, a16, o13, n14) {
    const l10 = new p2({ spatialReference: e13 }), c10 = await Promise.all(t20.fields.map(async (t21) => s14.create(l10, t21))), d11 = t20.featureFilter ? await p3.create({ geometryType: s20.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s20.metadata.timeInfo, fieldsIndex: s20.metadata.fieldsIndex, spatialReference: e13, filterJSON: t20.featureFilter }) : null;
    return e13.isWrappable || s5() || await Promise.all([import("./apiConverter-GCJB7PQV.js"), import("./jsonConverter-FKM4AX4S.js"), i4()]).then(([t21, e14, s21]) => {
      P3 = { fromGeometryToGXGeometry: e14.fromGeometryToGXGeometry, toGeometry: e14.toGeometry, fromSpatialReference: t21.fromSpatialReference };
    }), new _q(t20, s20, a16, e13, c10, d11, o13, n14);
  }
  constructor(t20, e13, s20, r17, i19, a16, o13, n14) {
    super(e13, s20, r17, i19, n14), this._schema = t20, this._featureFilter = a16, this._arcadeContextInfo = o13, this._tracks = /* @__PURE__ */ new Map(), this._metadata = e13.metadata.weakCloneWithAdditionalFields([{ name: r5, alias: "trackPart", type: "esriFieldTypeSmallInteger" }]), this._trackLineMetadata = i7.createFeature({ geometryType: "esriGeometryPolyline", objectIdField: "aggregateId", fieldsIndex: { fields: [...this._source.metadata.fieldsIndex.fields, ...this.aggregateFields, { name: r5, alias: "trackPart", type: "esriFieldTypeSmallInteger" }, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }], timeZoneByFieldName: null }, globalIdField: null, spatialReference: e13.metadata.spatialReference, outSpatialReference: e13.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: e13.metadata.timeInfo, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  get _isStream() {
    return this._source.isStream;
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  createState(t20) {
    return new U3(t20);
  }
  async *applyOverrideUpdate(t20) {
    C().error("Applying override to tracks is not supported");
  }
  displayMap(t20, e13, s20) {
    const r17 = new Map(t20.map((t21) => [e13(t21), t21])), i19 = [];
    for (const a16 of this._tracks.values()) {
      const t21 = r17.get(a16.objectId);
      if (null == t21) for (const e14 of a16.observations()) {
        const t22 = r17.get(e14.objectId);
        if (null != t22) {
          const a17 = s20(e14.displayId, t22, e14.objectId);
          i19.push(a17), r17.delete(e14.objectId);
        }
      }
      else {
        const e14 = s20(a16.displayId, t21, a16.objectId);
        i19.push(e14), r17.delete(a16.objectId);
      }
    }
    return i19;
  }
  getDisplayFeatures(t20) {
    const e13 = new Set(t20), s20 = [], r17 = [], i19 = this._source.chunks().map((t21) => t21.reader.getCursor());
    for (const a16 of this._tracks.values()) {
      e13.has(a16.displayId) && r17.push(a16.getTrackLineDisplayFeature());
      for (const { displayId: t21, chunkIndex: r18, featureIndex: o13 } of a16.observations()) if (e13.has(t21)) {
        const e14 = i19[r18];
        e14.setIndex(o13), s20.push({ displayId: t21, attributes: {}, ...e14.readLegacyFeatureWorldSpace() });
      }
    }
    return { features: s20, aggregates: [], tracks: r17 };
  }
  getFeatureObjectIdsForAggregate(t20) {
    for (const e13 of this._tracks.values()) if (e13.objectId === t20) return Array.from(e13.observations(), (t21) => t21.objectId);
    return [];
  }
  async *updateChunks() {
    var _a, _b;
    const t20 = this._source.chunks();
    if (!t20.length) return;
    const e13 = (_a = this._metadata.timeInfo) == null ? void 0 : _a.trackIdField;
    if (null == e13) return;
    const s20 = /* @__PURE__ */ new Set();
    for (let r17 = 0; r17 < t20.length; r17++) {
      const i19 = t20[r17].reader.getCursor();
      for (; i19.next(); ) {
        const t21 = i19.readAttribute(e13), a16 = i19.getObjectId();
        if (null != t21 && null != a16 && (null === this._featureFilter || this._featureFilter.check(i19, this._sqlOptions))) {
          if (i19.getDisplayId() || i19.setDisplayId(this._attributeStore.createDisplayIdForObjectId(a16)), !this._tracks.has(t21)) {
            const e14 = z3.getOid(t21), s21 = this._attributeStore.createDisplayIdForObjectId(e14), r18 = new z3(this._schema, t21, e14, s21, this.aggregateFields, this.spatialReference, this._source.metadata, this._isStream);
            this._tracks.set(t21, r18);
          }
          this._tracks.get(t21).stageObservation(r17, i19), s20.add(t21);
        }
      }
    }
    for (const r17 of this._tracks.values()) if (s20.has(r17.trackId)) {
      const e14 = r17.commitObservations(t20, (_b = this._featureFilter) == null ? void 0 : _b.timeExtent);
      for (const t21 of e14) this._attributeStore.releaseDisplayIdForObjectId(t21);
      r17.updateStatistics(t20, e6(1, this._arcadeContextInfo));
    } else this._removeTrack(r17);
    for (const r17 of this._sendStates.values()) yield* this._update(r17);
  }
  forEachAggregateWorldSpace(t20) {
    for (const e13 of this._tracks.values()) t20(e13.getTrackLineOptimizedFeature());
  }
  _removeTrack(t20) {
    this._tracks.delete(t20.trackId), this._attributeStore.releaseDisplayIdForObjectId(t20.objectId);
    for (const { objectId: e13 } of t20.observations()) this._attributeStore.releaseDisplayIdForObjectId(e13);
  }
  *_update(e13) {
    if (e13.done) return;
    e13.done = !this._source.updateTracking.updating;
    const s20 = [], r17 = [];
    for (const t20 of this._tracks.values()) if (t20.length > 0) {
      if (this._schema.showLatestObservation) {
        const r18 = t20.getLatestObservationFeatureForTile(e13);
        null != r18 && s20.push(r18);
      }
      this._schema.showTrackLine && t20.overlapsTile(e13.subscription.tile) && r17.push(t20.getTrackLineFeatureForTile(e13));
    }
    const i19 = u7.fromOptimizedFeatures(s20, this._metadata, e13.subscription.tile.transform), a16 = u7.fromOptimizedFeatures(r17, this._trackLineMetadata, e13.subscription.tile.transform);
    let o13 = [];
    if (this._schema.showPreviousObservations) {
      const s21 = this._source.chunks().map(() => []);
      for (const t20 of this._tracks.values()) for (const { chunkIndex: e14, featureIndex: r18 } of t20.previousObservations()) s21[e14].push(r18);
      o13 = this._source.chunks().map((t20, r18) => {
        const i20 = t20.getTileReader(e13.subscription.tile);
        if (null == i20) return null;
        const a17 = d6.from(i20, s21[r18]);
        return a17.setProcessorAttributes({ [r5]: s8.PreviousObservation }), "esriGeometryPoint" !== a17.geometryType && null != a17.getInTransform() || a17.setTransformForDisplay(e13.subscription.tile.transform), a17;
      }).filter(G);
    }
    this.events.emit("changed");
    const n14 = e13.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo), l10 = a16.getCursor();
    for (; l10.next(); ) this._attributeStore.setAttributeData(l10.getDisplayId(), l10, n14, this._sqlOptions);
    for (const t20 of o13) {
      const e14 = t20.getCursor();
      for (; e14.next(); ) this._attributeStore.setAttributeData(e14.getDisplayId(), e14, n14, this._sqlOptions);
    }
    const c10 = i19.getCursor();
    for (; c10.next(); ) this._attributeStore.setAttributeData(c10.getDisplayId(), c10, n14, this._sqlOptions);
    yield new e10(e13.subscription, a16, true, false, {});
    for (const t20 of o13) yield new e10(e13.subscription, t20, false, false, {});
    yield new e10(e13.subscription, i19, false, e13.done, {});
  }
};
function E(t20, e13, s20) {
  if (e13.length < 2) return X(t20, [e13], false, false);
  if (s20.isWrappable) {
    let r18 = false;
    for (let t21 = 1; t21 < e13.length; t21++) {
      const i20 = e13[t21][0], a16 = P2(i20, e13[t21 - 1][0], s20);
      i20 !== a16 && (e13[t21][0] = a16, r18 = true);
    }
    if (r18) {
      const r19 = a8({ paths: [e13], spatialReference: s20 });
      if (null != r19) return X(t20, r19.paths, false, false);
    }
    return X(t20, [e13], false, false);
  }
  const r17 = P3.fromGeometryToGXGeometry({ hasM: false, hasZ: false, paths: [e13] }), i19 = P3.fromSpatialReference(s20);
  if (null != i19) {
    const e14 = u4(r17, 1e6, i19, e2.geodesic);
    if (null != e14) {
      const s21 = P3.toGeometry(e14, i19);
      if (null != s21 && "paths" in s21) return X(t20, s21.paths, false, false);
    }
  }
  return X(t20, [e13], false, false);
}
function X3(t20, e13) {
  const s20 = 2, { coords: r17, lengths: i19 } = t20;
  if (!i19.length) return void e13(r17[0], r17[1]);
  let a16 = 0;
  for (let o13 = 0; o13 < i19.length; o13++) {
    const t21 = i19[o13];
    let n14 = 0, l10 = 0;
    for (let i20 = 0; i20 < t21; i20++) n14 += r17[s20 * (i20 + a16)], l10 += r17[s20 * (i20 + a16) + 1], e13(n14, l10);
    a16 += t21;
  }
}
function Z2(t20) {
  const { lengths: e13, coords: s20 } = t20, r17 = 2;
  if (!e13.length) return [H()];
  const i19 = [];
  let a16 = 0;
  for (let o13 = 0; o13 < e13.length; o13++) {
    const t21 = e13[o13], n14 = H();
    i19.push(n14);
    for (let e14 = 0; e14 < t21; e14++) {
      const t22 = s20[r17 * (e14 + a16)], i20 = s20[r17 * (e14 + a16) + 1];
      f2(n14, [t22, i20]);
    }
    a16 += t21;
  }
  return i19;
}

// node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var b3 = class {
  constructor(e13, t20) {
    this._connection = e13, this._source = t20, this._version = 1, this._registry = new F(), this._proxy = new s9({ fetch: (e14, t21) => this._connection.layerView.fetch(e14, t21), fetchDictionary: (e14, t21) => this._connection.layerView.fetchDictionary(e14, t21) }), this._attributeStore = new x2({ isLocal: false, update: (e14) => O(this._connection.container.updateAttributeView(e14)) });
  }
  destroy() {
    var _a;
    this._proxy.destroy(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    var _a;
    return (_a = this._strategy) == null ? void 0 : _a.aggregateQueryEngine;
  }
  get version() {
    return this._version;
  }
  getDisplayFeatures(e13) {
    return this._strategy ? this._strategy.getDisplayFeatures(e13) : { features: [], aggregates: [], tracks: [] };
  }
  getDisplayIds(e13) {
    const t20 = {};
    return this._strategy ? (this._strategy.displayMap(e13, (e14) => e14, (e14, s20, r17) => {
      t20[r17] = e14;
    }), t20) : t20;
  }
  getFeatureObjectIdsForAggregate(e13) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(e13) : [];
  }
  onSubscribe(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onSubscribe(e13);
  }
  onUnsubscribe(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onUnsubscribe(e13);
  }
  async update(e13, s20, r17, a16, n14) {
    var _a, _b2, _c, _d, _e, _f, _g;
    const h8 = e13.processor, u13 = i((_a = this._schema) == null ? void 0 : _a.storage, h8.storage), g7 = i((_b2 = this._schema) == null ? void 0 : _b2.mesh.properties, h8.mesh.properties), y7 = i((_c = this._schema) == null ? void 0 : _c.mesh.factory, h8.mesh.factory), d11 = i((_d = this._schema) == null ? void 0 : _d.mesh.strategy, h8.mesh.strategy), _5 = w2((_e = this._schema) == null ? void 0 : _e.expressionProperties, h8.expressionProperties), l10 = _5.some((e14) => this._attributeStore.hasArcadeDependency(e14)), m11 = _5.some((e14) => {
      var _a2;
      return ((_a2 = this._factory) == null ? void 0 : _a2.hasArcadeDependency(e14)) ?? false;
    }), b4 = _5.some((e14) => {
      var _a2;
      return (_a2 = this._strategy) == null ? void 0 : _a2.hasArcadeDependency(e14);
    }) || ((_f = this._strategy) == null ? void 0 : _f.isAggregate) && l10, j4 = m11 || b4, I2 = g7 || y7 || d11;
    if (!(u13 || I2 || (m11 || l10 || b4)) && !a16) return false;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: y(this._schema, h8), schema: h8 }), this._schema = h8;
    const x5 = g3.fromJSON(this._source.service.outSpatialReference), v2 = new p2({ fields: this._source.metadata.fieldsIndex, spatialReference: x5 }), k2 = { currentUser: h8.mesh.properties.currentUser };
    if ((u13 || I2 || l10) && (await this._attributeStore.update(h8.storage, v2, this._source.metadata, s20), (_g = this._strategy) == null ? void 0 : _g.invalidateAttributeData(S4(h8))), !a16 && !I2 && !j4) return false;
    (d11 || g7 || j4) && await this._updateStrategy(h8.mesh.strategy, x5, n14, S4(h8), k2), this._updateSortKey(v2, "sortKey" in h8.mesh.properties ? h8.mesh.properties.sortKey : null);
    const M4 = new s13(v2, this._proxy, r17, this._registry);
    return (y7 || "dictionary" === h8.mesh.factory.symbology.type) && (this._factory = await s12.create(M4, h8.mesh.factory)), this._version = s20, true;
  }
  async applyOverrideUpdate(e13) {
    if (!this._strategy) return;
    const t20 = this._strategy.applyOverrideUpdate(e13);
    for await (const r17 of t20) try {
      await this._process(r17);
    } catch (s20) {
    }
  }
  async updateChunks() {
    var _a;
    await this._doUpdateChunks(), (_a = this._strategy) == null ? void 0 : _a.afterUpdateChunks();
  }
  async removeChunks(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.removeChunks(e13), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: e13 }) {
    if (!this._strategy) return void this._attributeStore.setHighlight(e13.map(({ objectId: e14, highlightFlags: t21 }) => ({ objectId: e14, highlightFlags: t21, displayId: -1 })), e13);
    const t20 = this._strategy.displayMap(e13, ({ objectId: e14 }) => e14, (e14, { highlightFlags: t21 }, s20) => ({ objectId: s20, displayId: e14, highlightFlags: t21 }));
    this._attributeStore.setHighlight(t20, e13);
  }
  invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _doUpdateChunks() {
    if (!this._strategy) return;
    const e13 = this._strategy.updateChunks(), t20 = [], r17 = /* @__PURE__ */ new Map();
    for await (const a16 of e13) {
      let e14 = r17.get(a16.id);
      null == e14 && (e14 = new e8({ concurrency: 16, process: (e15) => this._process(e15) }), r17.set(a16.id, e14));
      const i19 = e14.push(a16).catch((e15) => f(e15));
      t20.push(i19);
    }
    try {
      await Promise.all(t20);
    } catch (i19) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(e13, t20, s20, r17, i19) {
    var _a;
    switch ((_a = this._strategy) == null ? void 0 : _a.destroy(), e13.type) {
      case "feature":
        this._strategy = new i16(this._source, this._attributeStore, r17, i19);
        break;
      case "binning":
        this._strategy = await y2.create(e13, t20, this._source, this._attributeStore, r17, i19);
        break;
      case "cluster":
        this._strategy = await x3.create(this._connection, e13, t20, this._source, this._attributeStore, r17, i19);
        break;
      case "track":
        this._strategy = await q.create(e13, t20, this._source, this._attributeStore, r17, i19);
    }
    for (const a16 of s20) this._strategy.onSubscribe(a16);
  }
  async _updateSortKey(t20, s20) {
    var _a;
    if (this._sortInfo = u((_a = this._sortInfo) == null ? void 0 : _a.computed), null != s20) {
      const e13 = s20.byRenderer ? null : await t20.createComputedField(s20);
      this._sortInfo = { ...s20, computed: e13 };
    }
  }
  async _process(e13) {
    var _a, _b2, _c;
    const t20 = e13.subscription;
    if (has("esri-2d-update-debug")) {
      const s21 = t20.tile;
      console.debug(`Version[${this._version}] Tile[${s21.key.id}, end=${e13.end}] Processor._process`);
    }
    const s20 = { currentUser: (_a = this._schema) == null ? void 0 : _a.mesh.properties.currentUser };
    await this._fetchResources(e13, s20), s2(t20.signal);
    const i19 = await this._write(e13, t20.tile.createArcadeEvaluationOptions(S4(this._schema)), s20), a16 = t20.tile.tileInfoView.getLODInfoAt(t20.tile.key), { message: o13, transferList: n14 } = i19.serialize(a16), c10 = { objectIdMap: null, inner: e13.createMessage(o13, this._version, this._attributeStore.epoch) };
    if ((_b2 = this._schema) == null ? void 0 : _b2.mesh.properties.returnMeshObjectId) {
      c10.objectIdMap = {};
      const t21 = (_c = e13.reader) == null ? void 0 : _c.getCursor();
      if (t21) for (; t21.next(); ) c10.objectIdMap[t21.getDisplayId()] = t21.getObjectId();
    }
    if (s2(t20.signal), await this._connection.container.onMessage(c10, { signal: t20.signal, transferList: n14 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s21 = t20.tile;
      console.debug(`Version[${this._version}] Tile[${s21.key.id}, end=${e13.end}] Processor._process.await`);
    }
  }
  async _fetchResources(e13, t20) {
    await this._fetchMatcherResources(e13), await this._fetchWriterResources(e13, t20);
  }
  async _fetchMatcherResources(e13) {
    if (e13.reader) return this._factory.enqueueMatcherRequests(this._proxy, e13.reader);
  }
  async _fetchWriterResources(e13, t20) {
    if (!e13.reader) return;
    const s20 = e13.reader.getCursor(), r17 = e13.subscription.tile.createArcadeEvaluationOptions(S4(this._schema));
    for (; s20.next(); ) this._factory.enqueueWriterRequests(this._proxy, s20, r17, t20);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(e13, t20, s20) {
    var _a;
    const r17 = e13.subscription.tile, i19 = (_a = e13.reader) == null ? void 0 : _a.getCursor(), a16 = (i19 == null ? void 0 : i19.getSize()) ?? 0, o13 = r17.tileInfoView.tileInfo.isWrappable, c10 = r17.tileInfoView.tileInfo.spatialReference.isWGS84, h8 = new g4(r17.key, this._strategy.enablePixelBuffering, o13, c10, a16);
    if (!i19) return h8;
    const u13 = r17.createArcadeEvaluationOptions(S4(this._schema));
    for (; i19.next(); ) {
      const e14 = this._getSortKeyValue(i19, t20);
      h8.entityStart(i19.getDisplayId(), e14), this._factory.write(h8, this._proxy, i19, u13, s20, r17.level), h8.entityEnd();
    }
    return h8;
  }
  _getSortKeyValue(e13, t20) {
    if (!this._sortInfo) return 0;
    const { computed: s20, order: r17, byRenderer: i19 } = this._sortInfo, a16 = i19 ? this._factory.getSortKey(e13, t20) : s20 == null ? void 0 : s20.read(e13, t20);
    return null == a16 || isNaN(a16) ? 0 : a16 * ("asc" === r17 ? -1 : 1);
  }
};
function w2(e13, t20) {
  var _a, _b, _c, _d;
  const s20 = [];
  return ((_a = e13 == null ? void 0 : e13.timeExtent) == null ? void 0 : _a.start) === ((_b = t20.timeExtent) == null ? void 0 : _b.start) && ((_c = e13 == null ? void 0 : e13.timeExtent) == null ? void 0 : _c.end) === ((_d = t20.timeExtent) == null ? void 0 : _d.end) || s20.push("timeProperties"), s20;
}
function S4(e13) {
  const { timeZone: t20 } = (e13 == null ? void 0 : e13.mesh.properties) ?? {}, { timeExtent: s20 } = (e13 == null ? void 0 : e13.expressionProperties) ?? {};
  return { timeZone: t20, timeExtent: s20 };
}

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t14 = class _t {
  static from(e13) {
    let n14 = 0, r17 = 0, o13 = 0;
    return e13.forEach((t20) => {
      const e14 = t20._readGeometry();
      e14 && (r17 += e14.isPoint ? 1 : e14.lengths.reduce((t21, e15) => t21 + e15, 0), o13 += e14.isPoint ? 1 : e14.lengths.length, n14 += 1);
    }), new _t(n14, r17, o13);
  }
  constructor(t20, e13, n14) {
    this.featureCount = t20, this.vertexCount = e13, this.ringCount = n14;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var o6 = 4;
function n11(e13, a16, i19) {
  const o13 = e13.orderByFields ?? i19.objectIdField + " ASC", n14 = e13.source, u13 = { returnCentroid: !(null !== n14 && "object" == typeof n14 && "path" in n14 && g2(n14.path)) && "esriGeometryPolygon" === i19.serviceGeometryType, returnGeometry: true, timeReferenceUnknownClient: i19.timeReferenceUnknownClient ?? void 0, outSpatialReference: g3.fromJSON(e13.outSpatialReference), orderByFields: "memory" === e13.type ? [] : [o13], where: a16.mutable.dataFilter.definitionExpression ?? "1=1", outFields: a16.mutable.availableFields, multipatchOption: "esriGeometryMultiPatch" === i19.serviceGeometryType ? "xyFootprint" : null };
  if ("feature" === a16.type) {
    const { gdbVersion: e14, historicMoment: t20, timeExtent: r17 } = a16.mutable.dataFilter;
    return { ...u13, gdbVersion: e14, historicMoment: t20 ? new Date(t20) : null, timeExtent: r17 ? p.fromJSON(r17) : null, outFields: a16.mutable.availableFields };
  }
  return u13;
}
var u11 = class _u {
  static fromSchema(e13, t20, r17) {
    const a16 = "feature" === t20.type ? t20.mutable.dataFilter.queryScaleRanges : [], i19 = t20.mutable.displayFilterInfo;
    return new _u(n11(e13, t20, r17), i19, a16, r17.subtypeField, t20.mutable.dataFilter.customParameters, r17.geometryType, e13.queryMetadata);
  }
  constructor(e13, t20, r17, a16, i19, s20, o13) {
    this._queryParams = e13, this._displayFilter = t20, this._queryScaleRanges = r17, this._subtypeField = a16, this._customParameters = i19, this._geometryType = s20, this._queryMetadata = o13;
  }
  get pageSize() {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support paged queries");
    const e13 = this._queryMetadata.supportsMaxRecordCountFactor ? o6 : null, t20 = (this._queryMetadata.maxRecordCount ?? 8e3) * (e13 ?? 1);
    return Math.min(8e3, t20);
  }
  get objectIdsQueryPageSize() {
    var _a;
    return ((_a = this._queryMetadata) == null ? void 0 : _a.maxRecordCount) ?? 2e3;
  }
  updateHistoricMoment(e13) {
    this._queryParams.historicMoment = e13;
  }
  updateFields(e13) {
    this._queryParams.outFields = e13;
  }
  createPatchFieldsQuery(e13, t20, r17) {
    if (!t20.getSize()) return null;
    const a16 = e13.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (a16.outFields ?? [])[0]) return null;
      a16.outFields = this._queryParams.outFields;
    } else {
      const e14 = new Set(this._queryParams.outFields), r18 = [];
      for (const a17 of e14) t20.hasField(a17) || r18.push(a17);
      if (0 === r18.length) return null;
      a16.outFields = r18;
    }
    a16.returnGeometry = false, a16.returnCentroid = false, a16.quantizationParameters = null, a16.cacheHint = true;
    const i19 = { inner: a16, customParameters: this._customParameters };
    if (has("esri-tiles-debug") && null != r17) {
      const e14 = r17.chunkId.toString().replaceAll("/", ".");
      i19.customParameters = i19.customParameters ? { ...i19.customParameters, chunkId: e14 } : { chunkId: e14 };
    }
    return i19;
  }
  createQuery(e13 = {}) {
    if (!this._queryParams) throw new Error("InternalError: queryInfo should be defined");
    return { inner: new b({ ...this._queryParams, ...e13 }), customParameters: this._customParameters };
  }
  createTileQuery(t20, r17) {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support tile queries");
    const i19 = this.createQuery(r17), s20 = i19.inner;
    if (this._queryScaleRanges.length) {
      const r18 = this._queryScaleRanges.filter((e13) => (!e13.minScale || e13.minScale >= t20.maxScale) && (!e13.maxScale || e13.maxScale <= t20.minScale)).map((e13) => e13.subtypeCode);
      if (r18.length) {
        const t21 = `${this._subtypeField} IN (${r18})`;
        s20.where = r4(s20.where, t21);
      }
    }
    if (this._displayFilter && (s20.where = r4(s20.where, c4(this._displayFilter, t20.minScale, t20.maxScale))), s20.quantizationParameters = r17.quantizationParameters ?? t20.getQuantizationParameters(), s20.resultType = "tile", s20.geometry = t20.extent, this._queryMetadata.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (s20.maxAllowableOffset = t20.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (s20.maxAllowableOffset = t20.resolution, "esriGeometryPolyline" === this._geometryType && (s20.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), s20.defaultSpatialReferenceEnabled = this._queryMetadata.supportsDefaultSpatialReference, s20.compactGeometryEnabled = this._queryMetadata.supportsCompactGeometry, this._queryMetadata.supportsMaxRecordCountFactor && (s20.maxRecordCountFactor = o6), has("esri-tiles-debug")) {
      const e13 = t20.id.replaceAll("/", ".");
      i19.customParameters = i19.customParameters ? { ...i19.customParameters, tileId: e13 } : { tileId: e13 };
    }
    return i19;
  }
  createPagedTileQuery(e13, t20) {
    const r17 = this.pageSize;
    return this.createTileQuery(e13, { start: r17 * t20, num: r17, returnExceededLimitFeatures: true });
  }
  createPagedQuery(e13) {
    const t20 = this.pageSize;
    return this.createQuery({ start: t20 * e13, num: t20, returnExceededLimitFeatures: true, maxRecordCountFactor: o6, cacheHint: true });
  }
  createObjectIdsQuery(e13) {
    return this.createQuery({ objectIds: e13, outFields: ["*"] });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var a12 = 2500;
var o7 = class extends g {
  constructor(e13) {
    super(), this._connection = e13, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.connectionStatus) ?? "disconnected";
    }, (e14) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e14 });
    }, { initial: true }), d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.errorString) || null;
    }, (e14) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e14 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e13) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t20 = "event-handles";
    this.removeHandles(t20), null != e13 && (this.addHandles([e13.events.on("data-received", (e14) => this._onFeature(e14)), e13.events.on("message-received", (e14) => this._onWebSocketMessage(e14)), e13.events.on("features-updated", (e14) => this._onUpdate(e14)), e13.events.on("tick", () => this._onTick())], t20), this._queuedCommands.forEach((t21) => t21(e13)), this._queuedCommands = []), this._strategy = e13;
  }
  updateCustomParameters(e13) {
    null != e13 && this._callOrEnqueue((t20) => t20.updateCustomParameters(e13));
  }
  sendMessageToSocket(e13) {
    this._callOrEnqueue((t20) => t20.sendMessageToSocket(e13));
  }
  sendMessageToClient(e13) {
    this._callOrEnqueue((t20) => t20.sendMessageToClient(e13));
  }
  enableEvent(e13, t20) {
    t20 ? this._enabledEventTypes.add(e13) : this._enabledEventTypes.delete(e13);
  }
  disconnect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.disconnect();
  }
  connect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.connect();
  }
  clear() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.clear();
  }
  _onWebSocketMessage(e13) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e13 });
  }
  _onFeature(e13) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e13.attributes, centroid: e13.centroid, geometry: e13.geometry } });
  }
  _onUpdate(e13) {
    this._updateInfo.client += e13;
  }
  _onTick() {
    const e13 = performance.now(), t20 = e13 - this._lastTime;
    if (t20 > a12) {
      const s20 = Math.round(this._updateInfo.client / (t20 / 1e3)), n14 = Math.round(this._updateInfo.websocket / (t20 / 1e3));
      this._resetUpdateInfo(e13), this._layerView.emitEvent({ name: "update-rate", event: { client: s20, websocket: n14 } });
    }
  }
  _resetUpdateInfo(e13) {
    this._lastTime = e13, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e13) {
    null != this._strategy ? e13(this._strategy) : this._queuedCommands.push(e13);
  }
};
r3([m2()], o7.prototype, "_strategy", void 0), o7 = r3([a("esri.views.2d.layers.features.sources.StreamMessenger")], o7);

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t15 = class extends i14 {
  constructor(e13, t20, r17, s20) {
    super(), this._reader = e13, this._queryJSON = t20, this._page = r17, this._end = s20, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e13) {
    const t20 = this.queryFeaturesInBounds(e13.bounds);
    return t20.setTransformForDisplay(e13.transform), t20;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/snapshotUtils.js
async function o8(e13, n14, o13, a16 = {}) {
  const s20 = (await Promise.allSettled(o13.map((r17) => t16(e13, n14, r17, a16)))).filter((r17) => "rejected" === r17.status).map((r17) => r17.reason);
  if (s20.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: s20 });
}
async function t16(r17, o13, t20, a16 = {}) {
  const s20 = `${r17.chunkPrefix ?? ""}${t20.num}`, u13 = await r17.fetch(t20.query, a16, { chunkId: s20 }), i19 = new t15(u13, t20.query.inner.toJSON(), t20.num, false);
  i19.chunkId = i19.normalizedChunkId = s20, s2(a16), o13.insert(i19);
}

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureCache.js
var o9 = 8e3;
var h6 = class {
  constructor(h8, a16, c10, n14) {
    this.store = h8, this.queryInfo = a16, this._options = c10, this._fetch = n14, this._nextBatch = /* @__PURE__ */ new Set(), this._fetchFeatures = k(async () => {
      var _a;
      if (0 === this._nextBatch.size || ((_a = this._options.signal) == null ? void 0 : _a.aborted)) return;
      const r17 = Array.from(this._nextBatch);
      this._nextBatch.clear(), r17.length > o9 && n.getLogger("esri.views.2d.layers.FeatureLayerView2D").warn(new s("highlight-too-many-features", `highlight is limited to ${o9} features on large layers configured with a display filter to avoid performance issues`));
      const h9 = this.queryInfo.objectIdsQueryPageSize, a17 = Math.ceil(o9 / h9), c11 = Math.min(a17, Math.ceil(r17.length / h9)), n15 = Array.from({ length: c11 }, (t20, e13) => {
        const s20 = e13 * h9, i19 = Math.min(s20 + h9, r17.length);
        return { num: e13, query: this.queryInfo.createObjectIdsQuery(r17.slice(s20, i19)) };
      });
      try {
        await o8({ chunkPrefix: "cache." + n3(), fetch: this._fetch }, this.store, n15, this._options);
      } catch (f6) {
      }
    });
  }
  prepareCacheUpdate(t20, e13) {
    if (e13) for (const r17 of e13) this._nextBatch.delete(r17);
    for (const r17 of t20) this._nextBatch.add(r17);
  }
  applyCacheUpdate() {
    var _a;
    return 0 === this._nextBatch.size || ((_a = this._options.signal) == null ? void 0 : _a.aborted) ? null : this._fetchFeatures().catch(() => {
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r15 = class {
  constructor(r17) {
    this._store = r17, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  unsafeSetQueryHistoricMoment(r17) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  async queryByObjectId(r17) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  async addParquetFile(r17) {
    throw new Error("InternalError: LoadStrategy does not support loading blobs");
  }
  prepareCacheUpdate(r17, t20) {
  }
  applyCacheUpdate() {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n12 = 268435455;
var o10 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a13(a16, i19, c10 = false) {
  var _a;
  const f6 = 1, d11 = 3, u13 = 9, g7 = 12, l10 = 13, p8 = 15, h8 = a16.asUnsafe(), b4 = h8.pos(), w3 = new o10();
  let m11 = 0, y7 = 0;
  const k2 = 1, x5 = 2, I2 = 4, L3 = 3;
  let A2 = null, F2 = null, C2 = null, S5 = false;
  const j4 = [];
  for (; h8.next(); ) switch (h8.tag()) {
    case f6:
      A2 = h8.getString();
      break;
    case d11:
      F2 = h8.getString();
      break;
    case g7:
      C2 = h8.processMessage(h);
      break;
    case u13:
      if (w3.exceededTransferLimit = h8.getBool(), w3.exceededTransferLimit) {
        w3.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w3.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e13 = 0; e13 < w3.centroid.length; e13++) w3.centroid[e13] = n12;
      }
      break;
    case l10: {
      const e13 = h8.processMessage(b2);
      e13.index = m11++, j4.push(e13);
      break;
    }
    case p8: {
      const e13 = h8.getLength(), t20 = h8.pos() + e13;
      if (!w3.exceededTransferLimit) {
        const e14 = w3.offsets.geometry, t21 = w3.centroid;
        e14.push(0), t21.push(n12), t21.push(n12);
      }
      !S5 && w3.exceededTransferLimit && (S5 = true, w3.offsets.attributes = c10 ? new Float64Array(8e3 * m11) : new Uint32Array(8e3 * m11));
      let s20 = y7 * m11;
      for (; h8.pos() < t20 && h8.next(); ) switch (h8.tag()) {
        case k2: {
          if (S5) w3.offsets.attributes[s20++] = h8.pos();
          else {
            w3.offsets.attributes.push(h8.pos());
          }
          const e14 = h8.getLength();
          h8.skipLen(e14);
          break;
        }
        case x5:
          if (i19) {
            const e14 = h8.getLength(), t21 = h8.pos() + e14;
            for (; h8.pos() < t21 && h8.next(); ) switch (h8.tag()) {
              case L3: {
                h8.getUInt32();
                const e15 = h8.getSInt64(), t22 = h8.getSInt64();
                w3.centroid[2 * y7] = e15, w3.centroid[2 * y7 + 1] = t22;
                break;
              }
              default:
                h8.skip();
            }
          } else {
            w3.offsets.geometry[y7] = h8.pos();
            const e14 = h8.getLength();
            w3.vertexCount += e14, h8.skipLen(e14);
          }
          break;
        case I2: {
          const e14 = h8.getLength(), t21 = h8.pos() + e14;
          for (; h8.pos() < t21 && h8.next(); ) switch (h8.tag()) {
            case L3: {
              h8.getUInt32();
              const e15 = h8.getSInt64(), t22 = h8.getSInt64();
              w3.centroid[2 * y7] = e15, w3.centroid[2 * y7 + 1] = t22;
              break;
            }
            default:
              h8.skip();
          }
          break;
        }
        default:
          h8.skip();
      }
      y7++, w3.hasFeatures = true;
      break;
    }
    default:
      h8.skip();
  }
  const U4 = A2 || F2;
  if (!U4) throw new s("FeatureSet has no objectId or globalId field name");
  return w3.fields = new Z(j4), w3.featureCount = y7, w3.fieldCount = m11, w3.objectIdFieldIndex = (_a = w3.fields.get(U4)) == null ? void 0 : _a.index, w3.transform = C2, w3.displayIds = new Uint32Array(w3.featureCount), w3.groupIds = new Uint16Array(w3.featureCount), h8.move(b4), w3;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var d8 = true;
var u12 = 268435455;
var c8 = 128;
var l6 = 128e3;
var g6 = { small: { delta: new Int32Array(c8), decoded: new Int32Array(c8) }, small64: { delta: new Float64Array(0), decoded: new Float64Array(0) }, large: { delta: new Int32Array(l6), decoded: new Int32Array(l6) }, large64: { delta: new Float64Array(0), decoded: new Float64Array(0) } };
function _4(e13, t20) {
  return t20 ? e13 <= g6.small64.delta.length ? g6.small64 : (e13 <= g6.large64.delta.length || (g6.large64.delta = new Float64Array(Math.round(1.25 * e13)), g6.large64.decoded = new Float64Array(Math.round(1.25 * e13))), g6.large64) : e13 <= g6.small.delta.length ? g6.small : (e13 <= g6.large.delta.length || (g6.large.delta = new Int32Array(Math.round(1.25 * e13)), g6.large.decoded = new Int32Array(Math.round(1.25 * e13))), g6.large);
}
function f4(r17) {
  try {
    const e13 = 2, t20 = new a4(new Uint8Array(r17), new DataView(r17));
    for (; t20.next(); ) {
      if (t20.tag() === e13) return I(t20.getMessage());
      t20.skip();
    }
  } catch (s20) {
    const r18 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: s20 });
    n.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r18);
  }
  return null;
}
function I(e13) {
  const t20 = 1;
  for (; e13.next(); ) {
    if (e13.tag() === t20) return e13.getMessage();
    e13.skip();
  }
  return null;
}
function y4(e13) {
  const t20 = 1, r17 = 2, s20 = 3, n14 = 4, a16 = 5, i19 = 6, h8 = 7, o13 = 8, d11 = 9, u13 = e13.getLength(), c10 = e13.pos() + u13;
  for (; e13.pos() < c10 && e13.next(); ) switch (e13.tag()) {
    case t20:
      return e13.getString();
    case r17:
      return e13.getFloat();
    case s20:
      return e13.getDouble();
    case n14:
      return e13.getSInt32();
    case a16:
      return e13.getUInt32();
    case i19:
      return e13.getInt64();
    case h8:
      return e13.getUInt64();
    case o13:
      return e13.getSInt64();
    case d11:
      return e13.getBool();
    default:
      return e13.skip(), null;
  }
  return null;
}
function m6(e13, t20, r17, s20, n14, a16) {
  return 0.5 * Math.abs(e13 * s20 + r17 * a16 + n14 * t20 - e13 * a16 - r17 * t20 - n14 * s20);
}
function p6(e13, t20, r17, s20, n14) {
  if (!e13) return false;
  return 0 === t20 * n14 - s20 * r17 && t20 * s20 + r17 * n14 > 0;
}
var x4 = class _x extends M2 {
  static fromBuffer(e13, t20, r17 = false) {
    const s20 = t20.geometryType, n14 = f4(e13), a16 = a13(n14, "esriGeometryPoint" === s20, r17);
    return new _x(n14, a16, t20, r17);
  }
  constructor(e13, t20, r17, s20) {
    super(r17), this._use64Bit = s20, this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0 }, this._parseCaches = new Array(), this._geometryType = r17.geometryType, this._reader = e13, this._header = t20, this._hasNext = t20.hasFeatures, this._isPoints = "esriGeometryPoint" === r17.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e13) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._featureIndex = e13;
  }
  getAttributeHash() {
    let e13 = "";
    for (const t20 of this._header.fields.fields) e13 += this._readAttributeAtIndex(t20.index) + ".";
    return e13;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e13) {
    this._header.displayIds[this._featureIndex] = e13;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e13 = this._reader.clone(), t20 = new _x(e13, this._header, this.metadata, this._use64Bit);
    return this.copyInto(t20), t20;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  get usedMemory() {
    var _a;
    return s3 + (((_a = this._cache.geometry) == null ? void 0 : _a.usedMemory) ?? 0);
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e13 = this._header.centroid[2 * this._featureIndex], t20 = this._header.centroid[2 * this._featureIndex + 1];
    return e13 === u12 ? null : new e([], [e13, t20]);
  }
  _readGeometry(e13 = false) {
    if (void 0 === this._cache.geometry) {
      let r17 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === u12) return null;
        const e14 = this._header.centroid[2 * this._featureIndex], t20 = this._header.centroid[2 * this._featureIndex + 1];
        r17 = new e([], [e14, t20]);
      } else {
        const s20 = this._header.offsets.geometry[this._featureIndex], n14 = this._reader;
        if (0 === s20) return null;
        n14.move(s20);
        try {
          r17 = e13 ? this._parseGeometryForDisplay(n14) : this._parseGeometry(n14);
        } catch (t20) {
          return null;
        }
      }
      return 0 === (r17 == null ? void 0 : r17.coords.length) && (r17 = null), this._cache.geometry = r17, r17;
    }
    return this._cache.geometry;
  }
  _readAttribute(e13, t20) {
    const r17 = this._header.fields.get(e13);
    if (null == r17) return;
    const s20 = this._readAttributeAtIndex(r17.index), n14 = this._header.fields.isDateField(r17.name);
    return t20 ? null == s20 ? s20 : n14 ? new Date(s20) : s20 : s20;
  }
  _readAttributes() {
    const e13 = {};
    for (const t20 of this._header.fields.fields) e13[t20.name] = this._readAttributeAtIndex(t20.index);
    return e13;
  }
  copyInto(e13) {
    super.copyInto(e13), e13._featureIndex = this._featureIndex, e13._featureOffset = this._featureOffset, e13._hasNext = this._hasNext, e13._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e13) {
    let t20 = this._parseCaches[e13];
    if (t20 || (t20 = new a7(this.getSize()), this._parseCaches[e13] = t20), t20.has(this._featureIndex)) return t20.get(this._featureIndex);
    const r17 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e13], s20 = this._reader;
    s20.move(r17);
    const n14 = y4(s20);
    return t20.set(this._featureIndex, n14), n14;
  }
  _readGeometryDeltaDecoded(e13 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t20 = this._readGeometry(e13);
      if (!t20) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t20, t20;
      const r17 = _4(t20.coords.length, this._use64Bit).decoded, s20 = t20.clone(r17), n14 = s20.coords;
      let a16 = 0;
      for (const e14 of s20.lengths) {
        for (let t21 = 1; t21 < e14; t21++) {
          const e15 = 2 * (a16 + t21), r18 = 2 * (a16 + t21 - 1);
          n14[e15] += n14[r18], n14[e15 + 1] += n14[r18 + 1];
        }
        a16 += e14;
      }
      return this._cache.unquantGeometry = s20, s20;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e13) {
    const t20 = 2, r17 = 3, s20 = e13.asUnsafe(), n14 = s20.getLength(), i19 = s20.pos() + n14, h8 = [], o13 = [];
    for (; s20.pos() < i19 && s20.next(); ) switch (s20.tag()) {
      case t20: {
        const e14 = s20.getUInt32(), t21 = s20.pos() + e14;
        for (; s20.pos() < t21; ) o13.push(s20.getUInt32());
        break;
      }
      case r17: {
        const e14 = s20.getUInt32(), t21 = s20.pos() + e14;
        for (h8.push(s20.getSInt64()), h8.push(s20.getSInt64()), this.hasZ && s20.getSInt64(), this.hasM && s20.getSInt64(); s20.pos() < t21; ) h8.push(s20.getSInt64()), h8.push(s20.getSInt64()), this.hasZ && s20.getSInt64(), this.hasM && s20.getSInt64();
        break;
      }
      default:
        s20.skip();
    }
    return new e(o13, h8);
  }
  _parseGeometryForDisplay(e13) {
    const t20 = 2, s20 = 3, n14 = e13.asUnsafe(), i19 = n14.getLength(), h8 = n14.pos() + i19, o13 = [], u13 = [];
    let c10 = 0, l10 = 0, g7 = null, f6 = 0;
    const I2 = "esriGeometryPolygon" === this.geometryType, y7 = "esriGeometryPolyline" === this.geometryType, x5 = I2 || y7;
    for (; n14.pos() < h8 && n14.next(); ) switch (n14.tag()) {
      case t20: {
        const e14 = n14.getUInt32(), t21 = n14.pos() + e14;
        for (; n14.pos() < t21; ) {
          const e15 = n14.getUInt32();
          o13.push(e15), c10 += e15;
        }
        g7 = _4(2 * c10, this._use64Bit).delta;
        break;
      }
      case s20: {
        n14.getUInt32();
        const e14 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n2(g7);
        for (const t21 of o13) if (l10 + e14 * t21 > g7.length) for (let e15 = 0; e15 < t21; e15++) n14.getSInt64(), n14.getSInt64(), this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64();
        else if (I2 && d8) {
          const e15 = this.getAreaSimplificationThreshold(t21, this._header.vertexCount);
          let r17 = 2, s21 = 1;
          const a16 = false;
          let i20 = n14.getSInt64(), h9 = n14.getSInt64();
          g7[l10++] = i20, g7[l10++] = h9, this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64();
          let o14 = n14.getSInt64(), d11 = n14.getSInt64();
          for (this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64(); r17 < t21; ) {
            let t22 = n14.getSInt64(), a17 = n14.getSInt64();
            this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64();
            const u14 = i20 + o14, c11 = h9 + d11;
            m6(i20, h9, u14, c11, u14 + t22, c11 + a17) >= e15 ? (f6 += -0.5 * (u14 - i20) * (c11 + h9), s21 > 1 && p6(x5, g7[l10 - 2], g7[l10 - 1], o14, d11) ? (g7[l10 - 2] += o14, g7[l10 - 1] += d11) : (g7[l10++] = o14, g7[l10++] = d11, s21++), i20 = u14, h9 = c11) : (t22 += o14, a17 += d11), o14 = t22, d11 = a17, r17++;
          }
          s21 < 3 || a16 ? l10 -= 2 * s21 : (f6 += -0.5 * (i20 + o14 - i20) * (h9 + d11 + h9), p6(x5, g7[l10 - 2], g7[l10 - 1], o14, d11) ? (g7[l10 - 2] += o14, g7[l10 - 1] += d11, u13.push(s21)) : (g7[l10++] = o14, g7[l10++] = d11, u13.push(++s21)));
        } else {
          let e15 = 0, r17 = n14.getSInt64(), s21 = n14.getSInt64();
          this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64(), g7[l10++] = r17, g7[l10++] = s21, e15 += 1;
          for (let a16 = 1; a16 < t21; a16++) {
            const t22 = n14.getSInt64(), i20 = n14.getSInt64(), h9 = r17 + t22, o14 = s21 + i20;
            f6 += -0.5 * (h9 - r17) * (o14 + s21), this.hasZ && n14.getSInt64(), this.hasM && n14.getSInt64(), a16 > 2 && p6(x5, g7[l10 - 2], g7[l10 - 1], t22, i20) ? (g7[l10 - 2] += t22, g7[l10 - 1] += i20) : (g7[l10++] = t22, g7[l10++] = i20, e15 += 1), r17 = h9, s21 = o14;
          }
          u13.push(e15);
        }
        break;
      }
      default:
        n14.skip();
    }
    return this._cache.area = f6, u13.length ? new e(u13, g7) : null != g7 ? this._createDeltaQuantizedExtrudedGeometry(g7[0], g7[1]) : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c9 = class {
  constructor(t20, e13) {
    this.service = t20, this._metadata = e13;
  }
  destroy() {
  }
};
function m7(t20, e13) {
  switch (t20.type) {
    case "memory":
      return new l7(t20, e13);
    case "ogc":
      return new y5(t20, e13);
    case "feature-service":
      return t20.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new d9(t20, e13) : new f5(t20, e13);
  }
}
async function p7(e13) {
  const r17 = new c5();
  return await r17.open(e13, {}), r17;
}
var l7 = class extends c9 {
  constructor(t20, e13) {
    super(t20, e13), this._portsOpen = p7(t20.source).then((t21) => this.client = t21);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(t20, e13) {
    await this._portsOpen;
    const r17 = await this.client.invoke("queryFeatures", t20.toJSON(), e13);
    return u7.fromFeatureSet(r17, this._metadata);
  }
};
var d9 = class extends c9 {
  async executeQuery(t20, e13) {
    const { data: r17 } = await d3(this.service.source, t20, e13), a16 = !t20.quantizationParameters;
    return x4.fromBuffer(r17, this._metadata, a16);
  }
};
var f5 = class extends c9 {
  async executeQuery(t20, s20) {
    var _a;
    const { source: i19, queryMetadata: u13 } = this.service;
    if (null != t20.quantizationParameters && !u13.supportsQuantization) {
      const u14 = t20.clone(), c11 = s6(u14.quantizationParameters);
      u14.quantizationParameters = null;
      const { data: m11 } = await c3(i19, u14, this._metadata.spatialReference, s20), p8 = ft(m11, this._metadata.objectIdField);
      return ht(c11, p8), u7.fromOptimizedFeatureSet(p8, this._metadata);
    }
    const { data: c10 } = await c3(i19, t20, this._metadata.spatialReference, s20);
    return "esriGeometryPoint" === this._metadata.geometryType && (c10.features = (_a = c10.features) == null ? void 0 : _a.filter((t21) => {
      if (null != t21.geometry) {
        const e13 = t21.geometry;
        return Number.isFinite(e13.x) && Number.isFinite(e13.y);
      }
      return true;
    })), u7.fromFeatureSet(c10, this._metadata);
  }
};
var y5 = class extends c9 {
  async executeQuery(t20, r17) {
    if (t20.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
      const i20 = t20.clone(), o13 = s6(i20.quantizationParameters);
      i20.quantizationParameters = null;
      const u13 = await $(this.service.source, t20, r17);
      return ht(o13, u13), u7.fromOptimizedFeatureSet(u13, this._metadata);
    }
    const i19 = await $(this.service.source, t20, r17);
    return u7.fromOptimizedFeatureSet(i19, this._metadata);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var i17 = class extends r15 {
  constructor(e13, t20, s20, n14, u13) {
    super(s20), this._serviceInfo = e13, this._queryInfo = t20, this._metadata = n14, this._connection = u13, this._queue = new _({ concurrency: 32, process: async (e14) => {
      var _a;
      const t21 = { signal: (_a = e14.options) == null ? void 0 : _a.signal, query: e14.query.customParameters, useRequestQueue: true };
      return this._adapter.executeQuery(e14.query.inner, t21);
    } }), this._adapter = m7(e13, n14);
  }
  unsafeSetQueryHistoricMoment(e13) {
    this._queryInfo.updateHistoricMoment(e13);
  }
  async updateFields(t20) {
    this._queryInfo.updateFields(t20);
    const r17 = Array.from(this._store.chunks()).map(async (e13) => {
      const t21 = b.fromJSON(e13.queryInfo.queryJSON);
      if (t21) try {
        return await this._tryUpdateFields(e13.reader, t21, { chunkId: e13.chunkId }), null;
      } catch (r18) {
        return r18;
      }
    }), n14 = (await Promise.all(r17)).filter((e13) => e13);
    if (n14.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: n14 });
  }
  async queryByObjectId(e13) {
    if (0 === e13.length) return u7.empty(this._metadata);
    const t20 = this._queryInfo.createQuery({ objectIds: e13 });
    return this._fetch(t20, null, null);
  }
  async _fetch(e13, t20, r17) {
    const s20 = await this._enqueue(e13, t20);
    return await this._tryUpdateFields(s20, e13.inner, r17), s20;
  }
  async _tryUpdateFields(r17, s20, n14) {
    const o13 = this._queryInfo.createPatchFieldsQuery(s20, r17, n14);
    if (!o13) return;
    const u13 = await this._enqueue(o13, this._options);
    u13.getSize() === r17.getSize() ? r17.joinAttributes(u13) : n.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new s("featurelayer-query", `Failed to join features. Expected a count of ${r17.getSize()} features, but got ${u13.getSize()}`, { query: o13.inner.toJSON(), debugInfo: n14 }));
  }
  async _enqueue(e13, t20) {
    return this._connection.onEvent({ type: "fetchStart" }), this._queue.push({ query: e13, options: t20 }).finally(() => {
      this._connection.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s18 = class extends i17 {
  constructor(t20, s20, h8, r17, d11) {
    super(t20, s20, h8, r17, d11), this._chunksById = /* @__PURE__ */ new Map(), this._featureCache = new h6(h8, s20, this._options, this._fetch.bind(this));
  }
  prepareCacheUpdate(e13, t20) {
    return this._featureCache.prepareCacheUpdate(e13, t20);
  }
  applyCacheUpdate() {
    return this._featureCache.applyCacheUpdate();
  }
  unload(e13) {
    this._removeChunks(e13.tile);
  }
  _addChunk(e13) {
    const t20 = e13.tile.id;
    this._chunksById.has(t20) || this._chunksById.set(t20, []);
    const s20 = e13.size();
    (s20 || e13.first || e13.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] ATileLoadStrategy.addChunk [count=${s20}]`), this._chunksById.get(t20).push(e13), this._store.insert(e13));
  }
  _removeChunks(e13) {
    const t20 = this._chunksById.get(e13.key.id) ?? [];
    for (const s20 of t20) has("esri-2d-update-debug") && console.debug(`Tile[${e13.key.id}] Chunk[${s20.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(s20);
    this._chunksById.delete(e13.key.id);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i18 = class extends i14 {
  constructor(e13, i19, t20, r17, s20, h8) {
    var _a, _b;
    super(), this._reader = e13, this._queryJSON = i19, this._tile = t20, this._sourceTile = r17, this._sourceTileDepth = s20, this._end = h8, this.chunkId = `${this._tile.key.id}.${(_a = this._sourceTile) == null ? void 0 : _a.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${(_b = this._sourceTile) == null ? void 0 : _b.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    var _a;
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: (_a = this._sourceTile) == null ? void 0 : _a.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e13) {
    return this._tile.key.id === e13.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var l8 = class {
  constructor(e13, o13) {
    this.subscription = e13, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = t3([m(e13.signal, () => this._controller.abort()), m(o13, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t20) {
    return this._tileIdToResult.get(t20);
  }
  set(t20, e13) {
    this._tileIdToResult.set(t20, e13);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var a14 = class extends s18 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t20 of this._loadStates.values()) t20.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { supportsDisplayFilter: true, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t20) {
    this._loadStates.has(t20.key.id) || this._loadStates.set(t20.key.id, new l8(t20, this._options));
    const s20 = this._loadStates.get(t20.key.id);
    let o13;
    try {
      for await (const o14 of this._fetchChunkInfos(s20, t20.tile, 0)) {
        const { queryJSON: t21, reader: i19, sourceTile: l10, sourceTileDepth: a17, tile: n14 } = o14, h8 = new i18(i19, t21, n14, l10, a17, false);
        s2(s20.options), this._addChunk(h8);
      }
    } catch (n14) {
      o13 = n14;
    }
    const a16 = new i18(u7.empty(this._metadata), null, t20.tile, null, -1, true);
    if (this._addChunk(a16), o13) throw o13;
  }
  unload(t20) {
    var _a2;
    super.unload(t20), (_a2 = this._loadStates.get(t20.key.id)) == null ? void 0 : _a2.destroy(), this._loadStates.delete(t20.key.id);
  }
  async *_fetchChunkInfos(t20, e13, s20) {
    let o13 = t20.get(e13.id);
    const r17 = !!o13;
    if (o13 || (o13 = await this._fetchChunkInfo(t20, e13, s20), t20.set(e13.id, o13)), o13.reader.exceededTransferLimit && s20 < has("featurelayer-query-max-depth")) for (const i19 of e13.createChildTiles()) yield* this._fetchChunkInfos(t20, i19, s20 + 1);
    else r17 || (yield o13);
  }
  async _fetchChunkInfo(t20, e13, s20) {
    const o13 = t20.subscription.tile.getQuantizationParameters(), r17 = this._queryInfo.createTileQuery(e13, { returnExceededLimitFeatures: false, quantizationParameters: o13 });
    return { reader: await this._fetch(r17, t20.options, { chunkId: e13.id }), queryJSON: r17.inner.toJSON(), tile: t20.subscription.tile, sourceTile: e13, sourceTileDepth: s20 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t17 = class extends i14 {
  constructor(e13, t20, i19, r17, s20) {
    super(), this._reader = e13, this._queryJSON = t20, this._tile = i19, this._page = r17, this._end = s20, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e13) {
    return this._tile.key.id === e13.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var l9 = class {
  constructor(e13, s20) {
    this.subscription = e13, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = t3([m(e13.signal, () => this._controller.abort()), m(s20, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let t20 = -1;
    for (const e13 of this._pages.values()) t20 = Math.max(t20, e13);
    return t20 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(t20, e13) {
    this._pages.add(t20), this._done = this._done || e13;
  }
};
var h7 = class extends s18 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t20 of this._loadStates.values()) t20.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { supportsDisplayFilter: true, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t20) {
    const o13 = r2(this._loadStates, t20.key.id, () => new l9(t20, this._options));
    let r17;
    try {
      await this._fetchPages(o13);
    } catch (h8) {
      r17 = h8;
    }
    const i19 = new t17(u7.empty(this._metadata), null, t20.tile, -1, true);
    if (c(o13.options) || this._addChunk(i19), r17) throw r17;
  }
  unload(t20) {
    var _a;
    super.unload(t20), (_a = this._loadStates.get(t20.key.id)) == null ? void 0 : _a.destroy(), this._loadStates.delete(t20.key.id);
  }
  async _fetchPages(t20) {
    const e13 = 4, s20 = 20;
    let r17 = 0, i19 = t20.pageStart, a16 = 1;
    for (; r17 < s20 && !t20.done; ) {
      const s21 = [];
      for (let e14 = 0; e14 < a16; e14++) s21.push(this._fetchChunk(t20, i19++));
      const n14 = await Promise.all(s21);
      for (const e14 of n14) (0 !== e14.size() || e14.first) && (t20.add(e14.page, !e14.reader.exceededTransferLimit), s2(t20.options), this._addChunk(e14));
      r17++, a16 = Math.min(a16 + 1, e13);
    }
  }
  async _fetchChunk(t20, e13) {
    const s20 = t20.subscription.tile, o13 = this._queryInfo.createPagedTileQuery(s20, e13), r17 = await this._fetch(o13, t20.options, { chunkId: `${s20.id}-${e13}` });
    return new t17(r17, o13.inner.toJSON(), s20, e13, false);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderParquet.js
var n13 = class _n extends M2 {
  constructor(t20, r17, n14, s20, i19, d11 = new Uint32Array(s20.size())) {
    var _a;
    super(t20), this._fields = r17, this._geometryInfo = n14, this._inner = s20, this._chunkId = i19, this._displayIds = d11, this._index = -1, this.usedMemory = s3, this._size = this._inner.size(), null != t20.objectIdField && (this._objectIdFieldIndex = (_a = this._fields.get(t20.objectIdField)) == null ? void 0 : _a.index), this._chunkId > 65535 && console.error("Exceeded max allowed parquet reader size");
  }
  destroy() {
    super.destroy(), this._inner.free();
  }
  get fields() {
    return this._fields;
  }
  get geometryType() {
    return this._geometryInfo.geometryType;
  }
  get hasFeatures() {
    return true;
  }
  get hasNext() {
    throw new Error("Method not implemented.");
  }
  get exceededTransferLimit() {
    return false;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return null;
  }
  getSize() {
    return this._size;
  }
  getCursor() {
    return this.copy();
  }
  getAttributeHash() {
    let e13 = "";
    for (const t20 of this.fields.fields) e13 += this._readAttribute(t20.name, false) + ".";
    return e13;
  }
  getObjectId() {
    return null != this._objectIdFieldIndex ? this._inner.readAttribute(this._index, this._objectIdFieldIndex) : this._index << 16 | this._chunkId;
  }
  getDisplayId() {
    return this._displayIds[this._index];
  }
  setDisplayId(e13) {
    this._displayIds[this._index] = e13;
  }
  setIndex(e13) {
    this._index = e13;
  }
  getBoundsXMin() {
    return this._inner.boundsXMin(this._index);
  }
  getBoundsYMin() {
    return this._inner.boundsYMin(this._index);
  }
  getBoundsXMax() {
    return this._inner.boundsXMax(this._index);
  }
  getBoundsYMax() {
    return this._inner.boundsYMax(this._index);
  }
  setBoundsXMin(e13) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMin(e13) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsXMax(e13) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMax(e13) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (; ++this._index < this._size && !this._getExists(); ) ;
    return this._index < this._size;
  }
  readGeometryArea() {
    var _a;
    return ((_a = this.readGeometryForDisplay()) == null ? void 0 : _a.area()) ?? 0;
  }
  copy() {
    const e13 = new _n(this.metadata, this._fields, this._geometryInfo, this._inner, this._chunkId, this._displayIds);
    return this.copyInto(e13), e13;
  }
  copyInto(e13) {
    super.copyInto(e13), e13._index = this._index;
  }
  readGeometryForDisplayTransformed(e13) {
    const [r17, n14] = e13.translate, [s20, i19] = e13.scale, d11 = this._inner.readGeometryTransformed(this._index, r17, n14, s20, i19);
    return d11 ? new e(d11.readLengthsUnsafe(), d11.readCoordsUnsafe()) : null;
  }
  _readGeometry(e13) {
    const r17 = this._inner.readCoords(this._index), n14 = this._inner.readLengths(this._index);
    return r17 && n14 ? new e(n14, r17) : null;
  }
  _readX() {
    var _a;
    return (_a = this._readGeometry()) == null ? void 0 : _a.coords[0];
  }
  _readY() {
    var _a;
    return (_a = this._readGeometry()) == null ? void 0 : _a.coords[1];
  }
  _readServerCentroid() {
    return null;
  }
  _readAttribute(e13, t20) {
    const r17 = this.fields.get(e13);
    if (!r17) return;
    if (null == r17.index) return this.getObjectId();
    const n14 = this._inner.readAttribute(this._index, r17.index);
    if (null == n14) return n14;
    const s20 = this.fields.isDateField(r17.name);
    return t20 ? null == n14 ? n14 : s20 ? new Date(n14) : n14 : n14;
  }
  _readAttributes() {
    const e13 = {};
    for (const t20 of this._fields.fields) null != t20.index ? this._inner.hasField(t20.index) && (e13[t20.name] = this._readAttribute(t20.name, false)) : e13.__OBJECTID = this.getObjectId();
    return e13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ParquetLoadStrategy.js
var m8 = class extends r15 {
  constructor(e13, t20, s20, i19) {
    super(i19), this._service = e13, this._metadata = t20, this._schema = s20, this._chunkId = 0, this._files = [], this._availableFields = new Set(s20.mutable.availableFields);
    const { geometryInfo: a16 } = this._service;
    if ("location" === a16.type) this._availableFields.add(a16.latitudeFieldName), this._availableFields.add(a16.longitudeFieldName);
    else if (null != a16.multiscale && a16.multiscale.levels.length >= 1) {
      const e14 = a16.multiscale.levels[0];
      this._availableFields.add(e14.column);
    } else this._availableFields.add(a16.primaryFieldName);
  }
  destroy() {
    for (const e13 of this._files) e13.destroy();
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  async updateFields(e13) {
    await this._promise;
    const i19 = new Set(e13), a16 = i2(i19, this._availableFields);
    this._availableFields = u2(a16, this._availableFields), a16.size && await Promise.all(this._files.map((e14) => {
      const t20 = Array.from(a16).map((t21) => e14.metadata.getFieldIndex(t21));
      return e14.inner.updateChunks(new Uint16Array(t20));
    }));
  }
  async load(e13) {
    return null == this._promise && (this._promise = this._download().then(() => {
      this._loadHigherResGeometry();
    })), this._promise;
  }
  unload(e13) {
  }
  async addParquetFile(e13) {
    this._insert(e13);
  }
  async _loadHigherResGeometry() {
    const { geometryInfo: e13 } = this._service;
    if ("geometry" === e13.type) {
      if (!(null != e13.multiscale && e13.multiscale.levels.length >= 1)) return;
      await this.updateFields([e13.primaryFieldName]);
    }
    const t20 = Array.from(this._store.chunks());
    this._store.clear();
    for (const s20 of t20) this._store.insert(s20);
    this._store.refresh();
  }
  async _insert(t20) {
    const s20 = await Jt.create(t20, { geometryInfo: this._service.geometryInfo, outSpatialReference: this._service.outSpatialReference, getCustomParameters: () => this._schema.mutable.dataFilter.customParameters }), { geometryInfo: r17 } = this._service;
    s2(this._options);
    const { fields: o13, timeZoneByFieldName: m11 } = this._service.metadata.fieldsIndex, d11 = o13.map((e13) => ({ ...e13, index: s20.metadata.getFieldIndex(e13.name) })), h8 = Z.fromJSON({ fields: d11, timeZoneByFieldName: m11 }), u13 = new Uint16Array(Array.from(this._availableFields.values()).map((e13) => {
      var _a;
      return (_a = h8.get(e13)) == null ? void 0 : _a.index;
    }).filter((e13) => null != e13));
    await s20.inner.readChunksWithCallback(u13, (e13) => {
      const t21 = this._chunkId++, s21 = new n13(this._metadata, h8, r17, e13, t21), i19 = new t15(s21, null, t21, false);
      this._store.insert(i19);
    }), this._files.push(s20);
  }
  async _download() {
    try {
      await Promise.all(this._service.source.urls.map((e14) => this._insert(e14)));
      const e13 = new t15(u7.empty(this._metadata), null, -1, true);
      this._store.insert(e13);
    } catch (e13) {
      throw console.error(e13), e13;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var a15 = class extends i17 {
  constructor(t20, e13, o13, s20, n14, a16) {
    super(t20, e13, o13, n14, a16), this._random = new t(1e3), this._featureCount = s20;
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(t20) {
    return null == this._promise && (this._promise = this._downloadPages(this._featureCount)), this._promise;
  }
  unload(t20) {
  }
  async _downloadPages(e13) {
    const r17 = Math.ceil(e13 / this._queryInfo.pageSize), o13 = Array.from({ length: r17 }, (t20, e14) => e14).sort((t20, e14) => this._random.getInt() - this._random.getInt()), a16 = await Promise.all(o13.map((t20) => this._downloadPage(t20))), i19 = new t15(u7.empty(this._metadata), null, -1, true);
    this._store.insert(i19);
    const u13 = a16.filter((t20) => t20);
    if (u13.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: u13 });
  }
  async _downloadPage(t20) {
    try {
      const r17 = this._queryInfo.createPagedQuery(t20), o13 = await this._fetch(r17, this._options, { chunkId: t20.toString() }), n14 = new t15(o13, r17.inner.toJSON(), t20, false);
      return s2(this._options), this._store.insert(n14), null;
    } catch (r17) {
      return r17;
    }
  }
};

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var o11 = 1e3;
var d10 = class {
  constructor(t20, e13, i19, r17, o13 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = i19, this._purgeOptions = r17, this.store = t20, this.objectIdField = e13, this.purgeInterval = o13, this._useGeneratedIds = this.objectIdField === _2;
  }
  removeById(t20) {
    this._removed.push(t20);
  }
  removeByTrackId(t20) {
    const e13 = this._trackIdToObservations.get(t20);
    if (e13) for (const s20 of e13.entries) this._removed.push(s20);
  }
  add(s20) {
    var _a;
    if (this._useGeneratedIds) {
      const t20 = this._nextId();
      s20.attributes[this.objectIdField] = t20, s20.objectId = t20;
    } else s20.objectId = s20.attributes[this.objectIdField];
    const i19 = s20.objectId;
    if (this._addOrUpdated.set(i19, s20), this._maxAge = Math.max(this._maxAge, s20.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField) return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t6(1e5)), void this._trackIdLessObservations.enqueue(i19);
    const r17 = s20.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(r17)) {
      const s21 = null != ((_a = this._purgeOptions) == null ? void 0 : _a.maxObservations) ? this._purgeOptions.maxObservations : o11, i20 = r(s21, 0, o11);
      this._trackIdToObservations.set(r17, new t6(i20));
    }
    const d11 = this._trackIdToObservations.get(r17), a16 = d11 == null ? void 0 : d11.enqueue(i19);
    null != a16 && (this._addOrUpdated.has(a16) ? this._addOrUpdated.delete(a16) : this._removed.push(a16));
  }
  checkForUpdates() {
    const t20 = this._getToAdd(), e13 = this._getToRemove(), s20 = performance.now(), o13 = s20 - this._lastPurge, d11 = Date.now();
    o13 >= this.purgeInterval && (this._purge(s20), this._lastPurge = s20);
    const a16 = [];
    if (null != e13) for (const i19 of e13) {
      const t21 = this.store.removeById(i19);
      null != t21 && a16.push(t21);
    }
    const n14 = [];
    if (null != t20) {
      const o14 = new Set(e13 ?? []);
      for (const e14 of t20) o14.has(e14.objectId) || (e14.attributes[e5] = s20, e14.attributes[i6] = d11, this.store.add(e14), n14.push(e14));
    }
    return !(!n14.length && !(a16 == null ? void 0 : a16.length)) && (this.store.update(n14, a16), true);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size) return null;
    const t20 = new Array(this._addOrUpdated.size);
    let e13 = 0;
    return this._addOrUpdated.forEach((s20) => t20[e13++] = s20), this._addOrUpdated.clear(), t20;
  }
  _getToRemove() {
    const t20 = this._removed;
    return this._removed.length ? (this._removed = [], t20) : null;
  }
  _nextId() {
    const t20 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t20;
  }
  _purge(t20) {
    const e13 = this._purgeOptions;
    null != e13 && (this._purgeSomeByDisplayCount(e13), this._purgeByAge(e13), this._purgeByAgeReceived(t20, e13), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t20) {
    if (!t20.displayCount) return;
    let e13 = this.store.size;
    if (e13 > t20.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s20 of this._trackIdToObservations.values()) if (e13 > t20.displayCount && s20.size) {
          const t21 = s20.dequeue();
          this._removed.push(t21), e13--;
        }
      }
      if (null != this._trackIdLessObservations) {
        let s20 = e13 - t20.displayCount;
        for (; s20-- > 0; ) {
          const t21 = this._trackIdLessObservations.dequeue();
          null != t21 && this._removed.push(t21);
        }
      }
    }
  }
  _purgeByAge(t20) {
    var _a;
    const e13 = (_a = this._timeInfo) == null ? void 0 : _a.startTimeField;
    if (!t20.age || !e13) return;
    const s20 = 60 * t20.age * 1e3, i19 = this._maxAge - s20;
    this.store.forEach((t21) => {
      t21.attributes[e13] < i19 && this._removed.push(t21.objectId);
    });
  }
  _purgeByAgeReceived(t20, e13) {
    if (!e13.ageReceived) return;
    const s20 = t20 - 60 * e13.ageReceived * 1e3;
    this.store.forEach((t21) => {
      t21.attributes[e5] < s20 && this._removed.push(t21.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t20, e13) => {
      0 === t20.size && this._trackIdToObservations.delete(e13);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s19 = class extends g {
  constructor(r17) {
    super(r17);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
r3([m2()], s19.prototype, "connection", void 0), r3([m2()], s19.prototype, "connectionStatus", null), r3([m2()], s19.prototype, "errorString", null), s19 = r3([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s19);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t18 = class {
  constructor(e13, t20) {
    this._metadata = e13, this._onUpdate = t20, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u7.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e13) {
    this._objectIdToFeature.set(e13.objectId, e13);
  }
  forEach(e13) {
    this._objectIdToFeature.forEach(e13);
  }
  removeById(e13) {
    const t20 = this._objectIdToFeature.get(e13);
    return t20 ? (this._objectIdToFeature.delete(e13), t20) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e13, t20) {
    this._onUpdate((e13 == null ? void 0 : e13.length) ?? 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r16 = class extends i14 {
  constructor(e13) {
    super(), this._reader = e13, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e13) {
    const r17 = this.queryFeaturesInBounds(e13.bounds);
    return r17.setTransformForDisplay(e13.transform), r17;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var m9 = class extends r15 {
  constructor(t20, s20, i19, c10, h8) {
    super(i19), this._service = t20, this._dataFilter = s20, this._streamOptions = c10, this._metadata = h8, this._connectionState = new s19(), this._forceRefresh = false, this.events = new i3();
    const { objectIdField: m11, timeInfo: d11 } = this._metadata, { purgeOptions: _5 } = s20;
    this._stagingStore = new t18(this._metadata.weakCloneWithAdditionalFields([{ name: i6, alias: "timeReceived", type: "esriFieldTypeDate" }]), (e13) => this.events.emit("features-updated", e13)), this._manager = new d10(this._stagingStore, m11, d11, _5), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { supportsDisplayFilter: false, willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this._connectionState) == null ? void 0 : _a.errorString;
  }
  async refresh() {
    const e13 = null != this._chunk;
    this._manager.checkForUpdates() || !e13 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r16(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick")) : this.events.emit("tick");
  }
  async updateFields(e13) {
    throw new Error("Updating available fields not supported for StreamLayer");
  }
  async load(e13) {
  }
  unload(e13) {
  }
  disconnect() {
    var _a;
    this._connection = u(this._connection), this._connectionState.connection = null, (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  connect() {
    if (null != this._connection) return;
    const { geometryType: e13, spatialReference: s20 } = this._metadata, { maxReconnectionAttempts: n14, maxReconnectionInterval: o13, geometryDefinition: r17, definitionExpression: a16, customParameters: c10 } = this._dataFilter;
    this._connection = r8(this._service.source, s20, this._streamOptions.outSR, e13, a16, r17, n14, o13, c10), this._handlesGroup = t3([this._connection.on("data-received", (e14) => this._onFeature(e14)), this._connection.on("message-received", (e14) => this._onWebSocketMessage(e14))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.updateCustomParameters(e13);
  }
  sendMessageToSocket(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToSocket(e13);
  }
  sendMessageToClient(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToClient(e13);
  }
  _onWebSocketMessage(e13) {
    if ("type" in e13) switch (e13.type) {
      case "delete":
        if (e13.objectIds) for (const t20 of e13.objectIds) this._manager.removeById(t20);
        if (e13.trackIds) for (const t20 of e13.trackIds) this._manager.removeByTrackId(t20);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e13);
  }
  _onFeature(e13) {
    try {
      this._manager.add(e13), this.events.emit("data-received", e13);
    } catch (t20) {
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var o12 = class {
  constructor(s20) {
    this._metadata = s20, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this._overrides = new a11(), this.events = new i3(), this.featureAdapter = new r7();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e13 of this._chunks.values()) this._chunksToRemove.push(e13);
    this._chunks.clear(), this._overrides.clearWeakOverrides();
  }
  *chunks() {
    this._overrides && (yield this._overrides.asChunk(this._metadata)), yield* this._chunks.values();
  }
  insert(e13) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] SourceChunkStore.insert`), this._overrides.onChunkInsert(e13), this._chunks.set(e13.chunkId, e13), this.events.emit("changed");
  }
  remove(e13) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e13.chunkId), this._chunksToRemove.push(e13);
  }
  cleanup() {
    const e13 = this._chunksToRemove;
    return this._chunksToRemove = [], this._overrides.cleanup(this._chunks.values()), e13;
  }
  applyOverride(e13) {
    this._overrides.apply(e13, this), this.events.emit("changed");
    for (const s20 of this._chunks.values()) s20.invalidate();
  }
  takeOverrideUpdate() {
    return this._overrides.takeOverrideUpdate();
  }
  refresh() {
    this.events.emit("refresh");
  }
  forEach(e13) {
    const s20 = /* @__PURE__ */ new Set();
    for (const t20 of this.chunks()) {
      const r17 = t20.reader.getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s20.has(t21) || (e13(r17.copy()), s20.add(t21));
      }
    }
  }
  forEachUnsafe(e13) {
    const s20 = /* @__PURE__ */ new Set();
    for (const t20 of this.chunks()) {
      const r17 = t20.reader.getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s20.has(t21) || (e13(r17), s20.add(t21));
      }
    }
  }
  mapObjectIdsFromGlobalIds(e13, s20) {
    const t20 = /* @__PURE__ */ new Map(), r17 = new Set(e13);
    return this._overrides.putWeakObjectIdsFromGlobalIds(t20, r17, s20), this._forEachUnsafeIgnoreOverrides((e14) => {
      const o13 = e14.readAttribute(s20);
      if (o13 && r17.has(o13) && !t20.has(o13)) {
        const s21 = e14.getObjectId();
        t20.set(o13, s21);
      }
    }), t20;
  }
  forEachInBounds(e13, s20) {
    const t20 = /* @__PURE__ */ new Set();
    for (const r17 of this.chunks()) {
      const o13 = r17.queryFeaturesInBounds(e13);
      for (; o13.next(); ) {
        const e14 = o13.getObjectId();
        t20.has(e14) || (s20(o13.copy()), t20.add(e14));
      }
    }
  }
  forEachBounds(e13, t20) {
    const r17 = u3();
    for (const s20 of e13) {
      s20.getBounds(r17) && t20(r17);
    }
  }
  _forEachUnsafeIgnoreOverrides(e13) {
    const s20 = /* @__PURE__ */ new Set();
    for (const t20 of this._chunks.values()) {
      const r17 = t20.reader.withoutOverrides().getCursor();
      for (; r17.next(); ) {
        const t21 = r17.getObjectId();
        s20.has(t21) || (e13(r17), s20.add(t21));
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var v = class {
  constructor(e13, t20, s20, r17, a16) {
    this.service = e13, this._aggregateAdapter = t20, this._subscriptions = s20, this._connection = r17, this._cachedObjectIds = a16, this._updateTracking = new d4({ debugName: "FeatureSource" }), this._didInvalidateData = false, this._metadata = i7.createFeature(e13.metadata), this._store = new o12(this._metadata);
  }
  destroy() {
    var _a, _b;
    (_a = this._strategy) == null ? void 0 : _a.destroy(), this._store.destroy(), (_b = this._streamMessenger) == null ? void 0 : _b.destroy(), "memory" === this.service.type && this.service.source.map((e13) => e13.close());
  }
  get metadata() {
    if (!this._metadata) throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t14.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema) return null;
      const { dataFilter: e13 } = this._schema.mutable, t20 = this._schema.mutable.availableFields, s20 = this._metadata;
      this._queryEngine = new L2({ featureStore: this._store, fieldsIndex: s20.fieldsIndex, geometryType: s20.geometryType, objectIdField: s20.objectIdField, hasM: false, hasZ: false, spatialReference: this.service.outSpatialReference, aggregateAdapter: this._aggregateAdapter, timeInfo: s20.timeInfo, definitionExpression: e13.definitionExpression, availableFields: t20 });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  get hasDisplayFilter() {
    return !!this._schema && ("displayFilterInfo" in this._schema.mutable && null != this._schema.mutable.displayFilterInfo);
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  prepareCacheUpdate(e13, t20) {
    const s20 = /* @__PURE__ */ new Set(), r17 = /* @__PURE__ */ new Set();
    for (const a16 of e13) this._cachedObjectIds.has(a16) || (this._cachedObjectIds.add(a16), s20.add(a16));
    for (const a16 of t20) this._cachedObjectIds.delete(a16), r17.add(a16);
    this.hasDisplayFilter && this._strategy.prepareCacheUpdate(s20, r17);
  }
  async applyCacheUpdate() {
    this.hasDisplayFilter && await this._updateTracking.addPromise(this._strategy.applyCacheUpdate());
  }
  cleanup() {
    return this._store.cleanup();
  }
  onSubscribe(e13) {
    var _a;
    this._connection.onEvent({ type: "subscribe", tile: e13.tile.id });
    const t20 = (_a = this._strategy) == null ? void 0 : _a.load(e13);
    t20 && (t20.then(() => this._connection.onEvent({ type: "loaded", tile: e13.tile.id })).catch((t21) => this._connection.onEvent({ type: "error", tile: e13.tile.id, error: t21 })), this._updateTracking.addPromise(t20));
  }
  onResume(e13) {
    var _a;
    this._updateTracking.addPromise(d((_a = this._strategy) == null ? void 0 : _a.load(e13)));
  }
  onUnsubscribe(e13) {
    var _a;
    this._connection.onEvent({ type: "unsubscribe", tile: e13.tile.id }), (_a = this._strategy) == null ? void 0 : _a.unload(e13);
  }
  applyOverride(e13) {
    this._didInvalidateData = true, this._store.applyOverride(e13);
  }
  takeOverrideUpdate() {
    return this._store.takeOverrideUpdate();
  }
  async update(e13, t20) {
    var _a, _b, _c;
    const s20 = e13.source, n14 = y((_a = this._schema) == null ? void 0 : _a.mutable, s20.mutable);
    if (!n14) return false;
    if (has("esri-2d-update-debug") && console.debug(`Version[${t20}] FeatureSource.update`, { changes: n14 }), this._schema = s20, (_b = this._queryEngine) == null ? void 0 : _b.destroy(), this._queryEngine = null, "feature-service" === this.service.type && null != this.service.queryMetadata.lastEditDate && (this._lastEditDate = this.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), a6(n14, "sourceRefreshVersion") && ((_c = this._strategy) == null ? void 0 : _c.refresh)) return await this._strategy.refresh(), true;
    if (("feature" === s20.type || "parquet" === s20.type) && a6(n14, "availableFields")) {
      if (await this._queryLastEditDateChanged() || this._didInvalidateData) this._didInvalidateData = false, await this._updateStrategy(t20);
      else {
        this._connection.onEvent({ type: "updateFieldsStart" });
        try {
          await this._strategy.updateFields(s20.mutable.availableFields), this._connection.onEvent({ type: "updateFieldsEnd" });
        } catch (o13) {
          this._connection.onEvent({ type: "updateFieldsError", error: o13 });
        }
      }
      return false;
    }
    return !!(s7(n14, "dataFilter") || s7(n14, "sourceRefreshVersion") || this._strategy.about.supportsDisplayFilter && s7(n14, "displayFilterInfo")) && (await this._updateStrategy(t20), true);
  }
  async addParquetFile(e13) {
    this._strategy.addParquetFile(e13);
  }
  unsafeSetQueryHistoricMoment(e13) {
    "feature" === this._schema.type && (this._schema.mutable.dataFilter.historicMoment = e13, this._strategy.unsafeSetQueryHistoricMoment(new Date(e13)));
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new o7(this._connection));
  }
  async normalizeOverrides(e13) {
    const t20 = { historicMoment: e13.historicMoment, commands: { updateWeak: e13.commands.updateWeak.map(s4.fromJSON), removeWeak: e13.commands.removeWeak, update: e13.commands.update.map(s4.fromJSON), remove: e13.commands.remove, release: e13.commands.release } }, s20 = e13.commands.updateByIdWeak, r17 = await this._queryOptimizedFeatures(s20);
    return t20.commands.updateWeak.push(...r17), t20;
  }
  async _queryOptimizedFeatures(e13) {
    if (0 === e13.length) return [];
    const t20 = [], s20 = (await this._strategy.queryByObjectId(e13)).getCursor();
    for (; s20.next(); ) t20.push(s20.readOptimizedFeatureWorldSpace());
    return t20;
  }
  getObjectIdsFromGlobalIds(e13) {
    const t20 = this.metadata.globalIdField;
    if (null == t20) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
    const s20 = this._store.mapObjectIdsFromGlobalIds(e13, t20).values();
    return Array.from(s20);
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate) return false;
    const t20 = this.service.source, s20 = { ...t20.query, f: "json" }, r17 = (await P(t20.path, { query: s20, responseType: "json" })).data.editingInfo.lastEditDate;
    return r17 !== this._lastEditDate && (this._lastEditDate = r17, true);
  }
  async _createStrategy() {
    const e13 = "isSourceHosted" in this.service && this.service.isSourceHosted, t20 = Array.isArray(this.service.source), s20 = this.service.source && "collection" in this.service.source, r17 = e13 || t20 || s20;
    if ("stream" === this._schema.type) {
      const e14 = new m9(this.service, this._schema.mutable.dataFilter, this._store, { outSR: this.service.outSpatialReference }, this.metadata);
      return this._streamMessenger.strategy = e14, e14;
    }
    if ("parquet" === this._schema.type) {
      const e14 = this.service;
      return new m8(e14, this._metadata, this._schema, this._store);
    }
    const a16 = this.service, i19 = u11.fromSchema(a16, this._schema, this._metadata), n14 = await this._supportSnapshotMode(a16, i19);
    return n14 ? new a15(a16, i19, this._store, n14.featureCount, this.metadata, this._connection) : r17 ? new h7(a16, i19, this._store, this.metadata, this._connection) : new a14(a16, i19, this._store, this.metadata, this._connection);
  }
  async _updateStrategy(e13) {
    var _a;
    const t20 = await this._createStrategy();
    this._connection.onEvent({ type: "updateStrategyStart", about: t20.about });
    const r17 = !!this._strategy;
    this._store.clear(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._strategy = t20, has("esri-2d-update-debug") && console.debug(`Version[${e13}] FeatureSource.updateStrategy`, { strategy: t20 });
    const a16 = Array.from(this._subscriptions.values());
    if (!a16.length) return void this._connection.onEvent({ type: "updateStrategyEnd" });
    const i19 = Promise.all(a16.map((e14) => this._strategy.load(e14).then(() => this._connection.onEvent({ type: "loaded", tile: e14.tile.id })).catch((t21) => this._connection.onEvent({ type: "error", tile: e14.tile.id, error: t21 }))));
    this._updateTracking.addPromise(i19), this._strategy.prepareCacheUpdate(this._cachedObjectIds);
    try {
      r17 && await i19;
    } catch (n14) {
      f(n14);
    }
    this._connection.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${e13}] FeatureSource.updateStrategyEnd`, { strategy: t20 });
  }
  async _supportSnapshotMode(e13, t20) {
    const { queryMetadata: s20 } = e13, r17 = s20.snapshotInfo;
    if (!r17 || !r17.supportsSnapshotMinThreshold || !r17.snapshotCountThresholds) return null;
    const a16 = e13.source, i19 = t20.createQuery();
    i19.inner.orderByFields = [], i19.inner.returnGeometry = false;
    const n14 = (await S(a16, i19.inner, { query: i19.customParameters })).data.count, { min: o13, max: h8 } = r17.snapshotCountThresholds;
    return n14 <= o13 || r17.supportsSnapshotMaxThreshold && n14 < h8 ? { featureCount: n14 } : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t19 = class {
  constructor(t20, r17) {
    this.tile = t20, this.version = r17, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m10 = class {
  constructor(e13) {
    this.inner = e13, this.resolver = L();
  }
};
var y6 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e13) => this._processor.getFeatureObjectIdsForAggregate(e13) }, this._subscriptions = /* @__PURE__ */ new Map(), this._cachedObjectIds = /* @__PURE__ */ new Set(), this._updateRequested = false, this._didSourceRefresh = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    var _a, _b, _c;
    this._subscriptions.clear(), (_a = this._processor) == null ? void 0 : _a.destroy(), (_b = this._source) == null ? void 0 : _b.destroy(), (_c = this._handles) == null ? void 0 : _c.remove(), this._updateOverridesRequest = null, this._tileInfoView = null;
  }
  onAttach(e13) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s20 = this._connection, i19 = z.fromJSON(e13.tileInfoJSON);
    this._tileInfoView = new h2(i19), this._source = new v(e13.service, this._aggregateAdapter, this._subscriptions, s20, this._cachedObjectIds), this._processor = new b3(s20, this._source), this._handles = t3([this._source.store.events.on("changed", () => this._requestUpdate()), this._source.store.events.on("refresh", () => this._requestRefresh()), d2(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), d(this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e13) {
    this._connection = new t7(e13);
  }
  get features() {
    var _a;
    const t20 = (_a = this._source) == null ? void 0 : _a.queryEngine;
    if (!t20) throw new s("no-queryEngine", "No query engine defined");
    return t20;
  }
  get aggregates() {
    var _a;
    const t20 = (_a = this._processor) == null ? void 0 : _a.aggregateQueryEngine;
    if (!t20) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t20;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e13) {
    return this._processor.getDisplayFeatures(e13);
  }
  getDisplayIds(e13) {
    return this._processor.getDisplayIds(e13);
  }
  getObjectIdsFromGlobalIds(e13) {
    return this._source.getObjectIdsFromGlobalIds(e13);
  }
  async updateSchema(e13, t20) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m10({ schema: e13, version: t20 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e13) {
    const t20 = new m10(e13);
    return this._updateSubscriptionRequests.push(t20), this._requestUpdate(), t20.resolver.promise;
  }
  updateHighlight(e13) {
    const t20 = new m10(e13);
    return this._updateHighlightRequests.push(t20), this._requestUpdate(), t20.resolver.promise;
  }
  async addParquetFile(e13) {
    return this._source.addParquetFile(e13);
  }
  async onOverride(t20) {
    if (null != this._updateOverridesRequest) throw new s("InternalError - Already processing an edit");
    this._updateOverridesRequest = new m10(t20);
    const s20 = this._updateOverridesRequest.resolver.promise;
    return this._requestUpdate(), s20;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e13, t20) {
    return this.features.executeQuery(e13, t20);
  }
  async queryHeatmapStatistics(e13) {
    const t20 = Math.round(u5(e13.radius));
    let s20 = Number.POSITIVE_INFINITY, i19 = Number.NEGATIVE_INFINITY;
    const r17 = "string" == typeof e13.fieldOffset, o13 = e13.fieldOffset ?? 0, n14 = Array.from(this._subscriptions.values()), u13 = this._source.chunks(), d11 = t20 ** 2, c10 = 3 / (Math.PI * d11), h8 = 2 * t20, l10 = Math.ceil(a5 / h8);
    for (const a16 of n14) {
      const t21 = a16.tile, n15 = new Float64Array(l10 * l10);
      for (const s21 of u13) {
        const i20 = s21.getTileReader(t21);
        if (!i20) continue;
        const u14 = i20.getCursor();
        for (; u14.next(); ) {
          let t22 = 1;
          if (null != e13.field) {
            const s23 = u14.readAttribute(e13.field);
            t22 = r17 ? -1 * +s23 : +s23 + o13;
          }
          const s22 = u14.readXForDisplay() / h8, i21 = u14.readYForDisplay() / h8, a17 = Math.floor(s22), p8 = Math.floor(i21);
          if (a17 < 0 || p8 < 0 || a17 >= l10 || p8 >= l10) continue;
          const g7 = ((0.5 + a17 - s22) * h8) ** 2 + ((0.5 + p8 - i21) * h8) ** 2;
          if (g7 > d11) continue;
          const _5 = t22 * (c10 * (1 - g7 / d11) ** 2);
          n15[p8 + a17 * l10] += _5;
        }
      }
      for (let e14 = 0; e14 < n15.length; e14++) s20 = Math.min(s20, n15[e14]), i19 = Math.max(i19, n15[e14]);
    }
    return { max: i19, min: s20 };
  }
  async getSampleFeatures(e13) {
    const t20 = this._source.chunks();
    if (t20.reduce((e14, t21) => e14 + t21.size(), 0) <= e13.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e14 = [];
        return this._source.store.forEachUnsafe((t21) => e14.push(t21.readLegacyFeatureWorldSpace())), e14;
      }
      return null;
    }
    const s20 = /* @__PURE__ */ new Set(), i19 = [], r17 = t20.map((e14) => e14.reader.getCursor()), o13 = new t(), u13 = 3 * e13.sampleSize;
    for (let n14 = 0; n14 < u13 && i19.length < e13.sampleSize; n14++) {
      const e14 = r17[o13.getIntRange(0, t20.length - 1)];
      if (0 === e14.getSize()) continue;
      const n15 = o13.getIntRange(0, e14.getSize() - 1);
      e14.setIndex(n15);
      const u14 = e14.getObjectId();
      s20.has(u14) || (s20.add(u14), i19.push(e14.readLegacyFeatureWorldSpace()));
    }
    return i19.length >= e13.sampleSize ? i19 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t4(() => this._scheduleNextUpdate()));
  }
  _requestRefresh() {
    this._didSourceRefresh = true, this._requestUpdate();
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = O(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e13) {
    const t20 = e13.tileId;
    if (this._subscriptions.has(t20)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t20}] Pipeline.subscribe`);
    const s20 = new r9(this._tileInfoView, t20), i19 = new t19(s20, e13.version);
    this._subscriptions.set(t20, i19), this._source.onSubscribe(i19), this._processor.onSubscribe(i19);
  }
  _unsubscribe(e13) {
    const t20 = this._subscriptions.get(e13);
    t20 && (has("esri-2d-update-debug") && console.debug(`Tile[${e13}] Pipeline.unsubscribe`), t20.abort(), this._source.onUnsubscribe(t20), this._processor.onUnsubscribe(t20), this._subscriptions.delete(t20.key.id));
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e14 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t21 of e14) this._doUpdateSubscriptions(t21.inner), t21.resolver.resolve();
    }
    if (this._updateHighlightRequests.length) {
      const e14 = this._updateHighlightRequests, t21 = /* @__PURE__ */ new Set(), s21 = /* @__PURE__ */ new Set();
      for (const i19 of e14) for (const { objectId: e15, highlightFlags: r18 } of i19.inner.highlights) r18 ? (t21.add(e15), s21.delete(e15)) : (s21.add(e15), t21.delete(e15));
      this._source.prepareCacheUpdate(t21, s21);
    }
    const e13 = this._updateSchemaRequest;
    this._updateSchemaRequest = null;
    let t20 = false;
    if (null != e13) {
      const { schema: s21, version: i19 } = e13.inner;
      t20 = await this._doUpdateSchema(s21, i19);
    }
    this._didSourceRefresh && (t20 = true, this._didSourceRefresh = false), t20 && (this._processor.invalidate(), await this._connection.container.updateRenderState(this._processor.version));
    const s20 = this._updateOverridesRequest;
    if (this._updateOverridesRequest = null, null != s20) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyOverride", s20.inner), null != s20.inner.historicMoment && this._source.unsafeSetQueryHistoricMoment(s20.inner.historicMoment);
      const e14 = await this._source.normalizeOverrides(s20.inner);
      this._source.applyOverride(e14), has("esri-2d-update-debug") && console.debug("Pipeline.endOverride", s20.inner);
    }
    if (await this._source.applyCacheUpdate(), this._updateHighlightRequests.length) {
      const e14 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t21 of e14) this._processor.updateHighlight(t21.inner), t21.resolver.resolve();
    }
    const r17 = this._source.cleanup();
    this._processor.removeChunks(r17);
    try {
      const e14 = this._source.takeOverrideUpdate();
      if (null != e14 && this._subscriptions.size) {
        has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesStart"), await this._connection.container.lockForOverrides();
        try {
          await this._processor.applyOverrideUpdate(e14);
        } catch (o13) {
          has("esri-2d-update-debug") && console.debug("InternalError", o13);
        }
        await this._connection.container.unlockForOverrides(), has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesEnd");
      }
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (o13) {
      f(o13);
    }
    null != s20 && s20.resolver.resolve(), null != e13 && e13.resolver.resolve(), null == e13 && t20 && await this._connection.container.trySwapRenderState(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e13, t20) {
    var _a;
    has("esri-2d-update-debug") && console.debug(`Version[${t20}] Pipeline.updateStart`, { schema: e13 });
    const s20 = { tileInfo: (_a = this._tileInfoView) == null ? void 0 : _a.tileInfo }, i19 = await this._source.update(e13, t20), r17 = Array.from(this._subscriptions.values()), o13 = this._processor.update(e13, t20, s20, i19, r17);
    return has("esri-2d-update-debug") && console.debug(`Version[${t20}] Pipeline.updateEnd`), o13;
  }
  _doUpdateSubscriptions(e13) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e13);
    for (const t20 of e13.subscribe) this._subscribe(t20);
    for (const t20 of e13.unsubscribe) this._unsubscribe(t20);
  }
};
export {
  y6 as default
};
//# sourceMappingURL=FeaturePipelineWorker-YLKY3KZO.js.map
