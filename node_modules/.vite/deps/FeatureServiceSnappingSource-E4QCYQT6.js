import {
  i as i3,
  o as o3
} from "./chunk-VRPQZVYZ.js";
import "./chunk-FNR27W4O.js";
import "./chunk-GIVDDPSR.js";
import "./chunk-V34X57N3.js";
import {
  t as t2
} from "./chunk-4NO34UCA.js";
import "./chunk-OSI4PMXO.js";
import "./chunk-TFOTFKYE.js";
import {
  b as b2
} from "./chunk-3T6XYN2R.js";
import "./chunk-6IYG6BTI.js";
import "./chunk-TWM4KR2X.js";
import {
  y as y2
} from "./chunk-LULXSZFE.js";
import {
  W,
  gs,
  ts
} from "./chunk-QQGGEN5E.js";
import "./chunk-QEAQVAMR.js";
import {
  h as h3
} from "./chunk-G4TWQWZ5.js";
import {
  i as i2
} from "./chunk-MAX4GY2G.js";
import {
  e as e3
} from "./chunk-ZGGC3KHK.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-PJIFP7OJ.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import {
  o as o2
} from "./chunk-ON7GWFUW.js";
import {
  h as h2
} from "./chunk-VPRLLNNO.js";
import {
  E
} from "./chunk-UCM2ZG62.js";
import {
  p,
  z
} from "./chunk-Q44EAKHA.js";
import {
  t
} from "./chunk-4HTLBMKF.js";
import "./chunk-SB6LU3VH.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import {
  c as c2
} from "./chunk-GSNLF6RP.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b
} from "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import {
  y
} from "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import {
  d5 as d4,
  m3,
  p2,
  w,
  z as z2
} from "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import {
  m3 as m2
} from "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import {
  r as r2
} from "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import {
  n
} from "./chunk-D3P3E2RE.js";
import {
  A,
  C,
  P,
  d as d3,
  v
} from "./chunk-UKY33OJN.js";
import {
  d as d2
} from "./chunk-HAWCNM3C.js";
import {
  V
} from "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import {
  S
} from "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import {
  h
} from "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j as j2
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import {
  a as a2,
  c
} from "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  o
} from "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  d,
  e,
  e2,
  i,
  k,
  s as s2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import {
  G,
  s
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function a3(s3, e4) {
  return ts(e4.extent, c3), gs(c3, o2(n2, s3.x, s3.y, 0));
}
var c3 = W();
var n2 = n();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p3 = class extends g {
  get tiles() {
    const e4 = this.tilesCoveringView, t3 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e4.sort((e5, i4) => a3(t3, e5) - a3(t3, i4)), e4;
  }
  _scaleEnabled() {
    return i2(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo) return [];
    if (!this._scaleEnabled) return [];
    const { spans: e4, lodInfo: t3 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: i4 } = t3, r3 = [];
    for (const { row: o4, colFrom: s3, colTo: n4 } of e4) for (let e5 = s3; e5 <= n4; e5++) {
      const s4 = t3.normalizeCol(e5), n5 = new t(null, i4, o4, s4);
      this.tileInfo.updateTileInfo(n5), r3.push(n5);
    }
    return r3;
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featuresTilingScheme) == null ? void 0 : _a.tileInfo) ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e4) {
    super(e4), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(d3(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.state) == null ? void 0 : _b.viewpoint;
    }, () => this.notifyChange("tilesCoveringView"), C));
  }
};
r([m({ readOnly: true })], p3.prototype, "tiles", null), r([m({ readOnly: true })], p3.prototype, "_scaleEnabled", null), r([m({ readOnly: true })], p3.prototype, "tilesCoveringView", null), r([m({ readOnly: true })], p3.prototype, "tileInfo", null), r([m({ readOnly: true })], p3.prototype, "tileSize", null), r([m({ constructOnly: true })], p3.prototype, "view", void 0), r([m({ constructOnly: true })], p3.prototype, "layer", void 0), r([m()], p3.prototype, "pointOfInterest", void 0), p3 = r([a("esri.views.2d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p3);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var a4 = class extends g {
  get _sortedTilesCoveringView() {
    var _a, _b;
    const e4 = (((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tiles) == null ? void 0 : _b.toArray()) ?? []).map(c4), t3 = this._effectivePointOfInterest;
    return null != t3 && e4.sort((e5, r3) => a3(t3, e5) - a3(t3, r3)), e4;
  }
  get tileInfo() {
    var _a, _b;
    return ((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tilingScheme) == null ? void 0 : _b.toTileInfo()) ?? null;
  }
  get tileSize() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tileSize) ?? 256;
  }
  get _effectivePointOfInterest() {
    var _a;
    const e4 = this.pointOfInterest;
    return null != e4 ? e4 : (_a = this.view.pointsOfInterest) == null ? void 0 : _a.focus.location;
  }
  constructor(e4) {
    super(e4), this.tiles = [], this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles([d3(() => this.view.featureTiles, (e4) => {
      this.removeHandles(u), e4 && this.addHandles(e4.addClient(), u);
    }, P), d3(() => this._sortedTilesCoveringView, (e4) => this._set("tiles", e4), { initial: true, equals: (e4, t3) => s(e4, t3, (e5, t4) => e5.id === t4.id) })]);
  }
};
function c4({ lij: [e4, t3, r3], extent: i4 }) {
  return new t(`${e4}/${t3}/${r3}`, e4, t3, r3, i4);
}
r([m({ readOnly: true })], a4.prototype, "tiles", void 0), r([m({ readOnly: true })], a4.prototype, "_sortedTilesCoveringView", null), r([m({ readOnly: true })], a4.prototype, "tileInfo", null), r([m({ readOnly: true })], a4.prototype, "tileSize", null), r([m({ constructOnly: true })], a4.prototype, "view", void 0), r([m()], a4.prototype, "pointOfInterest", void 0), r([m()], a4.prototype, "_effectivePointOfInterest", null), a4 = r([a("esri.views.3d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], a4);
var u = "feature-tiles";

// node_modules/@arcgis/core/views/support/TileTreeDebugger.js
var u2 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var d5 = class extends g {
  constructor(e4) {
    super(e4), this.updating = false, this.enablePolygons = true, this.enableLabels = true, this._polygons = /* @__PURE__ */ new Map(), this._labels = /* @__PURE__ */ new Map(), this._enabled = true;
  }
  initialize() {
    this._symbols = u2.map((e4) => new S({ color: [e4[0], e4[1], e4[2], 0.6], outline: { color: "black", width: 1 } })), this.update();
  }
  destroy() {
    this._enabled = false, this.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e4) {
    this._enabled !== e4 && (this._enabled = e4, this.update());
  }
  update() {
    if (!this._enabled) return void this.clear();
    const e4 = (e5) => {
      if (null != e5.label) return e5.label;
      let s3 = e5.lij.toString();
      return null != e5.loadPriority && (s3 += ` (${e5.loadPriority})`), e5.measures && (s3 += `[${e5.measures.lodLevel}]`), s3;
    }, t3 = this.getTiles(), i4 = new Array(), a6 = new Set((this._labels.size, this._labels.keys()));
    t3.forEach((m5, u4) => {
      var _a;
      const d6 = m5.lij.toString();
      a6.delete(d6);
      const g2 = ((_a = m5.measures) == null ? void 0 : _a.lodLevel) ?? m5.level, f = m5.geometry;
      if (this.enablePolygons && !this._polygons.has(d6)) {
        const e5 = new b({ geometry: f, symbol: this._symbols[g2 % this._symbols.length] });
        this._polygons.set(d6, e5), i4.push(e5);
      }
      if (this.enableLabels) {
        const a7 = e4(m5), g3 = u4 / (t3.length - 1), w2 = o(0, 200, g3), _ = o(20, 6, g3) / 0.75, j3 = null != m5.loadPriority && m5.loadPriority >= t3.length, v2 = new h([w2, j3 ? 0 : w2, j3 ? 0 : w2]), S2 = "3d" === this.view.type ? () => new w({ verticalOffset: new p2({ screenLength: 40 / 0.75 }), callout: new d4({ color: new h("white"), border: new m3({ color: new h("black") }) }), symbolLayers: new V([new z2({ text: a7, halo: { color: "white", size: 1 / 0.75 }, material: { color: v2 }, size: _ })]) }) : () => new m2({ text: a7, haloColor: "white", haloSize: 1 / 0.75, color: v2, size: _ }), L = this._labels.get(d6);
        if (L) {
          const e5 = S2();
          null != L.symbol && JSON.stringify(e5) === JSON.stringify(L.symbol) || (L.symbol = e5);
        } else {
          const e5 = new b({ geometry: f.extent.center, symbol: S2() });
          this._labels.set(d6, e5), i4.push(e5);
        }
      }
    });
    const m4 = new Array();
    a6.forEach((e5) => {
      const s3 = this._polygons.get(e5);
      null != s3 && (m4.push(s3), this._polygons.delete(e5));
      const o4 = this._labels.get(e5);
      null != o4 && (m4.push(o4), this._labels.delete(e5));
    }), this.view.graphics.removeMany(m4), this.view.graphics.addMany(i4);
  }
  clear() {
    this.view.graphics.removeMany(Array.from(this._polygons.values())), this.view.graphics.removeMany(Array.from(this._labels.values())), this._polygons.clear(), this._labels.clear();
  }
};
r([m({ constructOnly: true })], d5.prototype, "view", void 0), r([m({ readOnly: true })], d5.prototype, "updating", void 0), r([m()], d5.prototype, "enabled", null), d5 = r([a("esri.views.support.TileTreeDebugger")], d5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var n3 = class extends d5 {
  constructor(e4) {
    super(e4);
  }
  initialize() {
    const e4 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.addHandles(e2(() => clearInterval(e4)));
  }
  getTiles() {
    if (!this._debugInfo) return [];
    const e4 = /* @__PURE__ */ new Map(), t3 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t4) => {
      e4.set(t4.data.id, t4.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r4) => {
      e4.set(r4.data.id, r4.featureCount), t3.set(r4.data.id, r4.state);
    });
    const r3 = (r4) => {
      const o5 = t3.get(r4), s3 = e4.get(r4) ?? "?";
      return o5 ? `${o5}:${s3}
${r4}` : `store:${s3}
${r4}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e5) => {
      o4.set(e5.data.id, e5.data);
    }), this._debugInfo.pendingTiles.forEach((e5) => {
      o4.set(e5.data.id, e5.data);
    }), Array.from(o4.values()).map((e5) => ({ lij: [e5.level, e5.row, e5.col], level: e5.level, geometry: j2.fromExtent(c(e5.extent, this.view.spatialReference)), label: r3(e5.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e4) => {
      this._debugInfo = e4, this.update();
    });
  }
};
r([m({ constructOnly: true })], n3.prototype, "handle", void 0), n3 = r([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], n3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var u3 = class extends g {
  get updating() {
    return this._updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e4) {
    super(e4), this._updatingHandles = new h2(), this._suspendController = null, this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e5) => {
      const t3 = [];
      for (const { points: o4 } of e5.pointsInFeatures) for (const { z: e6 } of o4) t3.push(e6);
      return { elevations: t3, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this.updateOutFields = k(async (e5, t3) => {
      await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields", [...e5], t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
    });
  }
  destroy() {
    this._suspendController = e(this._suspendController), this._workerHandle.destroy(), this._updatingHandles.destroy();
  }
  initialize() {
    this._workerHandle = new y3(this.schedule, { alignElevation: async (e4, { signal: t3 }) => ({ result: await this.elevationAlignPointsInFeatures(e4.query, t3) }), getSymbologyCandidates: async (e4, { signal: t3 }) => ({ result: await this.queryForSymbologySnapping(e4, t3) }) }), this.addHandles([this._workerHandle.on("notify-updating", ({ updating: e4 }) => this._workerHandleUpdating = e4), this._workerHandle.on("notify-availability", ({ availability: e4 }) => this._set("availability", e4))]);
  }
  async setup(e4, t3) {
    var _a;
    const o4 = c5(e4.layer);
    if (null == o4) return;
    const i4 = { configuration: h4(e4.configuration), serviceInfo: o4, spatialReference: e4.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: (_a = e4.layer.elevationInfo) == null ? void 0 : _a.toJSON() };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", i4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async configure(e4, t3) {
    const o4 = h4(e4);
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", o4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async refresh(e4) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e4));
  }
  async fetchCandidates(e4, t3) {
    const { point: o4, filter: i4, coordinateHelper: n4 } = e4, a6 = { ...e4, point: e3(o4[0], o4[1], o4[2], n4.spatialReference.toJSON()), filter: i4 == null ? void 0 : i4.toJSON() };
    return this._workerHandle.invoke(a6, t3);
  }
  async updateTiles(e4, t3) {
    const o4 = { tiles: e4.tiles, tileInfo: null != e4.tileInfo ? e4.tileInfo.toJSON() : null, tileSize: e4.tileSize };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", o4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async handleEdits({ historicMoment: e4, addedFeatures: t3, deletedFeatures: i4, updatedFeatures: n4 }, a6) {
    const s3 = { historicMoment: e4, addedFeatures: (t3 == null ? void 0 : t3.map(({ objectId: e5 }) => e5).filter(G)) ?? [], deletedFeatures: (i4 == null ? void 0 : i4.map(({ objectId: e5, globalId: t4 }) => ({ objectId: e5, globalId: t4 }))) ?? [], updatedFeatures: (n4 == null ? void 0 : n4.map(({ objectId: e5 }) => e5).filter(G)) ?? [] };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("handleEdits", s3, a6)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, a6));
  }
  async setHistoricMoment(e4, t3) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setHistoricMoment", { moment: e4 }, t3));
  }
  getDebugInfo(e4) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e4);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e4) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e4);
  }
  async setSuspended(e4) {
    var _a;
    (_a = this._suspendController) == null ? void 0 : _a.abort(), this._suspendController = new AbortController(), await this._workerHandle.invokeMethod("setSuspended", e4, this._suspendController.signal);
  }
};
function h4(e4) {
  return { filter: null != e4.filter ? e4.filter.toJSON() : null, customParameters: e4.customParameters, viewType: e4.viewType };
}
function c5(e4) {
  var _a, _b;
  return "multipatch" === e4.geometryType || "mesh" === e4.geometryType ? null : { url: ((_a = e4.parsedUrl) == null ? void 0 : _a.path) ?? "", fieldsIndex: e4.fieldsIndex.toJSON(), geometryType: y.toJSON(e4.geometryType), capabilities: e4.capabilities, objectIdField: e4.objectIdField, globalIdField: e4.globalIdField, spatialReference: e4.spatialReference.toJSON(), timeInfo: (_b = e4.timeInfo) == null ? void 0 : _b.toJSON() };
}
r([m({ constructOnly: true })], u3.prototype, "schedule", void 0), r([m({ constructOnly: true })], u3.prototype, "hasZ", void 0), r([m({ constructOnly: true })], u3.prototype, "elevationAlignPointsInFeatures", void 0), r([m({ constructOnly: true })], u3.prototype, "queryForSymbologySnapping", void 0), r([m({ readOnly: true })], u3.prototype, "updating", null), r([m({ readOnly: true })], u3.prototype, "availability", void 0), r([m()], u3.prototype, "_workerHandleUpdating", void 0), u3 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], u3);
var y3 = class extends h3 {
  constructor(e4, t3) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e4, { strategy: "dedicated", client: t3 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a5 = class extends g {
  get tiles() {
    return [new t("0/0/0", 0, 0, 0, a2(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new z({ origin: new j({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new p({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e4) {
    super(e4), this.pointOfInterest = null;
  }
};
r([m({ readOnly: true })], a5.prototype, "tiles", null), r([m({ readOnly: true })], a5.prototype, "tileInfo", null), r([m({ readOnly: true })], a5.prototype, "tileSize", null), r([m({ constructOnly: true })], a5.prototype, "layer", void 0), r([m()], a5.prototype, "pointOfInterest", void 0), a5 = r([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var O = class extends g {
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get _layerView() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a.allLayerViews.find((e4) => e4.layer === this._layer);
  }
  get _isSuspended() {
    var _a;
    if (c2(this._layer)) {
      if (!this.layerSource.sublayerSources.some((e4) => e4.enabled && e4.layer.visible)) return true;
    }
    return !!this.view && (false !== ((_a = this._layerView) == null ? void 0 : _a.suspended) || !this.layerSource.enabled);
  }
  get updating() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.updating) || this._updatingHandles.updating;
  }
  get _outFields() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { view: e4, _layerView: t3, layerSource: r3 } = this, { layer: i4 } = r3, { fieldsIndex: s3, timeInfo: o4, floorInfo: a6, subtypeField: n4 } = i4, l = t3 && "filter" in t3 ? t3.filter : null, d6 = (l == null ? void 0 : l.where) && "1=1" !== l.where ? this._getOrLoadWhereFields(l.where, s3) : [];
    if ((l == null ? void 0 : l.timeExtent) && o4) {
      const { startField: e5, endField: t4 } = o4, r4 = ((_a = s3.get(e5)) == null ? void 0 : _a.name) ?? e5, i5 = ((_b = s3.get(t4)) == null ? void 0 : _b.name) ?? t4;
      r4 && d6.push(r4), i5 && d6.push(i5);
    }
    if ((e4 == null ? void 0 : e4.map) && b2(e4.map) && ((_c = e4.map.utilityNetworks) == null ? void 0 : _c.find((e5) => e5.isUtilityLayer(i4)))) {
      const e5 = (_d = i4.fieldsIndex.get("assetGroup")) == null ? void 0 : _d.name, t4 = (_e = i4.fieldsIndex.get("assetType")) == null ? void 0 : _e.name;
      e5 && t4 && (d6.push(e5), d6.push(t4));
    }
    if (i4 && (a6 == null ? void 0 : a6.floorField) && ((_f = e4 == null ? void 0 : e4.floors) == null ? void 0 : _f.length)) {
      const e5 = ((_g = s3.get(a6.floorField)) == null ? void 0 : _g.name) ?? a6.floorField;
      e5 && d6.push(e5);
    }
    if (n4) {
      const e5 = ((_h = s3.get(n4)) == null ? void 0 : _h.name) ?? n4;
      e5 && d6.push(e5);
    }
    return new Set(d6);
  }
  get configuration() {
    var _a;
    const { view: e4 } = this, { apiKey: t3, customParameters: r3 } = this._layer, i4 = null != e4 ? e4.type : "2d", s3 = this._layer.createQuery();
    return this._layerView && "effectiveDisplayFilter" in this._layerView && (s3.where = r2(s3.where, (_a = this._layerView.effectiveDisplayFilter) == null ? void 0 : _a.where)), { filter: s3, customParameters: t3 ? { ...r3, token: t3 } : r3, viewType: i4 };
  }
  get availability() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.availability) ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e4) {
    super(e4), this._updatingHandles = new h2(), this._workerHandle = null, this._debug = null, this._memoizedMakeGetGroundElevation = t2(i3);
  }
  initialize() {
    let e4;
    const t3 = this.view;
    if (null == t3 || t3.destroyed) this._tilesOfInterest = new a5({ layer: this._layer }), e4 = this._workerHandle = new u3();
    else switch (t3.type) {
      case "2d":
        this._tilesOfInterest = new p3({ view: t3, layer: this._layer }), e4 = this._workerHandle = new u3();
        break;
      case "3d": {
        const { resourceController: r3 } = t3, i4 = this._layer;
        this._tilesOfInterest = new a4({ view: t3 }), e4 = this._workerHandle = new u3({ schedule: (e5) => r3.immediate.schedule(e5), hasZ: this._layer.hasZ && (this._layer.returnZ ?? true), elevationAlignPointsInFeatures: async (e5, r4) => {
          const s3 = await t3.whenLayerView(i4);
          return s2(r4), s3.elevationAlignPointsInFeatures(e5, r4);
        }, queryForSymbologySnapping: async (e5, r4) => {
          const s3 = await t3.whenLayerView(i4);
          return s2(r4), s3.queryForSymbologySnapping(e5, r4);
        } }), this.addHandles([t3.elevationProvider.on("elevation-change", ({ context: t4 }) => {
          const { elevationInfo: r4 } = i4;
          y2(t4, r4) && d(e4.notifyElevationSourceChange());
        }), d3(() => i4.elevationInfo, () => d(e4.notifyElevationSourceChange()), P), d3(() => {
          var _a, _b;
          return (_b = (_a = this._layerView) == null ? void 0 : _a.layer) == null ? void 0 : _b.renderer;
        }, () => d(e4.notifySymbologyChange()), P), d3(() => {
          var _a;
          return ((_a = this._layerView) == null ? void 0 : _a.symbologySnappingSupported) ?? false;
        }, (t4) => d(e4.setSymbologySnappingSupported(t4)), P), v(() => {
          var _a;
          return (_a = this._layerView) == null ? void 0 : _a.layer;
        }, ["edits", "apply-edits", "graphic-update"], () => e4.notifySymbologyChange())]);
        break;
      }
    }
    this.addHandles([i(e4)]), d(e4.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null)), this._updatingHandles.add(() => this._updateTilesParameters, () => d(e4.updateTiles(this._updateTilesParameters, null)), P), this.addHandles([d3(() => this.configuration, (t4) => d(e4.configure(t4, null)), C), d3(() => this._layer.historicMoment, (t4) => d(e4.setHistoricMoment(t4)), A), d3(() => this._outFields, (t4) => d(e4.updateOutFields(t4)), P), d3(() => this._isSuspended, (t4) => d(e4.setSuspended(t4)), A)]), null != t3 && this.addHandles(d3(() => E.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r3) => {
      r3 && !this._debug ? (this._debug = new n3({ view: t3, handle: e4 }), this.addHandles(i(this._debug), "debug")) : !r3 && this._debug && this.removeHandles("debug");
    }, P)), this.addHandles([this.layerSource.layer.on("edits", (t4) => d(e4.handleEdits(t4, null))), this.layerSource.layer.on("apply-edits", (e5) => this._updatingHandles.addPromise(e5.result))]);
  }
  destroy() {
    this._updatingHandles.destroy(), this._tilesOfInterest.destroy();
  }
  refresh() {
    var _a;
    (_a = this._workerHandle) == null ? void 0 : _a.refresh(null);
  }
  async fetchCandidates(e4, t3) {
    const { coordinateHelper: r3, point: i4 } = e4;
    this._tilesOfInterest.pointOfInterest = r3.arrayToPoint(i4);
    const s3 = this._memoizedMakeGetGroundElevation(this.view, r3.spatialReference);
    return (await this._workerHandle.fetchCandidates({ ...e4 }, t3)).candidates.map((e5) => o3(e5, s3));
  }
  getDebugInfo(e4) {
    return this._workerHandle.getDebugInfo(e4);
  }
  _getOrLoadWhereFields(e4, t3) {
    const { _whereModule: i4 } = this;
    if (!this._loadWhereModuleTask && !i4) {
      const e5 = d2(async () => {
        const e6 = await import("./WhereClause-OEEOLETF.js");
        return this._whereModule = e6.default, this._whereModule;
      });
      return this._loadWhereModuleTask = e5, this._updatingHandles.addPromise(e5.promise), [];
    }
    if (!i4) return [];
    try {
      return i4.create(e4, { fieldsIndex: t3 }).fieldNames;
    } catch (s3) {
      return [];
    }
  }
};
r([m({ constructOnly: true })], O.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], O.prototype, "layerSource", void 0), r([m({ constructOnly: true })], O.prototype, "view", void 0), r([m()], O.prototype, "_tilesOfInterest", void 0), r([m({ readOnly: true })], O.prototype, "_updateTilesParameters", null), r([m()], O.prototype, "_layerView", null), r([m()], O.prototype, "_isSuspended", null), r([m({ readOnly: true })], O.prototype, "updating", null), r([m()], O.prototype, "_outFields", null), r([m({ readOnly: true })], O.prototype, "configuration", null), r([m({ readOnly: true })], O.prototype, "availability", null), r([m()], O.prototype, "_loadWhereModuleTask", void 0), r([m()], O.prototype, "_whereModule", void 0), O = r([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], O);
export {
  O as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-E4QCYQT6.js.map
