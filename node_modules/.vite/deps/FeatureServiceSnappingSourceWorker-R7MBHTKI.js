import {
  i as i3,
  n as n2,
  r as r2
} from "./chunk-WID5EUWY.js";
import {
  E
} from "./chunk-EKEKHPBG.js";
import {
  S,
  c as c2,
  f as f4,
  x
} from "./chunk-36CN7JP2.js";
import "./chunk-WX3BOMD3.js";
import {
  a as a3
} from "./chunk-TSFKACKN.js";
import "./chunk-W5QWJI4E.js";
import {
  u as u3
} from "./chunk-3RTT2FUJ.js";
import {
  f as f3
} from "./chunk-VC3KNIUZ.js";
import {
  o as o3
} from "./chunk-L4EC6LZW.js";
import "./chunk-N6TERPCK.js";
import {
  L as L2
} from "./chunk-SEOVQLIZ.js";
import "./chunk-EUB5OBXG.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-2UD6J77T.js";
import "./chunk-YYDDGFL6.js";
import "./chunk-SNZZPKBU.js";
import {
  at,
  ft,
  pt
} from "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-3WB47P7Q.js";
import "./chunk-6ZI2HC5K.js";
import "./chunk-WESTCUBG.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-BG4U4RTY.js";
import "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import "./chunk-2ZAGB4JV.js";
import "./chunk-B2CK3GCY.js";
import "./chunk-NINPG5JV.js";
import {
  h as h2
} from "./chunk-VPRLLNNO.js";
import "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import {
  z
} from "./chunk-Q44EAKHA.js";
import {
  t
} from "./chunk-4HTLBMKF.js";
import "./chunk-SB6LU3VH.js";
import "./chunk-5T3XQRJL.js";
import "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  b as b2
} from "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import {
  e as e2
} from "./chunk-BBPRJCMB.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-QW7P5D76.js";
import {
  h
} from "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BMNRD4FO.js";
import {
  f as f2
} from "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-D3P3E2RE.js";
import {
  C,
  d as d2,
  p,
  w
} from "./chunk-UKY33OJN.js";
import {
  b,
  d
} from "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import {
  i as i2
} from "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import {
  R,
  c,
  l,
  o as o2,
  u as u2
} from "./chunk-OXPM753Y.js";
import {
  w as w2
} from "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import {
  g as g3
} from "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  g2
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  e2 as e,
  f,
  g,
  i,
  m,
  o3 as o,
  u3 as u
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  L,
  a,
  s as s2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import {
  s
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r3 = class {
  constructor(t3, e3) {
    this.data = t3, this.resolution = e3, this.state = { type: i4.CREATED }, this.alive = true;
  }
  process(t3) {
    switch (this.state.type) {
      case i4.CREATED:
        return this.state = this._gotoFetchCount(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case i4.FETCH_COUNT:
        break;
      case i4.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case i4.FETCH_FEATURES:
        break;
      case i4.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t3);
      case i4.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case i4.CREATED:
      case i4.FETCH_COUNT:
        return 0;
      case i4.FETCHED_COUNT:
        return this.state.featureCount;
      case i4.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case i4.FETCHED_FEATURES:
        return this.state.features.length;
      case i4.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case i4.CREATED:
        return "created";
      case i4.FETCH_COUNT:
        return "fetch-count";
      case i4.FETCHED_COUNT:
        return "fetched-count";
      case i4.FETCH_FEATURES:
        return "fetch-features";
      case i4.FETCHED_FEATURES:
        return "fetched-features";
      case i4.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s3, a4) {
    return { type: i4.FETCH_COUNT, previous: s3, task: d(async (t3) => {
      const s4 = await b(a4.fetchCount(this, t3));
      this.state.type === i4.FETCH_COUNT && (this.state = u4(this.state, s4.ok ? s4.value : 1 / 0));
    }) };
  }
  _gotoFetchFeatures(s3, a4) {
    return { type: i4.FETCH_FEATURES, previous: s3, task: d(async (t3) => {
      const E3 = await b(a4.fetchFeatures(this, s3.featureCount, t3));
      this.state.type === i4.FETCH_FEATURES && (this.state = T(this.state, E3.ok ? E3.value : []));
    }) };
  }
  _goToDone(t3, e3) {
    return e3.finish(this, t3.features), { type: i4.DONE, previous: t3 };
  }
  reset() {
    const t3 = this.state;
    switch (this.state = { type: i4.CREATED }, t3.type) {
      case i4.CREATED:
      case i4.FETCHED_COUNT:
      case i4.FETCHED_FEATURES:
      case i4.DONE:
        break;
      case i4.FETCH_COUNT:
      case i4.FETCH_FEATURES:
        t3.task.abort();
    }
  }
  intersects(t3) {
    return null == t3 || !this.data.extent || (o2(t3, n3), R(this.data.extent, n3));
  }
};
function u4(t3, e3) {
  return { type: i4.FETCHED_COUNT, featureCount: e3, previous: t3 };
}
function T(t3, e3) {
  return { type: i4.FETCHED_FEATURES, previous: t3, features: e3 };
}
var i4;
!function(t3) {
  t3[t3.CREATED = 0] = "CREATED", t3[t3.FETCH_COUNT = 1] = "FETCH_COUNT", t3[t3.FETCHED_COUNT = 2] = "FETCHED_COUNT", t3[t3.FETCH_FEATURES = 3] = "FETCH_FEATURES", t3[t3.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t3[t3.DONE = 5] = "DONE";
}(i4 || (i4 = {}));
var n3 = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var j = class extends g {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e3 = /* @__PURE__ */ new Set();
    return this.objectIdField && e3.add(this.objectIdField), this.globalIdField && e3.add(this.globalIdField), e3;
  }
  set outFields(e3) {
    const t3 = this._get("outFields"), i5 = u(e3, this._mandatoryOutFields);
    f(i5, t3) || (this._set("outFields", i5), e(i5, t3) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e3) {
    const t3 = this._get("filter"), i5 = this._filterProperties(e3);
    JSON.stringify(t3) !== JSON.stringify(i5) && this._set("filter", i5);
  }
  set customParameters(e3) {
    const t3 = this._get("customParameters");
    JSON.stringify(t3) !== JSON.stringify(e3) && this._set("customParameters", e3);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e3) {
    const t3 = this._get("tileInfo");
    t3 !== e3 && (null != e3 && null != t3 && JSON.stringify(e3) === JSON.stringify(t3) || (this._set("tileInfo", e3), this.store.tileInfo = e3));
  }
  set tileSize(e3) {
    this._get("tileSize") !== e3 && this._set("tileSize", e3);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e3) {
    super(e3), this.suspended = true, this._historicMoment = null, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h2();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, () => {
      this._updatePriorities(), this._process();
    }, { sync: true, initial: true, equals: (e3, t3) => s(e3, t3, ({ id: e4 }, { id: t4 }) => e4 === t4) }), this.addHandles(p(() => !this.suspended, () => this._process()));
  }
  _updatePriorities() {
    this.store.setPriorityOrderByKey(this.tilesOfInterest.map((e3) => e3.id ?? "") ?? []);
  }
  destroy() {
    this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._process();
  }
  async handleEdits(e3) {
    if (e3.historicMoment && (this._historicMoment = e3.historicMoment), !e3.addedFeatures.length && !e3.updatedFeatures.length && !e3.deletedFeatures.length) return;
    for (const s3 of this._pendingTiles.values()) s3.reset();
    const t3 = { ...e3, deletedFeatures: e3.deletedFeatures.map(({ objectId: e4, globalId: t4 }) => e4 && -1 !== e4 ? e4 : this._lookupObjectIdByGlobalId(t4)) }, i5 = d(async (e4) => {
      try {
        await this.store.processEdits(t3, (e5, t4) => this._queryFeaturesById(e5, t4), e4), this._processPendingTiles();
      } catch (i6) {
        a(i6), n.getLogger(this).warn("Failed to apply edits", i6);
      }
    });
    this.addHandles(i5), await this._updatingHandles.addPromise(i5.promise);
  }
  setHistoricMoment(e3) {
    var _a;
    (e3 == null ? void 0 : e3.getTime()) !== ((_a = this._historicMoment) == null ? void 0 : _a.getTime()) && (this._historicMoment = e3, this.refresh());
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g2(this.url)) return;
    const e3 = d(async (e4) => {
      var _a;
      try {
        const t3 = await x(this.url, new b2({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e4 });
        this.store.extent = w2.fromJSON((_a = t3.data) == null ? void 0 : _a.extent);
      } catch (t3) {
        a(t3), n.getLogger(this).warn("Failed to fetch data extent", t3);
      }
    });
    this._updatingHandles.addPromise(e3.promise.then(() => this._process())), this.addHandles(e3);
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e3) => e3.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const e3 of this._pendingTiles.values()) e3.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended) return;
    const e3 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea), null != e3) for (const { data: t3, resolution: i5 } of e3.missingTiles) {
      const e4 = this._pendingTiles.get(t3.id);
      e4 ? (e4.resolution = i5, e4.alive = true) : this._createPendingTile(t3, i5);
    }
  }
  _collectMissingTilesInfo() {
    let e3 = null;
    for (const t3 of this.tilesOfInterest) {
      const i5 = this.store.process(t3, (e4, t4) => this._verifyTileComplexity(e4, t4), this.outFields);
      null == e3 ? e3 = i5 : e3.prepend(i5);
    }
    return e3;
  }
  _deletePendingTiles() {
    for (const e3 of this._pendingTiles.values()) e3.alive || this._deletePendingTile(e3);
  }
  _processPendingTiles() {
    const e3 = { fetchCount: (e4, t3) => this._fetchCount(e4, t3), fetchFeatures: (e4, t3, i5) => this._fetchFeatures(e4, t3, i5), finish: (e4, t3) => this._finishPendingTile(e4, t3), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e3)) for (const t3 of this._pendingTiles.values()) this._verifyTileComplexity(this.store.getFeatureCount(t3.data), t3.resolution) && this._updatingHandles.addPromise(t3.process(e3));
  }
  _verifyTileComplexity(e3, t3) {
    return this._verifyVertexComplexity(e3) && this._verifyFeatureDensity(e3, t3);
  }
  _verifyVertexComplexity(e3) {
    return e3 * this._minimumVerticesPerFeature < w3;
  }
  _verifyFeatureDensity(e3, t3) {
    if (null == this.tileInfo) return false;
    const i5 = this.tileSize * t3;
    return e3 * (q / (i5 * i5)) < M;
  }
  _ensureFetchAllCounts(e3) {
    let t3 = true;
    for (const i5 of this._pendingTiles.values()) i5.state.type < i4.FETCHED_COUNT && this._updatingHandles.addPromise(i5.process(e3)), i5.state.type <= i4.FETCH_COUNT && (t3 = false);
    return t3;
  }
  _finishPendingTile(e3, t3) {
    this.store.add(e3.data, t3), this._deletePendingTile(e3), this._updateAvailability();
  }
  _updateAvailability() {
    const e3 = this._collectMissingTilesInfo();
    this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea);
  }
  _setAvailability(e3) {
    this._set("availability", e3);
  }
  _createPendingTile(e3, t3) {
    const i5 = new r3(e3, t3);
    return this._pendingTiles.set(e3.id, i5), i5;
  }
  _deletePendingTile(e3) {
    e3.reset(), this._pendingTiles.delete(e3.data.id);
  }
  async _fetchCount(e3, t3) {
    return this.store.fetchCount(e3.data, this.url, this._createCountQuery(e3), { query: this.customParameters, timeout: x2, signal: t3 });
  }
  async _fetchFeatures(e3, t3, i5) {
    let s3 = 0;
    const r4 = [];
    let o4 = 0, n4 = t3;
    for (; ; ) {
      const a4 = this._createFeaturesQuery(e3), l2 = this._setPagingParameters(a4, s3, n4), { features: u5, exceededTransferLimit: d3 } = await this._queryFeatures(a4, i5);
      l2 && (s3 += a4.num), o4 += u5.length;
      for (const e4 of u5) r4.push(e4);
      if (n4 = t3 - o4, !l2 || !d3 || n4 <= 0) return r4;
    }
  }
  _filterProperties(e3) {
    return null == e3 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e3.where || "1=1", timeExtent: e3.timeExtent, gdbVersion: e3.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e3) {
    const t3 = this.globalIdField, i5 = this.objectIdField;
    if (null == t3) throw new Error("Expected globalIdField to be defined");
    let s3 = null;
    const r4 = e3 ? e2(e3) : e3;
    if (this.store.featureStore.forEach((e4) => {
      r4 === e2(e4.attributes[t3]) && (s3 = e4.objectId ?? e4.attributes[i5]);
    }), null == s3) throw new Error(`Expected to find a feature with globalId ${e3}`);
    return s3;
  }
  _queryFeaturesById(e3, t3) {
    const i5 = this._createFeaturesQuery();
    return i5.objectIds = e3, this._queryFeatures(i5, t3);
  }
  _queryFeatures(e3, t3) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e3, t3) : this._queryFeaturesJSON(e3, t3);
  }
  async _queryFeaturesPBF(e3, t3) {
    const { sourceSpatialReference: i5 } = this, { data: s3 } = await f4(this.url, e3, new a3({ sourceSpatialReference: i5 }), { query: this._configuration.customParameters, timeout: x2, signal: t3 });
    return at(s3);
  }
  async _queryFeaturesJSON(e3, t3) {
    const { sourceSpatialReference: i5 } = this, { data: s3 } = await c2(this.url, e3, i5, { query: this._configuration.customParameters, timeout: x2, signal: t3 });
    return ft(s3, this.objectIdField);
  }
  _createCountQuery(e3) {
    const t3 = this._createBaseQuery(e3);
    return this.capabilities.query.supportsCacheHint && (t3.cacheHint = true), t3;
  }
  _createFeaturesQuery(e3 = null) {
    var _a;
    const t3 = this._createBaseQuery(e3), i5 = null != (e3 == null ? void 0 : e3.data) ? this.store.getAttributesForTile((_a = e3 == null ? void 0 : e3.data) == null ? void 0 : _a.id) : null, s3 = u(i(this.outFields, i5 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t3.outFields = Array.from(s3), t3.returnGeometry = true, null != e3 && (this.capabilities.query.supportsResultType ? t3.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t3.cacheHint = true)), t3;
  }
  _createBaseQuery(e3) {
    const t3 = new b2({ returnZ: this.hasZ, returnM: false, historicMoment: this._historicMoment, geometry: null != this.tileInfo && null != e3 ? c(e3.data.extent, this.tileInfo.spatialReference) : void 0 }), i5 = this._configuration.filter;
    return null != i5 && (t3.where = i5.where, t3.gdbVersion = i5.gdbVersion, t3.timeExtent = i5.timeExtent), t3.outSpatialReference = this.spatialReference, t3;
  }
  _setPagingParameters(e3, t3, i5) {
    if (!this.capabilities.query.supportsPagination) return false;
    const { supportsMaxRecordCountFactor: s3, supportsCacheHint: r4, tileMaxRecordCount: o4, maxRecordCount: n4, supportsResultType: a4 } = this.capabilities.query, l2 = s3 ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u5 = l2 * ((a4 || r4) && o4 ? o4 : n4 || C2);
    return e3.start = t3, s3 ? (e3.maxRecordCountFactor = Math.min(l2, Math.ceil(i5 / u5)), e3.num = Math.min(i5, e3.maxRecordCountFactor * u5)) : e3.num = Math.min(i5, u5), true;
  }
};
r([m({ constructOnly: true })], j.prototype, "url", void 0), r([m({ constructOnly: true })], j.prototype, "objectIdField", void 0), r([m({ constructOnly: true })], j.prototype, "globalIdField", void 0), r([m({ constructOnly: true })], j.prototype, "capabilities", void 0), r([m({ constructOnly: true })], j.prototype, "sourceSpatialReference", void 0), r([m({ constructOnly: true })], j.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], j.prototype, "store", void 0), r([m({ readOnly: true })], j.prototype, "_minimumVerticesPerFeature", null), r([m()], j.prototype, "_mandatoryOutFields", null), r([m()], j.prototype, "outFields", null), r([m()], j.prototype, "suspended", void 0), r([m()], j.prototype, "_historicMoment", void 0), r([m()], j.prototype, "filter", null), r([m()], j.prototype, "customParameters", null), r([m({ readOnly: true })], j.prototype, "_configuration", null), r([m()], j.prototype, "tileInfo", null), r([m()], j.prototype, "tileSize", null), r([m()], j.prototype, "tilesOfInterest", void 0), r([m({ readOnly: true })], j.prototype, "updating", null), r([m({ readOnly: true })], j.prototype, "availability", void 0), r([m()], j.prototype, "hasZ", null), j = r([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], j);
var C2 = 2e3;
var x2 = 6e5;
var w3 = 1e6;
var q = 25;
var M = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t2 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._priorities = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._store.size;
  }
  setPriorityOrderByKey(t3) {
    this._priorities.clear();
    for (let r4 = t3.length - 1; r4 >= 0; r4--) this._priorities.set(t3[r4], t3.length - r4);
  }
  hasLowerPriority(t3) {
    const r4 = this._priorities.get(t3);
    if (null == r4) return true;
    for (const [e3] of this._store) {
      const t4 = this._priorities.get(e3);
      if (null == t4 || t4 < r4) return true;
    }
    return false;
  }
  someFromLowestToHighestPriority(t3) {
    const { _priorities: r4 } = this;
    for (const [e3, s3] of this._store) if (!r4.has(e3) && t3(s3, e3)) return true;
    for (const [e3] of r4) {
      const r5 = this._store.get(e3);
      if (r5 && t3(r5, e3)) return true;
    }
    return false;
  }
  set(t3, r4) {
    this._store.set(t3, r4);
  }
  delete(t3) {
    return this._store.delete(t3);
  }
  get(t3) {
    return this._store.get(t3);
  }
  has(t3) {
    return this._store.has(t3);
  }
  clear() {
    this._store.clear();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var g4 = class extends g {
  setPriorityOrderByKey(e3) {
    this._tiles.setPriorityOrderByKey(e3);
  }
  get _memoryLimitExceeded() {
    return this.featureStore.usedMemory >= this.maximumByteSize;
  }
  constructor(e3) {
    super(e3), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E.MEGABYTES, this._tileBounds = new o3(), this._tiles = new t2(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e3, t3) {
    var _a;
    for (const i5 of t3) this._referenceFeature(i5.objectId);
    const s3 = this.featureStore.upsertMany(t3), r4 = s3.map((e4) => new Set(Object.keys(e4.attributes))).reduce((e4, t4) => o(e4, t4), new Set(Object.keys(((_a = s3[0]) == null ? void 0 : _a.attributes) ?? []))), o4 = this._memoryLimitExceeded;
    this._addTileStorage(e3, new Set(s3.map((e4) => e4.objectId)), r4), o4 && this._applyCacheMemoryLimits();
  }
  _applyCacheMemoryLimits() {
    if (!this._memoryLimitExceeded) return;
    const { _tiles: e3, featureStore: t3, maximumByteSize: s3 } = this;
    e3.someFromLowestToHighestPriority((e4) => !this._memoryLimitExceeded || t3.usedMemory - this._estimateRemoveTileMemoryReduction(e4) < s3 || (this._removeTileStorage(e4), false));
  }
  _estimateRemoveTileMemoryReduction(e3) {
    var _a, _b;
    let t3 = 0;
    for (const s3 of e3.objectIds) {
      if (1 === this._refCounts.get(s3)) {
        const e4 = this.featureStore.getFeature(s3);
        e4 && (t3 += ((_b = (_a = this.featureStore).estimateFeatureUsedMemory) == null ? void 0 : _b.call(_a, e4)) ?? 0);
      }
    }
    return t3;
  }
  getAttributesForTile(e3) {
    var _a;
    return e3 ? (_a = this._tiles.get(e3)) == null ? void 0 : _a.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e3, t3, s3) {
    return this._processEditsDelete(e3.deletedFeatures.concat(e3.updatedFeatures)), this._processEditsRefetch(e3.addedFeatures.concat(e3.updatedFeatures), t3, s3);
  }
  _addTileStorage(e3, t3, s3) {
    const i5 = e3.id;
    this._tiles.set(i5, new v(e3, t3, s3)), this._tileBounds.set(i5, e3.extent), this._tileFeatureCounts.set(i5, t3.size);
  }
  _remove({ id: e3 }) {
    const t3 = this._tiles.get(e3);
    t3 && this._removeTileStorage(t3);
  }
  _removeTileStorage(e3) {
    const t3 = [];
    for (const i5 of e3.objectIds) this._unreferenceFeature(i5) === w4.REMOVED && t3.push(i5);
    this.featureStore.removeManyById(t3);
    const s3 = e3.data.id;
    this._tiles.delete(s3), this._tileBounds.delete(s3);
  }
  _processEditsDelete(e3) {
    this.featureStore.removeManyById(e3);
    for (const t3 of this._tiles.values()) {
      for (const s3 of e3) t3.objectIds.delete(s3);
      this._tileFeatureCounts.set(t3.data.id, t3.objectIds.size);
    }
    for (const t3 of e3) this._refCounts.delete(t3);
  }
  async _processEditsRefetch(e3, t3, s3) {
    if (!e3.length) return;
    const i5 = (await t3(e3, s3)).features, { hasZ: r4, hasM: o4 } = this.featureStore;
    for (const n4 of i5) {
      const e4 = pt(this._tmpBoundingRect, n4.geometry, r4, o4);
      null != e4 && this._tileBounds.forEachInBounds(e4, (e5) => {
        const t4 = this._tiles.get(e5);
        this.featureStore.add(n4);
        const s4 = n4.objectId;
        t4.objectIds.has(s4) || (t4.objectIds.add(s4), this._referenceFeature(s4), this._tileFeatureCounts.set(t4.data.id, t4.objectIds.size));
      });
    }
  }
  process(e3, t3 = () => true, s3) {
    if (null == this.tileInfo || !e3.extent || null != this.extent && !R(o2(this.extent, this._tmpBoundingRect), e3.extent)) return new S2(e3);
    if (this._memoryLimitExceeded && !this._tiles.hasLowerPriority(e3.id ?? "")) return new S2(e3);
    const i5 = this.getAttributesForTile(e3.id);
    if (e(s3, i5)) return new S2(e3);
    const o4 = this._createTileTree(e3, this.tileInfo);
    return this._simplify(o4, t3, null, 0, 1), this._collectMissingTiles(e3, o4, this.tileInfo, s3);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e3 }) => ({ data: e3, featureCount: this._tileFeatureCounts.get(e3.id) || 0 }));
  }
  getFeatureCount(e3) {
    return this._tileFeatureCounts.get(e3.id) ?? 0;
  }
  async fetchCount(e3, t3, s3, i5) {
    const r4 = this._tileFeatureCounts.get(e3.id);
    if (null != r4) return r4;
    const o4 = await S(t3, s3, i5);
    return this._tileFeatureCounts.set(e3.id, o4.data.count), o4.data.count;
  }
  _createTileTree(e3, t3) {
    const s3 = new C3(e3.level, e3.row, e3.col);
    return t3.updateTileInfo(s3, z.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e3.extent, (i5) => {
      var _a;
      const r4 = (_a = this._tiles.get(i5)) == null ? void 0 : _a.data;
      r4 && y(e3, r4) && this._populateChildren(s3, r4, t3, this._tileFeatureCounts.get(r4.id) || 0);
    }), s3;
  }
  _populateChildren(e3, t3, s3, i5) {
    const r4 = t3.level - e3.level - 1;
    if (r4 < 0) return void (e3.isLeaf = true);
    const o4 = t3.row >> r4, n4 = t3.col >> r4, l2 = e3.row << 1, u5 = n4 - (e3.col << 1) + (o4 - l2 << 1), c3 = e3.children[u5];
    if (null != c3) this._populateChildren(c3, t3, s3, i5);
    else {
      const r5 = new C3(e3.level + 1, o4, n4);
      s3.updateTileInfo(r5, z.ExtrapolateOptions.POWER_OF_TWO), e3.children[u5] = r5, this._populateChildren(r5, t3, s3, i5);
    }
  }
  _simplify(e3, t3, s3, i5, r4) {
    const o4 = r4 * r4;
    if (e3.isLeaf) return t3(this.getFeatureCount(e3), r4) ? 0 : (this._remove(e3), null != s3 && (s3.children[i5] = null), o4);
    const n4 = r4 / 2, l2 = n4 * n4;
    let u5 = 0;
    for (let c3 = 0; c3 < e3.children.length; c3++) {
      const s4 = e3.children[c3];
      u5 += null != s4 ? this._simplify(s4, t3, e3, c3, n4) : l2;
    }
    return 0 === u5 ? this._mergeChildren(e3) : 1 - u5 / o4 < T2 && (this._purge(e3), null != s3 && (s3.children[i5] = null), u5 = o4), u5;
  }
  _mergeChildren(e3) {
    const t3 = /* @__PURE__ */ new Set();
    let s3;
    this._forEachLeaf(e3, (e4) => {
      const r4 = this._tiles.get(e4.id);
      if (r4) {
        s3 = s3 ? o(s3, r4.attributeKeys) : new Set(r4.attributeKeys);
        for (const e5 of r4.objectIds) t3.has(e5) || (t3.add(e5), this._referenceFeature(e5));
        this._remove(e4);
      }
    }), this._addTileStorage(e3, t3, s3 ?? /* @__PURE__ */ new Set()), e3.isLeaf = true, e3.children[0] = e3.children[1] = e3.children[2] = e3.children[3] = null, this._tileFeatureCounts.set(e3.id, t3.size);
  }
  _forEachLeaf(e3, t3) {
    for (const s3 of e3.children) null != s3 && (s3.isLeaf ? t3(s3) : this._forEachLeaf(s3, t3));
  }
  _purge(e3) {
    if (null != e3) if (e3.isLeaf) this._remove(e3);
    else for (let t3 = 0; t3 < e3.children.length; t3++) {
      const s3 = e3.children[t3];
      this._purge(s3), e3.children[t3] = null;
    }
  }
  _collectMissingTiles(e3, t3, s3, i5) {
    const r4 = new E2(s3, e3, this.extent);
    return this._collectMissingTilesRecurse(t3, r4, 1, i5), r4.info;
  }
  _collectMissingTilesRecurse(e3, t3, s3, i5) {
    const o4 = this.getAttributesForTile(e3.id), n4 = o4 && !e(i5, o4);
    if (n4 && t3.addMissing(e3.level, e3.row, e3.col, s3), e3.isLeaf) return;
    if (!e3.hasChildren) return void (n4 || t3.addMissing(e3.level, e3.row, e3.col, s3));
    const l2 = s3 / 2;
    for (let r4 = 0; r4 < e3.children.length; r4++) {
      const s4 = e3.children[r4];
      null == s4 ? t3.addMissing(e3.level + 1, (e3.row << 1) + ((2 & r4) >> 1), (e3.col << 1) + (1 & r4), l2) : this._collectMissingTilesRecurse(s4, t3, l2, i5);
    }
  }
  _referenceFeature(e3) {
    const t3 = (this._refCounts.get(e3) || 0) + 1;
    return this._refCounts.set(e3, t3), 1 === t3 ? w4.ADDED : w4.UNCHANGED;
  }
  _unreferenceFeature(e3) {
    const t3 = (this._refCounts.get(e3) || 0) - 1;
    return 0 === t3 ? (this._refCounts.delete(e3), w4.REMOVED) : (t3 > 0 && this._refCounts.set(e3, t3), w4.UNCHANGED);
  }
  get test() {
  }
};
function y(e3, t3) {
  if (!e3 || !t3) return false;
  if (e3.level === t3.level) return e3.row === t3.row && e3.col === t3.col;
  const s3 = e3.level < t3.level, i5 = s3 ? e3 : t3, r4 = s3 ? t3 : e3, o4 = 1 << r4.level - i5.level;
  return Math.floor(r4.row / o4) === i5.row && Math.floor(r4.col / o4) === i5.col;
}
r([m({ constructOnly: true })], g4.prototype, "featureStore", void 0), r([m()], g4.prototype, "tileInfo", void 0), r([m()], g4.prototype, "extent", void 0), r([m()], g4.prototype, "maximumByteSize", void 0), g4 = r([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], g4);
var v = class {
  constructor(e3, t3, s3) {
    this.data = e3, this.objectIds = t3, this.attributeKeys = s3;
  }
};
var C3 = class {
  constructor(e3, t3, s3) {
    this.level = e3, this.row = t3, this.col = s3, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var S2 = class {
  constructor(e3, t3 = []) {
    this.missingTiles = t3, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l(e3.extent), this.coveredArea = this.fullArea;
  }
  prepend(e3) {
    this.missingTiles = e3.missingTiles.concat(this.missingTiles), this.coveredArea += e3.coveredArea, this.fullArea += e3.fullArea;
  }
};
var E2 = class {
  constructor(e3, t3, s3) {
    this._tileInfo = e3, this._extent = null, this.info = new S2(t3), null != s3 && (this._extent = o2(s3));
  }
  addMissing(e3, t3, s3, i5) {
    const r4 = new t(null, e3, t3, s3);
    this._tileInfo.updateTileInfo(r4, z.ExtrapolateOptions.POWER_OF_TWO), null == r4.extent || null != this._extent && !R(this._extent, r4.extent) || (this.info.missingTiles.push({ data: r4, resolution: i5 }), this.info.coveredArea -= l(r4.extent));
  }
};
var T2 = 0.18751;
var w4;
!function(e3) {
  e3[e3.ADDED = 0] = "ADDED", e3[e3.REMOVED = 1] = "REMOVED", e3[e3.UNCHANGED = 2] = "UNCHANGED";
}(w4 || (w4 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var I = class extends i2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = L(), this._elevationAligner = i3(), this._elevationFilter = r2(), this._symbologyCandidatesFetcher = n2(), this._updatingHandles = new h2(), this._alignPointsInFeatures = async (e3, t3) => {
      const i5 = { query: e3 }, s3 = await this.remoteClient.invoke("alignElevation", i5, { signal: t3 });
      return s2(t3), s3;
    }, this._getSymbologyCandidates = async (e3, t3) => {
      const i5 = { candidates: e3, spatialReference: this._spatialReference.toJSON() }, s3 = await this.remoteClient.invoke("getSymbologyCandidates", i5, { signal: t3 });
      return s2(t3), s3;
    };
  }
  get updating() {
    return this._isInitializing || this._updatingHandles.updating || this._featureFetcher.updating;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear();
  }
  async setup(e3) {
    if (this.destroyed) return { result: {} };
    const { geometryType: t3, objectIdField: i5, timeInfo: r4, fieldsIndex: a4 } = e3.serviceInfo, { hasZ: o4 } = e3, l2 = g3.fromJSON(e3.spatialReference);
    this._spatialReference = l2, this._featureStore = new f3({ ...e3.serviceInfo, hasZ: o4, hasM: false }), this._featureStore.estimateFeatureUsedMemory = (e4) => e4.usedMemory, this._queryEngine = new L2({ spatialReference: e3.spatialReference, featureStore: this._featureStore, geometryType: t3, fieldsIndex: a4, hasZ: o4, hasM: false, objectIdField: i5, timeInfo: r4 }), this._featureFetcher = new j({ store: new g4({ featureStore: this._featureStore }), url: e3.serviceInfo.url, objectIdField: e3.serviceInfo.objectIdField, globalIdField: e3.serviceInfo.globalIdField, capabilities: e3.serviceInfo.capabilities, spatialReference: l2, sourceSpatialReference: g3.fromJSON(e3.serviceInfo.spatialReference), customParameters: e3.configuration.customParameters });
    const u5 = "3d" === e3.configuration.viewType;
    return this._elevationAligner = i3(u5, { elevationInfo: null != e3.elevationInfo ? h.fromJSON(e3.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r2(u5), this.addHandles([d2(() => this._featureFetcher.availability, (e4) => this.emit("notify-availability", { availability: e4 }), C), d2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e3.configuration);
  }
  async configure(e3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e3), C4;
  }
  async setSuspended(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), this._featureFetcher.suspended = e3, C4;
  }
  async updateOutFields(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), this._featureFetcher.outFields = new Set(e3 ?? []), C4;
  }
  async fetchCandidates(e3, t3) {
    await this._whenSetup.promise, s2(t3);
    const i5 = b3(e3), s3 = t3 == null ? void 0 : t3.signal, a4 = await u3(this._queryEngine, i5, s3);
    s2(s3);
    const n4 = await this._elevationAligner.alignCandidates(a4.candidates, g3.fromJSON(e3.point.spatialReference) ?? g3.WGS84, s3);
    s2(s3);
    const o4 = await this._symbologyCandidatesFetcher.fetch(n4, s3);
    s2(s3);
    const l2 = 0 === o4.length ? n4 : n4.concat(o4);
    return { result: { candidates: this._elevationFilter.filter(i5, l2) } };
  }
  async updateTiles(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), this._featureFetcher.tileSize = e3.tileSize, this._featureFetcher.tilesOfInterest = e3.tiles, this._featureFetcher.tileInfo = null != e3.tileInfo ? z.fromJSON(e3.tileInfo) : null, C4;
  }
  async refresh(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), this._featureFetcher.refresh(), C4;
  }
  async whenNotUpdating(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), await w(() => !this.updating, t3), s2(t3), C4;
  }
  async getDebugInfo(e3, t3) {
    return s2(t3), { result: this._featureFetcher.debugInfo };
  }
  async handleEdits(e3, t3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s2(t3), await this._updatingHandles.addPromise(this._featureFetcher.handleEdits(e3)), s2(t3), C4;
  }
  async setHistoricMoment(e3, t3) {
    return this._featureFetcher.setHistoricMoment(e3.moment), C4;
  }
  async notifyElevationSourceChange(e3, t3) {
    return this._elevationAligner.notifyElevationSourceChange(), C4;
  }
  async notifySymbologyChange(e3, t3) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), C4;
  }
  async setSymbologySnappingSupported(e3) {
    return this._symbologyCandidatesFetcher = n2(e3, this._getSymbologyCandidates), C4;
  }
  _updateFeatureFetcherConfiguration(e3) {
    this._featureFetcher.filter = null != e3.filter ? b2.fromJSON(e3.filter) : null, this._featureFetcher.customParameters = e3.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
r([m({ readOnly: true })], I.prototype, "updating", null), r([m()], I.prototype, "_isInitializing", void 0), I = r([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], I);
var j2 = I;
function b3(e3) {
  if (!e3.filter) return { ...e3, query: { where: "1=1" } };
  const { distance: t3, units: i5, spatialRel: r4, where: s3, timeExtent: a4, objectIds: n4 } = e3.filter, o4 = { geometry: e3.filter.geometry ? f2(e3.filter.geometry) : void 0, distance: t3, units: i5, spatialRel: r4, timeExtent: a4, objectIds: n4, where: s3 ?? "1=1" };
  return { ...e3, query: o4 };
}
var C4 = { result: {} };
export {
  j2 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-R7MBHTKI.js.map
