import {
  E,
  I,
  N
} from "./chunk-5LCZI6ZH.js";
import {
  E as E2,
  S,
  f as f2,
  g,
  h,
  p
} from "./chunk-GWOCGJJE.js";
import {
  a,
  l,
  u as u2
} from "./chunk-DAFTSB3S.js";
import "./chunk-CDBQ673E.js";
import {
  u
} from "./chunk-3RTT2FUJ.js";
import {
  f
} from "./chunk-VC3KNIUZ.js";
import "./chunk-L4EC6LZW.js";
import "./chunk-N6TERPCK.js";
import {
  L
} from "./chunk-SEOVQLIZ.js";
import "./chunk-EUB5OBXG.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-2UD6J77T.js";
import "./chunk-YYDDGFL6.js";
import {
  j,
  x
} from "./chunk-SNZZPKBU.js";
import {
  nt,
  ot,
  rt,
  st,
  ut
} from "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-3WB47P7Q.js";
import "./chunk-6ZI2HC5K.js";
import "./chunk-WESTCUBG.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-BG4U4RTY.js";
import "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import "./chunk-2ZAGB4JV.js";
import "./chunk-B2CK3GCY.js";
import "./chunk-NINPG5JV.js";
import "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import "./chunk-SB6LU3VH.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  i
} from "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-QW7P5D76.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import {
  v
} from "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import {
  n as n2
} from "./chunk-DCSYHXZG.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import {
  ee,
  ne
} from "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import {
  d
} from "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  U,
  s as s2
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  b
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var A = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsQueryAttachmentOrderByFields: false, supportsQueryBins: true, supportsQueryWithCacheHint: true, supportsQueryWithDistance: true, supportsQueryWithResultType: true, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsSqlExpression: true, supportsDisjointSpatialRel: true }, queryBinsCapabilities: S };
var v2 = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(e, t = {}) {
    this._loadOptions = { url: e.url, customParameters: e.customParameters };
    const i2 = [], [r] = await Promise.all([e.url ? this._fetch(t == null ? void 0 : t.signal) : null, this._checkProjection(e.spatialReference)]), n3 = I(r, { geometryType: e.geometryType }), o = e.fields || n3.fields || [], u3 = null != e.hasZ ? e.hasZ : n3.hasZ, l2 = n3.geometryType;
    let d2 = e.objectIdField || n3.objectIdFieldName || "__OBJECTID";
    const p2 = e.spatialReference || U;
    let c = e.timeInfo;
    o === n3.fields && n3.unknownFields.length > 0 && i2.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n3.unknownFields } });
    const y = new Z(o);
    let h2 = y.get(d2);
    h2 ? ("esriFieldTypeString" !== h2.type && (h2.type = "esriFieldTypeOID"), h2.editable = false, h2.nullable = false, d2 = h2.name) : (h2 = { alias: d2, name: d2, type: "string" === n3.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, o.unshift(h2));
    const f3 = {};
    for (const a2 of o) {
      if (null == a2.name && (a2.name = a2.alias), null == a2.alias && (a2.alias = a2.name), !a2.name) throw new s("geojson-layer:invalid-field-name", "field name is missing", { field: a2 });
      if (!i.jsonValues.includes(a2.type)) throw new s("geojson-layer:invalid-field-type", `invalid type for field "${a2.name}"`, { field: a2 });
      if (a2.name !== h2.name) {
        const e2 = ee(a2);
        void 0 !== e2 && (f3[a2.name] = e2);
      }
      null == a2.length && (a2.length = ne(a2));
    }
    if (c) {
      if (c.startTimeField) {
        const e2 = y.get(c.startTimeField);
        e2 ? (c.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c.startTimeField = null;
      }
      if (c.endTimeField) {
        const e2 = y.get(c.endTimeField);
        e2 ? (c.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c.endTimeField = null;
      }
      if (c.trackIdField) {
        const e2 = y.get(c.trackIdField);
        e2 ? c.trackIdField = e2.name : (c.trackIdField = null, i2.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c } }));
      }
      c.startTimeField || c.endTimeField || (i2.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c } }), c = null);
    }
    const F = l2 ? u2(l2) : void 0, I2 = y.dateFields.length ? { timeZoneIANA: n2 } : null, T = { warnings: i2, featureErrors: [], layerDefinition: { ...A, drawingInfo: F ?? void 0, templates: l(f3), extent: void 0, geometryType: l2, objectIdField: d2, fields: o, hasZ: !!u3, timeInfo: c, dateFieldsTimeReference: I2 } };
    this._queryEngine = new L({ fieldsIndex: Z.fromLayerJSON({ fields: o, timeInfo: c, dateFieldsTimeReference: I2 }), geometryType: l2, hasM: false, hasZ: u3, objectIdField: d2, spatialReference: p2, timeInfo: c, featureStore: new f({ geometryType: l2, hasM: false, hasZ: u3 }) });
    const w = this._queryEngine.fieldsIndex.requiredFields.indexOf(h2);
    w > -1 && this._queryEngine.fieldsIndex.requiredFields.splice(w, 1), this._createDefaultAttributes = a(f3, d2);
    const q = await this._createFeatures(r);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, q);
    const x2 = this._normalizeFeatures(q, T.featureErrors);
    this._queryEngine.featureStore.addMany(x2);
    const { fullExtent: S2, timeExtent: R } = await this._queryEngine.fetchRecomputedExtents();
    if (T.layerDefinition.extent = S2, R) {
      const { start: e2, end: t2 } = R;
      T.layerDefinition.timeInfo.timeExtent = [e2, t2];
    }
    return T;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s3 } = this._queryEngine;
    return await Promise.all([E2(t, s3), x(e.adds, t), x(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), u(this._queryEngine, e, t.signal);
  }
  async queryAttributeBins(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e, t.signal);
  }
  async refresh(e) {
    var _a;
    this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), b(e2) || n.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: n3, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n3, timeExtent: a2 };
  }
  async _createFeatures(e) {
    if (null == e) return [];
    const { geometryType: t, hasZ: s3, objectIdField: i2 } = this._queryEngine, r = N(e, { geometryType: t, hasZ: s3, objectIdField: i2 });
    if (!s2(this._queryEngine.spatialReference, U)) for (const n3 of r) null != n3.geometry && (n3.geometry = st(j(ut(n3.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), U, this._queryEngine.spatialReference)));
    return r;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s3, customParameters: i2 } = this._loadOptions, r = (await P(s3 ?? "", { responseType: "json", query: { ...i2 }, signal: t })).data;
    return E(r), r;
  }
  _normalizeFeatures(e, t) {
    const { objectIdField: s3, fieldsIndex: i2 } = this._queryEngine, r = [];
    for (const n3 of e) {
      const e2 = this._createDefaultAttributes(), a2 = g(i2, e2, n3.attributes, true);
      a2 ? t == null ? void 0 : t.push(a2) : (this._assignObjectId(e2, n3.attributes, true), n3.attributes = e2, n3.objectId = e2[s3], r.push(n3));
    }
    return r;
  }
  async _applyEdits(e) {
    const { adds: t, updates: s3, deletes: i2 } = e, r = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if ((t == null ? void 0 : t.length) && this._applyAddEdits(r, t), (s3 == null ? void 0 : s3.length) && this._applyUpdateEdits(r, s3), i2 == null ? void 0 : i2.length) {
      for (const e2 of i2) r.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(i2);
    }
    const { fullExtent: n3, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n3, timeExtent: a2, featureEditResults: r };
  }
  _applyAddEdits(e, t) {
    const { addResults: s3 } = e, { geometryType: i2, hasM: r, hasZ: a2, objectIdField: o, spatialReference: u3, featureStore: l2, fieldsIndex: p2 } = this._queryEngine, c = [];
    for (const d2 of t) {
      if (d2.geometry && i2 !== v(d2.geometry)) {
        s3.push(p("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r2 = g(p2, t2, d2.attributes);
      if (r2) s3.push(r2);
      else {
        if (this._assignObjectId(t2, d2.attributes), d2.attributes = t2, null != d2.uid) {
          const t3 = d2.attributes[o];
          e.uidToObjectId[d2.uid] = t3;
        }
        if (null != d2.geometry) {
          const e2 = d2.geometry.spatialReference ?? u3;
          d2.geometry = j(h(d2.geometry, e2), e2, u3);
        }
        c.push(d2), s3.push(f2(d2.attributes[o]));
      }
    }
    l2.addMany(nt([], c, i2, a2, r, o));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    const { geometryType: s3, hasM: i2, hasZ: r, objectIdField: a2, spatialReference: o, featureStore: u3, fieldsIndex: l2 } = this._queryEngine;
    for (const d2 of t) {
      const { attributes: t2, geometry: y } = d2, m = t2 == null ? void 0 : t2[a2];
      if (null == m) {
        e.push(p(`Identifier field ${a2} missing`));
        continue;
      }
      if (!u3.has(m)) {
        e.push(p(`Feature with object id ${m} missing`));
        continue;
      }
      const h2 = rt(u3.getFeature(m), s3, r, i2);
      if (null != y) {
        if (s3 !== v(y)) {
          e.push(p("Incorrect geometry type."));
          continue;
        }
        const t3 = y.spatialReference ?? o;
        h2.geometry = j(h(y, t3), t3, o);
      }
      if (t2) {
        const s4 = g(l2, h2.attributes, t2);
        if (s4) {
          e.push(s4);
          continue;
        }
      }
      u3.add(ot(h2, s3, r, i2, a2)), e.push(f2(m));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s3 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s3.type) return () => s3.name + "-" + Date.now().toString(16);
    let i2 = Number.NEGATIVE_INFINITY;
    for (const r of t) r.objectId && (i2 = Math.max(i2, r.objectId));
    return i2 = Math.max(0, i2) + 1, () => i2++;
  }
  _assignObjectId(e, t, s3 = false) {
    const i2 = this._queryEngine.objectIdField;
    e[i2] = s3 && i2 in t ? t[i2] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await x(U, e);
    } catch {
      throw new s("geojson-layer", "Projection not supported");
    }
  }
};
export {
  v2 as default
};
//# sourceMappingURL=GeoJSONSourceWorker-JFL4D2WE.js.map
