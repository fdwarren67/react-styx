import {
  i as i2,
  o
} from "./chunk-VRPQZVYZ.js";
import "./chunk-FNR27W4O.js";
import "./chunk-GIVDDPSR.js";
import "./chunk-V34X57N3.js";
import {
  t
} from "./chunk-4NO34UCA.js";
import "./chunk-OSI4PMXO.js";
import "./chunk-TFOTFKYE.js";
import {
  E,
  y as y4
} from "./chunk-3T6XYN2R.js";
import "./chunk-6IYG6BTI.js";
import "./chunk-TWM4KR2X.js";
import {
  N
} from "./chunk-GHPQVNNU.js";
import "./chunk-VBE5VFL5.js";
import {
  y as y3
} from "./chunk-LULXSZFE.js";
import "./chunk-ZGGC3KHK.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import {
  a as a2
} from "./chunk-LL7BB425.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import {
  i,
  n,
  r as r2
} from "./chunk-WID5EUWY.js";
import {
  u
} from "./chunk-3RTT2FUJ.js";
import {
  f
} from "./chunk-VC3KNIUZ.js";
import "./chunk-L4EC6LZW.js";
import "./chunk-N6TERPCK.js";
import {
  L as L2
} from "./chunk-SEOVQLIZ.js";
import "./chunk-EUB5OBXG.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-2UD6J77T.js";
import "./chunk-YYDDGFL6.js";
import "./chunk-SNZZPKBU.js";
import {
  st
} from "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import {
  s as s2
} from "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-3WB47P7Q.js";
import "./chunk-6ZI2HC5K.js";
import "./chunk-WESTCUBG.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-BG4U4RTY.js";
import "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import "./chunk-2ZAGB4JV.js";
import "./chunk-B2CK3GCY.js";
import "./chunk-NINPG5JV.js";
import "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-PJIFP7OJ.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-ON7GWFUW.js";
import {
  h as h2
} from "./chunk-VPRLLNNO.js";
import {
  g as g3
} from "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import "./chunk-SB6LU3VH.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  L,
  O,
  Q
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-QW7P5D76.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-TCV7UF6X.js";
import {
  y as y2
} from "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  P,
  d as d2,
  v
} from "./chunk-UKY33OJN.js";
import {
  d
} from "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g as g2,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  g,
  h,
  s
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import {
  y
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var O2 = "graphics-collections";
var U = class extends g2 {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const s3 = async (o3, s4) => (await h(e.whenLayerView(t2), s4)).elevationAlignPointsInFeatures(o3, s4);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: s3 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r2(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, s3 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && s3 ? n(s3, async (o3, s4) => {
      const r3 = await e.whenLayerView(t2);
      return s(s4), r3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, s4);
    }) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e) => this._destroySource(e)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e2) => {
      this._updatingHandles.removeHandles(O2);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e3) => this._onGraphicUpdate(e3)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e3) => this._onGraphicsChanged(e3))], O2);
    }, P);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", ({ context: e2 }) => {
      y3(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), d2(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), P), v(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: s3 } } = e, r3 = await g(this._mapSources((o3) => this._fetchCandidatesForSource(o3, e, t2)));
    s(t2);
    const a3 = this._memoizedMakeGetGroundElevation(this.view, s3), p = r3.flat().map((e2) => o(e2, a3));
    return E(o2, p), p;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    var _a;
    const s3 = y4(t2, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d"), r3 = await u(e.queryEngine, s3, o2);
    s(o2);
    const i3 = await this._snappingElevationAligner.alignCandidates(r3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a3 = await this._symbologySnappingFetcher.fetch(i3, o2);
    s(o2);
    const p = 0 === a3.length ? i3 : [...i3, ...a3];
    return this._snappingElevationFilter.filter(s3, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e.graphic))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const s3 of e) null != s3.geometry && (this._needsInitializeProjection(s3.geometry.spatialReference) ? (t2.push(s3.geometry.spatialReference), o2.set(s3.uid, s3)) : this._add(s3));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const r3 = d(async (o2) => {
      await Q(e.map((e2) => ({ source: e2, dest: this.spatialReference })), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    });
    this._updatingHandles.addPromise(r3.promise);
    const i3 = { task: r3, graphics: t2 }, n2 = () => y(this._pendingAdds, i3);
    r3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const s3 = this._createOptimizedFeature(e.uid, t2);
    null != s3 && (o2.featureStore.add(s3), N(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !L(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = O(a2(t2), this.spatialReference);
    if (!o2) return null;
    const s3 = this._ensureGeometryHasZ(o2), r3 = st(s3, this._hasZ, false);
    return new s2(r3, { [Z2]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach((e2) => e2.forEach(t2));
        break;
      case "polygon":
        o2.rings.forEach((e2) => e2.forEach(t2));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y2.toJSON(e), o2 = this._hasZ, s3 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: s3, queryEngine: new L2({ featureStore: s3, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: Z2, type: "esriFieldTypeOID", alias: Z2 }] }), geometryType: t2, hasM: false, hasZ: o2, objectIdField: Z2, spatialReference: this.spatialReference, priority: g3.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources((t2) => this._removeFromSource(t2, e));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), N(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: s3, multipoint: r3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != s3 && i3.push(e(s3)), null != r3 && i3.push(e(r3)), i3;
  }
};
r([m()], U.prototype, "getGraphicsLayers", void 0), r([m({ constructOnly: true })], U.prototype, "layerSource", void 0), r([m({ constructOnly: true })], U.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], U.prototype, "view", void 0), r([m({ readOnly: true })], U.prototype, "updating", null), r([m({ readOnly: true })], U.prototype, "availability", void 0), r([m()], U.prototype, "_hasZ", null), r([m()], U.prototype, "_snappingElevationAligner", null), r([m()], U.prototype, "_snappingElevationFilter", null), r([m()], U.prototype, "_symbologySnappingFetcher", null), r([m()], U.prototype, "_extrudedPolygonSymbolsCount", void 0), U = r([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], U);
var Z2 = "OBJECTID";
export {
  U as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-73ZAACCS.js.map
