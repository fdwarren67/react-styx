import {
  r as r2
} from "./chunk-KNEUIVA5.js";
import "./chunk-3O7K7CQL.js";
import {
  r as r3
} from "./chunk-TG4CNFA5.js";
import "./chunk-TFOTFKYE.js";
import {
  d
} from "./chunk-3T6XYN2R.js";
import {
  c,
  f
} from "./chunk-6IYG6BTI.js";
import "./chunk-TWM4KR2X.js";
import {
  l,
  t,
  u as u2
} from "./chunk-FXA7IN4W.js";
import "./chunk-LULXSZFE.js";
import "./chunk-ZGGC3KHK.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-PJIFP7OJ.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import {
  w
} from "./chunk-ON7GWFUW.js";
import {
  P
} from "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-SB6LU3VH.js";
import {
  u
} from "./chunk-TKEIF3N7.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  O,
  U
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  x
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  s
} from "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/interactive/snapping/GridSnappingEngine.js
var w2 = class extends g {
  constructor(e) {
    super(e), this.options = null;
  }
  destroy() {
    this._set("options", null);
  }
  get grid() {
    return this.view.grid;
  }
  get effectiveViewRotation() {
    var _a;
    return ((_a = this.grid) == null ? void 0 : _a.rotateWithMap) ? 0 : s(this.view.rotation ?? 0);
  }
  get gridRotation() {
    var _a;
    return s(((_a = this.grid) == null ? void 0 : _a.rotation) ?? 0);
  }
  get gridCenter() {
    var _a;
    const { spatialReference: e, grid: t2 } = this;
    if (!t2 || !e || !U(t2.center.spatialReference, e)) return null;
    try {
      const r4 = O(t2.center, e), i = e.isWrappable && null != ((_a = this.view) == null ? void 0 : _a.center) ? P(r4.x, this.view.center.x, e) : r4.x;
      return f(i, r4.y, r4.z);
    } catch (i) {
      return n.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.", i), null;
    }
  }
  get offsetScaleFactor() {
    const { pixelsPerStride: e, grid: t2 } = this;
    if (!t2 || !e) return 1;
    const { majorLineInterval: r4, dynamicScaling: i } = t2;
    return r4 < 1 ? null : l(r4, e, i);
  }
  get spatialReference() {
    return this.view.spatialReference;
  }
  get gridMetersPerStride() {
    const { grid: e } = this;
    return e ? x(e.spacing, e.units, "meters") : null;
  }
  get viewMetersPerPixel() {
    const { viewMetersPerSRUnit: e } = this;
    return null == e ? null : e * u(this.view.scale, this.view.spatialReference);
  }
  get viewMetersPerSRUnit() {
    const { spatialReference: e } = this.view;
    return this.gridCenter ? u2(this.gridCenter[0], this.gridCenter[1], e) : null;
  }
  get pixelsPerStride() {
    const { gridMetersPerStride: e, viewMetersPerPixel: t2 } = this;
    return t2 && e ? e / t2 : null;
  }
  get updating() {
    return null != this.grid && null != this.spatialReference && null == this.viewMetersPerSRUnit;
  }
  async fetchCandidates(e, t2, r4) {
    var _a;
    const { options: i, view: n2 } = this;
    if (!(i == null ? void 0 : i.effectiveGridEnabled) || !n2.grid || ((_a = r4.feature) == null ? void 0 : _a.attributes) && d in r4.feature.attributes) return [];
    const o = r4.coordinateHelper.arrayToPoint(e), s2 = i.distance * ("touch" === r4.pointer ? i.touchSensitivityMultiplier : 1);
    return this.fetchCandidatesSync(o, s2);
  }
  fetchCandidatesSync(e, t2) {
    const r4 = [], { grid: i, effectiveViewRotation: n2, gridRotation: o, gridCenter: s2, viewMetersPerPixel: a2, viewMetersPerSRUnit: c2, offsetScaleFactor: u3, spatialReference: g2, gridMetersPerStride: f2, pixelsPerStride: m2 } = this;
    if (!(i && a2 && c2 && s2 && g2 && u3 && f2 && m2)) return r4;
    if (!i.dynamicScaling && m2 < t) return r4;
    if (!U(e.spatialReference, g2)) return r4;
    const S = O(e, g2), w3 = f(S.x, S.y, S.z), x2 = P2(w3, -o, s2, -n2), C = f2 / c2 * u3, U2 = j(x2, C, s2), { shouldSnapX: b, shouldSnapY: L } = R(U2, x2, t2, a2, c2);
    if (!b && !L) return [];
    const z = f((b ? U2 : x2)[0], (L ? U2 : x2)[1]), E = P2(z, o, s2, n2), F = P2(U2, o, s2, n2);
    if (L) {
      const e2 = M(U2, x2, C, "y"), t3 = P2(e2, o, s2, n2);
      r4.push(new r3({ lineStart: F, lineEnd: t3, targetPoint: E, isDraped: false }));
    }
    if (b) {
      const e2 = M(U2, x2, C, "x"), t3 = P2(e2, o, s2, n2);
      r4.push(new r3({ lineStart: F, lineEnd: t3, targetPoint: E, isDraped: false }));
    }
    return b && L && r4.push(new r2(E, r4[0], r4[1], false)), r4;
  }
};
r([m({ constructOnly: true })], w2.prototype, "view", void 0), r([m()], w2.prototype, "options", void 0), r([m()], w2.prototype, "grid", null), r([m()], w2.prototype, "effectiveViewRotation", null), r([m()], w2.prototype, "gridRotation", null), r([m()], w2.prototype, "gridCenter", null), r([m()], w2.prototype, "offsetScaleFactor", null), r([m()], w2.prototype, "spatialReference", null), r([m()], w2.prototype, "gridMetersPerStride", null), r([m()], w2.prototype, "viewMetersPerPixel", null), r([m()], w2.prototype, "viewMetersPerSRUnit", null), r([m()], w2.prototype, "pixelsPerStride", null), r([m()], w2.prototype, "updating", null), w2 = r([a("esri.views.interactive.snapping.GridSnappingEngine")], w2);
var P2 = (e, t2, r4, i) => {
  const n2 = c(e[0], e[1], e[2]);
  return w(n2, w(n2, n2, r4, t2), r4, i);
};
var j = (e, t2, r4) => {
  const i = (e[0] - r4[0]) / t2, n2 = (e[1] - r4[1]) / t2, o = Math.trunc(i), s2 = Math.trunc(n2), a2 = Math.round(i % 1), p = Math.round(n2 % 1), l2 = r4[0] + (o + a2) * t2, c2 = r4[1] + (s2 + p) * t2;
  return f(l2, c2);
};
var R = (e, t2, r4, i, n2) => {
  if (i <= 0) return { shouldSnapX: false, shouldSnapY: false };
  const o = (e[0] - t2[0]) / i, s2 = (e[1] - t2[1]) / i;
  return { shouldSnapX: Math.abs(o * n2) < r4, shouldSnapY: Math.abs(s2 * n2) < r4 };
};
var M = (e, t2, r4, i) => {
  if ("y" === i) {
    const i2 = t2[0] > e[0] ? 1 : -1;
    return f(e[0] + r4 * i2, e[1]);
  }
  const n2 = t2[1] > e[1] ? 1 : -1;
  return f(e[0], e[1] + r4 * n2);
};
export {
  w2 as GridSnappingEngine
};
//# sourceMappingURL=GridSnappingEngine-ICKQCAVM.js.map
