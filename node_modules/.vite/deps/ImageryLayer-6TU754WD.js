import {
  c as c6,
  f as f9,
  o as o4,
  p as p7
} from "./chunk-HCED77GY.js";
import {
  B as B2,
  L,
  U,
  c as c3,
  c2 as c5,
  ee,
  f as f6,
  g as g3,
  l as l6,
  p as p6,
  q,
  t as t5,
  w as w2
} from "./chunk-LM5DVV6Z.js";
import {
  $,
  V,
  a as a7,
  b as b4,
  c as c4,
  d as d5,
  f as f7,
  f2 as f8,
  h as h2,
  m as m2,
  m2 as m3,
  n as n5,
  o as o3,
  p as p4,
  p2 as p5,
  t as t4,
  v as v2,
  v2 as v3
} from "./chunk-AAIKSZFL.js";
import "./chunk-GHPQVNNU.js";
import "./chunk-VBE5VFL5.js";
import {
  s as s6,
  s2 as s7
} from "./chunk-KERBX4PO.js";
import {
  s as s8
} from "./chunk-N7FB6BVA.js";
import {
  A as A2,
  B2 as B,
  P as P2,
  S as S3,
  _,
  a as a6,
  c2,
  d as d3,
  i as i3,
  j as j4,
  n2,
  n3,
  n5 as n4
} from "./chunk-YLQRI5UO.js";
import {
  g as g2,
  l4 as l3,
  s as s4,
  s3 as s5
} from "./chunk-6QH5QYZM.js";
import "./chunk-23WGP47N.js";
import "./chunk-36CN7JP2.js";
import "./chunk-WX3BOMD3.js";
import "./chunk-TSFKACKN.js";
import "./chunk-W5QWJI4E.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import {
  t as t2
} from "./chunk-YZNN4Y2U.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-QY6LLTZM.js";
import {
  R
} from "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import {
  f as f5,
  i as i2,
  s as s2
} from "./chunk-6W3XFTHW.js";
import {
  t as t3
} from "./chunk-ISRSQJQR.js";
import {
  l as l4
} from "./chunk-WOB72RZU.js";
import {
  l as l5
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import {
  p as p3
} from "./chunk-S4QLDBOB.js";
import {
  e
} from "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-QAP2FVP7.js";
import {
  d as d4
} from "./chunk-6EREU4EG.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import "./chunk-5T3XQRJL.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import {
  A
} from "./chunk-NBXBK3QW.js";
import {
  j as j3
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f4
} from "./chunk-73NNNHMH.js";
import {
  b
} from "./chunk-C6YDI6QX.js";
import {
  d as d2,
  f2,
  l,
  y as y2
} from "./chunk-DJ5HVIE7.js";
import {
  S as S2
} from "./chunk-KPY4ZIC2.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import {
  b as b2
} from "./chunk-4JVIG75S.js";
import {
  s as s3
} from "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import {
  y
} from "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import {
  b as b3
} from "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  p as p2
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f as f3
} from "./chunk-3UBDE4PK.js";
import {
  p
} from "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b as b5
} from "./chunk-BLF64HON.js";
import {
  q as q2
} from "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import {
  l as l2
} from "./chunk-BMNRD4FO.js";
import {
  f,
  v
} from "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a5
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  d
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import {
  r as r3
} from "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import {
  u
} from "./chunk-552ZCNNH.js";
import {
  j as j2
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  Be,
  Ue,
  c,
  de
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o as o2
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import {
  o
} from "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import {
  I
} from "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a4
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a as a3,
  k
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  a as a2,
  h,
  i,
  x
} from "./chunk-7LCEUMDD.js";
import {
  a,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e2 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c7 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m4 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f10 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p8(e4) {
  return f10.has(e4.type);
}
function g4(n12, t8) {
  var _a;
  if (!n12 || !t8) return a(n12 || t8);
  const r4 = a(n12);
  if (r4.functionDefinition && t8.rasterFunctionDefinition) {
    const e4 = t8.rasterFunctionDefinition;
    (e4.thumbnail || e4.thumbnailEx) && (e4.thumbnail = e4.thumbnailEx = void 0), d6(r4.functionDefinition.arguments, t8), r4.rasterFunctionDefinition = r4.functionDefinition.toJSON();
  } else if ("none" !== ((_a = t8.functionName) == null ? void 0 : _a.toLowerCase())) {
    b6(r4.functionArguments).Raster = t8;
  }
  return r4;
}
function d6(e4, n12) {
  for (const t8 in e4) "raster" === t8.toLowerCase() && ("RasterFunctionVariable" === e4[t8].type ? (e4[t8] = n12.rasterFunctionDefinition, e4[t8].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e4[t8].type && d6(e4[t8].arguments, n12));
}
function h3(n12) {
  const t8 = a(e2[n12.functionName + "Function"]), o5 = n12.functionArguments;
  for (const e4 in o5) "raster" === e4.toLowerCase() ? (t8.arguments[e4] = h3(o5[e4]), t8.arguments[e4].type = "RasterFunctionTemplate") : "colormap" === e4.toLowerCase() ? (t8.arguments[e4].value = V2(o5[e4]), t8.arguments.ColorSchemeType.value = 0) : t8.arguments[e4].value = o5[e4];
  return t8;
}
function y3(e4, n12) {
  switch (n12 = n12 || {}, e4.type) {
    case "raster-stretch":
      return S4(e4, n12);
    case "class-breaks":
      return w3(e4, n12);
    case "unique-value":
      return F(e4, n12);
    case "raster-colormap":
      return N(e4, n12);
    case "vector-field":
      return T(e4, n12);
    case "raster-shaded-relief":
      return v4(e4, n12);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b6(e4) {
  const n12 = (e4 == null ? void 0 : e4.Raster) ?? (e4 == null ? void 0 : e4.raster);
  return n12 && "esri.layers.support.RasterFunction" === n12.declaredClass ? b6(n12.functionArguments) : e4;
}
var R2 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T(e4, t8) {
  const r4 = new w2();
  r4.functionName = "VectorFieldRenderer";
  const { dataType: o5, bandNames: a17 } = t8, i13 = "vector-uv" === o5;
  let s11, u7;
  if (a17 && 2 === a17.length) {
    const e5 = a17.map((e6) => e6.toLowerCase());
    s11 = e5.indexOf("magnitude"), u7 = e5.indexOf("direction");
  }
  -1 !== s11 && null !== s11 || (s11 = 0, u7 = 1);
  const c23 = "arithmetic" === e4.rotationType ? 1 : 2, f12 = "flow-from" === e4.flowRepresentation ? 0 : 1, p25 = e4.visualVariables ? e4.visualVariables.find((e5) => "Magnitude" === e5.field) : new b3(), g5 = { magnitudeBandID: s11, directionBandID: u7, isUVComponents: i13, referenceSystem: c23, massFlowAngleRepresentation: f12, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m4[e4.style.toLowerCase().replace("-", "_")], minimumMagnitude: p25.minDataValue, maximumMagnitude: p25.maxDataValue, minimumSymbolSize: p25.minSize, maximumSymbolSize: p25.maxSize };
  r4.functionArguments = g5;
  const d11 = h3(r4);
  return t8.convertToRFT ? w2.fromJSON({ rasterFunctionDefinition: d11 }) : r4;
}
function v4(e4, t8) {
  const r4 = t8.convertToRFT;
  if ("elevation" !== t8.dataType && ("generic" !== t8.dataType || 1 !== t8.bandCount || "s16" !== t8.pixelType && "s32" !== t8.pixelType && "f32" !== t8.pixelType && "f64" !== t8.pixelType)) return new w2();
  const i13 = new w2();
  i13.functionName = "Hillshade";
  const s11 = "traditional" === e4.hillshadeType ? 0 : 1, u7 = "none" === e4.scalingType ? 1 : 3, l15 = { HillshadeType: s11, SlopeType: u7, ZFactor: e4.zFactor };
  return 0 === s11 && (l15.Azimuth = e4.azimuth, l15.Altitude = e4.altitude), 3 === u7 && (l15.PSPower = e4.pixelSizePower, l15.PSZFactor = e4.pixelSizeFactor), i13.functionArguments = l15, i13.variableName = "Raster", e4.colorRamp && (i13.functionName = "ShadedRelief", r4 ? l15.ColorRamp = S3(e4.colorRamp) : l15.Colormap = B(e4.colorRamp)), r4 ? new w2({ rasterFunctionDefinition: h3(i13) }) : i13;
}
function S4(e4, t8) {
  var _a, _b;
  const r4 = t8.convertToRFT, s11 = new w2();
  s11.functionName = "Stretch";
  const l15 = R2[n4.toJSON(e4.stretchType)], c23 = "u8", m14 = (_a = e4.customStatistics) == null ? void 0 : _a.map((e5) => [e5.min, e5.max, e5.avg ?? 0, e5.stddev ?? 1]), f12 = { StretchType: l15, Statistics: m14, DRA: e4.dynamicRangeAdjustment, UseGamma: e4.useGamma, Gamma: e4.gamma, ComputeGamma: e4.computeGamma };
  if (null != e4.outputMin && (f12.Min = e4.outputMin), null != e4.outputMax && (f12.Max = e4.outputMax), l15 === R2.standardDeviation ? (f12.NumberOfStandardDeviations = e4.numberOfStandardDeviations, s11.outputPixelType = c23) : l15 === R2.percentClip ? (f12.MinPercent = e4.minPercent, f12.MaxPercent = e4.maxPercent, s11.outputPixelType = c23) : l15 === R2.minMax ? s11.outputPixelType = c23 : l15 === R2.sigmoid && (f12.SigmoidStrengthLevel = e4.sigmoidStrengthLevel), s11.functionArguments = f12, s11.variableName = "Raster", e4.colorRamp) {
    const u7 = e4.colorRamp, l16 = new w2();
    if (r4) l16.functionArguments = { ColorRamp: S3(u7) };
    else {
      const n12 = c2(u7, true);
      if (n12) l16.functionArguments = { colorRampName: n12 };
      else if (!t8.convertColorRampToColormap || "algorithmic" !== u7.type && "multipart" !== u7.type) {
        const n13 = e4.colorRamp.toJSON();
        "algorithmic" === n13.type ? n13.algorithm = n13.algorithm || "esriCIELabAlgorithm" : "multipart" === n13.type && ((_b = n13.colorRamps) == null ? void 0 : _b.length) && n13.colorRamps.forEach((e5) => e5.algorithm = e5.algorithm || "esriCIELabAlgorithm"), l16.functionArguments = { colorRamp: n13 };
      } else l16.functionArguments = { Colormap: B(u7) };
    }
    return l16.variableName = "Raster", l16.functionName = "Colormap", l16.functionArguments.Raster = s11, r4 ? new w2({ rasterFunctionDefinition: h3(l16) }) : l16;
  }
  return r4 ? new w2({ rasterFunctionDefinition: h3(s11) }) : s11;
}
function w3(e4, t8) {
  const r4 = [], o5 = [], a17 = [], i13 = [], s11 = 1e-4, { pixelType: u7, rasterAttributeTable: l15 } = t8, c23 = null == l15 ? null : l15.features, m14 = C(l15);
  if (m14 && c23 && Array.isArray(c23) && e4.classBreakInfos) {
    e4.classBreakInfos.forEach((n12, t9) => {
      var _a;
      const r6 = (_a = n12.symbol) == null ? void 0 : _a.color;
      let o7;
      (r6 == null ? void 0 : r6.a) && null != n12.minValue && null != n12.maxValue && c23.forEach((a18) => {
        null != n12.minValue && null != n12.maxValue && (o7 = a18.attributes[e4.field], (o7 >= n12.minValue && o7 < n12.maxValue || t9 === e4.classBreakInfos.length - 1 && o7 >= n12.minValue) && i13.push([a18.attributes[m14], r6.r, r6.g, r6.b]));
      });
    });
    const r5 = u7 ? x2(i13, u7) : i13, o6 = new w2();
    return o6.functionName = "Colormap", o6.functionArguments = {}, o6.functionArguments.Colormap = r5, o6.variableName = "Raster", t8.convertToRFT ? new w2({ rasterFunctionDefinition: h3(o6) }) : o6;
  }
  e4.classBreakInfos.forEach((e5, n12) => {
    if (null == e5.minValue || null == e5.maxValue) return;
    const t9 = e5.symbol && e5.symbol.color;
    (t9 == null ? void 0 : t9.a) ? (0 === n12 ? r4.push(e5.minValue, e5.maxValue + s11) : r4.push(e5.minValue + s11, e5.maxValue + s11), o5.push(n12), i13.push([n12, t9.r, t9.g, t9.b])) : a17.push(e5.minValue, e5.maxValue);
  });
  const f12 = u7 ? x2(i13, u7) : i13, p25 = new w2();
  p25.functionName = "Remap", p25.functionArguments = { InputRanges: r4, OutputValues: o5, NoDataRanges: a17 }, p25.variableName = "Raster";
  const g5 = new w2();
  return g5.functionName = "Colormap", g5.functionArguments = { Colormap: f12, Raster: p25 }, t8.convertToRFT ? new w2({ rasterFunctionDefinition: h3(g5) }) : g5;
}
function x2(e4, n12) {
  const r4 = c7.has(n12) ? s4(n12) : null;
  return r4 && e4.push([Math.floor(r4[0] - 1), 0, 0, 0], [Math.ceil(r4[1] + 1), 0, 0, 0]), e4;
}
function C(e4) {
  if (null == e4) return;
  const { fields: n12 } = e4, t8 = n12 == null ? void 0 : n12.find((e5) => (e5 == null ? void 0 : e5.name) && "value" === e5.name.toLowerCase());
  return t8 == null ? void 0 : t8.name;
}
function F(e4, t8) {
  var _a, _b;
  const r4 = [], { pixelType: o5, rasterAttributeTable: a17 } = t8, i13 = null == a17 ? null : a17.features, s11 = C(a17), u7 = (_b = (_a = e4.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), l15 = e4.uniqueValueInfos;
  if (l15) if (i13) {
    if (s11) {
      const n12 = /* @__PURE__ */ new Map();
      l15.forEach((e5) => {
        const t10 = e5.value, r5 = A3(e5);
        null != t10 && (r5 == null ? void 0 : r5.a) && n12.set(String(t10), r5.toRgb());
      });
      const t9 = e4.field;
      t9 && i13.forEach(({ attributes: e5 }) => {
        const o6 = String(e5[t9]), a18 = e5[s11], i14 = n12.get(o6);
        i14 ? r4.push([a18, ...i14]) : u7 && r4.push([a18, ...u7]);
      });
    }
  } else for (let n12 = 0; n12 < l15.length; n12++) {
    const e5 = l15[n12], t9 = A3(e5), o6 = +e5.value;
    if (t9 == null ? void 0 : t9.a) {
      if (isNaN(o6)) return null;
      r4.push([o6, t9.r, t9.g, t9.b]);
    }
  }
  const c23 = o5 ? x2(r4, o5) : r4, m14 = new w2();
  return m14.functionName = "Colormap", m14.functionArguments = {}, m14.functionArguments.Colormap = c23, m14.variableName = "Raster", t8.convertToRFT ? new w2({ rasterFunctionDefinition: h3(m14) }) : m14;
}
function A3(e4) {
  var _a, _b, _c, _d, _e;
  return "polygon-3d" === ((_a = e4.symbol) == null ? void 0 : _a.type) ? (_d = (_c = (_b = e4.symbol.symbolLayers) == null ? void 0 : _b.find((e5) => "fill" === e5.type)) == null ? void 0 : _c.material) == null ? void 0 : _d.color : (_e = e4.symbol) == null ? void 0 : _e.color;
}
function N(e4, t8) {
  const r4 = e4.extractColormap();
  if (!r4 || 0 === r4.length) return null;
  const { pixelType: o5 } = t8, a17 = o5 ? x2(r4, o5) : r4, i13 = new w2();
  return i13.functionName = "Colormap", i13.functionArguments = {}, i13.functionArguments.Colormap = a17, t8.convertToRFT ? new w2({ rasterFunctionDefinition: h3(i13) }) : i13;
}
function V2(e4) {
  const n12 = [], t8 = [];
  return e4.forEach((e5) => {
    n12.push(e5[0]), t8.push(A2([...e5.slice(1), 255]));
  }), { type: "RasterColormap", values: n12, colors: t8 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var d7 = class extends S {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e4, t8, r4) {
    this.layer.version < 10.3 || (t8[r4] = e4);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e4, t8, r4) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e4 && (t8[r4] = e4);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e4, t8, r4) {
    "lerc" === this.format && null != e4 && (t8[r4] = e4);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  get pixelType() {
    const { layer: e4 } = this;
    return e4.pixelType !== e4.serviceRasterInfo.pixelType ? e4.pixelType : void 0;
  }
  writeLercVersion(e4, t8, r4) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t8[r4] = e4);
  }
  get version() {
    const e4 = this.layer;
    return e4.commitProperty("bandIds"), e4.commitProperty("format"), e4.commitProperty("compressionQuality"), e4.commitProperty("compressionTolerance"), e4.commitProperty("interpolation"), e4.commitProperty("noData"), e4.commitProperty("noDataInterpretation"), e4.commitProperty("mosaicRule"), e4.commitProperty("rasterFunction"), e4.commitProperty("adjustAspectRatio"), e4.commitProperty("pixelFilter"), e4.commitProperty("pixelType"), e4.commitProperty("definitionExpression"), e4.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e4) {
    this._set("version", e4);
  }
  get mosaicRule() {
    const e4 = this.layer;
    let t8 = e4.mosaicRule;
    const r4 = e4.definitionExpression;
    return t8 ? r4 && r4 !== t8.where && (t8 = t8.clone(), t8.where = r4) : r4 && (t8 = new f6({ where: r4 })), t8;
  }
  get rasterFunction() {
    var _a, _b;
    const e4 = this.layer;
    let { rasterFunction: t8 } = e4;
    const r4 = e4.pixelFilter, o5 = !e4.format || e4.format.includes("jpg") || e4.format.includes("png");
    t8 = this._addResampleRasterFunction(t8);
    const i13 = (_a = e4.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i13 && (t8 = f11(t8, i13)), o5 && !r4 && "vector-field" !== ((_b = e4.renderer) == null ? void 0 : _b.type) && (t8 = this.combineRendererWithRenderingRule(t8)), t8;
  }
  combineRendererWithRenderingRule(e4) {
    const t8 = this.layer, { rasterInfo: r4, renderer: o5 } = t8;
    if (e4 = e4 || t8.rasterFunction, !o5 || !p8(o5)) return e4;
    return g4(y3(o5, { rasterAttributeTable: r4.attributeTable, pixelType: r4.pixelType, dataType: r4.dataType, bandNames: r4.bandInfos.map(({ name: e5 }) => e5), convertColorRampToColormap: t8.version < 10.6, convertToRFT: !!(e4 == null ? void 0 : e4.rasterFunctionDefinition), bandCount: r4.bandCount }), e4);
  }
  _addResampleRasterFunction(e4) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e4 == null ? void 0 : e4.functionName)) return e4;
    const t8 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r4 = this.layer.serviceRasterInfo.pixelSize;
    let o5 = new w2({ functionName: "Resample", functionArguments: { ResamplingType: t8, InputCellSize: r4 } });
    return o5 = (e4 == null ? void 0 : e4.rasterFunctionDefinition) ? new w2({ rasterFunctionDefinition: h3(o5) }) : o5, g4(o5, e4);
  }
};
function f11(e4, t8) {
  const r4 = new w2({ functionName: "Clip", functionArguments: { ClippingGeometry: t8.toJSON(), ClippingType: 1 } });
  return g4(r4, e4);
}
r([m()], d7.prototype, "layer", void 0), r([m({ json: { write: true } })], d7.prototype, "adjustAspectRatio", null), r([r2("adjustAspectRatio")], d7.prototype, "writeAdjustAspectRatio", null), r([m({ json: { write: true } })], d7.prototype, "bandIds", null), r([m({ json: { write: true } })], d7.prototype, "compression", void 0), r([m({ json: { write: true } })], d7.prototype, "compressionQuality", null), r([r2("compressionQuality")], d7.prototype, "writeCompressionQuality", null), r([m({ json: { write: true } })], d7.prototype, "compressionTolerance", null), r([r2("compressionTolerance")], d7.prototype, "writeCompressionTolerance", null), r([m({ json: { write: true } })], d7.prototype, "format", null), r([m({ type: String, json: { read: { reader: a6.read }, write: { writer: a6.write } } })], d7.prototype, "interpolation", null), r([m({ json: { write: true } })], d7.prototype, "noData", null), r([m({ type: String, json: { read: { reader: i3.read }, write: { writer: i3.write } } })], d7.prototype, "noDataInterpretation", null), r([m({ type: n2.apiValues, json: { read: n2.read, write: n2.write } })], d7.prototype, "pixelType", null), r([m({ json: { write: true } })], d7.prototype, "lercVersion", void 0), r([r2("lercVersion")], d7.prototype, "writeLercVersion", null), r([m({ type: Number })], d7.prototype, "version", null), r([m({ json: { write: true } })], d7.prototype, "mosaicRule", null), r([m({ json: { write: true, name: "renderingRule" } })], d7.prototype, "rasterFunction", null), d7 = r([a4("esri.layers.support.ExportImageServiceParameters")], d7);

// node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i4 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
r([m({ type: j, json: { read: true } })], i4.prototype, "fromGeometry", void 0), r([m({ type: j, json: { read: true, write: true } })], i4.prototype, "toGeometry", void 0), r([m({ json: { write: true } })], i4.prototype, "objectIds", void 0), r([m({ type: String, json: { write: true } })], i4.prototype, "where", void 0), r([m({ type: Number, json: { write: true } })], i4.prototype, "maxCount", void 0), i4 = r([a4("esri.rest.support.FindImagesParameters")], i4);
var m5 = i4;

// node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var s9 = (s11) => {
  let e4 = class extends s11 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return r([m({ json: { write: true } })], e4.prototype, "make", void 0), r([m({ json: { write: true } })], e4.prototype, "model", void 0), r([m({ json: { write: true } })], e4.prototype, "focalLength", void 0), r([m({ json: { write: true } })], e4.prototype, "pixelSize", void 0), r([m({ json: { write: true } })], e4.prototype, "rows", void 0), r([m({ json: { write: true } })], e4.prototype, "cols", void 0), e4 = r([a4("esri.rest.support.CameraInfoMixin")], e4), e4;
};

// node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n6 = class extends s9(S) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t8, o5) {
    o5.acquisitionDate = t8 == null ? void 0 : t8.getTime();
  }
};
r([m({ json: { write: true } })], n6.prototype, "id", void 0), r([m({ json: { name: "uri", write: true } })], n6.prototype, "referenceUri", void 0), r([m({ type: Date, json: { write: true } })], n6.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], n6.prototype, "writeAcquisitionDate", null), r([m({ json: { write: true } })], n6.prototype, "cameraID", void 0), r([m({ type: j, json: { write: true } })], n6.prototype, "center", void 0), r([m({ type: j, json: { write: true } })], n6.prototype, "perspectiveCenter", void 0), r([m({ json: { write: true } })], n6.prototype, "orientation", void 0), n6 = r([a4("esri.rest.support.ImageInspectionInfo")], n6);
var c8 = n6;

// node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p9 = class extends S {
  constructor() {
    super(...arguments), this.images = null;
  }
};
r([m({ type: [c8], json: { write: true } })], p9.prototype, "images", void 0), p9 = r([a4("esri.rest.support.FindImagesResult")], p9);
var c9 = p9;

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n7;
var l7 = n7 = class extends S {
  constructor(e4) {
    super(e4), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n7(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
r([m({ type: [String], json: { name: "angleName", write: true } })], l7.prototype, "angleNames", void 0), r([m({ type: j, json: { write: true } })], l7.prototype, "point", void 0), r([m({ type: g, json: { write: true } })], l7.prototype, "spatialReference", void 0), r([m({ type: x, json: { write: true } })], l7.prototype, "rasterId", void 0), l7 = n7 = r([a4("esri.rest.support.ImageAngleParameters")], l7);
var m6 = l7;

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p10 = class extends S {
  constructor(r4) {
    super(r4), this.north = null, this.up = null, this.spatialReference = null;
  }
};
r([m({ type: Number, json: { write: true } })], p10.prototype, "north", void 0), r([m({ type: Number, json: { write: true } })], p10.prototype, "up", void 0), r([m({ type: g, json: { write: true } })], p10.prototype, "spatialReference", void 0), p10 = r([a4("esri.rest.support.ImageAngleResult")], p10);
var i5 = p10;

// node_modules/@arcgis/core/rest/support/imageMeasureUtils.js
var u2 = new o({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p11 = class extends S {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
r([m({ type: Number, json: { read: true, write: true } })], p11.prototype, "value", void 0), r([m({ type: String, json: { read: true, write: true } })], p11.prototype, "displayValue", void 0), r([m({ type: Number, json: { read: true, write: true } })], p11.prototype, "uncertainty", void 0), p11 = r([a4("esri.rest.support.imageMeasureUtils.BaseImageMeasureResultValue")], p11);
var d8 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], d8.prototype, "unit", void 0), d8 = r([a4("esri.rest.support.imageMeasureUtils.ImageMeasureResultLengthValue")], d8);
var l8 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: de.read, write: de.write } })], l8.prototype, "unit", void 0), l8 = r([a4("esri.rest.support.imageMeasureUtils.ImageMeasureResultAreaValue")], l8);
var c10 = class extends p11 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: Be.read, write: Be.write } })], c10.prototype, "unit", void 0), c10 = r([a4("esri.rest.support.imageMeasureUtils.ImageMeasureResultAngleValue")], c10);

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a8 = class extends S {
  constructor(r4) {
    super(r4), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
r([m()], a8.prototype, "type", void 0), r([m({ type: u2.apiValues, json: { read: u2.read, write: u2.write } })], a8.prototype, "measureOperation", void 0), r([m({ type: f6, json: { write: true } })], a8.prototype, "mosaicRule", void 0), r([m({ type: j, json: { write: true } })], a8.prototype, "pixelSize", void 0), r([m({ json: { write: true } })], a8.prototype, "raster", void 0), a8 = r([a4("esri.rest.support.BaseImageMeasureParameters")], a8);
var m7 = a8;

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var u3;
var c11 = u3 = class extends m7 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e4, r4, t8) {
    null != e4 && (r4.geometryType = v(e4), r4[t8] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new u3(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ types: l2, json: { name: "fromGeometry", read: true, write: true } })], c11.prototype, "geometry", void 0), r([r2("geometry")], c11.prototype, "writeGeometry", null), r([m({ type: u2.apiValues, json: { write: u2.write } })], c11.prototype, "measureOperation", null), r([m({ json: { read: true } })], c11.prototype, "is3D", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], c11.prototype, "linearUnit", void 0), r([m({ type: String, json: { read: de.read, write: de.write } })], c11.prototype, "areaUnit", void 0), c11 = u3 = r([a4("esri.rest.support.ImageAreaParameters")], c11);
var y4 = c11;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var t6 = class extends S {
  constructor(r4) {
    super(r4), this.name = null, this.sensorName = null;
  }
};
r([m({ type: String, json: { read: true, write: true } })], t6.prototype, "name", void 0), r([m({ type: String, json: { read: true, write: true } })], t6.prototype, "sensorName", void 0), t6 = r([a4("esri.rest.support.BaseImageMeasureResult")], t6);
var p12 = t6;

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a9 = class extends p12 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
r([m({ type: l8, json: { read: true, write: true } })], a9.prototype, "area", void 0), r([m({ type: d8, json: { read: true, write: true } })], a9.prototype, "perimeter", void 0), a9 = r([a4("esri.rest.support.ImageAreaResult")], a9);
var i6 = a9;

// node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a10 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.outSpatialReference = null;
  }
};
r([m({ type: g, json: { name: "outSR", write: true } })], a10.prototype, "outSpatialReference", void 0), a10 = r([a4("esri.rest.support.ImageBoundaryParameters")], a10);
var c12 = a10;

// node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var c13 = class extends S {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r4, o5) {
    return null == r4 ? null : r4.rings ? j2.fromJSON(r4) : w.fromJSON(r4);
  }
};
r([m({ type: Number, json: { write: true } })], c13.prototype, "area", void 0), r([m({ types: l2, json: { name: "shape", write: true } })], c13.prototype, "geometry", void 0), r([o2("geometry")], c13.prototype, "readGeometry", null), c13 = r([a4("esri.rest.support.ImageBoundaryResult")], c13);
var i7 = c13;

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var c14;
var u4 = c14 = class extends m7 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e4, r4, t8) {
    null != e4 && (r4.geometryType = v(e4), r4[t8] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new c14(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ type: j, json: { read: true, write: true } })], u4.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], u4.prototype, "writeFromGeometry", null), r([m({ type: j, json: { read: true, write: true } })], u4.prototype, "toGeometry", void 0), r([m({ type: u2.apiValues, json: { write: u2.write } })], u4.prototype, "measureOperation", null), r([m({ json: { read: true } })], u4.prototype, "is3D", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], u4.prototype, "linearUnit", void 0), r([m({ type: String, json: { read: Be.read, write: Be.write } })], u4.prototype, "angularUnit", void 0), u4 = c14 = r([a4("esri.rest.support.ImageDistanceParameters")], u4);
var y5 = u4;

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a11 = class extends p12 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
r([m({ type: d8, json: { read: true, write: true } })], a11.prototype, "distance", void 0), r([m({ type: c10, json: { read: true, write: true } })], a11.prototype, "azimuthAngle", void 0), r([m({ type: c10, json: { read: true, write: true } })], a11.prototype, "elevationAngle", void 0), a11 = r([a4("esri.rest.support.ImageDistanceResult")], a11);
var p13 = a11;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var j5 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o5, t8, r4) {
    null != o5 && (t8.geometryType = v(o5), t8[r4] = JSON.stringify(o5.toJSON()));
  }
};
r([m({ types: l2, json: { read: f, write: true } })], j5.prototype, "geometry", void 0), r([r2("geometry")], j5.prototype, "writeGeometry", null), r([m({ json: { write: true } })], j5.prototype, "objectIds", void 0), r([r3(s3, { ignoreUnknown: false, name: "spatialRel" })], j5.prototype, "spatialRelationship", void 0), r([m({ type: p, json: { name: "time", write: true } })], j5.prototype, "timeExtent", void 0), r([m({ type: String, json: { write: true } })], j5.prototype, "where", void 0), j5 = r([a4("esri.rest.support.ImageGPSInfoParameters")], j5);
var y6 = j5;

// node_modules/@arcgis/core/rest/support/CameraInfo.js
var p14 = class extends s9(S) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
r([m({ json: { write: true } })], p14.prototype, "id", void 0), p14 = r([a4("esri.rest.support.CameraInfo")], p14);
var c15 = p14;

// node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p15 = class extends S {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o5, t8) {
    t8.acquisitionDate = o5 == null ? void 0 : o5.getTime();
  }
};
r([m({ json: { write: true } })], p15.prototype, "id", void 0), r([m({ json: { write: true } })], p15.prototype, "name", void 0), r([m({ type: Date, json: { write: true } })], p15.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], p15.prototype, "writeAcquisitionDate", null), r([m({ json: { write: true } })], p15.prototype, "cameraID", void 0), r([m({ type: j, json: { write: true } })], p15.prototype, "center", void 0), r([m({ json: { write: true } })], p15.prototype, "gps", void 0), r([m({ json: { write: true } })], p15.prototype, "orientation", void 0), p15 = r([a4("esri.rest.support.ImageGPSInfo")], p15);
var n8 = p15;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m8 = class extends S {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
r([m({ type: [n8], json: { write: true } })], m8.prototype, "images", void 0), r([m({ type: [c15], json: { write: true } })], m8.prototype, "cameras", void 0), m8 = r([a4("esri.rest.support.ImageGPSInfoResult")], m8);
var a12 = m8;

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y7;
var l9 = y7 = class extends m7 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e4, r4, t8) {
    null != e4 && (r4.geometryType = v(e4), r4[t8] = e4.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y7(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ type: j, json: { read: true } })], l9.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], l9.prototype, "writeFromGeometry", null), r([m({ type: j, json: { read: true, write: true } })], l9.prototype, "toGeometry", void 0), r([m({ type: u2.apiValues, json: { write: u2.write } })], l9.prototype, "measureOperation", null), r([m({ json: { read: true } })], l9.prototype, "operationType", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], l9.prototype, "linearUnit", void 0), l9 = y7 = r([a4("esri.rest.support.ImageHeightParameters")], l9);
var c16 = l9;

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p16 = class extends p12 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
r([m({ type: d8, json: { read: true, write: true } })], p16.prototype, "height", void 0), p16 = r([a4("esri.rest.support.ImageHeightResult")], p16);
var a13 = p16;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var c17;
var y8 = c17 = class extends S {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t8, e4, r4) {
    null != t8 && (e4.geometryType = v(t8), e4[r4] = JSON.stringify(t8.toJSON()));
  }
  set mosaicRule(t8) {
    let e4 = t8;
    (e4 == null ? void 0 : e4.mosaicMethod) && (e4 = f6.fromJSON({ ...e4.toJSON(), mosaicMethod: e4.mosaicMethod, mosaicOperation: e4.mosaicOperation })), this._set("mosaicRule", e4);
  }
  writeMosaicRule(t8, e4, r4) {
    null != t8 && (e4[r4] = JSON.stringify(t8.toJSON()));
  }
  set rasterFunction(t8) {
    let e4 = t8;
    (e4 == null ? void 0 : e4.rasterFunction) && (e4 = w2.fromJSON({ ...e4.toJSON(), rasterFunction: e4.rasterFunction, rasterFunctionArguments: e4.rasterFunctionArguments })), this._set("rasterFunction", e4);
  }
  writeRasterFunction(t8, e4, r4) {
    null != t8 && (e4[r4] = JSON.stringify(t8.toJSON())), t8.rasterFunctionDefinition && (e4[r4] = JSON.stringify(t8.rasterFunctionDefinition));
  }
  writeRasterFunctions(t8, e4, r4) {
    null != t8 && (e4[r4] = JSON.stringify(t8.map((t9) => t9.rasterFunctionDefinition || t9.toJSON())));
  }
  writePixelSize(t8, e4, r4) {
    null != t8 && (e4[r4] = JSON.stringify(t8));
  }
  writeTimeExtent(t8, e4, r4) {
    if (null != t8) {
      const o5 = null != t8.start ? t8.start.getTime() : null, i13 = null != t8.end ? t8.end.getTime() : null;
      e4[r4] = null != o5 ? null != i13 ? `${o5},${i13}` : `${o5}` : null;
    }
  }
  clone() {
    return new c17(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
r([m({ types: l2, json: { write: true } })], y8.prototype, "geometry", void 0), r([r2("geometry")], y8.prototype, "writeGeometry", null), r([m({ type: f6, json: { write: true } })], y8.prototype, "mosaicRule", null), r([r2("mosaicRule")], y8.prototype, "writeMosaicRule", null), r([m({ type: w2, json: { write: true, name: "renderingRule" } })], y8.prototype, "rasterFunction", null), r([r2("rasterFunction")], y8.prototype, "writeRasterFunction", null), r([m({ type: [w2], json: { write: true, name: "renderingRules" } })], y8.prototype, "rasterFunctions", void 0), r([r2("rasterFunctions")], y8.prototype, "writeRasterFunctions", null), r([m({ type: j, json: { write: true } })], y8.prototype, "pixelSize", void 0), r([r2("pixelSize")], y8.prototype, "writePixelSize", null), r([m({ type: Boolean, json: { write: true } })], y8.prototype, "returnGeometry", void 0), r([m({ type: Boolean, json: { write: true } })], y8.prototype, "returnCatalogItems", void 0), r([m({ type: Boolean, json: { write: true } })], y8.prototype, "returnPixelValues", void 0), r([m({ type: Number, json: { write: true } })], y8.prototype, "maxItemCount", void 0), r([m({ type: p, json: { write: { target: "time" } } })], y8.prototype, "timeExtent", void 0), r([r2("timeExtent")], y8.prototype, "writeTimeExtent", null), r([m({ json: { write: true } })], y8.prototype, "raster", void 0), r([m({ json: { write: true } })], y8.prototype, "viewId", void 0), r([m({ type: Boolean, json: { write: true } })], y8.prototype, "processAsMultidimensional", void 0), y8 = c17 = r([a4("esri.rest.support.ImageIdentifyParameters")], y8);
var d9 = y8;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p17 = class extends S {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
r([m({ json: { write: true } })], p17.prototype, "catalogItemVisibilities", void 0), r([m({ type: d4, json: { write: true } })], p17.prototype, "catalogItems", void 0), r([m({ type: j, json: { write: true } })], p17.prototype, "location", void 0), r([m({ json: { write: true } })], p17.prototype, "name", void 0), r([m({ json: { write: true } })], p17.prototype, "objectId", void 0), r([m({ json: { write: true } })], p17.prototype, "processedValues", void 0), r([m({ json: { write: true } })], p17.prototype, "properties", void 0), r([m({ json: { write: true } })], p17.prototype, "value", void 0), p17 = r([a4("esri.rest.support.ImageIdentifyResult")], p17);
var l10 = p17;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m9;
var c18 = m9 = class extends S {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r4, e4, o5) {
    e4.geometries = { geometryType: "esriGeometryPoint", geometries: r4.map((r5) => r5.toJSON()) };
  }
  clone() {
    var _a;
    return new m9({ geometries: ((_a = this.geometries) == null ? void 0 : _a.map((r4) => r4.clone())) ?? [], rasterId: this.rasterId });
  }
};
r([m({ type: [j], json: { write: true } })], c18.prototype, "geometries", void 0), r([r2("geometries")], c18.prototype, "writeGeometry", null), r([m({ type: x, json: { write: true } })], c18.prototype, "rasterId", void 0), c18 = m9 = r([a4("esri.rest.support.ImagePixelLocationParameters")], c18);
var a14 = c18;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t7 = class extends S {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
r([m({ json: { write: true } })], t7.prototype, "geometries", void 0), t7 = r([a4("esri.rest.support.ImagePixelLocationResult")], t7);
var p18 = t7;

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c19;
var u5 = c19 = class extends m7 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e4, r4, t8) {
    null != e4 && (r4.geometryType = v(e4), r4[t8] = e4.toJSON());
  }
  get measureOperation() {
    const { is3D: e4, geometry: r4 } = this;
    return "point" === r4.type ? e4 ? "point-3D" : "point" : e4 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c19(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ types: l2, json: { name: "fromGeometry", read: f } })], u5.prototype, "geometry", void 0), r([r2("geometry")], u5.prototype, "writeGeometry", null), r([m({ type: u2.apiValues, json: { read: u2.read, write: u2.write } })], u5.prototype, "measureOperation", null), r([m({ json: { read: true } })], u5.prototype, "is3D", void 0), u5 = c19 = r([a4("esri.rest.support.ImagePointParameters")], u5);
var l11 = u5;

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p19 = class extends p12 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
r([m({ type: j, json: { name: "point.value", read: true, write: true } })], p19.prototype, "point", void 0), p19 = r([a4("esri.rest.support.ImagePointResult")], p19);
var a15 = p19;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d10;
var h4 = d10 = class extends S {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.raster = void 0, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t8, e4, o5) {
    null != t8 && (e4.geometryType = v(t8), e4[o5] = t8.toJSON());
  }
  set locations(t8) {
    if (t8 == null ? void 0 : t8.length) {
      const e4 = new u({ spatialReference: t8[0].spatialReference, points: t8.map(({ x: t9, y: e5 }) => [t9, e5]) });
      this._set("locations", t8), this.geometry = e4;
    }
  }
  clone() {
    return new d10(a({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
r([m({ types: l2, json: { read: f } })], h4.prototype, "geometry", void 0), r([r2("geometry")], h4.prototype, "writeGeometry", null), r([m({ type: [j] })], h4.prototype, "locations", null), r([m({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], h4.prototype, "interpolation", void 0), r([m({ type: f6, json: { write: true } })], h4.prototype, "mosaicRule", void 0), r([m({ type: [String], json: { write: true } })], h4.prototype, "outFields", void 0), r([m({ type: j, json: { write: true } })], h4.prototype, "pixelSize", void 0), r([m({ type: String, json: { write: true } })], h4.prototype, "raster", void 0), r([m({ type: Boolean, json: { write: true } })], h4.prototype, "returnFirstValueOnly", void 0), r([m({ type: Number, json: { write: true } })], h4.prototype, "sampleDistance", void 0), r([m({ type: Number, json: { write: true } })], h4.prototype, "sampleCount", void 0), r([m({ type: Number, json: { write: true } })], h4.prototype, "sliceId", void 0), r([m({ type: p, json: { read: { source: "time" }, write: { target: "time" } } })], h4.prototype, "timeExtent", void 0), h4 = d10 = r([a4("esri.rest.support.ImageSampleParameters")], h4);
var j6 = h4;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i8 = class extends S {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
r([m({ json: { write: true } })], i8.prototype, "attributes", void 0), r([m({ type: j, json: { write: true } })], i8.prototype, "location", void 0), r([m({ json: { write: true } })], i8.prototype, "locationId", void 0), r([m({ json: { write: true } })], i8.prototype, "rasterId", void 0), r([m({ json: { write: true } })], i8.prototype, "resolution", void 0), r([m({ json: { write: true } })], i8.prototype, "pixelValue", void 0), i8 = r([a4("esri.rest.support.ImageSample")], i8);
var p20 = i8;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p21 = class extends S {
  constructor() {
    super(...arguments), this.samples = [];
  }
};
r([m({ type: [p20], json: { write: true } })], p21.prototype, "samples", void 0), p21 = r([a4("esri.rest.support.ImageSampleResult")], p21);
var m10 = p21;

// node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l12 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e4, r4, o5) {
    r4.geometries = (e4 == null ? void 0 : e4.length) ? { geometryType: v(e4[0]), geometries: e4.map((e5) => ({ ...e5.toJSON(), spatialReference: void 0 })) } : null;
  }
};
r([m({ types: [l2] })], l12.prototype, "geometries", void 0), r([r2("geometries")], l12.prototype, "writeGeometries", null), r([m({ type: [x], json: { write: true } })], l12.prototype, "rasterIds", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], l12.prototype, "outSpatialReference", void 0), l12 = r([a4("esri.rest.support.ImageToMapMultirayParameters")], l12);
var n9 = l12;

// node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var c20 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o5, e4, t8) {
    null != o5 && (e4.geometryType = v(o5), e4[t8] = { ...o5.toJSON(), spatialReference: void 0 });
  }
};
r([m({ types: l2, json: { read: f, write: true } })], c20.prototype, "geometry", void 0), r([r2("geometry")], c20.prototype, "writeGeometry", null), r([m({ json: { write: true } })], c20.prototype, "rasterId", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], c20.prototype, "outSpatialReference", void 0), r([m({ json: { name: "options.DOff", write: true } })], c20.prototype, "depthOffset", void 0), r([m({ json: { name: "options.Adjust", write: true } })], c20.prototype, "adjust", void 0), c20 = r([a4("esri.rest.support.ImageToMapParameters")], c20);
var l13 = c20;

// node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p22 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.referenceUri = null, this.rasterId = null;
  }
};
r([m({ type: String, json: { name: "uri", write: true } })], p22.prototype, "referenceUri", void 0), r([m({ type: Number, json: { write: true } })], p22.prototype, "rasterId", void 0), p22 = r([a4("esri.rest.support.ImageUrlParameters")], p22);
var i9 = p22;

// node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var e3 = class extends S {
  constructor() {
    super(...arguments), this.url = null;
  }
};
r([m({ json: { name: "imageURL", write: true } })], e3.prototype, "url", void 0), e3 = r([a4("esri.rest.support.ImageUrlResult")], e3);
var p23 = e3;

// node_modules/@arcgis/core/rest/support/ImageVolumeParameters.js
var l14 = new o({ 0: "constant", 1: "plane", 2: "minimum", 3: "maximum", 4: "average" }, { useNumericKeys: true });
var u6 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.geometries = [], this.mosaicRule = null, this.pixelSize = null, this.constantZ = null, this.baseType = "plane";
  }
  writeGeometries(o5, e4, r4) {
    (o5 == null ? void 0 : o5.length) && (e4.geometryType = v(o5[0]), e4.geometries = o5.map((o6) => o6.toJSON()));
  }
};
r([m({ types: [l2] })], u6.prototype, "geometries", void 0), r([r2("geometries")], u6.prototype, "writeGeometries", null), r([m({ type: f6, json: { write: true } })], u6.prototype, "mosaicRule", void 0), r([m({ type: j, json: { write: true } })], u6.prototype, "pixelSize", void 0), r([m({ json: { write: true } })], u6.prototype, "constantZ", void 0), r([m({ type: l14.apiValues, json: { read: l14.read, write: l14.write } })], u6.prototype, "baseType", void 0), u6 = r([a4("esri.rest.support.ImageVolumeParameters")], u6);
var y9 = u6;

// node_modules/@arcgis/core/rest/support/ImageVolume.js
var s10 = class extends S {
  constructor() {
    super(...arguments), this.area = null, this.cut = null, this.fill = null, this.maxZ = null, this.minZ = null, this.meanZ = null, this.cutCellCount = null, this.fillCellCount = null;
  }
};
r([m({ json: { write: true } })], s10.prototype, "area", void 0), r([m({ json: { write: true } })], s10.prototype, "cut", void 0), r([m({ json: { write: true } })], s10.prototype, "fill", void 0), r([m({ json: { name: "maxz", write: true } })], s10.prototype, "maxZ", void 0), r([m({ json: { name: "minz", write: true } })], s10.prototype, "minZ", void 0), r([m({ json: { name: "meanz", write: true } })], s10.prototype, "meanZ", void 0), r([m({ json: { write: true } })], s10.prototype, "cutCellCount", void 0), r([m({ json: { write: true } })], s10.prototype, "fillCellCount", void 0), s10 = r([a4("esri.rest.support.ImageVolume")], s10);
var i10 = s10;

// node_modules/@arcgis/core/rest/support/ImageVolumeResult.js
var p24 = class extends S {
  constructor() {
    super(...arguments), this.volumes = [];
  }
};
r([m({ type: [i10], json: { write: true } })], p24.prototype, "volumes", void 0), p24 = r([a4("esri.rest.support.ImageVolumeResult")], p24);
var m11 = p24;

// node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a16 = class extends a5.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r4, o5, e4) {
    null != r4 && (o5.geometryType = v(r4), o5[e4] = JSON.stringify(r4));
  }
};
r([m({ types: l2, json: { read: f, write: true } })], a16.prototype, "geometry", void 0), r([r2("geometry")], a16.prototype, "writeGeometry", null), r([m({ json: { write: true } })], a16.prototype, "rasterId", void 0), r([m({ json: { name: "options.VisibleOnly", write: true } })], a16.prototype, "visibleOnly", void 0), a16 = r([a4("esri.rest.support.MapToImageParameters")], a16);
var c21 = a16;

// node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var m12 = class extends S {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e4, r4) {
    return e4.spatialReference || (e4 = { ...e4, spatialReference: r4.Shape.spatialReference }), j.fromJSON(e4);
  }
};
r([m({ types: l2, json: { name: "Shape", read: f, write: true } })], m12.prototype, "geometry", void 0), r([m({ json: { name: "Length", write: true } })], m12.prototype, "length", void 0), r([m({ json: { name: "Area", write: true } })], m12.prototype, "area", void 0), r([m({ type: j, json: { name: "Center", write: true } })], m12.prototype, "center", void 0), r([o2("center")], m12.prototype, "readCenter", null), m12 = r([a4("esri.rest.support.MeasureAreaFromImageResult")], m12);
var i11 = m12;

// node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c22;
var y10 = c22 = class extends S {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r4, o5, e4) {
    null != r4 && (o5.geometryType = v(r4), o5[e4] = { ...r4.toJSON(), spatialReference: void 0 });
  }
  clone() {
    const r4 = a({ geometry: this.geometry, rasterId: this.rasterId });
    return new c22(r4);
  }
};
r([m({ types: l2, json: { name: "fromGeometry", read: f, write: true } })], y10.prototype, "geometry", void 0), r([r2("geometry")], y10.prototype, "writeGeometry", null), r([m({ json: { write: true } })], y10.prototype, "rasterId", void 0), y10 = c22 = r([a4("esri.rest.support.MeasureFromImageParameters")], y10);
var n10 = y10;

// node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m13 = class extends S {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
r([m({ types: l2, json: { name: "Shape", read: f, write: true } })], m13.prototype, "geometry", void 0), r([m({ json: { name: "Length", write: true } })], m13.prototype, "length", void 0), m13 = r([a4("esri.rest.support.MeasureLengthFromImageResult")], m13);
var i12 = m13;

// node_modules/@arcgis/core/rest/imageService.js
function B3(t8) {
  const e4 = t8 == null ? void 0 : t8.time;
  if (e4 && (null != e4.start || null != e4.end)) {
    const r4 = [];
    null != e4.start && r4.push(e4.start), null == e4.end || r4.includes(e4.end) || r4.push(e4.end), t8.time = r4.join(",");
  }
}
async function D(t8, r4, o5) {
  r4 = h(g3, r4);
  const s11 = f5(t8), p25 = r4.geometry ? [r4.geometry] : [], u7 = await R(p25), c23 = r4.toJSON();
  B3(c23);
  const f12 = u7 == null ? void 0 : u7[0];
  null != f12 && (c23.geometry = st(f12));
  const l15 = s2({ ...s11.query, f: "json", ...c23 });
  return i2(l15, o5);
}
async function k2(r4, o5, a17) {
  const s11 = (o5 = h(y9, o5)).toJSON();
  s11.geometries = JSON.stringify(s11.geometries);
  const p25 = f5(r4), u7 = s2({ ...p25.query, f: "json", ...s11 }), c23 = i2(u7, a17), { data: f12 } = await P(`${p25.path}/calculateVolume`, c23);
  return m11.fromJSON({ volumes: f12.results });
}
async function z(o5, a17, s11) {
  var _a, _b, _c;
  const p25 = (a17 = h(m6, a17)).toJSON();
  null != p25.angleName && (p25.angleName = p25.angleName.join(",")), ((_b = (_a = a17 == null ? void 0 : a17.point) == null ? void 0 : _a.spatialReference) == null ? void 0 : _b.imageCoordinateSystem) && (p25.point.spatialReference = nt(a17.point.spatialReference)), ((_c = a17 == null ? void 0 : a17.spatialReference) == null ? void 0 : _c.imageCoordinateSystem) && (p25.spatialReference = mt(a17.spatialReference));
  const u7 = f5(o5), l15 = s2({ ...u7.query, f: "json", ...p25 }), g5 = i2(l15, s11), { data: y11 } = await P(`${u7.path}/computeAngles`, g5);
  return y11.spatialReference = y11.spatialReference ? null != y11.spatialReference.geodataXform ? new g({ wkid: 0, imageCoordinateSystem: y11.spatialReference }) : g.fromJSON(y11.spatialReference) : null, "NaN" === y11.north && (y11.north = null), "NaN" === y11.up && (y11.up = null), new i5(y11);
}
async function E(r4, o5, a17) {
  var _a;
  const s11 = (o5 = h(a14, o5)).toJSON(), { geometries: p25 } = o5;
  if (p25) for (let t8 = 0; t8 < p25.length; t8++) ((_a = p25[t8].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (s11.geometries.geometries[t8].spatialReference = nt(p25[t8].spatialReference));
  const u7 = f5(r4), c23 = s2({ ...u7.query, f: "json", ...s11 }), f12 = i2(c23, a17), { data: l15 } = await P(`${u7.path}/computePixelLocation`, f12);
  return p18.fromJSON(l15);
}
async function X(e4, r4, o5) {
  const a17 = await D(e4, r4, o5), s11 = f5(e4), { data: m14 } = await P(`${s11.path}/computeStatisticsHistograms`, a17), { statistics: i13 } = m14;
  return (i13 == null ? void 0 : i13.length) && i13.forEach((t8) => {
    t8.avg = t8.mean, t8.stddev = t8.standardDeviation;
  }), { statistics: i13, histograms: m14.histograms };
}
async function K(e4, r4, o5) {
  const a17 = await D(e4, r4, o5), s11 = f5(e4), { data: m14 } = await P(`${s11.path}/computeHistograms`, a17);
  return { histograms: m14.histograms };
}
async function Q(r4, o5, s11) {
  var _a;
  const p25 = (o5 = h(j6, o5)).toJSON();
  B3(p25), ((_a = p25.outFields) == null ? void 0 : _a.length) && (p25.outFields = p25.outFields.join(","));
  const u7 = await R(o5.geometry), c23 = u7 == null ? void 0 : u7[0];
  null != c23 && (p25.geometry = st(c23));
  const f12 = f5(r4), l15 = s2({ ...f12.query, f: "json", ...p25 }), g5 = i2(l15, s11), { data: y11 } = await P(`${f12.path}/getSamples`, g5), j7 = y11.samples.map((t8) => {
    const e4 = "NaN" === t8.value || "" === t8.value ? null : t8.value.split(" ").map((t9) => Number(t9));
    return { ...t8, pixelValue: e4 };
  });
  return m10.fromJSON({ samples: j7 });
}
async function W(r4, o5, s11) {
  o5 = h(d9, o5);
  const p25 = f5(r4), u7 = o5.geometry ? [o5.geometry] : [];
  return R(u7).then((e4) => {
    const r5 = o5.toJSON(), a17 = e4 == null ? void 0 : e4[0];
    null != a17 && (r5.geometry = JSON.stringify(st(a17)));
    const n12 = s2({ ...p25.query, f: "json", ...r5 }), u8 = i2(n12, s11);
    return P(p25.path + "/identify", u8);
  }).then((t8) => l10.fromJSON(t8.data));
}
async function Y(t8, r4, o5) {
  r4 = h(c16, r4);
  const a17 = await et(t8, r4, [r4.fromGeometry, r4.toGeometry], o5);
  return a13.fromJSON(a17);
}
async function Z2(t8, r4, o5) {
  r4 = h(y4, r4);
  const a17 = await et(t8, r4, [r4.geometry], o5);
  return i6.fromJSON(a17);
}
async function _2(t8, r4, o5) {
  r4 = h(l11, r4);
  const a17 = await et(t8, r4, [r4.geometry], o5);
  return a15.fromJSON(a17);
}
async function tt(t8, r4, o5) {
  r4 = h(y5, r4);
  const a17 = await et(t8, r4, [r4.fromGeometry, r4.toGeometry], o5);
  return p13.fromJSON(a17);
}
async function et(e4, r4, o5, s11) {
  const p25 = f5(e4), u7 = await R(o5), c23 = r4.toJSON();
  null != u7[0] && (c23.fromGeometry = JSON.stringify(st(u7[0]))), null != u7[1] && (c23.toGeometry = JSON.stringify(st(u7[1])));
  const f12 = s2({ ...p25.query, f: "json", ...c23 }), l15 = i2(f12, s11), { data: g5 } = await P(p25.path + "/measure", l15);
  return g5;
}
async function rt(t8, e4, r4) {
  const o5 = await at(t8, e4, r4);
  return i12.fromJSON(o5);
}
async function ot(t8, e4, r4) {
  const o5 = await at(t8, e4, r4);
  return i11.fromJSON(o5);
}
async function at(r4, o5, a17) {
  o5 = h(n10, o5);
  const s11 = f5(r4), p25 = o5.toJSON(), u7 = s2({ ...s11.query, f: "json", ...p25 }), c23 = i2(u7, a17), { data: f12 } = await P(s11.path + "/measureFromImage", c23);
  return f12;
}
function st(t8) {
  var _a;
  const e4 = t8.toJSON();
  return ((_a = t8.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (e4.spatialReference = nt(t8.spatialReference)), e4;
}
function nt(t8) {
  const { imageCoordinateSystem: e4 } = t8;
  if (e4) {
    const { id: t9, referenceServiceName: r4 } = e4;
    return null != t9 ? r4 ? { icsid: t9, icsns: r4 } : { icsid: t9 } : { ics: e4 };
  }
  return t8.toJSON();
}
function mt(t8, e4) {
  if (!t8.imageCoordinateSystem) return c(t8);
  const r4 = nt(t8), { icsid: o5, icsns: a17 } = r4;
  return null == o5 || null != a17 && !(e4 == null ? void 0 : e4.toLowerCase().includes("/" + a17.toLowerCase() + "/")) ? JSON.stringify(r4) : `0:${o5}`;
}
async function it(r4, o5, a17) {
  o5 = h(c12, o5);
  const s11 = f5(r4), p25 = o5.toJSON();
  o5.outSpatialReference && (p25.outSR = mt(o5.outSpatialReference));
  const u7 = s2({ ...s11.query, f: "json", ...p25 }), c23 = i2(u7, a17), { data: f12 } = await P(s11.path + "/queryBoundary", c23);
  return i7.fromJSON(f12);
}
async function pt(r4, o5, s11) {
  var _a, _b;
  const p25 = (o5 = h(y6, o5)).toJSON();
  B3(p25), ((_a = p25.objectIds) == null ? void 0 : _a.length) && (p25.objectIds = p25.objectIds.join(",")), p25.geometry || p25.objectIds || p25.time || p25.where || (p25.where = "1=1");
  const u7 = await R(o5.geometry), c23 = u7 == null ? void 0 : u7[0];
  null != c23 && (p25.geometry = st(c23));
  const f12 = (c23 == null ? void 0 : c23.spatialReference) ?? ((_b = o5.geometry) == null ? void 0 : _b.spatialReference);
  f12 && (p25.inSR = mt(f12));
  const l15 = f5(r4), g5 = s2({ ...l15.query, f: "json", ...p25 }), y11 = i2(g5, s11), { data: j7 } = await P(`${l15.path}/queryGPSInfo`, y11);
  return a12.fromJSON(j7);
}
async function ut(r4, a17, s11) {
  const p25 = (a17 = h(l13, a17)).toJSON();
  a17.geometry.spatialReference.imageCoordinateSystem && (p25.geometry = st(a17.geometry)), a17.depthOffset && a17.adjust || delete p25.options;
  const u7 = f5(r4), c23 = s2({ ...u7.query, f: "json", ...p25 }), f12 = i2(c23, s11), { data: l15 } = await P(`${u7.path}/imageToMap`, f12);
  return f(l15);
}
async function ct(r4, a17, s11) {
  var _a;
  const p25 = (a17 = h(n9, a17)).toJSON();
  ((_a = a17.rasterIds) == null ? void 0 : _a.length) && (p25.rasterIds = a17.rasterIds.join(","));
  const u7 = f5(r4), c23 = s2({ ...u7.query, f: "json", ...p25 }), f12 = i2(c23, s11), { data: l15 } = await P(`${u7.path}/imageToMapMultiray`, f12);
  return f(l15);
}
async function ft(r4, s11, p25) {
  var _a;
  const u7 = (s11 = h(c21, s11)).toJSON(), c23 = await R(s11.geometry), f12 = c23 == null ? void 0 : c23[0];
  null != f12 && (u7.geometry = st(f12)), s11.visibleOnly || delete u7.options;
  const l15 = (f12 == null ? void 0 : f12.spatialReference) ?? ((_a = s11.geometry) == null ? void 0 : _a.spatialReference);
  l15 && (u7.inSR = mt(l15));
  const g5 = f5(r4), y11 = s2({ ...g5.query, f: "json", ...u7 }), j7 = i2(y11, p25), { data: d11 } = await P(`${g5.path}/mapToImage`, j7);
  return f(d11);
}
async function lt(r4, o5, a17) {
  const s11 = (o5 = h(i9, o5)).toJSON(), p25 = f5(r4), u7 = s2({ ...p25.query, f: "json", ...s11 }), c23 = i2(u7, a17), { data: f12 } = await P(`${p25.path}/getImageUrl`, c23);
  return p23.fromJSON(f12);
}
async function gt(r4, o5, s11) {
  var _a;
  const c23 = (o5 = h(m5, o5)).toJSON(), f12 = await R([o5.fromGeometry, o5.toGeometry]);
  null != f12[0] && (c23.fromGeometry = st(f12[0]), f12[0].spatialReference && (c23.inSR = mt(f12[0].spatialReference))), null != f12[1] && (c23.toGeometry = st(f12[1])), ((_a = o5.objectIds) == null ? void 0 : _a.length) && (c23.objectIds = c23.objectIds.join(","));
  const l15 = f5(r4), g5 = s2({ ...l15.query, f: "json", ...c23 }), y11 = i2(g5, s11), { data: j7 } = await P(`${l15.path}/find`, y11);
  return c9.fromJSON(j7);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n11(n12, m14, p25) {
  var _a, _b;
  const f12 = f5(n12), u7 = s2({ ...f12 == null ? void 0 : f12.query, f: "json" }), h5 = i2(u7, p25), d11 = `${f12 == null ? void 0 : f12.path}/${m14}/info`, c23 = P(`${d11}`, h5), g5 = P(`${d11}/keyProperties`, h5), x3 = await Promise.allSettled([c23, g5]), y11 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v5 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
  let P3 = null;
  ((_a = y11.statistics) == null ? void 0 : _a.length) && (P3 = y11.statistics.map((e4) => ({ min: e4[0], max: e4[1], avg: e4[2], stddev: e4[3] })));
  const S5 = w.fromJSON(y11.extent), j7 = Math.ceil(S5.width / y11.pixelSizeX - 0.1), w4 = Math.ceil(S5.height / y11.pixelSizeY - 0.1), b7 = S5.spatialReference, k3 = new j({ x: y11.pixelSizeX, y: y11.pixelSizeY, spatialReference: b7 }), z2 = ((_b = y11.histograms) == null ? void 0 : _b.length) ? y11.histograms : null, L2 = new n3({ origin: y11.origin, blockWidth: y11.blockWidth, blockHeight: y11.blockHeight, firstPyramidLevel: y11.firstPyramidLevel, maximumPyramidLevel: y11.maxPyramidLevel });
  return new d3({ width: j7, height: w4, bandCount: y11.bandCount, extent: S5, spatialReference: b7, pixelSize: k3, pixelType: y11.pixelType.toLowerCase(), statistics: P3, histograms: z2, keyProperties: v5, storageInfo: L2 });
}

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Ue2 = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Be2 = i(a2, { min: 0, max: 255 });
function Le(e4) {
  const t8 = JSON.stringify(e4), i13 = t8.includes('"rasterFunctionDefinition":{'), r4 = i13 ? t8.match(/"type":"(.*?FunctionArguments")/gi) : t8.match(/"rasterFunction":"(.*?")/gi), s11 = r4 == null ? void 0 : r4.map((e5) => i13 ? e5.slice(8, -18) : e5.slice(18, -1));
  return s11 ? s11.join("/") : null;
}
var ze = (c23) => {
  let m14 = class extends c23 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new d7({ layer: this }));
    }
    readServiceSupportsMosaicRule(e4, t8) {
      return this._isMosaicRuleSupported(t8);
    }
    get _rasterFunctionNamesIndex() {
      const e4 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t8) => {
        e4.set(t8.name.toLowerCase().replaceAll(/ /gi, "_"), t8.name);
      }), e4;
    }
    readBandIds(e4, t8) {
      if (Array.isArray(e4) && e4.length > 0 && e4.every((e5) => "number" == typeof e5)) return e4;
    }
    readCapabilities(e4, t8) {
      return this._readCapabilities(t8);
    }
    writeCompressionQuality(e4, t8, i13) {
      null != e4 && "lerc" !== this.format && (t8[i13] = e4);
    }
    writeCompressionTolerance(e4, t8, i13) {
      "lerc" === this.format && null != e4 && (t8[i13] = e4);
    }
    readDefaultMosaicRule(e4, t8) {
      return this._serviceSupportsMosaicRule ? f6.fromJSON(t8) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e4) {
      e4 && Ue2.has(e4.toLowerCase()) && this._set("format", e4.toLowerCase());
    }
    readFormat(e4, t8) {
      return "esriImageServiceDataTypeVector-UV" === t8.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t8.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e4, t8) {
      return null != t8.minLOD && null != t8.maxLOD ? e4 : 0;
    }
    readMaxScale(e4, t8) {
      return null != t8.minLOD && null != t8.maxLOD ? e4 : 0;
    }
    set mosaicRule(e4) {
      let t8 = e4;
      (t8 == null ? void 0 : t8.mosaicMethod) && (t8 = f6.fromJSON({ ...t8.toJSON(), mosaicMethod: t8.mosaicMethod, mosaicOperation: t8.mosaicOperation })), this._set("mosaicRule", t8);
    }
    readMosaicRule(e4, t8) {
      const i13 = e4 || t8.mosaicRule;
      return i13 ? f6.fromJSON(i13) : this._isMosaicRuleSupported(t8) ? f6.fromJSON(t8) : null;
    }
    writeMosaicRule(e4, t8, i13) {
      const { mosaicRule: r4 } = this;
      this._isValidCustomizedMosaicRule(r4) && (t8[i13] = r4.toJSON());
    }
    writeNoData(e4, t8, i13) {
      null != e4 && "number" == typeof e4 && (t8[i13] = Be2(e4));
    }
    readObjectIdField(e4, t8) {
      if (!e4) {
        const i13 = t8.fields.find((e5) => "esriFieldTypeOID" === e5.type || "oid" === e5.type);
        e4 = i13 == null ? void 0 : i13.name;
      }
      return e4;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e4, t8) {
      return this._isMosaicDataset(t8) ? "mosaic-dataset" : "raster-dataset";
    }
    get renderer() {
      const { activePresetRendererName: e4, presetRenderers: t8 } = this;
      if (e4) {
        const i13 = t8 == null ? void 0 : t8.find(({ name: t9 }) => t9 === e4);
        return i13 == null ? void 0 : i13.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e4) {
      this.activePresetRendererName = null, this.internalRenderer = e4;
    }
    set internalRenderer(e4) {
      this.loaded && (e4 = this._configRenderer(e4)), this._set("internalRenderer", e4);
    }
    readRenderer(e4, t8, i13) {
      var _a, _b;
      const r4 = (_b = (_a = t8 == null ? void 0 : t8.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, s11 = c5(r4, i13);
      return null == s11 ? null : ("vector-field" === s11.type && t8.symbolTileSize && !r4.symbolTileSize && (s11.symbolTileSize = t8.symbolTileSize), p8(s11) || n.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), s11);
    }
    writeRenderer(e4, t8, i13) {
      t8.layerDefinition = t8.layerDefinition || {}, t8.layerDefinition.drawingInfo = t8.layerDefinition.drawingInfo || {}, t8.layerDefinition.drawingInfo.renderer = e4.toJSON(), "vector-field" === e4.type && (t8.symbolTileSize = e4.symbolTileSize);
    }
    get rasterFields() {
      var _a, _b, _c, _d;
      const e4 = ((_a = this.fields) == null ? void 0 : _a.map((e5) => e5.clone())) ?? [];
      e4.push(o3()), "mosaic-dataset" === this.sourceType && ((_b = this.fields) == null ? void 0 : _b.length) && e4.push(m2()), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some(({ name: e5 }) => "none" === e5.toLowerCase()) && e4.push(c4()), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter(({ name: e5 }) => "none" !== e5.toLowerCase()).forEach(({ name: t9 }) => e4.push(f7(t9)));
      const { rasterInfo: t8 } = this;
      if (this._isVectorDataSet()) {
        const i14 = (_d = (_c = t8 == null ? void 0 : t8.multidimensionalInfo) == null ? void 0 : _c.variables[0].unit) == null ? void 0 : _d.trim(), r4 = d5(i14), s11 = $();
        e4.push(r4, s11);
      }
      if ((t8 == null ? void 0 : t8.multidimensionalInfo) && "raster-dataset" === this.sourceType) {
        const i14 = p5(t8.multidimensionalInfo);
        e4.push(...i14);
      }
      const i13 = t8 == null ? void 0 : t8.attributeTable;
      if (null != i13) {
        const t9 = v2(i13);
        e4.push(...t9);
      }
      return e4;
    }
    set rasterFunction(e4) {
      let t8 = e4;
      (t8 == null ? void 0 : t8.rasterFunction) && (t8 = w2.fromJSON({ ...t8.toJSON(), rasterFunction: t8.rasterFunction, rasterFunctionArguments: t8.rasterFunctionArguments })), this._set("rasterFunction", t8);
    }
    readRasterFunction(e4, t8) {
      const i13 = t8.rasterFunctionInfos;
      return t8.renderingRule || (i13 == null ? void 0 : i13.length) && "None" !== i13[0].name ? this._isRFTJson(t8.renderingRule) ? w2.fromJSON({ rasterFunctionDefinition: t8.renderingRule }) : w2.fromJSON(t8.renderingRule || { rasterFunctionInfos: t8.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e4, t8) {
      const i13 = e4 || t8.extent.spatialReference;
      return i13 ? g.fromJSON(i13) : null;
    }
    writePixelType(e4, t8, i13) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t8[i13] = n2.toJSON(e4));
    }
    readVersion(e4, t8) {
      let i13 = t8.currentVersion;
      return i13 || (i13 = t8.hasOwnProperty("fields") || t8.hasOwnProperty("timeInfo") ? 10 : 9.3), i13;
    }
    applyFilter(e4) {
      let t8 = e4;
      return this.pixelFilter && (t8 = this._clonePixelData(e4), this.pixelFilter(t8)), t8;
    }
    async applyRenderer(e4, t8) {
      let i13 = e4;
      const { renderer: r4, symbolizer: s11, pixelFilter: n12, bandIds: a17 } = this;
      if (!this._isPicture() && r4 && s11 && !n12) {
        const n13 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(r4.toJSON()), o5 = this._rasterJobHandler.instance;
        if (o5) {
          n13 && (s11.bind(), await o5.updateSymbolizer(s11, t8), this._cachedRendererJson = r4.toJSON());
          const l15 = await o5.symbolize({ bandIds: a17, ...e4 }, t8);
          i13 = { extent: e4.extent, pixelBlock: l15 };
        } else i13 = { extent: e4.extent, pixelBlock: s11.symbolize({ bandIds: a17, ...e4 }) };
      }
      return i13;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async calculateVolume(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsCalculateVolume) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e4 = a(e4), this.mosaicRule && null == e4.mosaicRule && (e4.mosaicRule = this.mosaicRule), k2(this.url, e4, this._getRequestOptions(t8));
    }
    async computeAngles(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsComputeAngles) throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return z(this.url, e4, this._getRequestOptions(t8));
    }
    async computePixelSpaceLocations(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsComputePixelLocation) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return E(this.url, e4, this._getRequestOptions(t8));
    }
    async computeHistograms(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsComputeHistograms) throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), K(this.url, e4, this._getRequestOptions(t8));
    }
    async computeStatisticsHistograms(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsComputeStatisticsHistograms) throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), X(this.url, e4, this._getRequestOptions(t8));
    }
    async measureHeight(e4, t8) {
      const i13 = await this._fetchCapabilities(t8 == null ? void 0 : t8.signal);
      if (!("base-and-top" === e4.operationType ? i13.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e4.operationType ? i13.mensuration.supportsHeightFromBaseAndTopShadow : i13.mensuration.supportsHeightFromTopAndTopShadow)) throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicRule(e4), Y(this.url, e4, this._getRequestOptions(t8));
    }
    async measureAreaAndPerimeter(e4, t8) {
      const i13 = await this._fetchCapabilities(t8 == null ? void 0 : t8.signal);
      if (!(i13.mensuration.supportsAreaAndPerimeter && (!e4.is3D || i13.mensuration.supports3D))) throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicRule(e4), Z2(this.url, e4, this._getRequestOptions(t8));
    }
    async measureDistanceAndAngle(e4, t8) {
      const i13 = await this._fetchCapabilities(t8 == null ? void 0 : t8.signal);
      if (!(i13.mensuration.supportsDistanceAndAngle && (!e4.is3D || i13.mensuration.supports3D))) throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicRule(e4), tt(this.url, e4, this._getRequestOptions(t8));
    }
    async measurePointOrCentroid(e4, t8) {
      const i13 = await this._fetchCapabilities(t8 == null ? void 0 : t8.signal);
      if (!(i13.mensuration.supportsPointOrCentroid && (!e4.is3D || i13.mensuration.supports3D))) throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicRule(e4), _2(this.url, e4, this._getRequestOptions(t8));
    }
    async measureLengthFromImage(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
      if ("polyline" !== e4.geometry.type) throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
      return rt(this.url, e4, this._getRequestOptions(t8));
    }
    async measureAreaFromImage(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
      if ("polygon" !== e4.geometry.type) throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
      return ot(this.url, e4, this._getRequestOptions(t8));
    }
    getField(e4) {
      const { fieldsIndex: t8 } = this;
      return null != t8 ? t8.get(e4) : void 0;
    }
    getFieldDomain(e4, t8) {
      const i13 = this.getField(e4);
      return i13 ? i13.domain : null;
    }
    async fetchImage(e4, t8, i13, s11 = {}) {
      if (null == e4 || null == t8 || null == i13) throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e5 = await this._generateRasterInfo(this.rasterFunction, { signal: s11.signal });
        e5 && (this.rasterInfo = e5);
      }
      const n12 = this.getExportImageServiceParameters(e4, t8, i13, s11.timeExtent);
      if (null == n12) {
        if (s11.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e5 = document.createElement("canvas");
          if (e5.width = t8, e5.height = i13, s11.returnImageBitmap) {
            return { imageBitmap: await t2(e5, `${ze2(this.parsedUrl)}/exportImage`, s11.signal) };
          }
          return { imageOrCanvasElement: e5 };
        }
        const { bandIds: r4, rasterInfo: n13 } = this, a18 = ((r4 == null ? void 0 : r4.length) || n13.bandCount) ?? 0, o6 = t8 * i13, l16 = n13.pixelType, u7 = [];
        for (let e5 = 0; e5 < a18; e5++) u7.push(g2.createEmptyBand(l16, o6));
        return { pixelData: { pixelBlock: new g2({ width: t8, height: i13, pixels: u7, mask: new Uint8Array(o6), pixelType: l16 }), extent: e4 } };
      }
      const a17 = !!s11.requestAsImageElement && !this.pixelFilter, o5 = a17 && !!s11.returnImageBitmap, l15 = { imageServiceParameters: n12, imageProps: { extent: e4, width: t8, height: i13, format: this.format }, requestAsImageElement: a17, returnImageBitmap: o5, signal: s11.signal };
      return this._requestArrayBuffer(l15);
    }
    fetchKeyProperties(e4) {
      return P(ze2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => e5.data);
    }
    fetchRasterAttributeTable(e4) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : P(ze2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => d4.fromJSON(e5.data));
    }
    getCatalogItemRasterInfo(e4, t8) {
      const i13 = { ...t8, query: this._getQueryParams() };
      return n11(ze2(this.parsedUrl), e4, i13);
    }
    async getCatalogItemICSInfo(e4, t8) {
      var _a, _b, _c, _d, _e;
      const { data: r4 } = await P(ze2(this.parsedUrl) + "/" + e4 + "/info/ics", { query: this._getQueryParams(), ...t8 }), s11 = r4 == null ? void 0 : r4.ics;
      if (!s11) return;
      let n12 = null;
      try {
        n12 = (await P(ze2(this.parsedUrl) + "/" + e4 + "/info", { query: this._getQueryParams(), ...t8 })).data.extent;
      } catch {
      }
      if (!(n12 == null ? void 0 : n12.spatialReference)) return { ics: s11, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const a17 = this.version >= 10.7 ? P(ze2(this.parsedUrl) + "/" + e4 + "/info/icstopixel", { query: this._getQueryParams(), ...t8 }).then((e5) => e5.data).catch(() => ({})) : {}, o5 = n12.spatialReference, l15 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [n12] }), inSR: c(o5), outSR: "0:" + e4 }, u7 = P(ze2(this.parsedUrl) + "/project", { query: this._getQueryParams(l15), ...t8 }).then((e5) => e5.data).catch(() => ({})), p25 = 5, c24 = (n12.xmin + n12.xmax) / 2, m15 = (n12.ymax - n12.ymin) / (p25 + 1), d11 = n12.ymin + m15, h5 = [];
      for (let i13 = 0; i13 < p25; i13++) h5.push({ x: c24, y: d11 + m15 * i13 });
      const f12 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h5 }), inSR: c(o5), outSR: "0:" + e4 }, g5 = P(ze2(this.parsedUrl) + "/project", { query: this._getQueryParams(f12), ...t8 }).then((e5) => e5.data).catch(() => ({})), I2 = await Promise.all([a17, u7, g5]);
      let w4 = I2[0].ipxf;
      if (null == w4) {
        const e5 = (_a = s11.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e5 == null ? void 0 : e5.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e5 == null ? void 0 : e5.coefficients) == null ? void 0 : _c.length) && (w4 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e5.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const v5 = w.fromJSON((_e = (_d = I2[1]) == null ? void 0 : _d.geometries) == null ? void 0 : _e[0]);
      v5 && (v5.spatialReference = new g({ wkid: 0, imageCoordinateSystem: s11 }));
      const S5 = I2[2].geometries ? I2[2].geometries.filter((e5) => null != (e5 == null ? void 0 : e5.x) && null != e5.y && "NaN" !== e5.x && "NaN" !== e5.y) : [], _4 = S5.length;
      if (_4 < 3) return { ics: s11, icsToPixelTransform: w4, icsExtent: v5, northDirection: null };
      let x3 = 0, F2 = 0, D2 = 0, T2 = 0;
      for (let i13 = 0; i13 < _4; i13++) x3 += S5[i13].x, F2 += S5[i13].y, D2 += S5[i13].x * S5[i13].x, T2 += S5[i13].x * S5[i13].y;
      const O = (_4 * T2 - x3 * F2) / (_4 * D2 - x3 * x3);
      let C3 = 0;
      const M = S5[p25 - 1].x > S5[0].x, N2 = S5[p25 - 1].y > S5[0].y;
      return O === 1 / 0 ? C3 = N2 ? 90 : 270 : 0 === O ? C3 = M ? 0 : 180 : O > 0 ? C3 = M ? 180 * Math.atan(O) / Math.PI : 180 * Math.atan(O) / Math.PI + 180 : O < 0 && (C3 = N2 ? 180 + 180 * Math.atan(O) / Math.PI : 360 + 180 * Math.atan(O) / Math.PI), { ics: s11, icsToPixelTransform: w4, icsExtent: v5, northDirection: C3 };
    }
    async generateRasterInfo(e4, t8) {
      var _a;
      e4 = h(w2, e4);
      const i13 = { ...t8, query: this._getQueryParams() };
      if (!e4 || "none" === ((_a = e4.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e4)) return this.serviceRasterInfo ?? f9(ze2(this.parsedUrl), this.sourceJSON, i13);
      const s11 = Le(e4);
      if (!s11) throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[s11]) return this._functionRasterInfos[s11];
      const n12 = p7(ze2(this.parsedUrl), e4, i13);
      this._functionRasterInfos[s11] = n12;
      try {
        return await n12;
      } catch (a17) {
        throw this._functionRasterInfos[s11] = null, a17;
      }
    }
    getExportImageServiceParameters(e4, t8, i13, r4) {
      var _a, _b;
      e4 = e4.clone().shiftCentralMeridian();
      const s11 = mt(e4.spatialReference, ze2(this.parsedUrl)), n12 = this.exportImageServiceParameters.toJSON(), { bandIds: a17, noData: o5 } = n12;
      let { renderingRule: l15 } = n12;
      const u7 = (_a = this.rasterFunction) == null ? void 0 : _a.rasterFunctionDefinition, p25 = (_b = this.renderer) == null ? void 0 : _b.type, c24 = !p25 || "raster-stretch" === p25 || "raster-colormap" === p25 || "unique-value" === p25 || "class-breaks" === p25 || "raster-shaded-relief" === p25;
      if ((a17 == null ? void 0 : a17.length) && this._hasRasterFunction(this.rasterFunction) && !u7 && c24) {
        const e5 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: a17 } };
        if ("Stretch" === l15.rasterFunction) e5.rasterFunctionArguments.Raster = l15.rasterFunctionArguments.Raster, l15.rasterFunctionArguments.Raster = e5;
        else if ("Colormap" === l15.rasterFunction) {
          const t9 = l15.rasterFunctionArguments.Raster;
          "Stretch" === (t9 == null ? void 0 : t9.rasterFunction) ? (e5.rasterFunctionArguments.Raster = t9.rasterFunctionArguments.Raster, t9.rasterFunctionArguments.Raster = e5) : (e5.rasterFunctionArguments.Raster = t9, l15.rasterFunctionArguments.Raster = e5);
        } else e5.rasterFunctionArguments.Raster = l15, l15 = e5;
        n12.bandIds = void 0;
      } else n12.bandIds = a17 == null ? void 0 : a17.join(",");
      Array.isArray(o5) && o5.length > 0 && (n12.noData = o5.join(","));
      const m15 = this._processMultidimensionalIntersection(null, r4, this.exportImageServiceParameters.mosaicRule);
      if (m15.isOutSide) return null;
      n12.mosaicRule = null != m15.mosaicRule ? JSON.stringify(m15.mosaicRule) : null, r4 = m15.timeExtent, n12.renderingRule = this._getRenderingRuleString(w2.fromJSON(l15));
      const d11 = {};
      if (null != r4) {
        const { start: e5, end: t9 } = r4.toJSON();
        e5 && t9 && e5 === t9 ? d11.time = "" + e5 : null == e5 && null == t9 || (d11.time = `${e5 ?? "null"},${t9 ?? "null"}`);
      }
      return { bbox: e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax, bboxSR: s11, imageSR: s11, size: t8 + "," + i13, ...n12, ...d11 };
    }
    async getSamples(e4, t8) {
      const i13 = await this._fetchCapabilities(t8 == null ? void 0 : t8.signal);
      if (!(i13 == null ? void 0 : i13.operations.supportsGetSamples)) throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e4 = a(e4);
      const { raster: n12 } = this;
      return n12 && null == e4.raster && (e4.raster = n12), Q(this.url, e4, this._getRequestOptions(t8));
    }
    async identify(e4, t8) {
      var _a;
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsIdentify) throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
      e4 = a(e4), this.version < 10.91 && "extent" === ((_a = e4.geometry) == null ? void 0 : _a.type) && (e4.geometry = j2.fromExtent(e4.geometry));
      const i13 = this._processMultidimensionalIntersection(e4.geometry, e4.timeExtent, e4.mosaicRule || this.mosaicRule);
      if (i13.isOutSide) throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e4.timeExtent = i13.timeExtent, e4.mosaicRule = i13.mosaicRule;
      const { raster: n12, rasterFunction: a17 } = this;
      return a17 && null == e4.rasterFunction && (e4.rasterFunction = a17), n12 && null == e4.raster && (e4.raster = n12), W(this.url, e4, this._getRequestOptions(t8));
    }
    async imageToMap(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsImageToMap) throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
      return ut(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async imageToMapMultiray(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsImageToMapMultiray) throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
      return ct(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async mapToImage(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsMapToImage) throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
      return ft(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async findImages(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsFindImages) throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
      return gt(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async getImageUrl(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsGetImageUrl) throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
      return lt(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    createQuery() {
      return new b2({ outFields: ["*"], returnGeometry: true, where: this.definitionExpression || "1=1" });
    }
    async queryBoundary(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsQueryBoundary) throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
      return e4 = e4 ?? { outSpatialReference: this.spatialReference }, it(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async queryRasters(e4, t8) {
      return { query: e4, requestOptions: t8 } = await this._prepareForQuery(e4, t8), s8(this.url, e4, t8);
    }
    async queryObjectIds(e4, t8) {
      return { query: e4, requestOptions: t8 } = await this._prepareForQuery(e4, t8), s7(this.url, e4, t8);
    }
    async queryGPSInfo(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsQueryGPSInfo) throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
      return e4 = e4 ?? { where: "1=1" }, pt(ze2(this.parsedUrl), e4, this._getRequestOptions(t8));
    }
    async queryRasterCount(e4, t8) {
      return { query: e4, requestOptions: t8 } = await this._prepareForQuery(e4, t8), s6(this.url, e4, t8);
    }
    async queryVisibleRasters(e4, t8) {
      var _a, _b, _c, _d;
      if (!e4) throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: i13, returnDomainValues: s11, returnTopmostRaster: n12, showNoDataRecords: a17 } = t8 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o5 = false, l15 = null, u7 = null;
      const p25 = t4.servicePixelValue.toLowerCase(), c24 = this._rasterFunctionNamesIndex;
      if (null != e4.outFields && (o5 = e4.outFields.some((e5) => !e5.toLowerCase().startsWith(p25)), this.version >= 10.4)) {
        const t9 = e4.outFields.filter((e5) => e5.toLowerCase().startsWith(p25) && e5.length > p25.length).map((e5) => {
          const t10 = e5.slice(p25.length + 1);
          return [this._updateRenderingRulesFunctionName(t10, c24), t10];
        });
        l15 = t9.map((e5) => new w2({ functionName: e5[0] })), u7 = t9.map((e5) => e5[1]);
        const { rasterFunction: i14 } = this;
        0 === l15.length ? (i14 == null ? void 0 : i14.functionName) ? (l15.push(i14), u7.push(i14.functionName)) : l15 = null : (i14 == null ? void 0 : i14.functionName) && !l15.some((e5) => e5.functionName === i14.functionName) && (l15.push(i14), u7.push(i14.functionName));
      }
      const m15 = null == e4.outSpatialReference || e4.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: d11 } = this;
      let h5 = e4.timeExtent || this.timeExtent;
      if (d11) {
        const { isOutside: t9, intersection: i14 } = m3(d11, { geometry: e4.geometry, timeExtent: e4.timeExtent, multidimensionalDefinition: (_a = this.exportImageServiceParameters.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition });
        if (t9) throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != (i14 == null ? void 0 : i14.timeExtent) && (h5 = i14.timeExtent);
      }
      const f12 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h5);
      let y11 = e4.geometry;
      this.version < 10.91 && "extent" === (y11 == null ? void 0 : y11.type) && (y11 = j2.fromExtent(y11));
      const R3 = this._getQueryParams({ geometry: y11, timeExtent: h5, mosaicRule: f12, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l15, pixelSize: i13, returnCatalogItems: o5, returnGeometry: m15, raster: this.raster, maxItemCount: n12 ? 1 : null });
      delete R3.f;
      const b7 = new d9(R3);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const i14 = await W(this.url, b7, { signal: t8 == null ? void 0 : t8.signal, query: { ...this.customParameters } }), r4 = e4.outFields, n13 = null != i14.value && i14.value.toLowerCase().includes("nodata"), l16 = o5 && !m15 && ((_b = i14 == null ? void 0 : i14.catalogItems) == null ? void 0 : _b.features.length) && (a17 || !n13), p26 = this.multidimensionalInfo && "raster-dataset" === this.sourceType ? f8({ rasterInfo: this.rasterInfo, multidimensionalDefinition: f12 == null ? void 0 : f12.multidimensionalDefinition, timeExtent: h5, multidimensionalSubset: this.multidimensionalSubset }) : null;
        if (!l16) return this._processVisibleRastersResponse(i14, { returnDomainValues: s11, templateRRFunctionNames: u7, showNoDataRecords: a17, templateFields: r4, effectiveMultidimensionalDefinition: p26 });
        const c25 = this.objectIdField || "ObjectId", d12 = ((_c = i14.catalogItems) == null ? void 0 : _c.features) ?? [], y12 = d12.map((e5) => {
          var _a2;
          return (_a2 = e5.attributes) == null ? void 0 : _a2[c25];
        }), g5 = new b2({ objectIds: y12, returnGeometry: true, outSpatialReference: e4.outSpatialReference, outFields: [c25] }), R4 = await this.queryRasters(g5);
        return ((_d = R4 == null ? void 0 : R4.features) == null ? void 0 : _d.length) && R4.features.forEach((t9) => {
          d12.forEach((i15) => {
            i15.attributes[c25] === t9.attributes[c25] && t9.geometry && (i15.geometry = t9.geometry.clone(), null != e4.outSpatialReference && (i15.geometry.spatialReference = e4.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(i14, { returnDomainValues: s11, templateRRFunctionNames: u7, showNoDataRecords: a17, templateFields: r4, effectiveMultidimensionalDefinition: p26 });
      } catch {
        throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e4, t8) {
      const r4 = P(ze2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e4 }), signal: t8 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.statistics;
      }), s11 = P(ze2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e4 }), signal: t8 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.histograms;
      }), n12 = await Promise.all([r4, s11]);
      return n12[0] && n12[0].forEach((e5) => {
        e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
      }), { statistics: n12[0] || null, histograms: n12[1] || null };
    }
    async createFlowMesh(e4, t8) {
      const i13 = this._rasterJobHandler.instance;
      return i13 ? i13.createFlowMesh(e4, t8) : s5(e4.meshType, e4.simulationSettings, e4.flowData, null != t8.signal ? t8.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e4) {
      const t8 = e4 ?? this.serviceRasterInfo.multidimensionalInfo;
      return v3(this.multidimensionalSubset, t8);
    }
    async _fetchService(e4) {
      await this._fetchServiceInfo(e4), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t8 = this.sourceJSON, i13 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : f9(ze2(this.parsedUrl), t8, { signal: e4, query: this._getQueryParams() }).then((e5) => (this._set("serviceRasterInfo", e5), this._set("multidimensionalInfo", e5.multidimensionalInfo), c6(e5, t8), e5)), r4 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e4 }) : null, s11 = this._getRasterFunctionInfos();
      return Promise.all([i13, r4, s11]).then((e5) => {
        e5[1] ? this._set("rasterInfo", e5[1]) : this._set("rasterInfo", e5[0]), e5[2] && this._set("rasterFunctionInfos", e5[2]), this.internalRenderer && !this._isSupportedRenderer(this.internalRenderer) && (this._set("internalRenderer", null), n.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("internalRenderer", this._configRenderer(this.renderer)), this.addHandles([d(() => this.rasterFunction, (e6) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e6).then((e7) => {
            e7 && (this.rasterInfo = e7);
          });
        })]);
        const { serviceRasterInfo: t9 } = this;
        null != t9.multidimensionalInfo && this._updateMultidimensionalDefinition(t9);
      });
    }
    _combineMosaicRuleWithTimeExtent(e4, t8) {
      var _a;
      const i13 = this.timeInfo, { multidimensionalInfo: r4 } = this.serviceRasterInfo;
      if (null == e4 || null == r4 || null == t8 || null == (i13 == null ? void 0 : i13.startField)) return e4;
      const { startField: s11 } = i13, n12 = r4.variables.some((e5) => e5.dimensions.some((e6) => e6.name === s11)) ? s11 : "StdTime";
      if (e4 = e4.clone(), "mosaic-dataset" === this.sourceType) return e4.multidimensionalDefinition = (_a = e4.multidimensionalDefinition) == null ? void 0 : _a.filter((e5) => e5.dimensionName !== n12), this._cleanupMultidimensionalDefinition(e4);
      e4.multidimensionalDefinition = e4.multidimensionalDefinition || [];
      const a17 = e4.multidimensionalDefinition.filter((e5) => e5.dimensionName === n12), o5 = null != t8.start ? t8.start.getTime() : null, l15 = null != t8.end ? t8.end.getTime() : null, u7 = null == o5 || null == l15 || o5 === l15, p25 = u7 ? [o5 || l15] : [[o5, l15]], c24 = this.version >= 10.8;
      if (a17.length) a17.forEach((e5) => {
        e5.dimensionName === n12 && (c24 ? (e5.dimensionName = null, e5.isSlice = false, e5.values = []) : (e5.isSlice = u7, e5.values = p25));
      });
      else if (!c24) {
        const t9 = e4.multidimensionalDefinition.filter((e5) => null != e5.variableName && null == e5.dimensionName);
        t9.length ? t9.forEach((e5) => {
          e5.dimensionName = n12, e5.isSlice = u7, e5.values = p25;
        }) : e4.multidimensionalDefinition.push(new p4({ variableName: "", dimensionName: n12, isSlice: u7, values: p25 }));
      }
      return this._cleanupMultidimensionalDefinition(e4);
    }
    _cleanupMultidimensionalDefinition(e4) {
      return null == e4 ? null : (e4.multidimensionalDefinition && (e4.multidimensionalDefinition = e4.multidimensionalDefinition.filter((e5) => !(!e5.variableName && !e5.dimensionName)), 0 === e4.multidimensionalDefinition.length && (e4.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e4.multidimensionalDefinition ? null : e4);
    }
    async _prepareForQuery(e4, t8) {
      if (!(await this._fetchCapabilities(t8 == null ? void 0 : t8.signal)).operations.supportsQuery) throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e4 = null != e4 ? h(b2, e4) : this.createQuery(), t8 = this._getRequestOptions(t8), this.raster && (t8.query = { ...t8.query, raster: this.raster }), { query: e4, requestOptions: t8 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise) return this._rasterJobHandler.connectionPromise;
      const e4 = new t5();
      this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        this._rasterJobHandler.instance = e4;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e4) {
      const { rasterInfo: t8, rasterFunction: i13 } = this;
      return "unique-value" === e4.type && this._hasRasterFunction(i13) && 1 === (t8 == null ? void 0 : t8.bandCount) && ["u8", "s8"].includes(t8.pixelType) || null != t8 && null != e4 && B2(t8).includes(e4.type);
    }
    async _fetchCapabilities(e4) {
      return this.capabilities || await this._fetchServiceInfo(e4), this.capabilities;
    }
    async _fetchServiceInfo(e4) {
      var _a;
      let t8 = this.sourceJSON;
      if (!t8) {
        const { data: r4, ssl: s11 } = await P(ze2(this.parsedUrl), { query: this._getQueryParams(), signal: e4 });
        t8 = r4, this.sourceJSON = t8, s11 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t8.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e5) => e5.trim()).indexOf("tilesonly")) > -1) throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t8, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e4) {
      var _a;
      return e4.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e4.serviceSourceType : ((_a = e4.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e4) {
      var _a;
      if (!e4) return false;
      const t8 = this._isMosaicDataset(e4), i13 = e4.currentVersion >= 10.71 && e4.hasMultidimensions && !(((_a = e4.fields) == null ? void 0 : _a.length) > 1);
      return t8 || i13;
    }
    _isVectorFieldResampleFunction(e4) {
      if (null == e4) return false;
      const { functionName: t8, functionArguments: i13 } = e4, r4 = "resample" === (t8 == null ? void 0 : t8.toLowerCase()), s11 = (i13 == null ? void 0 : i13.ResampleType) || (i13 == null ? void 0 : i13.resampleType);
      return r4 && (7 === s11 || 10 === s11);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e4) {
      var _a, _b, _c;
      const t8 = this._isPicture(), { rasterInfo: i13 } = this;
      if (!t8 && !this.pixelFilter || this._isVectorDataSet()) {
        const t9 = (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName, r4 = L({ variableName: t9, rasterFunctionName: (_c = this.rasterFunction) == null ? void 0 : _c.functionName, presetRenderers: this.presetRenderers });
        if (!this.bandIds && i13.bandCount >= 3) {
          const e5 = (r4 == null ? void 0 : r4.bandIds) ?? U(i13);
          !e5 || 3 === i13.bandCount && 0 === e5[0] && 1 === e5[1] && 2 === e5[2] || (this.bandIds = e5);
        }
        e4 || (e4 = (r4 == null ? void 0 : r4.renderer) ?? q(i13, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : t9 }));
        const s11 = ee(e4.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = s11, this.symbolizer.rasterInfo = i13) : this.symbolizer = new _({ rendererJSON: s11, rasterInfo: i13 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e4;
    }
    _clonePixelData(e4) {
      return null == e4 ? e4 : { extent: e4.extent && e4.extent.clone(), pixelBlock: null != e4.pixelBlock ? e4.pixelBlock.clone() : null };
    }
    _getQueryParams(e4) {
      null != (e4 == null ? void 0 : e4.renderingRule) && "string" != typeof e4.renderingRule && (e4.renderingRule = this._getRenderingRuleString(e4.renderingRule));
      const { raster: t8, viewId: i13 } = this;
      return { raster: t8, viewId: i13, f: "json", ...e4, ...this.customParameters };
    }
    _getRequestOptions(e4) {
      return { ...e4, query: { ...e4 == null ? void 0 : e4.query, ...this.customParameters } };
    }
    _decodePixelBlock(e4, t8, i13) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e4, options: t8 }) : j4(e4, t8, i13);
    }
    async _getRasterFunctionInfos(e4) {
      var _a;
      const t8 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded) return t8;
      if (t8 && this.version >= 10.3) {
        if (1 === t8.length && "none" === t8[0].name.toLowerCase()) return t8;
        const r4 = await P(ze2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e4 });
        return (_a = r4.data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e4) {
      return !this.pixelFilter && (!e4 || e4.includes("png"));
    }
    async _requestArrayBuffer(e4) {
      const { imageProps: t8, requestAsImageElement: s11, returnImageBitmap: n12, signal: a17 } = e4;
      if (s11 && this._canRequestImageElement(t8.format)) {
        const r4 = `${ze2(this.parsedUrl)}/exportImage`, { data: s12 } = await P(r4, { responseType: n12 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e4.imageServiceParameters }), signal: a17 });
        if (s12 instanceof Blob) {
          return { imageBitmap: await t2(s12, r4, a17), params: t8 };
        }
        return { imageOrCanvasElement: s12, params: t8 };
      }
      const o5 = this._initJobHandler(), l15 = P(ze2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e4.imageServiceParameters }), signal: a17 }), u7 = (await Promise.all([l15, o5]))[0].data, p25 = t8.format || "jpgpng";
      let c24 = p25;
      if ("bsq" !== c24 && "bip" !== c24 && (c24 = P2(u7)), !c24) throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u7)));
      const m15 = { signal: a17 }, d11 = "gif" === p25 || "bmp" === p25 || p25.includes("png") && ("png" === c24 || "jpg" === c24) ? j4(u7, { useCanvas: true, ...t8 }, m15) : this._decodePixelBlock(u7, { width: t8.width, height: t8.height, planes: null, pixelType: null, noDataValue: null, format: p25 }, m15);
      return { pixelData: { pixelBlock: await d11, extent: t8.extent }, params: t8 };
    }
    _generateRasterInfo(e4, t8) {
      return this.generateRasterInfo(e4, t8).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e4) {
      var _a;
      return e4 && JSON.stringify(e4.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e4) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule)) return;
      let t8 = h2(e4, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t8 && t8.length > 0) {
        this.mosaicRule = this.mosaicRule || new f6();
        const e5 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== ((_a = this.rasterFunction.functionName) == null ? void 0 : _a.toLowerCase()) && t8.forEach((e6) => e6.variableName = ""), t8 = t8.filter(({ variableName: e6, dimensionName: t9 }) => e6 && "*" !== e6 || t9), !(e5 == null ? void 0 : e5.length) && t8.length && (this.mosaicRule.multidimensionalDefinition = t8);
      }
    }
    _processVisibleRastersResponse(e4, i13) {
      var _a, _b, _c;
      i13 = i13 || {};
      const r4 = e4.value, { templateRRFunctionNames: s11, showNoDataRecords: n12, returnDomainValues: a17, templateFields: o5 } = i13, l15 = e4.processedValues;
      let u7 = (_a = e4.catalogItems) == null ? void 0 : _a.features, p25 = ((_c = (_b = e4.properties) == null ? void 0 : _b.Values) == null ? void 0 : _c.map((e5) => e5.replaceAll(/ /gi, ", "))) || [];
      const c24 = this.objectIdField || "ObjectId", m15 = "string" == typeof r4 && r4.toLowerCase().includes("nodata"), d11 = [];
      if (r4 && !u7 && !m15) {
        const e5 = {};
        e5[c24] = 0;
        p25 = [r4], u7 = [new b5({ geometry: this.fullExtent, attributes: e5 })], this.multidimensionalInfo && "raster-dataset" === this.sourceType && V(this.rasterFields, e5, i13.effectiveMultidimensionalDefinition);
      }
      if (!u7) return [];
      this._updateResponseFieldNames(u7, o5), m15 && !n12 && (u7 = []);
      const { itemPixelValue: h5, servicePixelValue: f12 } = t4, y11 = this.rasterFields.some((e5) => e5.name === h5);
      for (let t8 = 0; t8 < u7.length; t8++) {
        const e5 = u7[t8];
        if (null != r4) {
          const i14 = p25[t8], a18 = this.rasterFunction && l15 && l15.length > 0 && s11 && s11.length > 0 && s11.includes(this.rasterFunction.functionName) ? l15[s11.indexOf(this.rasterFunction.functionName)] : r4;
          if ("nodata" === i14.toLowerCase() && !n12) continue;
          y11 && (e5.attributes[h5] = i14), e5.attributes[f12] = a18, this._updateFeatureWithMagDirValues(e5, i14);
          const o6 = this.fields && this.fields.length > 0;
          let u8 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? o6 ? i14 : r4 : a18;
          this.rasterFunction || (u8 = o6 ? i14 : r4), this._updateFeatureWithRasterAttributeTableValues(e5, u8);
        }
        if (e5.sourceLayer = e5.layer = this, a17 && this._updateFeatureWithDomainValues(e5), s11 && l15 && s11.length === l15.length) for (let t9 = 0; t9 < s11.length; t9++) {
          const i14 = `${t4.servicePixelValue}.${s11[t9]}`;
          e5.attributes[i14] = l15[t9];
        }
        d11.push(u7[t8]);
      }
      return d11;
    }
    _processMultidimensionalIntersection(e4, t8, i13) {
      const { multidimensionalSubset: r4 } = this;
      if (!r4) return { isOutSide: false, timeExtent: t8, mosaicRule: i13 = this._combineMosaicRuleWithTimeExtent(i13, t8) };
      if (r4) {
        const { isOutside: i14, intersection: s11 } = m3(r4, { geometry: e4, timeExtent: t8 });
        if (i14) return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != (s11 == null ? void 0 : s11.timeExtent) && (t8 = s11.timeExtent);
      }
      if (i13 = this._combineMosaicRuleWithTimeExtent(i13, t8), i13 == null ? void 0 : i13.multidimensionalDefinition) {
        const { isOutside: e5 } = m3(r4, { multidimensionalDefinition: i13.multidimensionalDefinition });
        if (e5) return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t8, mosaicRule: i13 };
    }
    _updateFeatureWithRasterAttributeTableValues(e4, t8) {
      const i13 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == i13) return;
      const { features: r4, fields: s11 } = i13, n12 = s11.map((e5) => e5.name).find((e5) => "value" === e5.toLowerCase());
      if (!n12) return;
      const a17 = r4.filter((e5) => e5.attributes[n12] === (null != t8 ? parseInt(t8, 10) : null));
      a17 && a17[0] && s11.forEach((t9) => {
        const i14 = n5 + t9.name;
        e4.attributes[i14] = a17[0].attributes[t9.name];
      });
    }
    _updateFeatureWithMagDirValues(e4, t8) {
      if (!this._isVectorDataSet()) return;
      const i13 = t8.split(/,\s*/).map((e5) => parseFloat(e5)), r4 = i13.map((e5) => [e5]), s11 = i13.map((e5) => ({ minValue: e5, maxValue: e5, noDataValue: null })), n12 = new g2({ height: 1, width: 1, pixelType: "f32", pixels: r4, statistics: s11 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n12, extent: new w(0, 0, 0, 0, this.spatialReference) });
      const a17 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n12.pixels[0][0], n12.pixels[1][0]] : l3([n12.pixels[0][0], n12.pixels[1][0]]);
      e4.attributes[t4.magnitude] = a17[0], e4.attributes[t4.direction] = a17[1];
    }
    _updateFeatureWithDomainValues(e4) {
      const t8 = this.fields && this.fields.filter((e5) => e5.domain && "coded-value" === e5.domain.type);
      null != t8 && t8.forEach((t9) => {
        const i13 = e4.attributes[t9.name];
        if (null != i13) {
          const r4 = t9.domain.codedValues.find((e5) => e5.code === i13);
          r4 && (e4.attributes[t9.name] = r4.name);
        }
      });
    }
    _updateResponseFieldNames(e4, t8) {
      if (!t8 || t8.length < 1) return;
      const i13 = this.fieldsIndex;
      null != i13 && e4.forEach((e5) => {
        var _a;
        if (e5 == null ? void 0 : e5.attributes) for (const r4 of t8) {
          const t9 = (_a = i13.get(r4)) == null ? void 0 : _a.name;
          t9 && t9 !== r4 && (e5.attributes[r4] = e5.attributes[t9], delete e5.attributes[t9]);
        }
      });
    }
    _getRenderingRuleString(e4) {
      if (e4) {
        let t8 = e4.toJSON();
        return t8 = t8.rasterFunctionDefinition ?? t8, (t8.thumbnail || t8.thumbnailEx) && (t8.thumbnail = t8.thumbnailEx = null), JSON.stringify(t8);
      }
      return null;
    }
    _hasRasterFunction(e4) {
      return null != (e4 == null ? void 0 : e4.functionName) && "none" !== e4.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e4, t8) {
      if (!e4 || e4.length < 1) return;
      if ("Raw" === e4) return e4.replace("Raw", "None");
      const i13 = e4.toLowerCase().replaceAll(/ /gi, "_");
      return t8.has(i13) ? t8.get(i13) : e4;
    }
    _isRFTJson(e4) {
      return (e4 == null ? void 0 : e4.name) && e4.arguments && e4.function && e4.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e4) {
      const { raster: t8, mosaicRule: i13, rasterFunction: r4 } = this;
      r4 && null == e4.rasterFunction && (e4.rasterFunction = r4), i13 && null == e4.mosaicRule && (e4.mosaicRule = i13), t8 && null == e4.raster && (e4.raster = t8);
    }
    _applyMosaicRule(e4) {
      const { raster: t8, mosaicRule: i13 } = this;
      i13 && null == e4.mosaicRule && (e4.mosaicRule = i13), t8 && null == e4.raster && (e4.raster = t8);
    }
    _readCapabilities(e4) {
      var _a;
      const t8 = e4.capabilities ? e4.capabilities.toLowerCase().split(",").map((e5) => e5.trim()) : ["image", "catalog"], { currentVersion: i13, advancedQueryCapabilities: r4, maxRecordCount: s11 } = e4, n12 = t8.includes("image"), a17 = "esriImageServiceDataTypeElevation" === e4.serviceDataType, o5 = !(!e4.spatialReference && !((_a = e4.extent) == null ? void 0 : _a.spatialReference)), l15 = t8.includes("edit"), u7 = t8.includes("mensuration") && o5, p25 = null == e4.mensurationCapabilities ? [] : e4.mensurationCapabilities.toLowerCase().split(",").map((e5) => e5.trim()), c24 = u7 && p25.includes("basic"), m15 = this._isMosaicDataset(e4) && t8.includes("catalog"), d11 = t8.includes("download"), h5 = i13 >= 10.7 && a17 || i13 >= 11.4 && (a17 || u7 && p25.includes("3d"));
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n12, supportsExportImage: n12, supportsIdentify: n12, supportsImageToMap: i13 >= 11.2 && m15, supportsImageToMapMultiray: i13 >= 11.2 && m15, supportsMapToImage: i13 >= 11.2 && m15, supportsFindImages: i13 >= 11.2 && m15, supportsGetImageUrl: i13 >= 11.3 && d11, supportsMeasure: u7, supportsMeasureFromImage: i13 >= 11.2, supportsDownload: d11, supportsQuery: m15 && e4.fields && e4.fields.length > 0, supportsGetSamples: i13 >= 10.2 && n12, supportsProject: i13 >= 10.3 && n12, supportsComputeStatisticsHistograms: i13 >= 10.4 && n12, supportsQueryBoundary: i13 >= 10.6 && n12, supportsCalculateVolume: h5, supportsComputePixelLocation: i13 >= 10.7 && m15, supportsComputeAngles: i13 >= 10.91, supportsQueryGPSInfo: i13 >= 11.2 && m15, supportsAdd: l15, supportsDelete: l15, supportsEditing: l15, supportsUpdate: l15, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryBins: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: s11, maxRecordCountFactor: void 0, supportsStatistics: !!(r4 == null ? void 0 : r4.supportsStatistics), supportsOrderBy: !!(r4 == null ? void 0 : r4.supportsOrderBy), supportsDistinct: !!(r4 == null ? void 0 : r4.supportsDistinct), supportsPagination: !!(r4 == null ? void 0 : r4.supportsPagination), supportsStandardizedQueriesOnly: !!(r4 == null ? void 0 : r4.useStandardizedQueries), supportsPercentileStatistics: !!(r4 == null ? void 0 : r4.supportsPercentileStatistics), supportsCentroid: !!(r4 == null ? void 0 : r4.supportsReturningGeometryCentroid), supportsCurrentUser: false, supportsDistance: !!(r4 == null ? void 0 : r4.supportsQueryWithDistance), supportsExtent: !!(r4 == null ? void 0 : r4.supportsReturningQueryExtent), supportsGeometryProperties: !!(r4 == null ? void 0 : r4.supportsReturningGeometryProperties), supportsHavingClause: !!(r4 == null ? void 0 : r4.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsReturnMesh: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(r4 == null ? void 0 : r4.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0, supportsTrueCurve: false }, mensuration: { supportsDistanceAndAngle: c24, supportsAreaAndPerimeter: c24, supportsPointOrCentroid: c24, supportsHeightFromBaseAndTop: u7 && p25.includes("base-top height"), supportsHeightFromBaseAndTopShadow: u7 && p25.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: u7 && p25.includes("top-top shadow height"), supports3D: u7 && p25.includes("3d") } };
    }
  };
  function ze2(e4) {
    return (e4 == null ? void 0 : e4.path) ?? "";
  }
  return r([m({ clonable: false })], m14.prototype, "_functionRasterInfos", void 0), r([m({ clonable: false })], m14.prototype, "_rasterJobHandler", void 0), r([m({ clonable: false })], m14.prototype, "_cachedRendererJson", void 0), r([m({ readOnly: true })], m14.prototype, "_serviceSupportsMosaicRule", void 0), r([o2("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], m14.prototype, "readServiceSupportsMosaicRule", null), r([m({ readOnly: true })], m14.prototype, "_rasterFunctionNamesIndex", null), r([m()], m14.prototype, "adjustAspectRatio", void 0), r([m({ type: [x], json: { write: true } })], m14.prototype, "bandIds", void 0), r([o2("bandIds")], m14.prototype, "readBandIds", null), r([m({ readOnly: true, json: { read: false } })], m14.prototype, "capabilities", void 0), r([o2("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], m14.prototype, "readCapabilities", null), r([m({ type: Number })], m14.prototype, "compressionQuality", void 0), r([r2("compressionQuality")], m14.prototype, "writeCompressionQuality", null), r([m({ type: Number })], m14.prototype, "compressionTolerance", void 0), r([r2("compressionTolerance")], m14.prototype, "writeCompressionTolerance", null), r([m({ json: { read: { source: "copyrightText" } } })], m14.prototype, "copyright", void 0), r([m({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], m14.prototype, "defaultMosaicRule", void 0), r([o2("defaultMosaicRule", ["defaultMosaicMethod"])], m14.prototype, "readDefaultMosaicRule", null), r([m({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], m14.prototype, "definitionExpression", void 0), r([m({ readOnly: true, constructOnly: true })], m14.prototype, "exportImageServiceParameters", void 0), r([m()], m14.prototype, "rasterInfo", void 0), r([m({ readOnly: true, type: [y] })], m14.prototype, "fields", void 0), r([m({ readOnly: true })], m14.prototype, "fieldsIndex", null), r([m({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff", "bip", "bsq"], json: { write: true } })], m14.prototype, "format", null), r([o2("service", "format", ["serviceDataType"])], m14.prototype, "readFormat", null), r([m({ type: w })], m14.prototype, "fullExtent", void 0), r([m({ readOnly: true })], m14.prototype, "hasMultidimensions", void 0), r([m({ json: { read: { source: "maxImageHeight" } } })], m14.prototype, "imageMaxHeight", void 0), r([m({ json: { read: { source: "maxImageWidth" } } })], m14.prototype, "imageMaxWidth", void 0), r([m({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], m14.prototype, "interpolation", void 0), r([m()], m14.prototype, "minScale", void 0), r([o2("service", "minScale")], m14.prototype, "readMinScale", null), r([m()], m14.prototype, "maxScale", void 0), r([o2("service", "maxScale")], m14.prototype, "readMaxScale", null), r([m({ type: f6 })], m14.prototype, "mosaicRule", null), r([o2("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], m14.prototype, "readMosaicRule", null), r([r2("mosaicRule")], m14.prototype, "writeMosaicRule", null), r([m()], m14.prototype, "multidimensionalInfo", void 0), r([m({ type: c3, json: { write: true } })], m14.prototype, "multidimensionalSubset", void 0), r([m({ json: { type: x } })], m14.prototype, "noData", void 0), r([r2("noData")], m14.prototype, "writeNoData", null), r([m({ type: String, json: { type: i3.jsonValues, read: i3.read, write: i3.write } })], m14.prototype, "noDataInterpretation", void 0), r([m({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], m14.prototype, "objectIdField", void 0), r([o2("objectIdField")], m14.prototype, "readObjectIdField", null), r([m({ readOnly: true })], m14.prototype, "geometryType", void 0), r([m({})], m14.prototype, "typeIdField", void 0), r([m({})], m14.prototype, "types", void 0), r([m({ readOnly: true })], m14.prototype, "parsedUrl", null), r([m({ type: Function })], m14.prototype, "pixelFilter", void 0), r([m()], m14.prototype, "raster", void 0), r([m({ readOnly: true })], m14.prototype, "sourceType", void 0), r([o2("sourceType", ["serviceSourceType", "fields"])], m14.prototype, "readSourceType", null), r([m()], m14.prototype, "viewId", void 0), r([m()], m14.prototype, "renderer", null), r([m({ types: l6, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: p6, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], m14.prototype, "internalRenderer", null), r([o2("internalRenderer")], m14.prototype, "readRenderer", null), r([r2("internalRenderer")], m14.prototype, "writeRenderer", null), r([m({ clonable: false })], m14.prototype, "symbolizer", void 0), r([m(f2)], m14.prototype, "opacity", void 0), r([m({ readOnly: true })], m14.prototype, "rasterFields", null), r([m({ constructOnly: true })], m14.prototype, "rasterFunctionInfos", void 0), r([m({ type: w2, json: { name: "renderingRule" } })], m14.prototype, "rasterFunction", null), r([o2("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], m14.prototype, "readRasterFunction", null), r([m({ readOnly: true })], m14.prototype, "serviceDataType", void 0), r([m({ readOnly: true, type: g })], m14.prototype, "spatialReference", void 0), r([o2("spatialReference", ["spatialReference", "extent"])], m14.prototype, "readSpatialReference", null), r([m({ type: n2.apiValues, json: { read: n2.read, type: n2.jsonValues } })], m14.prototype, "pixelType", void 0), r([r2("pixelType")], m14.prototype, "writePixelType", null), r([m({ constructOnly: true, type: d3 })], m14.prototype, "serviceRasterInfo", void 0), r([m()], m14.prototype, "sourceJSON", void 0), r([m(y2)], m14.prototype, "url", void 0), r([m({ readOnly: true })], m14.prototype, "version", void 0), r([o2("version", ["currentVersion", "fields", "timeInfo"])], m14.prototype, "readVersion", null), m14 = r([a4("esri.layers.mixins.ArcGISImageService")], m14), m14;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var _3 = class extends p2(l5(t(b(j3(o4(ze(f4(e(l4(S2(a5.ClonableMixin(f3)))))))))))) {
  constructor(...e4) {
    super(...e4), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k(async (e5, r4, t8) => {
      const { save: o5, saveAs: s11 } = await import("./imageryUtils-ACOGEUZB.js");
      switch (e5) {
        case A.SAVE:
          return o5(this, r4);
        case A.SAVE_AS:
          return s11(this, t8, r4);
      }
    });
  }
  normalizeCtorArgs(e4, r4) {
    return "string" == typeof e4 ? { url: e4, ...r4 } : e4;
  }
  load(e4) {
    const r4 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(a3).then(() => this._fetchService(r4))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e4) {
    this._set("legendEnabled", e4);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e4) {
    this._set("listMode", e4);
  }
  writeOperationalLayerType(e4, r4, t8) {
    var _a;
    const o5 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r4[t8] = o5 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    var _a;
    return !(!this.raster || !((_a = this.url) == null ? void 0 : _a.toLowerCase().includes("/rasterrendering/imageserver")));
  }
  createPopupTemplate(e4) {
    const { rasterFields: r4 } = this, t8 = /* @__PURE__ */ new Set(), o5 = t4.itemPixelValue.toLowerCase(), s11 = "raster-dataset" === this.sourceType, i13 = a7.toLowerCase(), a17 = `${t4.servicePixelValue.toLowerCase()}.`;
    for (const l15 of r4) {
      const e5 = l15.name.toLowerCase();
      e5 === o5 || e5.startsWith(a17) || s11 && e5.startsWith(i13) || t8.add(l15.name);
    }
    const p25 = p3({ fields: r4, title: this.title }, { ...e4, visibleFieldNames: t8 }), { rasterInfo: n12 } = this;
    return (p25 == null ? void 0 : p25.fieldInfos) && n12 && b4(p25.fieldInfos, n12), p25;
  }
  queryFeatures(e4, r4) {
    return this.queryRasters(e4, r4).then((e5) => {
      if (e5 == null ? void 0 : e5.features) for (const r5 of e5.features) r5.layer = r5.sourceLayer = this;
      return e5;
    });
  }
  queryFeatureCount(e4, r4) {
    return this.queryRasterCount(e4, r4);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, r4) {
    return this._debouncedSaveOperations(A.SAVE_AS, r4, e4);
  }
  serviceSupportsSpatialReference(e4) {
    return t3(this, e4);
  }
  write(e4, r4) {
    if (!this._isPreviewLayer) return super.write(e4, r4);
    if (r4 == null ? void 0 : r4.messages) {
      const e5 = `${r4.origin}/${r4.layerContainerType || "operational-layers"}`;
      r4.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
};
r([m(d2)], _3.prototype, "legendEnabled", null), r([m({ type: ["show", "hide"] })], _3.prototype, "listMode", null), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], _3.prototype, "isReference", void 0), r([m({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], _3.prototype, "operationalLayerType", void 0), r([r2("web-map", "operationalLayerType")], _3.prototype, "writeOperationalLayerType", null), r([m(l)], _3.prototype, "popupEnabled", void 0), r([m({ type: q2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], _3.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], _3.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, json: { read: false } })], _3.prototype, "type", void 0), r([m({ readOnly: true })], _3.prototype, "_isPreviewLayer", null), _3 = r([a4("esri.layers.ImageryLayer")], _3);
var C2 = _3;
export {
  C2 as default
};
//# sourceMappingURL=ImageryLayer-6TU754WD.js.map
