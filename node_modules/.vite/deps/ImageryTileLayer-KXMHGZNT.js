import {
  K,
  X,
  e as e2,
  i,
  n as n5,
  o as o3,
  t as t3,
  u as u2,
  u2 as u3
} from "./chunk-F2BQZJI3.js";
import "./chunk-WZ5XGARC.js";
import {
  T as T3
} from "./chunk-3TEY2BPT.js";
import {
  c as c3,
  f as f3,
  o as o2
} from "./chunk-HCED77GY.js";
import {
  w as w3
} from "./chunk-LM5DVV6Z.js";
import {
  $,
  N as N2,
  b as b2,
  c as c2,
  d as d5,
  o,
  p as p4,
  p2 as p5,
  t as t2,
  v
} from "./chunk-AAIKSZFL.js";
import "./chunk-GHPQVNNU.js";
import "./chunk-VBE5VFL5.js";
import {
  c,
  y as y3
} from "./chunk-UAJ7VMFY.js";
import {
  T as T2,
  w as w2
} from "./chunk-OE5AB3OL.js";
import "./chunk-FQS6ZZHL.js";
import {
  B,
  D,
  F,
  L,
  N,
  P,
  R,
  U,
  d as d3,
  h2 as h3,
  m2,
  n as n3,
  n3 as n4,
  p as p2,
  r as r2,
  r2 as r3
} from "./chunk-YLQRI5UO.js";
import {
  E,
  T,
  W,
  g as g2,
  l2 as l
} from "./chunk-6QH5QYZM.js";
import "./chunk-23WGP47N.js";
import "./chunk-EKEKHPBG.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-32RP26YL.js";
import "./chunk-QY6LLTZM.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import {
  z
} from "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import "./chunk-YUQ6PSJ2.js";
import "./chunk-SB6LU3VH.js";
import {
  l as l2
} from "./chunk-WOB72RZU.js";
import {
  l as l3
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import {
  p as p3
} from "./chunk-S4QLDBOB.js";
import {
  e
} from "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-QAP2FVP7.js";
import {
  d as d4
} from "./chunk-6EREU4EG.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import {
  A
} from "./chunk-NBXBK3QW.js";
import {
  j as j2
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f2
} from "./chunk-73NNNHMH.js";
import {
  b
} from "./chunk-C6YDI6QX.js";
import {
  d as d2
} from "./chunk-DJ5HVIE7.js";
import {
  S
} from "./chunk-KPY4ZIC2.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import {
  y as y2
} from "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  p
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BLF64HON.js";
import {
  q
} from "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a3
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  d
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import {
  s as s2
} from "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import {
  h as h2
} from "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  k as k2
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import {
  I
} from "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a,
  k,
  n as n2,
  u3 as u,
  y
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  h
} from "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import {
  G,
  has
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/covJSONParser.js
function i2(e3) {
  return ["x", "e", "east", "long", "longitude"].includes(e3.toLowerCase());
}
function r4(e3) {
  return ["y", "n", "west", "lat", "latitude"].includes(e3.toLowerCase());
}
function o4(e3) {
  const { axes: l4 } = e3.domain, s3 = Object.keys(l4), a4 = [], o5 = [];
  let u7 = -1, m6 = -1, c6 = [];
  for (let t5 = 0; t5 < s3.length; t5++) {
    const e4 = s3[t5];
    i2(e4) ? u7 = t5 : r4(e4) && (m6 = t5);
    const n7 = l4[e4], d10 = [];
    if ("values" in n7) {
      n7.values.forEach((e6) => d10.push("string" == typeof e6 ? new Date(e6).getTime() : e6));
      const e5 = d10[1] - d10[0];
      a4.push([d10[0] - 0.5 * e5, d10[d10.length - 1] + 0.5 * e5]), o5.push(e5);
    } else {
      const { start: e5, stop: t6, num: l5 } = n7, s4 = (t6 - e5) / (l5 - 1);
      a4.push([e5 - 0.5 * s4, t6 + 0.5 * s4]), o5.push(s4);
      for (let n8 = 0; n8 < l5; n8++) d10.push(e5 + s4 * n8);
    }
    c6.push({ name: e4, values: d10, extent: [d10[0], d10[d10.length - 1]] });
  }
  u7 > -1 && -1 === m6 ? m6 = 0 === u7 ? 1 : 0 : m6 > -1 && -1 === u7 ? u7 = 0 === m6 ? 1 : 0 : -1 === m6 && -1 === u7 && (u7 = 0, m6 = 1), c6 = c6.filter((e4, t5) => !(t5 === u7 || t5 === m6));
  const { referencing: d9 } = e3.domain, f6 = d9.find((e4) => e4.coordinates.includes(s3[u7])).system.id, p8 = f6 == null ? void 0 : f6.slice(f6.lastIndexOf("/") + 1), h6 = null == p8 || "CRS84" === p8 ? 4326 : Number(p8), g5 = new g({ wkid: h6 }), [b4, y5] = a4[u7], [x2, j3] = a4[m6], v4 = new w({ xmin: b4, xmax: y5, ymin: x2, ymax: j3, spatialReference: g5 });
  return { width: Math.round(v4.width / o5[u7]), height: Math.round(v4.height / o5[m6]), extent: v4, dimensions: c6 };
}
function u4(e3) {
  const t5 = s2();
  return t5 ? e3[t5] ?? Object.values(e3)[0] : Object.values(e3)[0];
}
function m3() {
  return Math.round(255 * Math.random());
}
function c4(t5) {
  var _a, _b;
  const n7 = {}, { parameters: l4 } = t5;
  if (!l4) return n7;
  for (const [s3, a4] of Object.entries(l4)) {
    const { type: t6, description: l5, unit: i3, categoryEncoding: r6, observedProperty: o5 } = a4;
    if ("Parameter" === t6 && (n7[s3] = {}, l5 && (n7[s3].description = u4(l5)), i3 && (n7[s3].unit = i3.label ? u4(i3.label) : null, n7[s3].symbol = (_a = i3.symbol) == null ? void 0 : _a.value), r6)) {
      const t7 = Object.entries(r6).map((e3, t8) => ({ OID: t8, Value: Number(e3[1]), ClassName: e3[0].slice(e3[0].lastIndexOf("/") + 1), Count: 1 }));
      let l6 = false;
      ((_b = o5 == null ? void 0 : o5.categories) == null ? void 0 : _b.length) && (o5.categories.forEach((n8) => {
        if (!n8.id) return;
        const s4 = n8.id.slice(n8.id.lastIndexOf("/") + 1), a6 = t7.find((e3) => e3.ClassName === s4);
        if (!a6) return;
        const i4 = n8.label ? u4(n8.label) : null;
        if (a6.Label = i4, n8.preferredColor) {
          const t8 = h2.fromHex(n8.preferredColor);
          t8 && (l6 = true, a6.Red = t8.r, a6.Green = t8.g, a6.Blue = t8.b);
        }
      }), l6 && t7.forEach((e3) => {
        null == e3.Red && (e3.Red = m3(), e3.Green = m3(), e3.Blue = m3());
      }));
      const a5 = { objectIdFieldName: "", fields: [{ name: "OID", type: "esriFieldTypeOID", alias: "OID", domain: null }, { name: "Value", type: "esriFieldTypeInteger", alias: "Value", domain: null }, { name: "Count", type: "esriFieldTypeDouble", alias: "Count", domain: null }, { name: "ClassName", type: "esriFieldTypeString", alias: "ClassName", domain: null, length: 50 }, { name: "Label", type: "esriFieldTypeString", alias: "Label", domain: null, length: 50 }], features: t7.map((e3) => ({ attributes: e3 })) };
      l6 && a5.fields.push({ name: "Red", type: "esriFieldTypeInteger", alias: "Red", domain: null }, { name: "Green", type: "esriFieldTypeInteger", alias: "Green", domain: null }, { name: "Blue", type: "esriFieldTypeInteger", alias: "Blue", domain: null }), n7[s3].attributeTable = a5;
    }
  }
  return n7;
}
function d6(e3) {
  let t5 = Number.MAX_VALUE, n7 = -Number.MAX_VALUE;
  for (let l4 = 0; l4 < e3.length; l4++) {
    const s3 = e3[l4];
    null != s3 && (s3 < t5 && (t5 = s3), s3 > n7 && (n7 = s3));
  }
  return l(t5, n7);
}
function f4(e3, t5, n7) {
  const l4 = e3.map((e4, n8) => ({ name: e4, count: t5[n8] })).sort((e4, t6) => e4.name > t6.name ? -1 : 1), s3 = (a4 = 1, (e4) => a4 *= e4.count);
  var a4;
  const i3 = [...l4.slice(1), { name: "", count: 1 }].reverse().map(s3).reverse();
  let r6 = 0;
  for (let o5 = e3.length - 1; o5 >= 0; o5--) {
    r6 += i3[l4.findIndex(({ name: t6 }) => t6 === e3[o5])] * (n7 % t5[o5]), n7 = Math.floor(n7 / t5[o5]);
  }
  return r6;
}
function p6(e3) {
  var _a;
  const { width: t5, height: n7, extent: l4, dimensions: a4 } = o4(e3), { ranges: i3 } = e3, r6 = Object.keys(i3).sort((e4, t6) => e4 < t6 ? -1 : 1), u7 = [];
  for (let s3 = 0; s3 < r6.length; s3++) {
    const e4 = r6[s3];
    (a4 == null ? void 0 : a4.length) && u7.push({ name: e4, dimensions: a4 });
  }
  const m6 = c4(e3);
  u7.forEach((e4) => m6[e4.name] && Object.assign(e4, m6[e4.name]));
  const p8 = u7.length ? { variables: u7 } : void 0, h6 = [];
  for (let o5 = 0; o5 < r6.length; o5++) {
    const e4 = r6[o5], { values: l5, dataType: u8, axisNames: m7, shape: c6 } = i3[e4], p9 = c6.length > 2 ? o5 * c6.slice(0, -2).reduce((e5, t6) => e5 * t6) : 0, g6 = m7.slice(0, -2), b4 = c6.slice(0, -2), y5 = "float" === u8 ? "f32" : d6(l5), x2 = t5 * n7, j3 = l5.length / x2;
    for (let i4 = 0; i4 < j3; i4++) {
      const e5 = g2.createEmptyBand(y5, x2), r7 = new Uint8Array(x2).fill(255);
      let u9 = false;
      const m8 = i4 * x2;
      for (let t6 = 0; t6 < x2; t6++) {
        const n8 = l5[m8 + t6];
        null == n8 ? (r7[t6] = 0, u9 = true) : e5[t6] = n8;
      }
      if (0 === o5 || (a4 == null ? void 0 : a4.length)) {
        const l6 = new g2({ width: t5, height: n7, mask: u9 ? r7 : null, pixels: [e5], pixelType: y5 });
        if (l6.updateStatistics(), a4 == null ? void 0 : a4.length) {
          h6[f4(g6, b4, i4) + p9] = l6;
        } else h6.push(l6);
      } else {
        const t6 = h6[i4];
        t6.pixels.push(e5), u9 ? t6.mask && (t6.mask = g2.combineBandMasks([t6.mask, r7])) : t6.mask = u9 ? r7 : null;
      }
    }
  }
  const g5 = (_a = Object.values(m6).find((e4) => e4.attributeTable)) == null ? void 0 : _a.attributeTable;
  return { extent: l4, pixelBlocks: h6, multidimensionalInfo: p8, attributeTable: g5, bandNames: p8 ? void 0 : r6 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var f5 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.source = null;
  }
  get url() {
    return "";
  }
  fetchRawTile(t5, e3, s3, i3 = {}) {
    if (!this._pixelBlockTiles) {
      const { rasterInfo: r7 } = this, [o5, a4] = r7.storageInfo.tileInfo.size, { sliceId: l4 } = i3, { pixelBlocks: n7 } = this.source, m6 = { pixelBlock: null == l4 ? n7[0] : n7[l4], useBilinear: "thematic" !== r7.dataType, tileSize: { width: o5, height: a4 }, level: t5, row: e3, col: s3 }, c6 = this.rasterJobHandler ? this.rasterJobHandler.clipTile(m6, i3) : E(m6);
      return Promise.resolve(c6);
    }
    const r6 = this._pixelBlockTiles.get(`${t5}/${e3}/${s3}`);
    return Promise.resolve(r6);
  }
  async _open(t5) {
    const e3 = this.source, { pixelBlocks: s3, attributeTable: i3, statistics: r6, histograms: l4, name: m6, nativeExtent: c6, transform: p8 } = e3, u7 = s3[0], { width: h6, height: d9, pixelType: f6 } = u7, g5 = e3.extent ?? new w({ xmin: -0.5, ymin: 0.5, xmax: h6 - 0.5, ymax: d9 - 0.5, spatialReference: new g({ wkid: 3857 }) }), x2 = e3.isPseudoSpatialReference ?? !e3.extent, y5 = { x: g5.width / h6, y: g5.height / d9 }, b4 = { ...e3.keyProperties };
    i3 && (b4.DataType = "Thematic");
    const v4 = new d3({ width: h6, height: d9, pixelType: f6, extent: g5, nativeExtent: c6, attributeTable: i3, transform: p8, pixelSize: y5, spatialReference: g5.spatialReference, bandCount: u7.pixels.length, keyProperties: b4, multidimensionalInfo: e3.multidimensionalInfo, statistics: r6, isPseudoSpatialReference: x2, histograms: l4 });
    this.ioConfig.skipMapInfo && this.updateImageSpaceRasterInfo(v4), this.createRemoteDatasetStorageInfo(v4, 512, 512), this._set("rasterInfo", v4), this.updateTileInfo(), v4.multidimensionalInfo ? await this._buildMDimStats(e3.pixelBlocks, v4.multidimensionalInfo) : await this._buildInMemoryRaster(u7, { width: 512, height: 512 }, t5), v4.multidimensionalInfo || (this.source = null), this.datasetName = m6;
  }
  async _buildInMemoryRaster(t5, i3, r6) {
    var _a, _b;
    const { rasterInfo: o5 } = this, a4 = o5.storageInfo.maximumPyramidLevel ?? 0, l4 = "thematic" !== o5.dataType, n7 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: i3, maximumPyramidLevel: a4, useBilinear: l4 }, r6) : Promise.resolve(W(t5, i3, a4, l4)), m6 = null != o5.statistics, c6 = null != o5.histograms, p8 = this.ioConfig.skipStatistics || m6 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, r6) : Promise.resolve(h3(t5)), d9 = await y([n7, p8]);
    if (!d9[0].value && d9[1].value) throw new s("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = d9[0].value, m6 || (o5.statistics = (_a = d9[1].value) == null ? void 0 : _a.statistics), c6 || (o5.histograms = (_b = d9[1].value) == null ? void 0 : _b.histograms);
  }
  async _buildMDimStats(t5, e3, s3) {
    for (let i3 = 0; i3 < e3.variables.length; i3++) {
      const r6 = e3.variables[i3];
      if (r6.statistics) continue;
      const o5 = r6.dimensions.map((t6) => {
        var _a, _b;
        return new p4({ variableName: r6.name, dimensionName: t6.name, values: [((_a = t6.values) == null ? void 0 : _a[0]) ?? ((_b = t6.extent) == null ? void 0 : _b[0])], isSlice: true });
      }), a4 = N2(o5, e3), n7 = null == a4 ? null : t5[a4];
      if (null == n7) continue;
      const m6 = this.rasterJobHandler ? await this.rasterJobHandler.computeStatisticsHistograms({ pixelBlock: n7 }, s3) : m2(n7);
      r6.statistics = m6.statistics, r6.histograms || (r6.histograms = m6.histograms);
    }
  }
};
r([m({ type: String, json: { write: true } })], f5.prototype, "datasetFormat", void 0), r([m()], f5.prototype, "source", void 0), r([m()], f5.prototype, "url", null), f5 = r([a2("esri.layers.support.rasterDatasets.InMemoryRaster")], f5);
var g3 = f5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/CovJSONRaster.js
var m4 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "CovJSON";
  }
  fetchRawTile(e3, t5, r6, s3 = {}) {
    return this._inMemoryRaster.fetchRawTile(e3, t5, r6, s3);
  }
  async _open(e3) {
    const { extent: t5, pixelBlocks: r6, multidimensionalInfo: s3, attributeTable: a4, bandNames: o5 } = await this._fetchData(e3), { statistics: i3, histograms: n7 } = m2(r6[0]), m6 = o5 == null ? void 0 : o5.map((e4) => ({ BandName: e4 })), h6 = { DataType: a4 ? "Thematic" : s3 ? "Scientific" : "Generic", BandProperties: m6 }, d9 = new g3({ source: { extent: t5, pixelBlocks: r6, attributeTable: a4 ? d4.fromJSON(a4) : null, multidimensionalInfo: s3, statistics: i3, histograms: n7, keyProperties: h6, isPseudoSpatialReference: false } });
    await d9.open(), this._inMemoryRaster = d9;
    const u7 = this.source ? "" : this.url.slice(this.url.lastIndexOf("/") + 1);
    this._set("datasetName", u7.slice(0, u7.indexOf("."))), this._set("rasterInfo", d9.rasterInfo);
  }
  async _fetchData(e3) {
    var _a, _b, _c, _d;
    const r6 = this.source ?? (await this.request(this.url, { signal: e3 == null ? void 0 : e3.signal })).data, s3 = "imagery-tile-layer:open-coverage-json";
    if ("coverage" !== ((_a = r6.type) == null ? void 0 : _a.toLowerCase()) || "grid" !== ((_c = (_b = r6.domain) == null ? void 0 : _b.domainType) == null ? void 0 : _c.toLowerCase())) throw new s(s3, "Only coverage with Grid domain type is supported");
    if (!r6.ranges) throw new s(s3, "Missing ranges in the grid coverage data");
    if (!((_d = r6.domain.referencing) == null ? void 0 : _d.length)) throw new s(s3, "Missing domain referencing in the grid coverage data");
    const a4 = Object.values(r6.ranges);
    for (let n7 = 0; n7 < a4.length; n7++) {
      const { axisNames: e4, shape: r7, type: c6, values: l4 } = a4[n7];
      if (!("ndarray" === c6.toLowerCase() && (l4 == null ? void 0 : l4.length) && (e4 == null ? void 0 : e4.length) && (r7 == null ? void 0 : r7.length))) throw new s(s3, "Only ranges with valid NdArray, axisNames, shape, and inline values are supported");
      if (!(i2(e4[e4.length - 1]) && r4(e4[e4.length - 2]))) throw new s(s3, "Only row-major ordered pixel values are supported. X axis must be the last axis.");
    }
    return p6(r6);
  }
};
r([m({ type: String, json: { write: true } })], m4.prototype, "datasetFormat", void 0), r([m({ constructOnly: true })], m4.prototype, "source", void 0), m4 = r([a2("esri.layers.support.rasterDatasets.CovJSONRaster")], m4);
var h4 = m4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u5(e3, t5) {
  if (!e3 || !t5) return null;
  const n7 = [];
  for (let r6 = 0; r6 < e3.length; r6++) n7.push(e3[r6]), n7.push(t5[r6]);
  return n7;
}
function c5(e3) {
  const t5 = e2(e3, "GeodataXform"), n7 = d7(o3(t5, "SpatialReference/WKID") || t3(t5, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t5.getAttribute("xsi:type")) return { spatialReference: n7, transform: null };
  const r6 = o3(t5, "PolynomialOrder") ?? 1, a4 = u3(t5, "CoeffX/Double"), c6 = u3(t5, "CoeffY/Double"), m6 = u3(t5, "InverseCoeffX/Double"), p8 = u3(t5, "InverseCoeffY/Double"), S4 = u5(a4, c6), C = u5(m6, p8);
  return { spatialReference: n7, transform: S4 && C && S4.length && C.length ? new y3({ spatialReference: n7, polynomialOrder: r6, forwardCoefficients: S4, inverseCoefficients: C }) : null };
}
function m5(e3) {
  var _a;
  const t5 = o3(e3, "NoDataValue"), n7 = e2(e3, "Histograms/HistItem"), r6 = o3(n7, "HistMin"), o5 = o3(n7, "HistMax"), f6 = o3(n7, "BucketCount"), u7 = (_a = t3(n7, "HistCounts")) == null ? void 0 : _a.split("|").map((e4) => Number(e4));
  let c6, m6, d9, p8;
  n5(e3, "Metadata/MDI").forEach((e4) => {
    const t6 = Number(e4.textContent ?? e4.nodeValue);
    switch (e4.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c6 = t6;
        break;
      case "STATISTICS_MAXIMUM":
        m6 = t6;
        break;
      case "STATISTICS_MEAN":
        d9 = t6;
        break;
      case "STATISTICS_STDDEV":
        p8 = t6;
    }
  });
  const S4 = o3(e3, "Metadata/SourceBandIndex");
  return { noDataValue: t5, histogram: (u7 == null ? void 0 : u7.length) && null != r6 && null != o5 ? { min: r6, max: o5, size: f6 || u7.length, counts: u7 } : null, sourceBandIndex: S4, statistics: null != c6 && null != m6 ? { min: c6, max: m6, avg: d9, stddev: p8 } : null };
}
function d7(e3) {
  if (!e3) return null;
  let r6 = Number(e3);
  if (!isNaN(r6) && 0 !== r6) return new g({ wkid: r6 });
  if (e3 = String(e3).trim(), k2(e3)) return new g({ wkt2: e3 });
  const s3 = e3.toUpperCase();
  if (s3.startsWith("COMPD_CS")) {
    if (!s3.includes("VERTCS") || !s3.includes("GEOGCS") && !s3.startsWith("PROJCS")) return null;
    const n7 = s3.indexOf("VERTCS"), a4 = s3.indexOf("PROJCS"), i3 = a4 > -1 ? a4 : s3.indexOf("GEOGCS");
    if (-1 === i3) return null;
    const l4 = e3.slice(i3, e3.lastIndexOf("]", n7) + 1).trim(), o5 = e3.slice(n7, e3.lastIndexOf("]")).trim();
    r6 = p7(l4);
    const f6 = new g(r6 ? { wkid: r6 } : { wkt: l4 }), u7 = p7(o5);
    return u7 && (f6.vcsWkid = u7), f6;
  }
  return s3.startsWith("GEOGCS") || s3.startsWith("PROJCS") ? (r6 = p7(e3), new g(0 !== r6 ? { wkid: r6 } : { wkt: e3 })) : null;
}
function p7(e3) {
  var _a;
  const t5 = e3.replaceAll("]", "[").replaceAll('"', "").split("[").map((e4) => e4.trim()).filter((e4) => "" !== e4), n7 = t5[t5.length - 1].split(","), r6 = (_a = n7[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r6 || "esri" === r6) && e3.endsWith('"]]')) {
    const e4 = Number(n7[1]);
    if (!isNaN(e4) && 0 !== e4) return e4;
  }
  return 0;
}
function S2(t5) {
  var _a;
  if ("pamdataset" !== ((_a = t5 == null ? void 0 : t5.documentElement.tagName) == null ? void 0 : _a.toLowerCase())) return {};
  const n7 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t5.documentElement.childNodes.forEach((e3) => {
    if (1 === e3.nodeType) {
      if (i(e3, "SRS")) {
        if (!n7.spatialReference) {
          const t6 = t3(e3);
          n7.spatialReference = d7(t6);
        }
      } else if (i(e3, "Metadata")) if ("xml:ESRI" === e3.getAttribute("domain")) {
        const { spatialReference: t6, transform: r6 } = c5(e3);
        n7.transform = r6, n7.spatialReference || (n7.spatialReference = t6);
      } else {
        n5(e3, "MDI").forEach((e4) => n7.metadata[e4.getAttribute("key")] = t3(e4));
      }
      else if (i(e3, "PAMRasterBand")) {
        const t6 = m5(e3);
        null != t6.sourceBandIndex && null == n7.rasterBands[t6.sourceBandIndex] ? n7.rasterBands[t6.sourceBandIndex] = t6 : n7.rasterBands.push(t6);
      }
    }
  });
  const i3 = n7.rasterBands;
  if (i3.length) {
    const t6 = !!i3[0].statistics;
    n7.statistics = t6 ? i3.map((e3) => e3.statistics).filter(G) : null;
    const r6 = !!i3[0].histogram;
    n7.histograms = r6 ? i3.map((e3) => e3.histogram).filter(G) : null;
  }
  return n7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h5 = class extends X {
  fetchRawTile(t5, s3, e3, r6 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, s3, e3, r6);
  }
  async _open(t5) {
    const s3 = await this._fetchData(t5);
    let { spatialReference: e3, statistics: r6, histograms: a4, transform: o5 } = await this._fetchAuxiliaryData(t5);
    const l4 = !e3;
    l4 && (e3 = new g({ wkid: 3857 })), (a4 == null ? void 0 : a4.length) && null == r6 && (r6 = p2(a4));
    const { width: p8, height: c6 } = s3;
    let u7 = new w({ xmin: -0.5, ymin: 0.5 - c6, xmax: p8 - 0.5, ymax: 0.5, spatialReference: e3 });
    const h6 = o5 ? o5.forwardTransform(u7) : u7;
    let d9 = true;
    if (o5) {
      const t6 = o5.forwardCoefficients;
      d9 = t6 && 0 === t6[1] && 0 === t6[2], d9 && (o5 = null, u7 = h6);
    }
    const w5 = new g3({ source: { extent: h6, nativeExtent: u7, transform: o5, pixelBlocks: [s3], statistics: r6, histograms: a4, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: l4 }, ioConfig: { sampling: "closest", skipStatistics: true } });
    this.ioConfig.skipMapInfo && (w5.ioConfig.skipMapInfo = true), await w5.open(), w5.source = null, this._set("rasterInfo", w5.rasterInfo), this._inMemoryRaster = w5;
  }
  async _fetchData(t5) {
    const { data: e3 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), r6 = P(e3).toUpperCase();
    if ("JPG" !== r6 && "PNG" !== r6 && "GIF" !== r6 && "BMP" !== r6) throw new s("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r6);
    const a4 = r6.toLowerCase(), o5 = "gif" === a4 || "bmp" === a4 || !has("ios"), i3 = await this.decodePixelBlock(e3, { format: a4, useCanvas: o5, hasNoZlibMask: true });
    if (null == i3) throw new s("image-aux-raster:open", "the data cannot be decoded");
    return i3;
  }
  async _fetchAuxiliaryData(t5) {
    var _a;
    const s3 = t5 == null ? void 0 : t5.signal, { skipExtensions: a4 = [], skipMapInfo: o5 } = this.ioConfig, i3 = o5 || a4.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s3 }), n7 = this.datasetFormat, l4 = "JPG" === n7 ? "jgw" : "PNG" === n7 ? "pgw" : "BMP" === n7 ? "bpw" : null, m6 = l4 && a4.includes(l4) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + l4, { responseType: "text", signal: s3 }), c6 = await y([i3, m6]);
    if (s3 == null ? void 0 : s3.aborted) throw u();
    const f6 = S2((_a = c6[0].value) == null ? void 0 : _a.data);
    if (!f6.transform) {
      const t6 = c6[1].value ? c6[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      f6.transform = 6 === (t6 == null ? void 0 : t6.length) ? new y3({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return f6;
  }
};
r([m({ type: String, json: { write: true } })], h5.prototype, "datasetFormat", void 0), h5 = r([a2("esri.layers.support.rasterDatasets.ImageAuxRaster")], h5);
var d8 = h5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g4 = class extends X {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async fetchRawTile(e3, t5, i3, s3 = {}) {
    const { storageInfo: r6, extent: a4 } = this.rasterInfo, { transposeInfo: l4 } = r6, n7 = null != l4 && !!s3.transposedVariableName;
    if (this._slices && !n7 && null == s3.sliceId) return null;
    const o5 = n7 ? 0 : r6.maximumPyramidLevel - e3 + this._levelOffset, c6 = `${this.url}/tile/${o5}/${t5}/${i3}`, m6 = this._slices ? n7 ? { variable: s3.transposedVariableName } : { sliceId: s3.sliceId || 0 } : null, { data: u7 } = await this.request(c6, { query: m6, responseType: "array-buffer", signal: s3.signal });
    if (!u7) return null;
    const h6 = n7 ? l4.tileSize : r6.tileInfo.size, f6 = await this.decodePixelBlock(u7, { width: h6[0], height: h6[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: n7, noDataValue: this.rasterInfo.noDataValue });
    if (null == f6) return null;
    const d9 = r6.blockBoundary[e3];
    if ("jpg" !== r6.compression || i3 > d9.minCol && i3 < d9.maxCol && t5 > d9.minRow && t5 < d9.maxRow) return f6;
    const { origin: y5, blockWidth: x2, blockHeight: g5 } = r6, { x: v4, y: S4 } = this.getPyramidPixelSize(e3), I4 = Math.round((a4.xmin - y5.x) / v4) % x2, w5 = Math.round((a4.xmax - y5.x) / v4) % x2 || x2, j3 = Math.round((y5.y - a4.ymax) / S4) % g5, M = Math.round((y5.y - a4.ymin) / S4) % g5 || g5, b4 = i3 === d9.minCol ? I4 : 0, T4 = t5 === d9.minRow ? j3 : 0, _2 = i3 === d9.maxCol ? w5 : x2, O = t5 === d9.maxRow ? M : g5;
    return T(f6, { x: b4, y: T4 }, { width: _2 - b4, height: O - T4 }), f6;
  }
  getSliceIndex(e3) {
    if (!this._slices || null == e3 || 0 === e3.length) return null;
    const t5 = e3;
    for (let i3 = 0; i3 < this._slices.length; i3++) {
      const e4 = this._slices[i3].multidimensionalDefinition;
      if (e4.length === t5.length && !e4.some((e5) => {
        const i4 = t5.find((t6) => e5.variableName === t6.variableName && t6.dimensionName === e5.dimensionName);
        if (!i4) return true;
        return (Array.isArray(e5.values[0]) ? `${e5.values[0][0]}-${e5.values[0][1]}` : e5.values[0]) !== (Array.isArray(i4.values[0]) ? `${i4.values[0][0]}-${i4.values[0][1]}` : i4.values[0]);
      })) return i3;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e3, t5) {
    var _a, _b, _c;
    const i3 = this.request(this.url + "/statistics", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.statistics;
    }), s3 = this.request(this.url + "/histograms", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.histograms;
    }), r6 = await Promise.all([i3, s3]);
    return r6[0] && r6[0].forEach((e4) => {
      e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
    }), ((_c = (_b = (_a = r6[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.counts) == null ? void 0 : _c.length) || (r6[1] = null), { statistics: r6[0] || null, histograms: r6[1] || null };
  }
  async computeBestPyramidLevelForLocation(e3, t5 = {}) {
    if (!this._tilemapCache) return 0;
    let i3 = this.identifyPixelLocation(e3, 0, t5.datumTransformation);
    if (null === i3) return null;
    let s3 = 0;
    const { maximumPyramidLevel: r6 } = this.rasterInfo.storageInfo;
    let a4 = r6 - s3 + this._levelOffset;
    const l4 = i3.srcLocation;
    for (; a4 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a4, i3.row, i3.col, t5)) break;
      } catch {
      }
      if (a4--, s3++, i3 = this.identifyPixelLocation(l4, s3, t5.datumTransformation), null === i3) return null;
    }
    return -1 === a4 || null == i3 ? null : s3;
  }
  async _open(e3) {
    var _a, _b;
    const r6 = e3 == null ? void 0 : e3.signal, a4 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r6 });
    a4.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l4 = a4.data;
    if (this.sourceJSON = l4, !l4) throw new s("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l4.tileInfo) throw new s("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const n7 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l4.cacheType, null == this.tileType && (n7.includes(l4.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l4.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = ((_a = l4.name) == null ? void 0 : _a.slice(l4.name.indexOf("/") + 1)) ?? "";
    const o5 = await this._fetchRasterInfo({ signal: r6 });
    if (null == o5) throw new s("image-server-raster:open", "cannot initialize image service");
    c3(o5, l4);
    const c6 = "Map" === this.tileType ? v2(l4.tileInfo, l4) : z.fromJSON(l4.tileInfo);
    n2(c6);
    const [f6, p8] = this._computeMinMaxLOD(o5, c6), { extent: d9, pixelSize: x2 } = o5, g5 = 0.5 / o5.width * x2.x, I4 = Math.max(x2.x, x2.y), { lods: w5 } = c6;
    ("Map" !== this.tileType && 0 !== l4.maxScale || Math.abs(x2.x - x2.y) > g5 || !w5.some((e4) => Math.abs(e4.resolution - I4) < g5)) && (x2.x = x2.y = f6.resolution, o5.width = Math.ceil((d9.xmax - d9.xmin) / x2.x - 0.1), o5.height = Math.ceil((d9.ymax - d9.ymin) / x2.y - 0.1));
    const j3 = f6.level - p8.level, [M, b4] = c6.size, T4 = [], _2 = [];
    w5.forEach((e4, t5) => {
      e4.level >= p8.level && e4.level <= f6.level && T4.push({ x: e4.resolution, y: e4.resolution }), t5 < w5.length - 1 && _2.push(Math.round(10 * e4.resolution / w5[t5 + 1].resolution) / 10);
    }), T4.sort((e4, t5) => e4.x - t5.x);
    const O = this.computeBlockBoundary(d9, M, b4, c6.origin, T4, j3), R2 = T4.length > 1 ? T4.slice(1) : null;
    let z2;
    l4.transposeInfo && (z2 = { tileSize: [l4.transposeInfo.rows, l4.transposeInfo.cols], packetSize: ((_b = o5.keyProperties) == null ? void 0 : _b._yxs.PacketSize) ?? 0 });
    const N3 = _2.length <= 1 || _2.length >= 3 && _2.slice(0, -1).every((e4) => e4 === _2[0]) ? _2[0] ?? 2 : Math.round(10 / (p8.resolution / f6.resolution) ** (-1 / j3)) / 10;
    if (o5.storageInfo = new n4({ blockWidth: c6.size[0], blockHeight: c6.size[1], pyramidBlockWidth: c6.size[0], pyramidBlockHeight: c6.size[1], pyramidResolutions: R2, pyramidScalingFactor: N3, compression: c6.format, origin: c6.origin, firstPyramidLevel: 1, maximumPyramidLevel: j3, tileInfo: c6, transposeInfo: z2, blockBoundary: O }), S3(o5), this._set("rasterInfo", o5), l4.capabilities.toLowerCase().includes("tilemap")) {
      const e4 = { tileInfo: o5.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T3({ layer: e4 });
    }
  }
  async _fetchRasterInfo(e3) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e4 = t5.fullExtent || t5.extent, i4 = Math.ceil((e4.xmax - e4.xmin) / t5.pixelSizeX - 0.1), s4 = Math.ceil((e4.ymax - e4.ymin) / t5.pixelSizeY - 0.1), r7 = g.fromJSON(t5.spatialReference || e4.spatialReference), a5 = new j({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: r7 });
      return new d3({ width: i4, height: s4, bandCount: 3, extent: w.fromJSON(e4), spatialReference: r7, pixelSize: a5, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i3 } = e3, s3 = f3(this.url, this.sourceJSON, { signal: i3, query: this.ioConfig.customFetchParameters }), r6 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i3 }).then((e4) => {
      var _a;
      return (_a = e4.data) == null ? void 0 : _a.slices;
    }).catch(() => null) : null, a4 = await Promise.all([s3, r6]);
    return this._slices = a4[1], a4[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e3 } = this;
    e3.minScale && e3.minScale < 0 && (e3.minScale = 0), e3.maxScale && e3.maxScale < 0 && (e3.maxScale = 0);
  }
  _computeMinMaxLOD(e3, t5) {
    const { pixelSize: i3 } = e3, s3 = 0.5 / e3.width * i3.x, { lods: r6 } = t5, a4 = t5.lodAt(Math.max.apply(null, r6.map((e4) => e4.level))), l4 = t5.lodAt(Math.min.apply(null, r6.map((e4) => e4.level))), { tileType: n7 } = this;
    if ("Map" === n7) return this._levelOffset = r6[0].level, [a4, l4];
    if ("Raster" === n7) {
      return [r6.find((e4) => e4.resolution === i3.x) ?? a4, l4];
    }
    const { minScale: o5, maxScale: c6 } = this.sourceJSON;
    let m6 = a4;
    c6 > 0 && (m6 = r6.find((e4) => Math.abs(e4.scale - c6) < s3), m6 || (m6 = r6.filter((e4) => e4.scale > c6).sort((e4, t6) => e4.scale > t6.scale ? 1 : -1)[0] ?? a4));
    let u7 = l4;
    return o5 > 0 && (u7 = r6.find((e4) => Math.abs(e4.scale - o5) < s3) ?? l4, this._levelOffset = u7.level - l4.level), [m6, u7];
  }
};
function v2(e3, t5) {
  if (!e3) return null;
  const { minScale: i3, maxScale: s3, minLOD: r6, maxLOD: a4 } = t5;
  if (null != r6 && null != a4) return z.fromJSON({ ...e3, lods: e3.lods.filter(({ level: e4 }) => null != e4 && e4 >= r6 && e4 <= a4) });
  if (0 !== i3 && 0 !== s3) {
    const t6 = (e4) => Math.round(1e4 * e4) / 1e4, r7 = i3 ? t6(i3) : 1 / 0, a5 = s3 ? t6(s3) : -1 / 0;
    return z.fromJSON({ ...e3, lods: e3.lods.filter((e4) => {
      const i4 = t6(e4.scale);
      return i4 <= r7 && i4 >= a5;
    }) });
  }
  return z.fromJSON(e3);
}
function S3(e3) {
  const { extent: t5, spatialReference: i3 } = e3;
  t5.xmin > -1 && t5.xmax > 181 && (i3 == null ? void 0 : i3.wkid) && i3.isGeographic && (e3.nativeExtent = e3.extent, e3.transform = new c(), e3.extent = e3.transform.forwardTransform(t5));
}
r([m({ type: String, json: { write: true } })], g4.prototype, "datasetFormat", void 0), r([m()], g4.prototype, "tileType", void 0), g4 = r([a2("esri.layers.support.rasterDatasets.ImageServerRaster")], g4);
var I2 = g4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y4 = /* @__PURE__ */ new Map();
y4.set("Int8", "s8"), y4.set("UInt8", "u8"), y4.set("Int16", "s16"), y4.set("UInt16", "u16"), y4.set("Int32", "s32"), y4.set("UInt32", "u32"), y4.set("Float32", "f32"), y4.set("Float64", "f32"), y4.set("Double64", "f32");
var x = /* @__PURE__ */ new Map();
x.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w4 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async fetchRawTile(t5, e3, r6, s3 = {}) {
    const { blockWidth: o5, blockHeight: a4, blockBoundary: i3 } = this.rasterInfo.storageInfo, l4 = i3[t5];
    if (!l4 || l4.maxRow < e3 || l4.maxCol < r6 || l4.minRow > e3 || l4.minCol > r6) return null;
    const { bandCount: f6, pixelType: c6 } = this.rasterInfo, { ranges: p8, actualTileWidth: m6, actualTileHeight: h6 } = this._getTileLocation(t5, e3, r6);
    if (!p8 || 0 === p8.length) return null;
    if (0 === p8[0].from && 0 === p8[0].to) {
      const t6 = new Uint8Array(o5 * a4);
      return new g2({ width: o5, height: a4, pixels: void 0, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: u7 } = this.ioConfig, g5 = this._getBandSegmentCount(), d9 = [];
    let y5 = 0;
    for (y5 = 0; y5 < g5; y5++) u7 && !u7.includes(y5) || d9.push(this.request(this._files.data, { range: { from: p8[y5].from, to: p8[y5].to }, responseType: "array-buffer", signal: s3.signal }));
    const w5 = await Promise.all(d9), I4 = w5.map((t6) => t6.data.byteLength).reduce((t6, e4) => t6 + e4), b4 = new Uint8Array(I4), R2 = [];
    let A2 = 0;
    for (y5 = 0; y5 < g5; y5++) R2.push(A2), b4.set(new Uint8Array(w5[y5].data), A2), A2 += w5[y5].data.byteLength;
    const F3 = x.get(this.rasterInfo.storageInfo.compression).decoderFormat, _2 = await this.decodePixelBlock(b4.buffer, { width: o5, height: a4, format: F3, planes: (u7 == null ? void 0 : u7.length) || f6, offsets: R2, pixelType: c6 });
    if (null == _2) return null;
    let { noDataValue: S4 } = this.rasterInfo;
    if (null != S4 && "lerc" !== F3 && !_2.mask && (S4 = S4[0], null != S4)) {
      const t6 = _2.width * _2.height, e4 = new Uint8Array(t6);
      if (Math.abs(S4) > 1e24) for (y5 = 0; y5 < t6; y5++) Math.abs((_2.pixels[0][y5] - S4) / S4) > 1e-6 && (e4[y5] = 1);
      else for (y5 = 0; y5 < t6; y5++) _2.pixels[0][y5] !== S4 && (e4[y5] = 1);
      _2.mask = e4;
    }
    let k4 = 0, M = 0;
    if (m6 !== o5 || h6 !== a4) {
      let t6 = _2.mask;
      if (t6) for (y5 = 0; y5 < a4; y5++) if (M = y5 * o5, y5 < h6) for (k4 = m6; k4 < o5; k4++) t6[M + k4] = 0;
      else for (k4 = 0; k4 < o5; k4++) t6[M + k4] = 0;
      else for (t6 = new Uint8Array(o5 * a4), _2.mask = t6, y5 = 0; y5 < h6; y5++) for (M = y5 * o5, k4 = 0; k4 < m6; k4++) t6[M + k4] = 1;
    }
    return _2;
  }
  async _open(t5) {
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e3 = t5 ? t5.signal : null, r6 = await this.request(this.url, { responseType: "xml", signal: e3 }), { rasterInfo: s3, files: o5 } = this._parseHeader(r6.data), { skipMapInfo: a4, skipExtensions: i3 = [] } = this.ioConfig;
    if (!i3.includes("aux.xml") && !a4) {
      const e4 = await this._fetchAuxiliaryData(t5);
      null != e4 && (s3.statistics = e4.statistics ?? s3.statistics, s3.histograms = e4.histograms, e4.histograms && null == s3.statistics && (s3.statistics = p2(e4.histograms)));
    }
    a4 && this.updateImageSpaceRasterInfo(s3), this._set("rasterInfo", s3), this._files = o5;
    const n7 = await this.request(o5.index, { responseType: "array-buffer", signal: e3 });
    this._storageIndex = I3(n7.data);
    const { blockWidth: l4, blockHeight: f6 } = this.rasterInfo.storageInfo, c6 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: p8, height: m6 } = this.rasterInfo, h6 = [], u7 = this._getBandSegmentCount();
    let g5 = 0, y5 = -1;
    for (; g5 < this._storageIndex.length; ) {
      y5++;
      const t6 = Math.ceil(p8 / l4 / c6 ** y5) - 1, e4 = Math.ceil(m6 / f6 / c6 ** y5) - 1;
      g5 += (t6 + 1) * (e4 + 1) * u7 * 4, h6.push({ maxRow: e4, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = h6, y5 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y5), this.updateTileInfo();
  }
  _getBandSegmentCount() {
    return x.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e3, r6) {
    const { blockWidth: s3, blockHeight: o5, pyramidScalingFactor: a4 } = this.rasterInfo.storageInfo, { width: i3, height: n7 } = this.rasterInfo, l4 = this._getBandSegmentCount();
    let f6, c6, p8, m6 = 0, h6 = 0;
    for (p8 = 0; p8 < t5; p8++) h6 = a4 ** p8, f6 = Math.ceil(i3 / s3 / h6), c6 = Math.ceil(n7 / o5 / h6), m6 += f6 * c6;
    h6 = a4 ** t5, f6 = Math.ceil(i3 / s3 / h6), c6 = Math.ceil(n7 / o5 / h6), m6 += e3 * f6 + r6, m6 *= 4 * l4;
    const u7 = this._storageIndex.subarray(m6, m6 + 4 * l4);
    let g5 = 0, d9 = 0;
    const y5 = [];
    for (let x2 = 0; x2 < l4; x2++) g5 = u7[4 * x2] * 2 ** 32 + u7[4 * x2 + 1], d9 = g5 + u7[4 * x2 + 2] * 2 ** 32 + u7[4 * x2 + 3], y5.push({ from: g5, to: d9 });
    return { ranges: y5, actualTileWidth: r6 < f6 - 1 ? s3 : Math.ceil(i3 / h6) - s3 * (f6 - 1), actualTileHeight: e3 < c6 - 1 ? o5 : Math.ceil(n7 / h6) - o5 * (c6 - 1) };
  }
  _parseHeader(t5) {
    const r6 = e2(t5, "MRF_META/Raster");
    if (!r6) throw new s("mrf:open", "not a valid MRF format");
    const s3 = e2(r6, "Size"), n7 = parseInt(s3.getAttribute("x"), 10), c6 = parseInt(s3.getAttribute("y"), 10), m6 = parseInt(s3.getAttribute("c"), 10), g5 = (t3(r6, "Compression") || "none").toLowerCase();
    if (!x.has(g5)) throw new s("mrf:open", "currently does not support compression " + g5);
    const d9 = t3(r6, "DataType") || "UInt8", w5 = y4.get(d9);
    if (null == w5) throw new s("mrf:open", "currently does not support pixel type " + d9);
    const I4 = e2(r6, "PageSize"), b4 = parseInt(I4.getAttribute("x"), 10), R2 = parseInt(I4.getAttribute("y"), 10), A2 = e2(r6, "DataValues");
    let F3, _2;
    A2 && (_2 = A2.getAttribute("NoData"), null != _2 && (F3 = _2.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e2(t5, "MRF_META/CachedSource")) throw new s("mrf:open", "currently does not support MRF referencing other data files");
    const S4 = e2(t5, "MRF_META/GeoTags"), k4 = e2(S4, "BoundingBox");
    let M, j3 = false;
    if (null != k4) {
      const t6 = parseFloat(k4.getAttribute("minx")), e3 = parseFloat(k4.getAttribute("miny")), r7 = parseFloat(k4.getAttribute("maxx")), s4 = parseFloat(k4.getAttribute("maxy")), a4 = t3(S4, "Projection") || "";
      let n8 = g.WGS84;
      if ("LOCAL_CS[]" !== a4) if (a4.toLowerCase().startsWith("epsg:")) {
        const t7 = Number(a4.slice(5));
        isNaN(t7) || 0 === t7 || (n8 = new g({ wkid: t7 }));
      } else n8 = d7(a4) ?? g.WGS84;
      else j3 = true, n8 = new g({ wkid: 3857 });
      M = new w(t6, e3, r7, s4), M.spatialReference = n8;
    } else j3 = true, M = new w({ xmin: -0.5, ymin: 0.5 - c6, xmax: n7 - 0.5, ymax: 0.5, spatialReference: new g({ wkid: 3857 }) });
    const C = e2(t5, "MRF_META/Rsets"), T4 = parseInt((C == null ? void 0 : C.getAttribute("scale")) || "2", 10), L2 = M.spatialReference, U2 = new n4({ origin: new j({ x: M.xmin, y: M.ymax, spatialReference: L2 }), blockWidth: b4, blockHeight: R2, pyramidBlockWidth: b4, pyramidBlockHeight: R2, compression: g5, pyramidScalingFactor: T4 }), B3 = new j({ x: M.width / n7, y: M.height / c6, spatialReference: L2 }), E2 = new d3({ width: n7, height: c6, extent: M, isPseudoSpatialReference: j3, spatialReference: L2, bandCount: m6, pixelType: w5, pixelSize: B3, noDataValue: F3, storageInfo: U2 }), P3 = t3(t5, "datafile"), W2 = t3(t5, "IndexFile");
    return { rasterInfo: E2, files: { mrf: this.url, index: W2 || this.url.replace(".mrf", ".idx"), data: P3 || this.url.replace(".mrf", x.get(g5).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e3 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return S2(e3);
    } catch {
      return null;
    }
  }
};
function I3(t5) {
  if (t5.byteLength % 16 > 0) throw new Error("invalid array buffer must be multiples of 16");
  let e3, r6, s3, o5, a4, i3;
  if (r3) {
    for (r6 = new Uint8Array(t5), o5 = new ArrayBuffer(t5.byteLength), s3 = new Uint8Array(o5), a4 = 0; a4 < t5.byteLength / 4; a4++) for (i3 = 0; i3 < 4; i3++) s3[4 * a4 + i3] = r6[4 * a4 + 3 - i3];
    e3 = new Uint32Array(o5);
  } else e3 = new Uint32Array(t5);
  return e3;
}
r([m()], w4.prototype, "_files", void 0), r([m()], w4.prototype, "_storageIndex", void 0), r([m({ type: String, json: { write: true } })], w4.prototype, "datasetFormat", void 0), w4 = r([a2("esri.layers.support.rasterDatasets.MRFRaster")], w4);
var b3 = w4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t4(e3) {
  const t5 = e3.fields, r6 = e3.records, n7 = t5.some((e4) => "oid" === e4.name.toLowerCase()) ? "OBJECTID" : "OID", i3 = [{ name: n7, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e4) => ({ name: e4.name, type: "esriFieldType" + e4.typeName, alias: e4.name }))), a4 = i3.map((e4) => e4.name), s3 = [];
  let o5 = 0, l4 = 0;
  return r6.forEach((e4) => {
    const t6 = {};
    for (t6[n7] = o5++, l4 = 1; l4 < a4.length; l4++) t6[a4[l4]] = e4[l4 - 1];
    s3.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i3, features: s3 };
}
var r5 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r6) {
    const n7 = new DataView(r6), i3 = 3 & n7.getUint8(0);
    if (3 !== i3) return { header: { version: i3 }, recordSet: null };
    const a4 = n7.getUint32(4, true), s3 = n7.getUint16(8, true), o5 = n7.getUint16(10, true), l4 = { version: i3, recordCount: a4, headerByteCount: s3, recordByteCount: o5 };
    let p8 = 32;
    const d9 = [], g5 = [];
    let h6;
    if (3 === i3) {
      for (; 13 !== n7.getUint8(p8); ) h6 = String.fromCharCode(n7.getUint8(p8 + 11)).trim(), d9.push({ name: r2(new Uint8Array(r6, p8, 11)), type: h6, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(h6)], length: n7.getUint8(p8 + 16) }), p8 += 32;
      if (p8 += 1, d9.length > 0) for (; g5.length < a4 && r6.byteLength - p8 > o5; ) {
        const t5 = [];
        32 === n7.getUint8(p8) ? (p8 += 1, d9.forEach((n8) => {
          if ("C" === n8.type) t5.push(r2(new Uint8Array(r6, p8, n8.length)).trim());
          else if ("N" === n8.type) t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r6, p8, n8.length)).trim(), 10));
          else if ("F" === n8.type) t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r6, p8, n8.length)).trim()));
          else if ("D" === n8.type) {
            const e3 = String.fromCharCode.apply(null, new Uint8Array(r6, p8, n8.length)).trim();
            t5.push(new Date(parseInt(e3.slice(0, 4), 10), parseInt(e3.slice(4, 6), 10) - 1, parseInt(e3.slice(6, 8), 10)));
          }
          p8 += n8.length;
        }), g5.push(t5)) : p8 += o5;
      }
    }
    return { header: l4, fields: d9, records: g5, recordSet: t4({ fields: d9, records: g5 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var _ = (e3, t5) => {
  var _a;
  return (_a = e3.get(t5)) == null ? void 0 : _a.values;
};
var F2 = (e3, t5) => {
  var _a, _b;
  return (_b = (_a = e3.get(t5)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var v3 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async fetchRawTile(e3, t5, r6, i3 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e3, t5, r6)) return null;
    const s3 = await this._fetchRawTiffTile(e3, t5, r6, false, i3);
    if (null != s3 && this._headerInfo.hasMaskBand) {
      const a4 = await this._fetchRawTiffTile(e3, t5, r6, true, i3);
      null != a4 && a4.pixels[0] instanceof Uint8Array && (s3.mask = a4.pixels[0]);
    }
    return s3;
  }
  async _open(e3) {
    var _a, _b, _c, _d;
    const t5 = e3 ? e3.signal : null, { data: s3 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: t5 });
    if (!s3) throw new s("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a4, firstIFDPos: n7, isBigTiff: o5 } = F(s3), f6 = [];
    await this._readIFDs(f6, s3, a4, n7, 0, o5 ? 8 : 4, t5);
    const { imageInfo: l4, rasterInfo: u7 } = k3(f6), p8 = N(f6), c6 = U(f6);
    if (this._headerInfo = { littleEndian: a4, isBigTiff: o5, ifds: f6, pyramidIFDs: p8, maskIFDs: c6, ...l4 }, this._set("rasterInfo", u7), !l4.isSupported) throw new s("tiffraster:open", "this tiff is not supported: " + l4.message);
    if (!l4.tileWidth) throw new s("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    u7.isPseudoSpatialReference && n.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const h6 = (_b = (_a = f6[0].get("PREDICTOR")) == null ? void 0 : _a.values) == null ? void 0 : _b[0], m6 = (_d = (_c = f6[0].get("SAMPLEFORMAT")) == null ? void 0 : _c.values) == null ? void 0 : _d[0];
    if (3 === m6 && 2 === h6) throw new s("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");
    const { skipMapInfo: x2, skipExtensions: T4 = [] } = this.ioConfig;
    if (!T4.includes("aux.xml") && !x2) {
      const t6 = await this._fetchAuxiliaryMetaData(e3);
      null != t6 && P2(t6, u7);
    }
    T4.includes("vat.dbf") || 1 !== u7.bandCount || "u8" !== u7.pixelType || x2 || (u7.attributeTable = await this._fetchAuxiliaryTable(e3), null != u7.attributeTable && (u7.keyProperties.DataType = "thematic")), x2 && this.updateImageSpaceRasterInfo(u7), this.updateTileInfo();
  }
  async _readIFDs(e3, t5, r6, i3, s3, a4 = 4, n7) {
    if (!i3) return null;
    if (i3 >= t5.byteLength || i3 < 0) {
      t5 = (await this.request(this.url, { range: { from: i3 + s3, to: i3 + s3 + this._bufferSize }, responseType: "array-buffer", signal: n7 })).data, s3 = i3 + s3, i3 = 0;
    }
    const o5 = await this._readIFD(t5, r6, i3, s3, n3.tiffTags, a4, n7);
    if (e3.push(o5.ifd), !o5.nextIFD) return null;
    await this._readIFDs(e3, t5, r6, o5.nextIFD - s3, s3, a4, n7);
  }
  async _readIFD(e3, r6, i3, s3, a4 = n3.tiffTags, n7 = 4, o5) {
    var _a, _b;
    if (!e3) return null;
    const f6 = B(e3, r6, i3, s3, a4, n7);
    if (f6.success) {
      const i4 = [];
      if ((_a = f6.ifd) == null ? void 0 : _a.forEach((e4) => {
        e4.values || i4.push(e4);
      }), i4.length > 0) {
        const a5 = i4.map((e4) => e4.offlineOffsetSize).filter(G), n8 = Math.min.apply(null, a5.map((e4) => e4[0]));
        if (Math.min.apply(null, a5.map((e4) => e4[0] + e4[1])) - n8 <= this._bufferSize) {
          const { data: t5 } = await this.request(this.url, { range: { from: n8, to: n8 + this._bufferSize }, responseType: "array-buffer", signal: o5 });
          e3 = t5, s3 = n8, i4.forEach((t6) => L(e3, r6, t6, s3));
        }
      }
      if ((_b = f6.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const t5 = f6.ifd.get("GEOKEYDIRECTORY"), i5 = t5 == null ? void 0 : t5.values;
        if (i5 && i5.length > 4) {
          const a5 = i5[0] + "." + i5[1] + "." + i5[2], n8 = await this._readIFD(e3, r6, t5.valueOffset + 6 - s3, s3, n3.geoKeys, 2, o5);
          t5.data = n8.ifd, t5.data && t5.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a5] });
        }
      }
      return f6;
    }
    if (f6.requiredBufferSize && f6.requiredBufferSize !== e3.byteLength) {
      const t5 = await this.request(this.url, { range: { from: s3, to: s3 + f6.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o5 });
      return (e3 = t5.data).byteLength < f6.requiredBufferSize ? null : this._readIFD(e3, r6, 0, s3, n3.tiffTags, 4, o5);
    }
  }
  async _fetchRawTiffTile(e3, t5, r6, i3, s3 = {}) {
    const a4 = this._getTileLocation(e3, t5, r6, i3);
    if (!a4) return null;
    const { ranges: n7, actualTileWidth: o5, actualTileHeight: f6, ifd: l4 } = a4, u7 = n7.map((e4) => this.request(this.url, { range: e4, responseType: "array-buffer", signal: s3.signal })), p8 = await Promise.all(u7), c6 = p8.map((e4) => e4.data.byteLength).reduce((e4, t6) => e4 + t6), h6 = 1 === p8.length ? p8[0].data : new ArrayBuffer(c6), m6 = [0], d9 = [0];
    if (p8.length > 1) {
      const e4 = new Uint8Array(h6);
      for (let t6 = 0, r7 = 0; t6 < p8.length; t6++) {
        const i4 = p8[t6].data;
        e4.set(new Uint8Array(i4), r7), m6[t6] = r7, r7 += i4.byteLength, d9[t6] = i4.byteLength;
      }
    }
    const { blockWidth: y5, blockHeight: g5 } = this.getBlockWidthHeight(e3), x2 = await this.decodePixelBlock(h6, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l4, offsets: m6, sizes: d9 }, width: y5, height: g5, planes: null, pixelType: null });
    if (null == x2) return null;
    let T4, I4, w5;
    if (o5 !== y5 || f6 !== g5) {
      let e4 = x2.mask;
      if (e4) for (T4 = 0; T4 < g5; T4++) if (w5 = T4 * y5, T4 < f6) for (I4 = o5; I4 < y5; I4++) e4[w5 + I4] = 0;
      else for (I4 = 0; I4 < y5; I4++) e4[w5 + I4] = 0;
      else for (e4 = new Uint8Array(y5 * g5), x2.mask = e4, T4 = 0; T4 < f6; T4++) for (w5 = T4 * y5, I4 = 0; I4 < o5; I4++) e4[w5 + I4] = 1;
    }
    return x2;
  }
  _getTileLocation(e3, t5, r6, i3 = false) {
    const { firstPyramidLevel: s3, blockBoundary: a4 } = this.rasterInfo.storageInfo, n7 = 0 === e3 ? 0 : e3 - (s3 - 1), { _headerInfo: o5 } = this;
    if (!o5) return null;
    const f6 = i3 ? o5.maskIFDs[n7] : 0 === n7 ? o5 == null ? void 0 : o5.ifds[0] : o5 == null ? void 0 : o5.pyramidIFDs[n7 - 1];
    if (!f6) return null;
    const l4 = R(f6, o5), u7 = _(f6, "TILEOFFSETS");
    if (void 0 === u7) return null;
    const p8 = _(f6, "TILEBYTECOUNTS"), { minRow: c6, minCol: h6, maxRow: m6, maxCol: d9 } = a4[n7];
    if (t5 > m6 || r6 > d9 || t5 < c6 || r6 < h6) return null;
    const y5 = F2(f6, "IMAGEWIDTH"), g5 = F2(f6, "IMAGELENGTH"), x2 = F2(f6, "TILEWIDTH"), T4 = F2(f6, "TILELENGTH"), w5 = [];
    if (l4) {
      const { bandCount: e4 } = this.rasterInfo;
      for (let i4 = 0; i4 < e4; i4++) {
        const e5 = i4 * (m6 + 1) * (d9 + 1) + t5 * (d9 + 1) + r6;
        w5[i4] = { from: u7[e5], to: u7[e5] + p8[e5] - 1 };
      }
    } else {
      const e4 = t5 * (d9 + 1) + r6;
      w5.push({ from: u7[e4], to: u7[e4] + p8[e4] - 1 });
    }
    for (let I4 = 0; I4 < w5.length; I4++) if (null == w5[I4].from || !w5[I4].to || w5[I4].to < 0) return null;
    return { ranges: w5, ifd: f6, actualTileWidth: r6 === d9 && y5 % x2 || x2, actualTileHeight: t5 === m6 && g5 % T4 || T4 };
  }
  async _fetchAuxiliaryMetaData(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 == null ? void 0 : e3.signal });
      return S2(t5);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e3 == null ? void 0 : e3.signal }), r6 = r5.parse(t5);
      return (r6 == null ? void 0 : r6.recordSet) ? d4.fromJSON(r6.recordSet) : null;
    } catch {
      return null;
    }
  }
};
function k3(e3) {
  var _a, _b;
  const t5 = D(e3), { width: r6, height: i3, tileWidth: s3, tileHeight: a4, planes: p8, pixelType: c6, compression: h6, firstPyramidLevel: d9, maximumPyramidLevel: y5, pyramidBlockWidth: g5, pyramidBlockHeight: x2, pyramidResolutions: T4, tileBoundary: I4, affine: R2, metadata: b4 } = t5, S4 = ((_a = t5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t5.extent.spatialReference) == null ? void 0 : _b.wkid);
  let v4 = d7(S4), k4 = !!t5.isPseudoGeographic;
  null == v4 && (k4 = true, v4 = new g({ wkid: 3857 }));
  const P3 = new w({ ...t5.extent, spatialReference: v4 }), D3 = new j(P3 ? { x: P3.xmin, y: P3.ymax, spatialReference: v4 } : { x: 0, y: 0 }), O = new n4({ blockWidth: s3, blockHeight: a4, pyramidBlockWidth: g5, pyramidBlockHeight: x2, compression: h6, origin: D3, firstPyramidLevel: d9, maximumPyramidLevel: y5, pyramidResolutions: T4, blockBoundary: I4 }), L2 = new j({ x: (P3.xmax - P3.xmin) / r6, y: (P3.ymax - P3.ymin) / i3, spatialReference: v4 }), B3 = b4 ? { BandProperties: b4.bandProperties, DataType: b4.dataType } : {};
  let j3 = null;
  const z2 = F2(e3[0], "PHOTOMETRICINTERPRETATION"), A2 = _(e3[0], "COLORMAP");
  if (z2 <= 3 && (A2 == null ? void 0 : A2.length) > 3 && A2.length % 3 == 0) {
    j3 = [];
    const e4 = A2.length / 3;
    for (let t6 = 0; t6 < e4; t6++) j3.push([t6, A2[t6] >>> 8, A2[t6 + e4] >>> 8, A2[t6 + 2 * e4] >>> 8]);
  }
  const C = new d3({ width: r6, height: i3, bandCount: p8, pixelType: c6, pixelSize: L2, storageInfo: O, spatialReference: v4, isPseudoSpatialReference: k4, keyProperties: B3, extent: P3, colormap: j3, statistics: b4 ? b4.statistics : null });
  if ((R2 == null ? void 0 : R2.length) && (C.nativeExtent = new w({ xmin: -0.5, ymin: 0.5 - i3, xmax: r6 - 0.5, ymax: 0.5, spatialReference: v4 }), C.transform = new y3({ polynomialOrder: 1, forwardCoefficients: [R2[2] + R2[0] / 2, R2[5] - R2[3] / 2, R2[0], R2[3], -R2[1], -R2[4]] }), C.extent = C.transform.forwardTransform(C.nativeExtent), C.pixelSize = new j({ x: (P3.xmax - P3.xmin) / r6, y: (P3.ymax - P3.ymin) / i3, spatialReference: v4 }), O.origin.x = -0.5, O.origin.y = 0.5), T4) {
    const { x: e4, y: t6 } = C.pixelSize;
    T4.forEach((r7) => {
      r7.x *= e4, r7.y *= t6;
    });
  }
  return { imageInfo: t5, rasterInfo: C };
}
function P2(e3, t5) {
  if (t5.statistics = e3.statistics ?? t5.statistics, t5.histograms = e3.histograms, e3.histograms && null == t5.statistics && (t5.statistics = p2(e3.histograms)), e3.transform && null == t5.transform) {
    t5.transform = e3.transform, t5.nativeExtent = t5.extent;
    const r6 = t5.transform.forwardTransform(t5.nativeExtent);
    t5.pixelSize = new j({ x: (r6.xmax - r6.xmin) / t5.width, y: (r6.ymax - r6.ymin) / t5.height, spatialReference: t5.spatialReference }), t5.extent = r6;
  }
  t5.isPseudoSpatialReference && e3.spatialReference && (t5.spatialReference = e3.spatialReference, t5.extent.spatialReference = t5.nativeExtent.spatialReference = t5.storageInfo.origin.spatialReference = t5.spatialReference);
}
r([m()], v3.prototype, "_files", void 0), r([m()], v3.prototype, "_headerInfo", void 0), r([m()], v3.prototype, "_bufferSize", void 0), r([m({ type: String, json: { write: true } })], v3.prototype, "datasetFormat", void 0), v3 = r([a2("esri.layers.support.rasterDatasets.TIFFRaster")], v3);
var D2 = v3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var n6 = /* @__PURE__ */ new Map();
n6.set("MRF", { desc: "Meta Raster Format", constructor: b3 }), n6.set("TIFF", { desc: "GeoTIFF", constructor: D2 }), n6.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I2 }), n6.set("JPG", { desc: "JPG Raster Format", constructor: d8 }), n6.set("PNG", { desc: "PNG Raster Format", constructor: d8 }), n6.set("GIF", { desc: "GIF Raster Format", constructor: d8 }), n6.set("BMP", { desc: "BMP Raster Format", constructor: d8 }), n6.set("CovJSON", { desc: "COVJSON Raster Format", constructor: h4 }), n6.set("MEMORY", { desc: "In Memory Raster Format", constructor: g3 });
var u6 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return n6.forEach((r6, e3) => t5.add(e3)), t5;
  }
  static async open(r6) {
    var _a;
    const { url: e3, ioConfig: s3, source: o5, sourceJSON: a4 } = r6;
    let c6 = r6.datasetFormat ?? (s3 == null ? void 0 : s3.datasetFormat);
    null == c6 && (e3.includes(".") ? c6 = e3.slice(e3.lastIndexOf(".") + 1).toUpperCase() : "coverage" === ((_a = o5 == null ? void 0 : o5.type) == null ? void 0 : _a.toLowerCase()) ? c6 = "CovJSON" : (o5 == null ? void 0 : o5.extent) && o5.pixelblocks && (c6 = "MEMORY")), "OVR" === c6 || "TIF" === c6 ? c6 = "TIFF" : "JPG" === c6 || "JPEG" === c6 || "JFIF" === c6 ? c6 = "JPG" : "COVJSON" === c6 && (c6 = "CovJSON"), e3.toLowerCase().includes("/imageserver") && !e3.toLowerCase().includes("/wcsserver") && (c6 = "RasterTileServer");
    const u7 = { url: e3, source: o5, sourceJSON: a4, datasetFormat: c6, ioConfig: s3 ?? { bandIds: null, sampling: null } };
    if (Object.keys(u7).forEach((t5) => {
      null == u7[t5] && delete u7[t5];
    }), c6) {
      if (!this.supportedFormats.has(c6)) throw new s("rasterfactory:open", "not a supported format " + c6);
      if ("CRF" === c6) throw new s("rasterfactory:open", `cannot open raster: ${e3}`);
      const s4 = new (0, n6.get(c6).constructor)(u7);
      return await s4.open({ signal: r6.signal }), s4;
    }
    const i3 = Array.from(n6.keys()).filter((t5) => "CovJSON" !== t5 && "Memory" !== t5);
    let l4 = 0;
    const m6 = () => {
      if (c6 = i3[l4++], !c6) return null;
      if ("CRF" === c6) return null;
      const t5 = new (0, n6.get(c6).constructor)(u7);
      return t5.open({ signal: r6.signal }).then(() => t5).catch(() => m6());
    };
    return m6();
  }
  static register(t5, r6, e3) {
    n6.has(t5.toUpperCase()) || n6.set(t5.toUpperCase(), { desc: r6, constructor: e3 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var V = class extends p(t(b(j2(o2(e(K(l3(l2(f2(S(a3.ClonableMixin(f)))))))))))) {
  constructor(...e3) {
    super(...e3), this._primaryRasters = [], this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this.source = void 0, this._debouncedSaveOperations = k(async (e4, t5, r6) => {
      const { save: s3, saveAs: i3 } = await import("./imageryUtils-ACOGEUZB.js");
      switch (e4) {
        case A.SAVE:
          return s3(this, t5);
        case A.SAVE_AS:
          return i3(this, r6, t5);
      }
    });
  }
  normalizeCtorArgs(e3, t5) {
    return "string" == typeof e3 ? { url: e3, ...t5 } : e3;
  }
  load(e3) {
    const t5 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(a).then(() => this._openRaster(t5))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a, _b;
    const e3 = [o("Pixel Value"), c2("Raw Pixel Value")], t5 = ((_a = this.raster) == null ? void 0 : _a.rasterInfo) ?? this.serviceRasterInfo, r6 = t5 == null ? void 0 : t5.attributeTable;
    if (r6) {
      const t6 = v(r6);
      e3.push(...t6);
    }
    const s3 = t5 == null ? void 0 : t5.dataType, i3 = t5 == null ? void 0 : t5.multidimensionalInfo;
    if (("vector-magdir" === s3 || "vector-uv" === s3) && null != i3) {
      const t6 = (_b = i3.variables[0].unit) == null ? void 0 : _b.trim(), r7 = d5(t6), s4 = $();
      e3.push(r7, s4);
    }
    if (i3) {
      const t6 = p5(i3);
      e3.push(...t6);
    }
    return e3;
  }
  createPopupTemplate(e3) {
    const { rasterFields: t5 } = this, r6 = (e3 == null ? void 0 : e3.visibleFieldNames) ?? new Set(t5.map(({ name: e4 }) => e4).filter((e4) => e4 !== t2.rawServicePixelValue)), s3 = p3({ fields: t5, title: this.title }, { ...e3, visibleFieldNames: r6 }), { rasterInfo: i3 } = this.raster;
    return (s3 == null ? void 0 : s3.fieldInfos) && i3 && b2(s3.fieldInfos, i3), s3;
  }
  async generateRasterInfo(e3, t5) {
    var _a;
    if (e3 = h(w3, e3), await this.load(), !e3 || "none" === ((_a = e3.functionName) == null ? void 0 : _a.toLowerCase())) return this.serviceRasterInfo;
    try {
      const { rasterInfo: r6 } = await this._openFunctionRaster(e3, t5);
      return r6;
    } catch (r6) {
      if (r6 instanceof s) throw r6;
      throw new s("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, t5) {
    return this._debouncedSaveOperations(A.SAVE_AS, t5, e3);
  }
  write(e3, t5) {
    const r6 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === r6.datasetFormat && ("Raster" === r6.tileType || "Map" === r6.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url)) return super.write(e3, t5);
    if (t5 == null ? void 0 : t5.messages) {
      const e4 = `${t5.origin}/${t5.layerContainerType || "operational-layers"}`;
      t5.messages.push(new s("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e3) {
    var _a;
    let t5 = false;
    if (this.raster) await this._openFromRaster(this.raster, e3), t5 = "Function" === this.raster.datasetFormat, !t5 && this.rasterFunction && (this._primaryRasters = [this.raster], await this._initializeWithFunctionRaster(this.rasterFunction));
    else {
      const { url: t6, rasterFunction: r7, source: i3 } = this;
      if (!t6 && !i3) throw new s("imagery-tile-layer:open", "missing url or source parameter");
      i3 ? await this._openFromSource(i3, e3) : r7 ? await this._openFromUrlWithRasterFunction(t6, r7, e3) : await this._openFromUrl(t6, e3);
    }
    const r6 = this.raster.rasterInfo;
    if (!r6) throw new s("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("serviceRasterInfo", t5 ? r6 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", r6.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e4 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e4, { origin: "service" });
    } else this.read({ tileInfo: (_a = this.serviceRasterInfo) == null ? void 0 : _a.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(d(() => this.customParameters, (e4) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e4);
    }));
  }
  async _openFromRaster(e3, t5) {
    e3.rasterInfo || await e3.open({ signal: t5 }), this._primaryRasters = "Function" === e3.datasetFormat ? e3.primaryRasters.rasters : [e3], this.url || (this.url = this._primaryRasters[0].url);
  }
  async _openFromUrlWithRasterFunction(e3, t5, r6) {
    const i3 = [e3];
    t5 && w2(t5.toJSON(), i3);
    const o5 = await Promise.all(i3.map((e4) => u6.open({ url: e4, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: r6 }))), a4 = o5.findIndex((e4) => null == e4);
    if (a4 > -1) throw new s("imagery-tile-layer:open", `cannot open raster: ${i3[a4]}`);
    return this._primaryRasters = o5, this._initializeWithFunctionRaster(t5);
  }
  async _openFromUrl(e3, t5) {
    const r6 = await u6.open({ url: e3, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == r6) throw new s("imagery-tile-layer:open", `cannot open raster: ${e3}`);
    this._primaryRasters = [r6], this.raster = r6;
  }
  async _openFromSource(e3, t5) {
    var _a;
    const r6 = "the tiled imagery data source is not supported", i3 = "coverage" === ((_a = e3.type) == null ? void 0 : _a.toLowerCase()) ? "CovJSON" : e3.extent && e3.pixelBlock ? "MEMORY" : null;
    if (!i3) throw new s("imagery-tile-layer:open", r6);
    "MEMORY" === i3 && (e3 = { ...e3, pixelBlock: void 0, pixelBlocks: [e3.pixelBlock] });
    const o5 = await u6.open({ url: "", source: e3, datasetFormat: i3, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == o5) throw new s("imagery-tile-layer:open", r6);
    this._primaryRasters = [o5], this.rasterFunction ? await this._initializeWithFunctionRaster(this.rasterFunction) : this.raster = o5;
  }
  async _openFunctionRaster(e3, t5) {
    var _a;
    const r6 = { raster: this._primaryRasters[0] };
    this._primaryRasters.length > 1 && this._primaryRasters.forEach((e4) => r6[e4.url] = e4);
    const s3 = T2(((_a = e3.functionDefinition) == null ? void 0 : _a.toJSON()) ?? e3.toJSON(), r6), i3 = new u2({ rasterFunction: s3 });
    return await i3.open(t5), i3;
  }
  async _initializeWithFunctionRaster(e3, t5) {
    try {
      this.raster = await this._openFunctionRaster(e3, t5);
    } catch (r6) {
      r6 instanceof s && n.getLogger(this).error("imagery-tile-layer:open", r6.message), n.getLogger(this).warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = this._primaryRasters[0];
    }
  }
};
r([m({ clonable: false })], V.prototype, "_primaryRasters", void 0), r([m(d2)], V.prototype, "legendEnabled", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], V.prototype, "isReference", void 0), r([m({ type: ["show", "hide"] })], V.prototype, "listMode", void 0), r([m({ json: { read: true, write: true } })], V.prototype, "blendMode", void 0), r([m({ type: w3, json: { name: "renderingRule", write: true } })], V.prototype, "rasterFunction", void 0), r([m()], V.prototype, "sourceJSON", void 0), r([m({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], V.prototype, "version", void 0), r([m({ readOnly: true, json: { read: false } })], V.prototype, "type", void 0), r([m({ type: ["ArcGISTiledImageServiceLayer"] })], V.prototype, "operationalLayerType", void 0), r([m({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, t5) => !t5.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e3, t5, r6) {
  t5[r6] = !e3;
} } } })], V.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], V.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], V.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, type: [y2] })], V.prototype, "fields", void 0), r([m({ readOnly: true, type: [y2] })], V.prototype, "rasterFields", null), r([m({ constructOnly: true })], V.prototype, "source", void 0), V = r([a2("esri.layers.ImageryTileLayer")], V);
var B2 = V;
export {
  B2 as default
};
//# sourceMappingURL=ImageryTileLayer-KXMHGZNT.js.map
