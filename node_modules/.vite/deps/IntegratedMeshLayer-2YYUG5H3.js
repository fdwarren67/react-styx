import {
  v as v2
} from "./chunk-SGYJ7J7R.js";
import "./chunk-FDGPK3YS.js";
import {
  a as a4,
  m as m2,
  p as p2,
  y
} from "./chunk-AAJ7HOPE.js";
import {
  R,
  V as V2
} from "./chunk-Q6AGOKIE.js";
import {
  $,
  Z,
  w
} from "./chunk-LULXSZFE.js";
import "./chunk-6AWA6GOC.js";
import "./chunk-5Y5NK5SR.js";
import "./chunk-SXBN3QCZ.js";
import "./chunk-XD7AJMUV.js";
import "./chunk-6TUECH7E.js";
import "./chunk-3ECUFCNI.js";
import "./chunk-BSQH3I7W.js";
import {
  i
} from "./chunk-5GYWQFHA.js";
import {
  l
} from "./chunk-WOB72RZU.js";
import {
  e
} from "./chunk-RTA3XNM7.js";
import {
  j as j2
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  b
} from "./chunk-C6YDI6QX.js";
import {
  c
} from "./chunk-DJ5HVIE7.js";
import {
  S as S2
} from "./chunk-KPY4ZIC2.js";
import "./chunk-WO43UGNC.js";
import {
  L,
  sn
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-BBPRJCMB.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-GSNLF6RP.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  C,
  v
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import {
  V
} from "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  p
} from "./chunk-BECTSF5P.js";
import {
  I
} from "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3,
  s as s2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a as a2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  a,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/SceneModification.js
var m3;
var f2 = m3 = class extends S {
  constructor(e2) {
    super(e2), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e2, r3, o2, s3) {
    var _a;
    if (((_a = s3.layer) == null ? void 0 : _a.spatialReference) && !s3.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!L(e2.spatialReference, s3.layer.spatialReference)) return void ((s3 == null ? void 0 : s3.messages) && s3.messages.push(new s2("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s3.layer.spatialReference, context: s3 })));
      const p3 = new j();
      sn(e2, p3, s3.layer.spatialReference), r3[o2] = p3.toJSON(s3);
    } else r3[o2] = e2.toJSON(s3);
    delete r3[o2].spatialReference;
  }
  clone() {
    return new m3({ geometry: a(this.geometry), type: this.type });
  }
};
r([m({ type: j }), v2()], f2.prototype, "geometry", void 0), r([r2(["web-scene", "portal-item"], "geometry")], f2.prototype, "writeGeometry", null), r([m({ type: ["clip", "mask", "replace"], nonNullable: true }), v2()], f2.prototype, "type", void 0), f2 = m3 = r([a3("esri.layers.support.SceneModification")], f2);
var y2 = f2;

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var n2;
var m4 = n2 = class extends S.JSONSupportMixin(V.ofType(y2)) {
  constructor(r3) {
    super(r3), this.url = null;
  }
  clone() {
    return new n2({ url: this.url, items: this.items.map((r3) => r3.clone()) });
  }
  toJSON(r3) {
    return this.toArray().map((o2) => o2.toJSON(r3)).filter((r4) => !!r4.geometry);
  }
  static fromJSON(r3, o2) {
    const t2 = new n2();
    for (const e2 of r3) t2.add(y2.fromJSON(e2, o2));
    return t2;
  }
  static async fromUrl(r3, t2, e2) {
    const i2 = { url: I(r3), origin: "service" }, c2 = await P(r3, { responseType: "json", signal: e2 == null ? void 0 : e2.signal }), m5 = t2.toJSON(), a6 = [];
    for (const o2 of c2.data) a6.push(y2.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: m5 } }, i2));
    return new n2({ url: r3, items: a6 });
  }
};
r([m({ type: String })], m4.prototype, "url", void 0), m4 = n2 = r([a3("esri.layers.support.SceneModifications")], m4);
var a5 = m4;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var A = class extends R(l(b(j2(t(S2(e(i(f)))))))) {
  constructor(...e2) {
    super(...e2), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.path = null, this.definitionExpression = null;
  }
  initialize() {
    this.addHandles(v(() => this.modifications, "after-changes", () => this.modifications = this.modifications, C));
  }
  normalizeCtorArgs(e2, t2) {
    return "string" == typeof e2 ? { url: e2, ...t2 } : e2;
  }
  readModifications(e2, t2, o2) {
    this._modificationsSource = { url: p(e2, o2), context: o2 };
  }
  set elevationInfo(e2) {
    null != e2 && "absolute-height" !== e2.mode || this._set("elevationInfo", e2), this._validateElevationInfo(e2);
  }
  async load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), this;
  }
  async _doLoad(e2) {
    const t2 = e2 == null ? void 0 : e2.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e2);
    } catch (o2) {
      a2(o2);
    }
    if (await this._fetchService(t2), null != this._modificationsSource) {
      const t3 = await a5.fromUrl(this._modificationsSource.url, this.spatialReference, e2);
      this.setAtOrigin("modifications", t3, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t2);
  }
  beforeSave() {
    if (null != this._modificationsSource) return this.load().then(() => {
    }, () => {
    });
  }
  async saveAs(e2, t2) {
    return this._debouncedSaveOperations(V2.SAVE_AS, { ...t2, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e2);
  }
  async save() {
    const e2 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(V2.SAVE, e2);
  }
  validateLayer(e2) {
    if (e2.layerType && "IntegratedMesh" !== e2.layerType) throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e2.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
  _validateElevationInfo(e2) {
    const t2 = "Integrated mesh layers";
    $(n.getLogger(this), Z(t2, "absolute-height", e2)), $(n.getLogger(this), w(t2, e2));
  }
};
r([m({ type: String, readOnly: true })], A.prototype, "geometryType", void 0), r([m({ type: ["show", "hide"] })], A.prototype, "listMode", void 0), r([m({ type: ["IntegratedMeshLayer"] })], A.prototype, "operationalLayerType", void 0), r([m({ json: { read: false }, readOnly: true })], A.prototype, "type", void 0), r([m({ type: p2, readOnly: true })], A.prototype, "nodePages", void 0), r([m({ type: [a4], readOnly: true })], A.prototype, "materialDefinitions", void 0), r([m({ type: [y], readOnly: true })], A.prototype, "textureSetDefinitions", void 0), r([m({ type: [m2], readOnly: true })], A.prototype, "geometryDefinitions", void 0), r([m({ readOnly: true })], A.prototype, "serviceUpdateTimeStamp", void 0), r([m({ type: a5 }), v2({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], A.prototype, "modifications", void 0), r([o(["web-scene", "portal-item"], "modifications")], A.prototype, "readModifications", null), r([m(c)], A.prototype, "elevationInfo", null), r([m({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], A.prototype, "path", void 0), A = r([a3("esri.layers.IntegratedMeshLayer")], A);
var P2 = A;
export {
  P2 as default
};
//# sourceMappingURL=IntegratedMeshLayer-2YYUG5H3.js.map
