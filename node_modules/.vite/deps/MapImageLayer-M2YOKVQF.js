import {
  y as y2
} from "./chunk-KTOV24GA.js";
import "./chunk-M44TFGCQ.js";
import {
  f as f3,
  m as m2,
  se
} from "./chunk-RLLWSFJD.js";
import {
  e as e3
} from "./chunk-TMXFIMYK.js";
import "./chunk-6TKDWEU3.js";
import "./chunk-M76M42H4.js";
import "./chunk-KERBX4PO.js";
import "./chunk-N7FB6BVA.js";
import "./chunk-36CN7JP2.js";
import "./chunk-WX3BOMD3.js";
import "./chunk-TSFKACKN.js";
import "./chunk-W5QWJI4E.js";
import "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import {
  t as t3
} from "./chunk-YZNN4Y2U.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-3XDQGJHT.js";
import "./chunk-BMOULVP4.js";
import "./chunk-LVHCS2TZ.js";
import "./chunk-YSZGPB5I.js";
import {
  i
} from "./chunk-5GYWQFHA.js";
import "./chunk-QOBHQZYU.js";
import "./chunk-CKW4LZG2.js";
import "./chunk-VYOLHG4T.js";
import {
  i as i2
} from "./chunk-TKEIF3N7.js";
import "./chunk-RMOE6XHW.js";
import "./chunk-QAXPIBME.js";
import {
  t as t4
} from "./chunk-ISRSQJQR.js";
import {
  l
} from "./chunk-WOB72RZU.js";
import {
  l as l2
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import "./chunk-S4QLDBOB.js";
import {
  e as e2
} from "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-XZDT5RTS.js";
import "./chunk-QAP2FVP7.js";
import "./chunk-6EREU4EG.js";
import "./chunk-7DHQ2VMC.js";
import "./chunk-ZXHHBJMH.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-ZDLUQDDX.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import "./chunk-5T3XQRJL.js";
import "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import {
  j
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f2
} from "./chunk-73NNNHMH.js";
import {
  b as b2
} from "./chunk-C6YDI6QX.js";
import {
  y
} from "./chunk-DJ5HVIE7.js";
import {
  S
} from "./chunk-KPY4ZIC2.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-BBPRJCMB.js";
import {
  t
} from "./chunk-THN5CUTS.js";
import "./chunk-FF3WJRKN.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-RO66CZDO.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  p as p2
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t as t2
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import {
  p
} from "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import {
  a as a3
} from "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  c
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  e,
  m,
  n2 as n
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a,
  b
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  x
} from "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/MapImageLayer.js
var J = class extends p2(l2(t2(m2(f3(l(b2(j(S(f2(i(e2(f)))))))))))) {
  constructor(...e4) {
    super(...e4), this._exportImageParameters = new y2({ layer: this }), this.dateFieldsTimeZone = null, this.datesInUnknownTimezone = false, this.dpi = 96, this.gdbVersion = null, this.imageFormat = "png24", this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.isReference = null, this.labelsVisible = false, this.operationalLayerType = "ArcGISMapServiceLayer", this.preferredTimeZone = null, this.sourceJSON = null, this.sublayers = null, this.type = "map-image", this.url = null;
  }
  normalizeCtorArgs(e4, r3) {
    return "string" == typeof e4 ? { url: e4, ...r3 } : e4;
  }
  load(e4) {
    const r3 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Map Service"] }, e4).catch(a).then(() => this._fetchService(r3))), Promise.resolve(this);
  }
  destroy() {
    this._exportImageParameters.destroy();
  }
  readImageFormat(e4, r3) {
    const t5 = r3.supportedImageFormatTypes;
    return t5 && t5.includes("PNG32") ? "png32" : "png24";
  }
  writeSublayers(e4, r3, t5, i3) {
    var _a, _b, _c;
    if (!this.loaded || !e4) return;
    const s2 = e4.slice().reverse().flatten(({ sublayers: e5 }) => e5 && e5.toArray().reverse()).toArray();
    let o2 = false;
    const a4 = n(i3.origin);
    if (((_a = this.capabilities) == null ? void 0 : _a.operations.supportsExportMap) && ((_c = (_b = this.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsDynamicLayers)) {
      if (a4 === e.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("service").sublayers;
        o2 = e3(s2, e5, e.SERVICE);
      } else if (a4 > e.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("portal-item");
        o2 = e3(s2, e5.sublayers, n(e5.origin));
      }
    }
    const p3 = [], n2 = { writeSublayerStructure: o2, ...i3 };
    let m3 = o2 || this.hasVisibleLayersForOrigin(a4);
    s2.forEach((e5) => {
      const r4 = e5.write({}, n2);
      p3.push(r4), m3 = m3 || "user" === e5.originOf("visible");
    });
    p3.some((e5) => Object.keys(e5).length > 1) && (r3.layers = p3), m3 && (r3.visibleLayers = s2.filter((e5) => e5.visible).map((e5) => e5.id));
  }
  createExportImageParameters(e4, r3, t5, i3) {
    const s2 = (i3 == null ? void 0 : i3.pixelRatio) || 1;
    e4 && this.version >= 10 && (e4 = e4.clone().shiftCentralMeridian()), this._exportImageParameters.floors = (i3 == null ? void 0 : i3.floors) ?? null, this._exportImageParameters.scale = i2({ extent: e4, width: r3 }) * s2;
    const o2 = this._exportImageParameters.toJSON(), a4 = !(i3 == null ? void 0 : i3.rotation) || this.version < 10.3 ? {} : { rotation: -i3.rotation }, p3 = e4 == null ? void 0 : e4.spatialReference, n2 = c(p3);
    o2.dpi *= s2;
    const m3 = {};
    if (i3 == null ? void 0 : i3.timeExtent) {
      const { start: e5, end: r4 } = i3.timeExtent.toJSON();
      m3.time = e5 && r4 && e5 === r4 ? "" + e5 : `${e5 ?? "null"},${r4 ?? "null"}`;
    } else this.timeInfo && !this.timeInfo.hasLiveData && (m3.time = "null,null");
    return { bbox: e4 ? e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax : void 0, bboxSR: n2, imageSR: n2, size: r3 + "," + t5, ...o2, ...a4, ...m3 };
  }
  async fetchImage(e4, r3, t5, i3) {
    const { data: s2 } = await this._fetchImage("image", e4, r3, t5, i3);
    return s2;
  }
  async fetchImageBitmap(e4, r3, t5, i3) {
    const { data: s2, url: o2 } = await this._fetchImage("blob", e4, r3, t5, i3);
    return t3(s2, o2, i3 == null ? void 0 : i3.signal);
  }
  async fetchRecomputedExtents(e4 = {}) {
    const t5 = { ...e4, query: { returnUpdates: true, f: "json", ...this.customParameters, token: this.apiKey } }, { data: i3 } = await P(this.url, t5), { extent: s2, fullExtent: o2, timeExtent: a4 } = i3, p3 = s2 || o2;
    return { fullExtent: p3 && w.fromJSON(p3), timeExtent: a4 && p.fromJSON({ start: a4[0], end: a4[1] }) };
  }
  loadAll() {
    return t(this, (e4) => {
      e4(this.allSublayers), e4(this.subtables);
    });
  }
  serviceSupportsSpatialReference(e4) {
    return t4(this, e4);
  }
  async _fetchImage(e4, i3, s2, o2, p3) {
    var _a, _b, _c;
    const n2 = { responseType: e4, signal: (p3 == null ? void 0 : p3.signal) ?? null, query: { ...this.parsedUrl.query, ...this.createExportImageParameters(i3, s2, o2, p3), f: "image", ...this.refreshParameters, ...this.customParameters, token: this.apiKey } }, m3 = this.parsedUrl.path + "/export";
    if (null != ((_a = n2.query) == null ? void 0 : _a.dynamicLayers) && !((_c = (_b = this.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsDynamicLayers)) throw new s("mapimagelayer:dynamiclayer-not-supported", `service ${this.url} doesn't support dynamic layers, which is required to be able to change the sublayer's order, rendering, labeling or source.`, { query: n2.query });
    try {
      const { data: e5 } = await P(m3, n2);
      return { data: e5, url: m3 };
    } catch (l3) {
      if (b(l3)) throw l3;
      throw new s("mapimagelayer:image-fetch-error", `Unable to load image: ${m3}`, { error: l3 });
    }
  }
  async _fetchService(e4) {
    if (this.sourceJSON) return void this.read(this.sourceJSON, { origin: "service", url: this.parsedUrl });
    const { data: t5, ssl: i3 } = await P(this.parsedUrl.path, { query: { f: "json", ...this.parsedUrl.query, ...this.customParameters, token: this.apiKey }, signal: e4 });
    i3 && (this.url = this.url.replace(/^http:/i, "https:")), this.sourceJSON = t5, this.read(t5, { origin: "service", url: this.parsedUrl });
  }
  hasVisibleLayersForOrigin(e4) {
    var _a;
    return !(null == e4 || !((_a = this.sublayersSourceJSON[e4]) == null ? void 0 : _a.visibleLayers));
  }
};
r([m(a3("dateFieldsTimeReference"))], J.prototype, "dateFieldsTimeZone", void 0), r([m({ type: Boolean })], J.prototype, "datesInUnknownTimezone", void 0), r([m()], J.prototype, "dpi", void 0), r([m()], J.prototype, "gdbVersion", void 0), r([m()], J.prototype, "imageFormat", void 0), r([o("imageFormat", ["supportedImageFormatTypes"])], J.prototype, "readImageFormat", null), r([m({ json: { origins: { service: { read: { source: "maxImageHeight" } } } } })], J.prototype, "imageMaxHeight", void 0), r([m({ json: { origins: { service: { read: { source: "maxImageWidth" } } } } })], J.prototype, "imageMaxWidth", void 0), r([m()], J.prototype, "imageTransparency", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], J.prototype, "isReference", void 0), r([m({ json: { read: false, write: false } })], J.prototype, "labelsVisible", void 0), r([m({ type: ["ArcGISMapServiceLayer"] })], J.prototype, "operationalLayerType", void 0), r([m({ json: { read: false, write: false } })], J.prototype, "popupEnabled", void 0), r([m(a3("preferredTimeReference"))], J.prototype, "preferredTimeZone", void 0), r([m()], J.prototype, "sourceJSON", void 0), r([m({ json: { write: { ignoreOrigin: true } } })], J.prototype, "sublayers", void 0), r([r2("sublayers", { layers: { type: [se] }, visibleLayers: { type: [x] } })], J.prototype, "writeSublayers", null), r([m({ type: ["show", "hide", "hide-children"] })], J.prototype, "listMode", void 0), r([m({ json: { read: false }, readOnly: true, value: "map-image" })], J.prototype, "type", void 0), r([m(y)], J.prototype, "url", void 0), J = r([a2("esri.layers.MapImageLayer")], J);
var q = J;
export {
  q as default
};
//# sourceMappingURL=MapImageLayer-M2YOKVQF.js.map
