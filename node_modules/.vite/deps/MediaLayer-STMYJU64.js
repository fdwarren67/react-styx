import {
  c as c4,
  e as e3,
  j as j4,
  m as m4,
  n as n7,
  p as p6
} from "./chunk-FGOTWAKV.js";
import {
  p as p5
} from "./chunk-FDGPK3YS.js";
import "./chunk-LL7BB425.js";
import {
  e as e2,
  t as t3
} from "./chunk-OBRCQKKM.js";
import {
  o as o3
} from "./chunk-L4EC6LZW.js";
import "./chunk-3WB47P7Q.js";
import {
  p as p4
} from "./chunk-2PJ3OYOC.js";
import {
  n as n6,
  t as t2
} from "./chunk-T7CHWWE2.js";
import {
  s as s5
} from "./chunk-FWVSIQMR.js";
import {
  I,
  _ as _2,
  o as o4
} from "./chunk-4ACM2XXN.js";
import "./chunk-ON7GWFUW.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-ZPDG5M3T.js";
import {
  A
} from "./chunk-NBXBK3QW.js";
import {
  j as j3
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  b
} from "./chunk-C6YDI6QX.js";
import "./chunk-DJ5HVIE7.js";
import {
  S as S2
} from "./chunk-KPY4ZIC2.js";
import {
  O,
  Q,
  X
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import {
  n as n3
} from "./chunk-BBPRJCMB.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-GSNLF6RP.js";
import {
  p as p3
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import {
  u
} from "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-W7QCICS6.js";
import {
  n as n5
} from "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import {
  a as a2
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import {
  n as n4
} from "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import {
  m as m3
} from "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  d,
  w
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import {
  V as V2
} from "./chunk-BQYXRSVC.js";
import {
  i
} from "./chunk-BJEQ2APY.js";
import {
  p as p2
} from "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import {
  c as c3
} from "./chunk-FZPO5AYT.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j as j2
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import {
  o as o2
} from "./chunk-OXPM753Y.js";
import {
  w as w2,
  x2 as x
} from "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  s as s4
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import {
  s as s3
} from "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import {
  r as r3
} from "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  M,
  c,
  r
} from "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2,
  U,
  m as m2,
  p,
  y
} from "./chunk-BECTSF5P.js";
import {
  H,
  P,
  V,
  Y,
  Z,
  _,
  lt,
  tt
} from "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  e,
  m,
  n2
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  c as c2,
  k,
  s as s2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r as r2
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c5 = class extends a2 {
  projectOrWarn(e4, r4) {
    if (null == e4) return e4;
    const { geometry: t4, pending: c6 } = X(e4, r4);
    return c6 ? null : c6 || t4 ? t4 : (n.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e4, sourceSpatialReference: e4.spatialReference, targetSpatialReference: r4 }), null);
  }
};
c5 = r2([a("esri.layers.support.GeoreferenceBase")], c5);
var a3 = c5;

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var S3 = e2();
var C = n6();
var N = class extends S {
};
r2([m({ type: Number, json: { write: { isRequired: true } } })], N.prototype, "x", void 0), r2([m({ type: Number, json: { write: { isRequired: true } } })], N.prototype, "y", void 0), N = r2([a("esri.layers.support.ControlPointsGeoreference.ControlPointJSONType")], N);
var q = class extends a2 {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
r2([m()], q.prototype, "sourcePoint", void 0), r2([m({ type: j })], q.prototype, "mapPoint", void 0), q = r2([a("esri.layers.support.ControlPointsGeoreference.ControlPoint")], q);
var O2 = class extends S.JSONSupportMixin(a3) {
  constructor(t4) {
    super(t4), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(t4, o5) {
    const e4 = g.fromJSON(o5.spatialReference), r4 = t3(...o5.coefficients, 1);
    return t4.map((t5) => (o4(C, t5.x, t5.y), p6(C, C, r4), { sourcePoint: t5, mapPoint: new j({ x: C[0], y: C[1], spatialReference: e4 }) }));
  }
  writeControlPoints(t4, o5, r4, i2) {
    if (null != this.transform) null != t4 && T(t4[0]) && (o5.controlPoints = t4.map((t5) => {
      const o6 = t5.sourcePoint;
      return { x: o6.x, y: o6.y };
    }), o5.spatialReference = t4[0].mapPoint.spatialReference.toJSON(), o5.coefficients = this.transform.slice(0, 8));
    else {
      const t5 = new s("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration. Make sure the parent media element is loaded i.e. the ImageElement or VideoElement set as 'MediaLayer.source'.", { layer: i2 == null ? void 0 : i2.layer, georeference: this });
      (i2 == null ? void 0 : i2.messages) ? i2.messages.push(t5) : n.getLogger(this).error(t5.name, t5.message);
    }
  }
  get coords() {
    if (null == this.controlPoints) return null;
    const t4 = this._updateTransform(S3);
    if (null == t4 || !T(this.controlPoints[0])) return null;
    const o5 = this.controlPoints[0].mapPoint.spatialReference;
    return K(t4, this.width, this.height, o5);
  }
  set coords(t4) {
    if (null == this.controlPoints || !T(this.controlPoints[0])) return;
    const o5 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, o5))) return;
    const { width: e4, height: r4 } = this, { rings: [[n8, s6, c6, a4]] } = t4, p8 = { sourcePoint: c3(0, r4), mapPoint: new j({ x: n8[0], y: n8[1], spatialReference: o5 }) }, u6 = { sourcePoint: c3(0, 0), mapPoint: new j({ x: s6[0], y: s6[1], spatialReference: o5 }) }, m5 = { sourcePoint: c3(e4, 0), mapPoint: new j({ x: c6[0], y: c6[1], spatialReference: o5 }) }, f2 = { sourcePoint: c3(e4, r4), mapPoint: new j({ x: a4[0], y: a4[1], spatialReference: o5 }) };
    T(p8) && T(u6) && T(m5) && T(f2) && (B(S3, p8, u6, m5, f2), this.controlPoints = this.controlPoints.map(({ sourcePoint: t5 }) => (o4(C, t5.x, t5.y), p6(C, C, S3), { sourcePoint: t5, mapPoint: new j({ x: C[0], y: C[1], spatialReference: o5 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : s5(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(t4) {
    if (null == t4 || null == this.transform || null == this.controlPoints || !T(this.controlPoints[0])) return null;
    o4(C, t4.x, t4.y);
    const o5 = this.controlPoints[0].mapPoint.spatialReference;
    return p6(C, C, this.transform), new j({ x: C[0], y: C[1], spatialReference: o5 });
  }
  toSource(t4) {
    if (null == t4 || null == this.inverseTransform || null == this.controlPoints || !T(this.controlPoints[0])) return null;
    const o5 = this.controlPoints[0].mapPoint.spatialReference;
    return t4 = t4.normalize(), null == (t4 = X(t4, o5).geometry) ? null : (o4(C, t4.x, t4.y), p6(C, C, this.inverseTransform), c3(C[0], C[1]));
  }
  toSourceNormalized(t4) {
    const o5 = this.toSource(t4);
    return null != o5 && (o5.x /= this.width, o5.y /= this.height), o5;
  }
  _updateTransform(t4) {
    const { controlPoints: o5, width: e4, height: r4 } = this;
    if (!(null != o5 && e4 > 0 && r4 > 0)) return null;
    const [n8, i2, s6, l] = o5;
    if (!T(n8)) return null;
    const c6 = n8.mapPoint.spatialReference, a4 = this._projectControlPoint(i2, c6), p8 = this._projectControlPoint(s6, c6), u6 = this._projectControlPoint(l, c6);
    if (!a4.valid || !p8.valid || !u6.valid) return null;
    if (!T(a4.controlPoint)) return null;
    null == t4 && (t4 = e2());
    let m5 = null;
    return m5 = T(p8.controlPoint) && T(u6.controlPoint) ? B(t4, n8, a4.controlPoint, p8.controlPoint, u6.controlPoint) : T(p8.controlPoint) ? V3(t4, n8, a4.controlPoint, p8.controlPoint) : U2(t4, n8, a4.controlPoint), m5.every((t5) => 0 === t5) ? null : m5;
  }
  _projectControlPoint(t4, o5) {
    if (!T(t4)) return { valid: true, controlPoint: t4 };
    const { sourcePoint: e4, mapPoint: r4 } = t4, { geometry: i2, pending: s6 } = X(r4, o5);
    return s6 ? { valid: false, controlPoint: null } : s6 || i2 ? { valid: true, controlPoint: { sourcePoint: e4, mapPoint: i2 } } : (n.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: t4, sourceSpatialReference: r4.spatialReference, targetSpatialReference: o5 }), { valid: false, controlPoint: null });
  }
};
function T(t4) {
  return null != (t4 == null ? void 0 : t4.sourcePoint) && null != t4.mapPoint;
}
r2([m({ type: [q], json: { write: { allowNull: false, isRequired: true, target: { controlPoints: { type: [N], isRequired: true }, coefficients: { type: [Number], isRequired: true }, spatialReference: { type: g, isRequired: true } } } } })], O2.prototype, "controlPoints", void 0), r2([o("controlPoints")], O2.prototype, "readControlPoints", null), r2([r3("controlPoints")], O2.prototype, "writeControlPoints", null), r2([m({ clonable: false })], O2.prototype, "coords", null), r2([m({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], O2.prototype, "height", void 0), r2([m({ readOnly: true })], O2.prototype, "inverseTransform", null), r2([m({ readOnly: true })], O2.prototype, "transform", null), r2([m({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], O2.prototype, "width", void 0), O2 = r2([a("esri.layers.support.ControlPointsGeoreference")], O2);
var _3 = n6();
var M2 = n6();
var G = n6();
var I2 = n6();
var J = n6();
var L = n6();
var E = n6();
var k2 = n6();
var z = Math.PI / 2;
function A2(t4, o5, e4) {
  o4(t4, e4.sourcePoint.x, e4.sourcePoint.y), o4(o5, e4.mapPoint.x, e4.mapPoint.y);
}
function U2(t4, o5, e4) {
  return A2(_3, J, o5), A2(M2, L, e4), I(G, M2, _3, z), I(I2, _3, M2, z), I(E, L, J, -z), I(k2, J, L, -z), H2(t4, _3, M2, G, I2, J, L, E, k2);
}
function V3(t4, o5, e4, r4) {
  return A2(_3, J, o5), A2(M2, L, e4), A2(G, E, r4), _2(I2, _3, M2, 0.5), I(I2, G, I2, Math.PI), _2(k2, J, L, 0.5), I(k2, E, k2, Math.PI), H2(t4, _3, M2, G, I2, J, L, E, k2);
}
function B(t4, o5, e4, r4, n8) {
  return A2(_3, J, o5), A2(M2, L, e4), A2(G, E, r4), A2(I2, k2, n8), H2(t4, _3, M2, G, I2, J, L, E, k2);
}
var W = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F(t4, o5, e4, r4, n8) {
  return t4[0] = o5[0], t4[1] = o5[1], t4[2] = e4[0], t4[3] = e4[1], t4[4] = r4[0], t4[5] = r4[1], t4[6] = n8[0], t4[7] = n8[1], t4;
}
function H2(t4, o5, e4, r4, n8, i2, l, c6, a4) {
  return j4(t4, F(W, o5, e4, r4, n8), F(D, i2, l, c6, a4));
}
function K(t4, o5, e4, r4) {
  const n8 = t2(0, e4), s6 = t2(0, 0), l = t2(o5, 0), c6 = t2(o5, e4);
  return p6(n8, n8, t4), p6(s6, s6, t4), p6(l, l, t4), p6(c6, c6, t4), new j2({ rings: [[n8, s6, l, c6, n8]], spatialReference: r4 });
}
var Q2 = O2;

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var u2 = n6();
var y2 = class extends a3 {
  constructor(t4) {
    super(t4), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t4, topRight: o5, bottomLeft: e4, bottomRight: r4 } = this;
    if (null == t4 || null == o5 || null == e4 || null == r4) return null;
    const s6 = t4.spatialReference;
    return o5 = this.projectOrWarn(o5, s6), e4 = this.projectOrWarn(e4, s6), r4 = this.projectOrWarn(r4, s6), null == o5 || null == e4 || null == r4 ? null : new j2({ rings: [[[e4.x, e4.y], [t4.x, t4.y], [o5.x, o5.y], [r4.x, r4.y], [e4.x, e4.y]]], spatialReference: s6 });
  }
  set coords(t4) {
    const { topLeft: o5 } = this;
    if (null == o5) return;
    const e4 = o5.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, e4))) return;
    const { rings: [[r4, s6, i2, l]] } = t4;
    this.bottomLeft = new j({ x: r4[0], y: r4[1], spatialReference: e4 }), this.topLeft = new j({ x: s6[0], y: s6[1], spatialReference: e4 }), this.topRight = new j({ x: i2[0], y: i2[1], spatialReference: e4 }), this.bottomRight = new j({ x: l[0], y: l[1], spatialReference: e4 });
  }
  toSourceNormalized(t4) {
    const { topLeft: s6, topRight: i2, bottomRight: p8, bottomLeft: c6 } = this;
    if (null == t4 || null == s6 || null == i2 || null == p8 || null == c6) return null;
    const m5 = s6.spatialReference;
    t4 = t4.normalize();
    const f2 = X(t4, m5).geometry;
    if (null == f2) return null;
    o4(u2, f2.x, f2.y);
    const y3 = j4(e2(), [s6.x, s6.y, c6.x, c6.y, i2.x, i2.y, p8.x, p8.y], [0, 0, 0, 1, 1, 0, 1, 1]);
    return p6(u2, u2, y3), c3(u2[0], u2[1]);
  }
};
r2([m({ clonable: false })], y2.prototype, "coords", null), r2([m({ type: j })], y2.prototype, "bottomLeft", void 0), r2([m({ type: j })], y2.prototype, "bottomRight", void 0), r2([m({ type: j })], y2.prototype, "topLeft", void 0), r2([m({ type: j })], y2.prototype, "topRight", void 0), y2 = r2([a("esri.layers.support.CornersGeoreference")], y2);
var h = y2;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var p7 = class extends a3 {
  constructor(t4) {
    super(t4), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent) return null;
    const { xmin: t4, ymin: e4, xmax: r4, ymax: o5, spatialReference: n8 } = this.extent;
    let s6;
    if (this.rotation) {
      const { x: n9, y: i2 } = this.extent.center, a4 = x2(n9, i2, this.rotation);
      s6 = [a4(t4, e4), a4(t4, o5), a4(r4, o5), a4(r4, e4)], s6.push(s6[0]);
    } else s6 = [[t4, e4], [t4, o5], [r4, o5], [r4, e4], [t4, e4]];
    return new j2({ rings: [s6], spatialReference: n8 });
  }
  set coords(t4) {
    if (null == t4 || null == this.extent) return;
    const r4 = this.extent.spatialReference;
    if (t4 = this.projectOrWarn(t4, r4), null == (t4 == null ? void 0 : t4.extent)) return;
    const { rings: [[o5, n8, s6]], extent: { center: { x: i2, y: c6 } } } = t4, m5 = M(Math.PI / 2 - Math.atan2(n8[1] - o5[1], n8[0] - o5[0])), l = x2(i2, c6, -m5), [p8, u6] = l(o5[0], o5[1]), [f2, h3] = l(s6[0], s6[1]);
    this.extent = new w2({ xmin: p8, ymin: u6, xmax: f2, ymax: h3, spatialReference: r4 }), this.rotation = m5;
  }
  toSourceNormalized(t4) {
    const { extent: e4, rotation: n8 } = this;
    if (null == t4 || null == e4) return null;
    const { xmin: s6, ymin: i2, xmax: a4, ymax: c6, center: l, spatialReference: p8 } = e4;
    t4 = t4.normalize();
    const u6 = X(t4, p8).geometry;
    if (null == u6) return null;
    let f2 = u6.x, h3 = u6.y;
    return n8 && ([f2, h3] = x2(l.x, l.y, -n8)(f2, h3)), c3(c(f2, s6, a4, 0, 1), c(h3, c6, i2, 0, 1));
  }
};
function x2(t4, e4, r4) {
  const o5 = u(r4), n8 = Math.cos(o5), s6 = Math.sin(o5);
  return (r5, o6) => [n8 * (r5 - t4) + s6 * (o6 - e4) + t4, n8 * (o6 - e4) - s6 * (r5 - t4) + e4];
}
r2([m({ clonable: false })], p7.prototype, "coords", null), r2([m({ type: w2 })], p7.prototype, "extent", void 0), r2([m({ type: Number })], p7.prototype, "rotation", void 0), p7 = r2([a("esri.layers.support.ExtentAndRotationGeoreference")], p7);
var u3 = p7;

// node_modules/@arcgis/core/layers/support/mediaUtils.js
function u4(e4) {
  return "media" === (e4 == null ? void 0 : e4.type);
}
function P3(e4, o5) {
  const r4 = n2(o5);
  return u4(e4) && !!e4.portalItem && null != r4 && r4 > e.PORTAL_ITEM;
}
function d3(t4, n8, o5) {
  var _a;
  if (!t4 || "control-points" === t4.type) return t4;
  const { coords: i2 } = t4;
  if (5 !== ((_a = i2 == null ? void 0 : i2.rings[0]) == null ? void 0 : _a.length)) return null;
  const [a4, c6, p8, l] = i2.rings[0], { spatialReference: y3 } = i2;
  return new Q2({ controlPoints: [{ mapPoint: new j({ x: a4[0], y: a4[1], spatialReference: y3 }), sourcePoint: c3(0, o5) }, { mapPoint: new j({ x: c6[0], y: c6[1], spatialReference: y3 }), sourcePoint: c3(0, 0) }, { mapPoint: new j({ x: p8[0], y: p8[1], spatialReference: y3 }), sourcePoint: c3(n8, 0) }, { mapPoint: new j({ x: l[0], y: l[1], spatialReference: y3 }), sourcePoint: c3(n8, o5) }], width: n8, height: o5 });
}
function x3(e4, t4, n8) {
  return { enabled: !P3(n8 == null ? void 0 : n8.layer, n8 == null ? void 0 : n8.origin), ignoreOrigin: true };
}
var w3 = { json: { name: "url", type: String, write: { overridePolicy: x3 } } };
var g2 = { readOnly: true, json: { read: false, write: { target: "mediaType", overridePolicy: x3 } } };
var h2 = { types: { key: "type", base: a3, typeMap: { "control-points": Q2, corners: h, "extent-and-rotation": u3 } }, json: { types: { key: "type", base: a3, typeMap: { "control-points": Q2 } }, write: { overridePolicy: () => ({ enabled: true, ignoreOrigin: true }) } } };

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var u5 = class extends n5.NumericIdentifiableMixin(S2(m3)) {
  constructor(e4) {
    super(e4), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e4) {
    return Q2.fromJSON(e4);
  }
  writeGeoreference(e4, o5, t4, n8) {
    var _a;
    const i2 = (_a = n8 == null ? void 0 : n8.resources) == null ? void 0 : _a.pendingOperations, c6 = () => {
      var _a2;
      const i3 = d3(this.georeference, this.contentWidth, this.contentHeight);
      if (i3) {
        if ("control-points" !== e4.type && n.getLogger(this).warn(`only georeference of type 'control-points' may be persisted. The georeference of type '${e4.type}' has been automatically converted.`), 4 !== ((_a2 = i3.controlPoints) == null ? void 0 : _a2.length) && (n8 == null ? void 0 : n8.messages)) return void n8.messages.push(new s("property:unsupported", "only 'control-points' georeference with 4 control points may be persisted."));
        o5[t4] = i3.write({}, n8);
      }
    };
    if ("control-points" !== e4.type && !this.loaded && i2) return o5[t4] = {}, void i2.push(this.load().then(c6));
    c6();
  }
  get contentWidth() {
    return 0;
  }
  get contentHeight() {
    return 0;
  }
  toSource(e4) {
    const { georeference: r4, contentWidth: o5, contentHeight: t4 } = this;
    if (null == e4 || null == r4 || 0 === o5 || 0 === t4) return null;
    const s6 = r4.toSourceNormalized(e4);
    return null == s6 ? null : (s6.x *= o5, s6.y *= t4, s6);
  }
};
r2([m(h2)], u5.prototype, "georeference", void 0), r2([o("georeference")], u5.prototype, "readGeoreference", null), r2([r3("georeference")], u5.prototype, "writeGeoreference", null), r2([m({ json: { read: false, write: false } })], u5.prototype, "opacity", void 0), u5 = r2([a("esri.layers.support.MediaElementBase")], u5);
var d4 = u5;

// node_modules/@arcgis/core/layers/support/ImageElement.js
var E2;
var U3 = class extends d4 {
  constructor(t4) {
    super(t4), this.animationOptions = null, this.content = null, this.image = null, this.type = "image", this[E2] = true, this.image = null;
  }
  load() {
    const t4 = this.image;
    if ("string" == typeof t4) {
      const e4 = p4(t4).then((t5) => {
        this._set("content", t5);
      });
      this.addResolvingPromise(e4);
    } else if (t4 instanceof HTMLImageElement) {
      const e4 = t4.decode().then(() => {
        this._set("content", t4);
      });
      this.addResolvingPromise(e4);
    } else t4 ? this._set("content", t4) : this.addResolvingPromise(Promise.reject(new s("image-element:invalid-image-type", "Invalid image type", { image: t4 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalWidth : this.content.width;
  }
  get contentHeight() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalHeight : this.content.height;
  }
  readImage(t4, e4, o5) {
    return p(e4.url, o5);
  }
  writeImage(t4, e4, o5, r4) {
    if (null == t4) return;
    const n8 = r4 == null ? void 0 : r4.portalItem, s6 = r4 == null ? void 0 : r4.resources;
    if (!n8 || !s6) return void ("string" == typeof t4 && (e4[o5] = m2(t4, r4)));
    const a4 = L2(t4) ? t4 : null;
    if (a4) {
      if (null == U(a4)) return void (e4[o5] = a4);
      const t5 = m2(a4, { ...r4, verifyItemRelativeUrls: (r4 == null ? void 0 : r4.verifyItemRelativeUrls) ? { writtenUrls: r4.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, y.NO);
      if (n8 && t5 && !Y(t5)) return s6.toKeep.push({ resource: n8.resourceFromPath(t5), compress: false }), void (e4[o5] = t5);
    }
    e4[o5] = "<pending>", s6.pendingOperations.push(M3(t4).then((t5) => {
      const r5 = R(t5, n8);
      e4[o5] = r5.itemRelativeUrl, s6.toAdd.push({ resource: r5, content: { type: "blob", blob: t5 }, compress: false, finish: (t6) => {
        this.image = t6.url;
      } });
    }));
  }
};
E2 = n7, r2([m()], U3.prototype, "animationOptions", void 0), r2([m({ readOnly: true })], U3.prototype, "content", void 0), r2([m({ readOnly: true })], U3.prototype, "contentWidth", null), r2([m({ readOnly: true })], U3.prototype, "contentHeight", null), r2([m(w3)], U3.prototype, "image", void 0), r2([o("image", ["url"])], U3.prototype, "readImage", null), r2([r3("image")], U3.prototype, "writeImage", null), r2([m(g2)], U3.prototype, "type", void 0), U3 = r2([a("esri.layers.support.ImageElement")], U3);
var H3 = U3;
function L2(t4) {
  return "string" == typeof t4 && !tt(t4) && !Z(t4);
}
async function M3(t4) {
  if ("string" == typeof t4) {
    if (tt(t4)) return lt(t4);
    return (await P2(t4, { responseType: "blob" })).data;
  }
  return new Promise((e4) => P4(t4).toBlob(e4));
}
function P4(t4) {
  if (t4 instanceof HTMLCanvasElement) return t4;
  const e4 = t4 instanceof HTMLImageElement ? t4.naturalWidth : t4.width, o5 = t4 instanceof HTMLImageElement ? t4.naturalHeight : t4.height, r4 = document.createElement("canvas"), i2 = r4.getContext("2d");
  return r4.width = e4, r4.height = o5, t4 instanceof HTMLImageElement ? i2.drawImage(t4, 0, 0, t4.width, t4.height) : t4 instanceof ImageData && i2.putImageData(t4, 0, 0), r4;
}
function R(t4, e4) {
  const o5 = n3(), r4 = `${V("media", o5)}.${p5({ type: "blob", blob: t4 })}`;
  return e4.resourceFromPath(r4);
}

// node_modules/@arcgis/core/layers/support/VideoElement.js
var U4;
var b2 = class extends d4 {
  constructor(e4) {
    super(e4), this.autoplay = true, this.content = null, this.controller = null, this.type = "video", this[U4] = true;
  }
  load() {
    const e4 = this.video;
    return "string" == typeof e4 ? this.addResolvingPromise(Promise.all([this._preProcessVideoUrl(e4), import("./VideoController-OKJATJEY.js")]).then(async ([e5, { default: t4 }]) => {
      this.controller = new t4(), this.controller.playerUrl = e5, await w(() => {
        var _a;
        return (_a = this.controller) == null ? void 0 : _a.element;
      }), this.controller.loop = true, this.controller.muted = true, this.controller.playsInline = true, this.controller.crossOrigin = "anonymous", await w(() => {
        var _a;
        return "can-play" === ((_a = this.controller) == null ? void 0 : _a.state);
      }), await this.controller.play(), this.autoplay || this.controller.pause(), this._set("content", this.controller.element);
    })) : e4 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e4).then(() => {
      this._set("content", e4);
    })) : this.addResolvingPromise(Promise.reject(new s("video-element:invalid-video-type", "Invalid video type", { video: e4 }))), Promise.resolve(this);
  }
  get contentWidth() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoWidth) ?? 0;
  }
  get contentHeight() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoHeight) ?? 0;
  }
  get currentTime() {
    var _a;
    return (_a = this.controller) == null ? void 0 : _a.currentTime;
  }
  set currentTime(e4) {
    var _a;
    if (!this.controller) return;
    const t4 = r(e4, 0, this.controller.duration);
    (_a = this.controller) == null ? void 0 : _a.setCurrentTime(t4);
  }
  get duration() {
    var _a;
    return (_a = this.controller) == null ? void 0 : _a.duration;
  }
  set video(e4) {
    "not-loaded" === this.loadStatus ? this._set("video", e4) : n.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  writeVideo(e4, t4, r4, s6) {
    if (!e4) return void ((s6 == null ? void 0 : s6.messages) && s6.messages.push(new s("video-element:unsupported-video", "video source is missing")));
    const i2 = V4(e4) ? e4 : null;
    if (!i2) return void ((s6 == null ? void 0 : s6.messages) && s6.messages.push(new s("video-element:unsupported-video", "video source must be an absolute url")));
    !Y(i2) && (s6 == null ? void 0 : s6.blockedRelativeUrls) && s6.blockedRelativeUrls.push(i2);
    const n8 = _(i2);
    !U(n8) ? t4[r4] = n8 : (s6 == null ? void 0 : s6.messages) && s6.messages.push(new s("video-element:unsupported-video", "video source cannot be an item resource"));
  }
  async _preProcessVideoUrl(e4) {
    if (H(e4)) return P(e4);
    try {
      return await P2(e4, { method: "head" }), e4;
    } catch {
      return P(e4, true);
    }
  }
  _loadVideo(e4) {
    return new Promise((t4, o5) => {
      const s6 = c2(e4, "canplay", () => {
        this.removeHandles("canplay"), this.autoplay ? e4.play().then(t4, o5) : t4();
      });
      this.addHandles(s6, "canplay"), "anonymous" !== e4.crossOrigin && (e4.crossOrigin = "anonymous", Z(e4.src) || (e4.src = e4.src));
    });
  }
};
U4 = e3, r2([m()], b2.prototype, "autoplay", void 0), r2([m({ readOnly: true })], b2.prototype, "content", void 0), r2([m({ readOnly: true })], b2.prototype, "contentWidth", null), r2([m({ readOnly: true })], b2.prototype, "contentHeight", null), r2([m()], b2.prototype, "controller", void 0), r2([m({ type: Number })], b2.prototype, "currentTime", null), r2([m({ type: Number })], b2.prototype, "duration", null), r2([m(w3)], b2.prototype, "video", null), r2([r3("video")], b2.prototype, "writeVideo", null), r2([m(g2)], b2.prototype, "type", void 0), b2 = r2([a("esri.layers.support.VideoElement")], b2);
var P5 = b2;
function V4(e4) {
  return "string" == typeof e4 && !tt(e4) && !Z(e4);
}

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w4 = { key: "type", defaultKeyValue: "image", base: d4, typeMap: { image: H3, video: P5 } };
var M4 = V2.ofType(w4);
var I3 = class extends m3.LoadableMixin(p2.EsriPromiseMixin(i.EventedAccessor)) {
  constructor(e4) {
    super(e4), this._index = new o3(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e5) => {
      for (const s6 of e5.removed) {
        const e6 = this._elementViewsMap.get(s6);
        this._elementViewsMap.delete(s6), this._index.delete(e6), this.removeHandles(e6), e6.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t4 } = this;
      for (const s6 of e5.added) {
        if (this._elementViewsMap.get(s6)) continue;
        const e6 = new m4({ spatialReference: t4, element: s6 });
        this._elementViewsMap.set(s6, e6);
        const r4 = d(() => e6.coords, () => this._updateIndexForElement(e6, false));
        this._updateIndexForElement(e6, true), this.addHandles(r4, e6);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e6, t5) => this._elementsIndexes.set(e6, t5)), this.emit("refresh");
    }, this.elements = new M4();
  }
  async load(e4) {
    if (s2(e4), !this.spatialReference) {
      const e5 = this.elements.find((e6) => {
        var _a;
        return null != ((_a = e6.georeference) == null ? void 0 : _a.coords);
      });
      this._set("spatialReference", e5 ? e5.georeference.coords.spatialReference : g.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e4) {
    this._set("elements", n4(e4, this._get("elements"), M4));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus) return null;
    const e4 = this._index.fullBounds;
    return null == e4 ? null : new w2({ xmin: e4[0], ymin: e4[1], xmax: e4[2], ymax: e4[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e4) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e4) : n.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e4, t4) {
    await this.load(), await Q(e4.spatialReference, this.spatialReference, null, t4);
    const s6 = s4(e4.spatialReference, this.spatialReference) ? e4 : O(e4, this.spatialReference);
    if (!s6) return [];
    const r4 = s6.normalize(), o5 = [];
    for (const n8 of r4) this._index.forEachInBounds(o2(n8), ({ normalizedCoords: e5, element: t5 }) => {
      null != e5 && x(n8, e5) && o5.push(t5);
    });
    return o5.sort((e5, t5) => this._elementsIndexes.get(e5) - this._elementsIndexes.get(t5)), o5;
  }
  hasElement(e4) {
    return this.elements.includes(e4);
  }
  _updateIndexForElement(e4, t4) {
    const s6 = e4.normalizedBounds, r4 = this._index.has(e4), o5 = null != s6;
    this._index.delete(e4), o5 && this._index.set(e4, s6), this.notifyChange("fullExtent"), t4 || (r4 !== o5 ? this.emit("refresh") : this.emit("change", { element: e4.element }));
  }
};
r2([m()], I3.prototype, "elements", null), r2([m({ readOnly: true })], I3.prototype, "fullExtent", null), r2([m()], I3.prototype, "spatialReference", null), I3 = r2([a("esri.layers.support.LocalMediaElementSource")], I3);
var V5 = I3;

// node_modules/@arcgis/core/layers/MediaLayer.js
var b3 = class extends p3(t(b(j3(S2(f))))) {
  constructor(e4) {
    super(e4), this.effectiveSource = null, this.georeference = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this._debouncedSaveOperations = k(async (e5, r4, o5) => {
      const { save: t4, saveAs: s6 } = await import("./mediaLayerUtils-65BVZG6L.js");
      switch (e5) {
        case A.SAVE:
          return t4(this, r4);
        case A.SAVE_AS:
          return s6(this, o5, r4);
      }
    }), this.source = new V5();
  }
  load(e4) {
    return this.addResolvingPromise(this._doLoad(e4)), Promise.resolve(this);
  }
  async _doLoad(e4) {
    await this.loadFromPortal({ supportedTypes: ["Media Layer"] }, e4);
    let t4 = this.source;
    if (!t4) throw new s("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer.");
    const s6 = this._getSourceOverride(t4, this.georeference);
    s6 && (this.setAtOrigin("source", s6, "web-map"), this.setAtOrigin("source", s6, "web-scene"), t4 = s6);
    const i2 = c4(t4) ? new V5({ elements: new V2([t4]) }) : t4;
    this._set("effectiveSource", i2), this.spatialReference && (i2.spatialReference = this.spatialReference), await i2.load(e4), this.spatialReference = i2.spatialReference;
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), this.effectiveSource !== this.source && ((_b = this.source) == null ? void 0 : _b.destroy());
  }
  readGeoreference(e4, r4) {
    return e4 && "itemId" in r4 && r4.itemId ? e4 : void 0;
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  get source() {
    return this._get("source");
  }
  set source(e4) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("source", e4) : n.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) ? new V5({ elements: new V2(e4) }) : e4 instanceof V2 ? new V5({ elements: e4 }) : e4 : null;
  }
  readSource(e4, r4, o5) {
    if ("itemId" in r4 && r4.itemId) return;
    const t4 = this._createSource(r4);
    return t4 == null ? void 0 : t4.read(r4, o5), t4;
  }
  writeSource(e4, r4, t4, s6) {
    if (e4 && e4 instanceof V5) {
      const r5 = e4.elements.length;
      if (1 !== r5) return void ((s6 == null ? void 0 : s6.messages) && s6.messages.push(new s("media-layer:unsupported-source", `local media element source can only be persisted if it contains exactly one ImageElement, but it has ${r5}.`)));
      e4 = e4.elements.at(0);
    }
    c4(e4) ? e4.write(r4, s6) : (s6 == null ? void 0 : s6.messages) && (e4 ? s6.messages.push(new s("media-layer:unsupported-source", "only media elements of type 'ImageElement' or 'VideoElement' can be persisted")) : s6.messages.push(new s("media-layer:unsupported-source", "the media layer is missing a source")));
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, r4) {
    return this._debouncedSaveOperations(A.SAVE_AS, r4, e4);
  }
  _createSource(e4) {
    if ("mediaType" in e4) switch (e4.mediaType) {
      case "image":
        return new H3();
      case "video":
        return new P5();
    }
    return null;
  }
  _getSourceOverride(e4, r4) {
    if (c4(e4) && this.originIdOf("source") === e.PORTAL_ITEM && r4 && (this.originIdOf("georeference") === e.WEB_MAP || this.originIdOf("georeference") === e.WEB_SCENE)) {
      const o5 = e4.toJSON(), t4 = this._createSource(o5);
      return t4.read({ ...o5 }, { origin: "portal-item" }), t4.read({ georeference: r4 }, { origin: "web-map" }), t4.read({ georeference: r4 }, { origin: "web-scene" }), t4;
    }
    return null;
  }
};
r2([m({ readOnly: true })], b3.prototype, "effectiveSource", void 0), r2([m({ readOnly: true, json: { read: false, write: false, origins: { "web-document": { read: true } } } })], b3.prototype, "georeference", void 0), r2([o("web-document", "georeference")], b3.prototype, "readGeoreference", null), r2([m({ type: String })], b3.prototype, "copyright", void 0), r2([m({ readOnly: true })], b3.prototype, "fullExtent", null), r2([m({ type: ["MediaLayer"] })], b3.prototype, "operationalLayerType", void 0), r2([m({ type: ["show", "hide"] })], b3.prototype, "listMode", void 0), r2([m({ nonNullable: true, json: { write: { enabled: true, allowNull: false, target: { url: { type: String }, mediaType: { type: ["image", "video"] }, georeference: { type: Q2 } }, overridePolicy(e4, r4, o5) {
  return { enabled: true, allowNull: false, ignoreOrigin: P3(this, o5 == null ? void 0 : o5.origin) && c4(e4) && !!e4.georeference && e4.originIdOf("georeference") > e.PORTAL_ITEM };
} } } })], b3.prototype, "source", null), r2([s3("source")], b3.prototype, "castSource", null), r2([o("source", ["url"])], b3.prototype, "readSource", null), r2([r3("source")], b3.prototype, "writeSource", null), r2([m()], b3.prototype, "spatialReference", void 0), r2([m({ readOnly: true })], b3.prototype, "type", void 0), b3 = r2([a("esri.layers.MediaLayer")], b3);
var E3 = b3;
export {
  E3 as default
};
//# sourceMappingURL=MediaLayer-STMYJU64.js.map
