import {
  n as n2,
  t
} from "./chunk-YNAPL6LN.js";
import {
  E,
  S,
  f as f2,
  g,
  h,
  p
} from "./chunk-GWOCGJJE.js";
import {
  a,
  l as l2,
  u as u2
} from "./chunk-DAFTSB3S.js";
import "./chunk-CDBQ673E.js";
import {
  u
} from "./chunk-3RTT2FUJ.js";
import {
  f
} from "./chunk-VC3KNIUZ.js";
import "./chunk-L4EC6LZW.js";
import "./chunk-N6TERPCK.js";
import {
  L
} from "./chunk-SEOVQLIZ.js";
import "./chunk-EUB5OBXG.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-2UD6J77T.js";
import "./chunk-YYDDGFL6.js";
import {
  j,
  x
} from "./chunk-SNZZPKBU.js";
import {
  nt,
  ot,
  rt
} from "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-3WB47P7Q.js";
import "./chunk-6ZI2HC5K.js";
import "./chunk-WESTCUBG.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-BG4U4RTY.js";
import "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import "./chunk-2ZAGB4JV.js";
import "./chunk-B2CK3GCY.js";
import "./chunk-NINPG5JV.js";
import "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import "./chunk-SB6LU3VH.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  i
} from "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-QW7P5D76.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import {
  l,
  v
} from "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import {
  n
} from "./chunk-DCSYHXZG.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import {
  ee,
  ne
} from "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  U
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var O = U;
var D = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: U };
var w = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsQueryAttachmentOrderByFields: false, supportsQueryBins: true, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: true, supportsSqlExpression: true, supportsDisjointSpatialRel: true, supportsQueryWithCacheHint: true }, queryBinsCapabilities: S };
function Q(e) {
  return l(e) ? null != e.z : !!e.hasZ;
}
function S2(e) {
  return l(e) ? null != e.m : !!e.hasM;
}
var v2 = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(t2) {
    const i2 = [], { features: s2 } = t2, r = this._inferLayerProperties(s2, t2.fields), n3 = t2.fields || [], a2 = null != t2.hasM ? t2.hasM : !!r.hasM, u3 = null != t2.hasZ ? t2.hasZ : !!r.hasZ, f3 = !t2.spatialReference && !r.spatialReference, g2 = f3 ? O : t2.spatialReference || r.spatialReference, I = f3 ? D : null, b = t2.geometryType || r.geometryType, F = !b;
    let j2 = t2.objectIdField || r.objectIdField, E2 = t2.timeInfo;
    const Q2 = new Z(n3);
    if (!F && (f3 && i2.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !b)) throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!j2) throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (r.objectIdField && j2 !== r.objectIdField && (i2.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${j2}" doesn't match the field name "${r.objectIdField}", found in the provided fields` }), j2 = r.objectIdField), j2 && !r.objectIdField) {
      const e = Q2.get(j2);
      e ? (j2 = e.name, e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : n3.unshift({ alias: j2, name: j2, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const o of n3) {
      if (null == o.name && (o.name = o.alias), null == o.alias && (o.alias = o.name), !o.name) throw new s("feature-layer:invalid-field-name", "field name is missing", { field: o });
      if (o.name === j2 && (o.type = "esriFieldTypeOID"), !i.jsonValues.includes(o.type)) throw new s("feature-layer:invalid-field-type", `invalid type for field "${o.name}"`, { field: o });
      null == o.length && (o.length = ne(o));
    }
    const S3 = {};
    for (const e of n3) if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
      const t3 = ee(e);
      void 0 !== t3 && (S3[e.name] = t3);
    }
    if (E2) {
      if (E2.startTimeField) {
        const e = Q2.get(E2.startTimeField);
        e ? (E2.startTimeField = e.name, e.type = "esriFieldTypeDate") : E2.startTimeField = null;
      }
      if (E2.endTimeField) {
        const e = Q2.get(E2.endTimeField);
        e ? (E2.endTimeField = e.name, e.type = "esriFieldTypeDate") : E2.endTimeField = null;
      }
      if (E2.trackIdField) {
        const e = Q2.get(E2.trackIdField);
        e ? E2.trackIdField = e.name : (E2.trackIdField = null, i2.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: E2 } }));
      }
      E2.startTimeField || E2.endTimeField || (i2.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: E2 } }), E2 = null);
    }
    const v3 = Q2.dateFields.length ? { timeZoneIANA: t2.dateFieldsTimeZone ?? n } : null;
    this._createDefaultAttributes = a(S3, j2);
    const M = { warnings: i2, featureErrors: [], layerDefinition: { ...w, drawingInfo: u2(b), templates: l2(S3), extent: I, geometryType: b, objectIdField: j2, fields: n3, hasZ: u3, hasM: a2, timeInfo: E2, dateFieldsTimeReference: v3 }, assignedObjectIds: {} };
    if (this._queryEngine = new L({ fieldsIndex: Z.fromLayerJSON({ fields: n3, timeInfo: E2, dateFieldsTimeReference: v3 }), geometryType: b, hasM: a2, hasZ: u3, objectIdField: j2, spatialReference: g2, featureStore: new f({ geometryType: b, hasM: a2, hasZ: u3 }), timeInfo: E2 }), !(s2 == null ? void 0 : s2.length)) return this._nextObjectId = t, M;
    const A = n2(j2, s2);
    return this._nextObjectId = A + 1, await x(s2, g2), this._loadInitialFeatures(M, s2);
  }
  async applyEdits(e) {
    const { spatialReference: t2, geometryType: i2 } = this._queryEngine;
    return await Promise.all([E(t2, i2), x(e.adds, t2), x(e.updates, t2)]), this._applyEdits(e);
  }
  queryFeatures(e, t2 = {}) {
    return this._queryEngine.executeQuery(e, t2.signal);
  }
  queryFeatureCount(e, t2 = {}) {
    return this._queryEngine.executeQueryForCount(e, t2.signal);
  }
  queryObjectIds(e, t2 = {}) {
    return this._queryEngine.executeQueryForIds(e, t2.signal);
  }
  queryExtent(e, t2 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t2.signal);
  }
  querySnapping(e, t2 = {}) {
    return u(this._queryEngine, e, t2.signal);
  }
  queryAttributeBins(e, t2 = {}) {
    return this._queryEngine.executeAttributeBinsQuery(e, t2.signal);
  }
  _inferLayerProperties(e, i2) {
    let s2, r, n3 = null, a2 = null, o = null;
    for (const l3 of e) {
      const e2 = l3.geometry;
      if (null != e2 && (n3 || (n3 = v(e2)), a2 || (a2 = e2.spatialReference), null == s2 && (s2 = Q(e2)), null == r && (r = S2(e2)), n3 && a2 && null != s2 && null != r)) break;
    }
    if (i2 && i2.length) {
      let e2 = null;
      i2.some((t2) => {
        const i3 = "esriFieldTypeOID" === t2.type, s3 = !t2.type && t2.name && "objectid" === t2.name.toLowerCase();
        return e2 = t2, i3 || s3;
      }) && (o = e2.name);
    }
    return { geometryType: n3, spatialReference: a2, objectIdField: o, hasM: r, hasZ: s2 };
  }
  async _loadInitialFeatures(e, i2) {
    const { geometryType: s2, hasM: n3, hasZ: a2, objectIdField: o, spatialReference: l3, featureStore: u3, fieldsIndex: d } = this._queryEngine, p2 = [];
    for (const r of i2) {
      if (null != r.uid && (e.assignedObjectIds[r.uid] = -1), r.geometry && s2 !== v(r.geometry)) {
        e.featureErrors.push(p("Incorrect geometry type."));
        continue;
      }
      const i3 = this._createDefaultAttributes(), n4 = g(d, i3, r.attributes, true);
      n4 ? e.featureErrors.push(n4) : (this._assignObjectId(i3, r.attributes, true), r.attributes = i3, null != r.uid && (e.assignedObjectIds[r.uid] = r.attributes[o]), null != r.geometry && (r.geometry = j(r.geometry, r.geometry.spatialReference, l3)), p2.push(r));
    }
    u3.addMany(nt([], p2, s2, a2, n3, o));
    const { fullExtent: c, timeExtent: y } = await this._queryEngine.fetchRecomputedExtents();
    if (e.layerDefinition.extent = c, y) {
      const { start: t2, end: i3 } = y;
      e.layerDefinition.timeInfo.timeExtent = [t2, i3];
    }
    return e;
  }
  async _applyEdits(e) {
    const { adds: t2, updates: i2, deletes: s2 } = e, r = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if ((t2 == null ? void 0 : t2.length) && this._applyAddEdits(r, t2), (i2 == null ? void 0 : i2.length) && this._applyUpdateEdits(r, i2), s2 == null ? void 0 : s2.length) {
      for (const e2 of s2) r.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(s2);
    }
    const { fullExtent: n3, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n3, timeExtent: a2, featureEditResults: r };
  }
  _applyAddEdits(e, i2) {
    const { addResults: s2 } = e, { geometryType: n3, hasM: a2, hasZ: o, objectIdField: l3, spatialReference: u3, featureStore: d, fieldsIndex: p2 } = this._queryEngine, c = [];
    for (const r of i2) {
      if (r.geometry && n3 !== v(r.geometry)) {
        s2.push(p("Incorrect geometry type."));
        continue;
      }
      const i3 = this._createDefaultAttributes(), a3 = g(p2, i3, r.attributes);
      if (a3) s2.push(a3);
      else {
        if (this._assignObjectId(i3, r.attributes), r.attributes = i3, null != r.uid) {
          const t2 = r.attributes[l3];
          e.uidToObjectId[r.uid] = t2;
        }
        if (null != r.geometry) {
          const e2 = r.geometry.spatialReference ?? u3;
          r.geometry = j(h(r.geometry, e2), e2, u3);
        }
        c.push(r), s2.push(f2(r.attributes[l3]));
      }
    }
    d.addMany(nt([], c, n3, o, a2, l3));
  }
  _applyUpdateEdits({ updateResults: e }, i2) {
    const { geometryType: s2, hasM: r, hasZ: o, objectIdField: l3, spatialReference: u3, featureStore: d, fieldsIndex: p2 } = this._queryEngine;
    for (const c of i2) {
      const { attributes: i3, geometry: y } = c, m = i3 == null ? void 0 : i3[l3];
      if (null == m) {
        e.push(p(`Identifier field ${l3} missing`));
        continue;
      }
      if (!d.has(m)) {
        e.push(p(`Feature with object id ${m} missing`));
        continue;
      }
      const h2 = rt(d.getFeature(m), s2, o, r);
      if (null != y) {
        if (s2 !== v(y)) {
          e.push(p("Incorrect geometry type."));
          continue;
        }
        const i4 = y.spatialReference ?? u3;
        h2.geometry = j(h(y, i4), i4, u3);
      }
      if (i3) {
        const t2 = g(p2, h2.attributes, i3);
        if (t2) {
          e.push(t2);
          continue;
        }
      }
      d.add(ot(h2, s2, o, r, l3)), e.push(f2(m));
    }
  }
  _assignObjectId(e, t2, i2 = false) {
    const s2 = this._queryEngine.objectIdField;
    i2 && t2 && isFinite(t2[s2]) ? e[s2] = t2[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  v2 as default
};
//# sourceMappingURL=MemorySourceWorker-FDAM47H3.js.map
