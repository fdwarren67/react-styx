import {
  Ye
} from "./chunk-HPA5LQSZ.js";
import "./chunk-3SU7BOQG.js";
import "./chunk-JED5CITL.js";
import "./chunk-TRBU6WLM.js";
import "./chunk-XBF3Q5CM.js";
import "./chunk-BSQH3I7W.js";
import "./chunk-PHUXOQ5V.js";
import "./chunk-7LZ547RY.js";
import "./chunk-3XDQGJHT.js";
import "./chunk-BMOULVP4.js";
import "./chunk-LVHCS2TZ.js";
import "./chunk-YSZGPB5I.js";
import "./chunk-5GYWQFHA.js";
import "./chunk-MR2DYNTG.js";
import "./chunk-65Z5LAMC.js";
import "./chunk-IFZYBBFM.js";
import "./chunk-WYOFTVUU.js";
import "./chunk-S4AV6MOI.js";
import "./chunk-QOBHQZYU.js";
import "./chunk-CKW4LZG2.js";
import "./chunk-VYOLHG4T.js";
import "./chunk-TKEIF3N7.js";
import "./chunk-RMOE6XHW.js";
import "./chunk-QAXPIBME.js";
import "./chunk-ISRSQJQR.js";
import "./chunk-WOB72RZU.js";
import {
  f
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import "./chunk-S4QLDBOB.js";
import "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-5ZCYRESW.js";
import "./chunk-XZDT5RTS.js";
import "./chunk-QAP2FVP7.js";
import "./chunk-6EREU4EG.js";
import "./chunk-7DHQ2VMC.js";
import "./chunk-Z5UGTZ3C.js";
import "./chunk-ZXHHBJMH.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-4GBYHIKO.js";
import "./chunk-ZDLUQDDX.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import "./chunk-5T3XQRJL.js";
import "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import {
  A
} from "./chunk-NBXBK3QW.js";
import "./chunk-K5B7AETB.js";
import "./chunk-KLCKQJVO.js";
import "./chunk-5APVNM2E.js";
import "./chunk-73NNNHMH.js";
import "./chunk-C6YDI6QX.js";
import "./chunk-DJ5HVIE7.js";
import "./chunk-KPY4ZIC2.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-WO43UGNC.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-BBPRJCMB.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-RO66CZDO.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-3UBDE4PK.js";
import {
  p
} from "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a3
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  N
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import {
  o
} from "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  g,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  a,
  e
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientation.js
var s2 = class extends g {
  set horizontalWKID(t) {
    t ? N({ wkid: +t }) ? this._set("horizontalWKID", +t) : this._set("horizontalWKID", t) : this._set("horizontalWKID", null);
  }
  set verticalWKID(t) {
    t ? this._set("verticalWKID", isFinite(t) && N({ wkid: +t }) ? +t : null) : this._set("verticalWKID", null);
  }
  get isAdvanced() {
    const { affineTransformations: t, focalLength: o2, principalOffsetPoint: e2, radialDistortionCoefficients: r2, tangentialDistortionCoefficients: i2 } = this;
    return (t == null ? void 0 : t.length) > 1 && !Number.isNaN(o2) && (e2 == null ? void 0 : e2.length) > 1 && (r2 == null ? void 0 : r2.length) > 1 && (i2 == null ? void 0 : i2.length) > 1;
  }
};
r([m({ json: { write: true } })], s2.prototype, "affineTransformations", void 0), r([m({ json: { write: true } })], s2.prototype, "focalLength", void 0), r([m({ json: { write: true } })], s2.prototype, "principalOffsetPoint", void 0), r([m({ json: { write: true } })], s2.prototype, "radialDistortionCoefficients", void 0), r([m({ json: { write: true } })], s2.prototype, "tangentialDistortionCoefficients", void 0), r([m({ json: { write: true } })], s2.prototype, "horizontalWKID", null), r([m({ json: { write: true } })], s2.prototype, "verticalWKID", null), r([m({ json: { write: true } })], s2.prototype, "x", void 0), r([m({ json: { write: true } })], s2.prototype, "y", void 0), r([m({ json: { write: true } })], s2.prototype, "z", void 0), r([m({ json: { write: true } })], s2.prototype, "type", void 0), s2 = r([a2("esri.layers.orientedImagery.core.CameraOrientation")], s2);
var n = s2;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationHPR.js
var s3 = class extends a3.ClonableMixin(S.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 1;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: r2, x: e2, y: i2, z: p5, heading: s6, pitch: n7, roll: a5, affineTransformations: c3, focalLength: m3, principalOffsetPoint: f4, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: u2 } = this, d2 = [o2, t, r2, e2, i2, p5, s6, n7, a5];
    return this.isAdvanced && (c3 == null ? void 0 : c3.forEach((o3) => d2.push(o3)), d2.push(m3), f4 == null ? void 0 : f4.forEach((o3) => d2.push(o3)), y2 == null ? void 0 : y2.forEach((o3) => d2.push(o3)), u2 == null ? void 0 : u2.forEach((o3) => d2.push(o3))), d2.map((o3) => Number.isNaN(o3) ? "" : o3).join("|");
  }
};
r([m({ json: { write: true } })], s3.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], s3.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "heading", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "pitch", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "roll", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], s3.prototype, "z", void 0), s3 = r([a2("esri.layers.orientedImagery.core.CameraOrientationHPR")], s3);
var n2 = s3;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationLTP.js
var p2 = class extends a3.ClonableMixin(S.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 4;
  }
  toString() {
    const { type: o2, latitude: r2, longitude: t, ellipsoidRadius: e2, squaredEccentricity: i2, properties: s6 } = this, p5 = `${s6}`.split("|");
    return p5.splice(1, 1), `${o2}|${r2}|${t}|${e2}|${i2}|${p5.join("|")}`;
  }
};
r([m({ json: { write: true } })], p2.prototype, "type", void 0), r([m({ json: { write: true }, type: Number })], p2.prototype, "latitude", void 0), r([m({ json: { write: true }, type: Number })], p2.prototype, "longitude", void 0), r([m({ json: { write: true }, type: Number })], p2.prototype, "ellipsoidRadius", void 0), r([m({ json: { write: true }, type: Number })], p2.prototype, "squaredEccentricity", void 0), r([m({ json: { write: true } })], p2.prototype, "properties", void 0), p2 = r([a2("esri.layers.orientedImagery.core.CameraOrientationLTP")], p2);
var c = p2;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationOPK.js
var s4 = class extends a3.ClonableMixin(S.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 2;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: r2, x: e2, y: i2, z: p5, omega: s6, phi: n7, kappa: a5, affineTransformations: c3, focalLength: m3, principalOffsetPoint: f4, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: u2 } = this, d2 = [o2, t, r2, e2, i2, p5, s6, n7, a5];
    return this.isAdvanced && (c3 == null ? void 0 : c3.forEach((o3) => d2.push(o3)), d2.push(m3), f4 == null ? void 0 : f4.forEach((o3) => d2.push(o3)), y2 == null ? void 0 : y2.forEach((o3) => d2.push(o3)), u2 == null ? void 0 : u2.forEach((o3) => d2.push(o3))), d2.map((o3) => isNaN(o3) ? "" : o3).join("|");
  }
};
r([m({ json: { write: true } })], s4.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], s4.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "omega", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "phi", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "kappa", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], s4.prototype, "z", void 0), s4 = r([a2("esri.layers.orientedImagery.core.CameraOrientationOPK")], s4);
var n3 = s4;

// node_modules/@arcgis/core/layers/orientedImagery/core/CameraOrientationYPR.js
var n4 = class extends a3.ClonableMixin(S.JSONSupportMixin(n)) {
  constructor() {
    super(...arguments), this.type = 3;
  }
  get isAdvanced() {
    const { affineTransformations: o2, focalLength: t, principalOffsetPoint: e2, radialDistortionCoefficients: r2, tangentialDistortionCoefficients: i2 } = this;
    return (o2 == null ? void 0 : o2.length) > 1 || !Number.isNaN(t) || (e2 == null ? void 0 : e2.length) > 1 || (r2 == null ? void 0 : r2.length) > 1 || (i2 == null ? void 0 : i2.length) > 1;
  }
  toString() {
    const { type: o2, horizontalWKID: t, verticalWKID: e2, x: r2, y: i2, z: s6, yaw: n7, pitch: p5, roll: a5, affineTransformations: c3, focalLength: f4, principalOffsetPoint: m3, radialDistortionCoefficients: y2, tangentialDistortionCoefficients: l3 } = this, u2 = [o2, t, e2, r2, i2, s6, n7, p5, a5];
    return this.isAdvanced && (c3 == null ? void 0 : c3.forEach((o3) => u2.push(o3)), u2.push(f4), m3 == null ? void 0 : m3.forEach((o3) => u2.push(o3)), m3 == null ? void 0 : m3.forEach((o3) => u2.push(o3)), y2 == null ? void 0 : y2.forEach((o3) => u2.push(o3)), l3 == null ? void 0 : l3.forEach((o3) => u2.push(o3))), u2.map((o3) => Number.isNaN(o3) ? "" : o3).join("|");
  }
};
r([m({ json: { write: true } })], n4.prototype, "type", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "affineTransformations", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "focalLength", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "principalOffsetPoint", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "radialDistortionCoefficients", void 0), r([m({ type: [Number], json: { write: true } })], n4.prototype, "tangentialDistortionCoefficients", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "yaw", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "pitch", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "roll", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "y", void 0), r([m({ type: Number, json: { write: true } })], n4.prototype, "z", void 0), n4 = r([a2("esri.layers.orientedImagery.core.CameraOrientationYPR")], n4);
var p3 = n4;

// node_modules/@arcgis/core/layers/orientedImagery/enums/CameraOrientationType.js
var P;
!function(P3) {
  P3[P3.HPR = 1] = "HPR", P3[P3.OPK = 2] = "OPK", P3[P3.YPR = 3] = "YPR", P3[P3.LTP = 4] = "LTP";
}(P || (P = {}));

// node_modules/@arcgis/core/layers/orientedImagery/core/cameraOrientationRegistry.js
var n5 = /* @__PURE__ */ new Map();
n5.set(`${P.OPK}`, { desc: "Using Omega Phi Kappa", constructor: n3 }), n5.set(`${P.HPR}`, { desc: "Using Heading, Pitch and Roll", constructor: n2 }), n5.set(`${P.YPR}`, { desc: "Using Yaw, Pitch and Roll", constructor: p3 }), n5.set(`${P.LTP}`, { desc: "Using Local Tangent Plane", constructor: c });

// node_modules/@arcgis/core/layers/orientedImagery/core/ElevationSourceDefinitions.js
var n6 = class extends a3.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.url = null;
  }
};
r([m({ type: Number, json: { write: true } })], n6.prototype, "lod", void 0), r([m({ type: String, json: { write: true } })], n6.prototype, "rasterFunction", void 0), r([m({ type: String, json: { write: true } })], n6.prototype, "url", void 0), n6 = r([a2("esri.layers.orientedImagery.core.ElevationSourceDefinitions.ElevationSource")], n6);
var i = class extends a3.ClonableMixin(S) {
  constructor() {
    super(...arguments), this.constantElevation = null;
  }
};
r([m({ type: Number, json: { write: true } })], i.prototype, "constantElevation", void 0), i = r([a2("esri.layers.orientedImagery.core.ElevationSourceDefinitions.ConstantElevation")], i);
var l = (o2) => null != o2 && "number" == typeof o2.constantElevation;

// node_modules/@arcgis/core/layers/orientedImagery/core/utils.js
function s5(t, n7, e2) {
  return n7 && (t = `${n7}${t}`), e2 && (t += `${e2}`), t;
}
function l2(t, n7, r2) {
  let { url: i2 } = t;
  return i2 ? (i2 = s5(i2, n7, r2), new n6({ ...t, url: i2 })) : null;
}
function a4(t, n7, e2) {
  return t ? l(t) ? new i(t) : l2(t, n7, e2) : t;
}
var u = new o({ Minutes: "minutes", Hours: "hours", Days: "days", Weeks: "weeks", Months: "months", Years: "years" });
var c2 = new o({ Feet: "feet", Meter: "meter" });
var f2 = new o({ 360: "360", Horizontal: "horizontal", Inspection: "inspection", Nadir: "nadir", Oblique: "oblique", "": null });
var p4 = /* @__PURE__ */ new Map();
function h(t) {
  const [n7, e2, r2, i2, o2, s6, l3, a5, u2, c3, f4, p5, h3, g4, d2, y2, w2, D, z2, $, I, K] = t.slice(1);
  return { horizontalWKID: n7, verticalWKID: e2, x: r2, y: i2, z: o2, omega: s6, phi: l3, kappa: a5, ...m2([u2, c3, f4, p5, h3, g4], [y2, w2], [D, z2, $], [I, K], d2) };
}
p4.set(`${P.HPR}`, d), p4.set(`${P.YPR}`, y), p4.set(`${P.OPK}`, h), p4.set(`${P.LTP}`, w);
var g2 = (t) => {
  const n7 = t.map((t2) => parseFloat(t2)).filter((t2) => !isNaN(t2));
  if (n7.length === t.length) return n7;
};
function m2(t, n7, e2, r2, i2) {
  const o2 = g2(t), s6 = g2(n7), l3 = g2(e2), a5 = g2(r2);
  return { affineTransformations: 6 === (o2 == null ? void 0 : o2.length) ? o2 : void 0, focalLength: 6 === (o2 == null ? void 0 : o2.length) ? parseFloat(i2) : void 0, principalOffsetPoint: 2 !== (s6 == null ? void 0 : s6.length) ? [0, 0] : s6, radialDistortionCoefficients: 3 !== (l3 == null ? void 0 : l3.length) ? [0, 0, 0] : l3, tangentialDistortionCoefficients: 2 !== (a5 == null ? void 0 : a5.length) ? [0, 0] : a5 };
}
function d(t) {
  const [n7, e2, r2, i2, o2, s6, l3, a5, u2, c3, f4, p5, h3, g4, d2, y2, w2, D, z2, $, I, K] = t.slice(1);
  return { horizontalWKID: n7, verticalWKID: e2, x: r2, y: i2, z: o2, heading: s6, pitch: l3, roll: a5, ...m2([u2, c3, f4, p5, h3, g4], [y2, w2], [D, z2, $], [I, K], d2) };
}
function y(t) {
  const [n7, e2, r2, i2, o2, s6, l3, a5, u2, c3, f4, p5, h3, g4, d2, y2, w2, D, z2, $, I, K] = t.slice(1);
  return { horizontalWKID: n7, verticalWKID: e2, x: r2, y: i2, z: o2, yaw: s6, pitch: l3, roll: a5, ...m2([u2, c3, f4, p5, h3, g4], [y2, w2], [D, z2, $], [I, K], d2) };
}
function w(t) {
  var _a;
  const [e2, r2, i2, o2, s6, ...l3] = t.slice(1), a5 = p4.get(s6), u2 = (_a = n5.get(s6)) == null ? void 0 : _a.constructor;
  if (!a5 || !u2) return null;
  return { latitude: e2, longitude: r2, ellipsoidRadius: i2, squaredEccentricity: o2, properties: new u2(a5([s6, "", ...l3])) };
}
function z(t) {
  return Array.isArray(t) && 9 === (t == null ? void 0 : t.length) && !t.some(isNaN);
}

// node_modules/@arcgis/core/layers/OrientedImageryLayer.js
var h2 = /* @__PURE__ */ new Set(["demPathPrefix", "demPathSuffix", "depthImagePathPrefix", "depthImagePathSuffix", "elevationSource", "horizontalMeasurementUnit", "imageGeometryField", "imageReferenceField", "verticalMeasurementUnit", "videoPathPrefix", "videoPathSuffix", "timeAnimation", "visibilityTimeExtent"]);
var g3 = (e2, t) => !h2.has(t) && e2;
var f3 = (e2, t, i2) => {
  const r2 = `orientedImageryProperties.${e2}`;
  return { name: r2, write: t ? { ignoreOrigin: true, target: r2, writer: t } : { ignoreOrigin: true }, read: i2 ? { ignoreOrigin: true, source: r2, reader: i2 } : { ignoreOrigin: true } };
};
function v(e2) {
  return e2.json ? (e2.json.origins = e2.json.origins ?? {}, e2.json.origins["web-scene"] = { write: false, read: false }, e2) : e2;
}
function j(e2, t, i2, r2) {
  const { name: o2, write: a5, read: n7 } = f3(e2, t, i2), s6 = { name: o2, write: a5, read: n7, origins: { service: { name: `orientedImageryInfo.${o2}`, write: t, read: i2 }, "web-scene": { name: o2, write: g3(a5, e2), read: g3(n7, e2) }, "web-map": { name: o2, write: a5, read: n7 } } };
  return r2 && s6.origins ? (s6.type = r2, s6.origins["web-map"].type = r2, s6.origins["web-scene"].type = r2, s6) : s6;
}
var P2 = class extends Ye {
  constructor() {
    super(...arguments), this.cameraHeading = null, this.cameraHeight = null, this.cameraPitch = null, this.cameraRoll = null, this.coveragePercent = null, this.demPathPrefix = null, this.demPathSuffix = null, this.depthImagePathPrefix = null, this.depthImagePathSuffix = null, this.elevationSource = null, this.farDistance = null, this.geometryType = "point", this.horizontalFieldOfView = null, this.horizontalMeasurementUnit = null, this.imageGeometryField = "ImageGeometry", this.imagePathPrefix = null, this.imagePathSuffix = null, this.imageReferenceField = "OIObjectID", this.imageRotation = null, this.maximumDistance = null, this.nearDistance = null, this.operationalLayerType = "OrientedImageryLayer", this.orientationAccuracy = null, this.orientedImageryType = null, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Oriented Imagery Layer"]), this.type = "oriented-imagery", this.timeIntervalUnit = "days", this.useViewTime = true, this.verticalFieldOfView = null, this.verticalMeasurementUnit = null, this.videoPathPrefix = null, this.videoPathSuffix = null, this.visibilityTimeExtent = null;
  }
  get effectiveElevationSource() {
    const { elevationSource: e2, demPathPrefix: t, demPathSuffix: i2 } = this;
    return a4(e2, t, i2);
  }
  async save(e2) {
    return this._debouncedSaveOperations(A.SAVE, e2);
  }
  async saveAs(e2, t) {
    return this._debouncedSaveOperations(A.SAVE_AS, t, e2);
  }
  findFirstValidLayerId(e2) {
    var _a, _b;
    return (_b = (_a = e2.layers) == null ? void 0 : _a.find((e3) => this.supportedSourceTypes.has(e3.type))) == null ? void 0 : _b.id;
  }
  _verifySource() {
    if (super._verifySource(), "point" !== this.geometryType) throw new s("oriented-imagery-layer:invalid-geometry-type", "OrientedImageryLayer only supports point geometry type");
  }
};
r([m({ type: Number, json: j("cameraHeading") })], P2.prototype, "cameraHeading", void 0), r([m({ type: Number, json: j("cameraHeight") })], P2.prototype, "cameraHeight", void 0), r([m({ type: Number, json: j("cameraPitch") })], P2.prototype, "cameraPitch", void 0), r([m({ type: Number, json: j("cameraRoll") })], P2.prototype, "cameraRoll", void 0), r([m({ type: Number, json: j("coveragePercent") })], P2.prototype, "coveragePercent", void 0), r([m({ type: String, json: j("demPathPrefix") })], P2.prototype, "demPathPrefix", void 0), r([m({ type: String, json: j("demPathSuffix") })], P2.prototype, "demPathSuffix", void 0), r([m({ type: String, json: j("depthImagePathPrefix") })], P2.prototype, "depthImagePathPrefix", void 0), r([m({ type: String, json: j("depthImagePathSuffix") })], P2.prototype, "depthImagePathSuffix", void 0), r([m({ type: Object, json: j("elevationSource") })], P2.prototype, "elevationSource", void 0), r([m({ readOnly: true })], P2.prototype, "effectiveElevationSource", null), r([m({ type: Number, json: j("farDistance") })], P2.prototype, "farDistance", void 0), r([m()], P2.prototype, "geometryType", void 0), r([m({ type: Number, json: j("horizontalFieldOfView") })], P2.prototype, "horizontalFieldOfView", void 0), r([m({ type: String, json: j("horizontalMeasurementUnit") })], P2.prototype, "horizontalMeasurementUnit", void 0), r([m({ type: String, json: { ...j("imageGeometryField"), default: "ImageGeometry" } })], P2.prototype, "imageGeometryField", void 0), r([m({ type: String, json: j("imagePathPrefix") })], P2.prototype, "imagePathPrefix", void 0), r([m({ type: String, json: j("imagePathSuffix") })], P2.prototype, "imagePathSuffix", void 0), r([m({ type: String, json: { ...j("imageReferenceField"), default: "OIObjectID" } })], P2.prototype, "imageReferenceField", void 0), r([m({ type: Number, json: j("imageRotation") })], P2.prototype, "imageRotation", void 0), r([m({ type: Number, json: j("maximumDistance") })], P2.prototype, "maximumDistance", void 0), r([m({ type: Number, json: j("nearDistance") })], P2.prototype, "nearDistance", void 0), r([m({ type: ["OrientedImageryLayer"], json: { origins: { "portal-item": { name: "layerType", write: { enabled: true, ignoreOrigin: true } } } } })], P2.prototype, "operationalLayerType", void 0), r([m({ json: { ...j("orientationAccuracy", (e2, t, i2) => {
  e(i2, e2.join(";"), t);
}, (e2) => {
  var _a;
  const t = (_a = e2 == null ? void 0 : e2.split(";")) == null ? void 0 : _a.map(Number);
  return z(t) ? t : [0, 0, 0, 0, 0, 0, 0, 0, 0];
}, String) } })], P2.prototype, "orientationAccuracy", void 0), r([m({ json: { ...j("orientedImageryType", f2.write, f2.read, f2.jsonValues.slice(1)) } })], P2.prototype, "orientedImageryType", void 0), r([m({ json: { read: false }, value: "oriented-imagery", readOnly: true })], P2.prototype, "type", void 0), r([m({ type: u.apiValues, json: { ...j("timeIntervalUnit", u.write, u.read, u.jsonValues) } })], P2.prototype, "timeIntervalUnit", void 0), r([m(v(a(f)))], P2.prototype, "useViewTime", void 0), r([m({ type: Number, json: j("verticalFieldOfView") })], P2.prototype, "verticalFieldOfView", void 0), r([m({ type: c2.apiValues, json: { ...j("verticalMeasurementUnit", c2.write, c2.read, c2.jsonValues) } })], P2.prototype, "verticalMeasurementUnit", void 0), r([m({ type: String, json: j("videoPathPrefix") })], P2.prototype, "videoPathPrefix", void 0), r([m({ type: String, json: j("videoPathSuffix") })], P2.prototype, "videoPathSuffix", void 0), r([m({ type: p, json: { origins: { "web-scene": { write: false, read: false } } } })], P2.prototype, "visibilityTimeExtent", void 0), P2 = r([a2("esri.layers.OrientedImageryLayer")], P2);
var S2 = P2;
export {
  S2 as default
};
//# sourceMappingURL=OrientedImageryLayer-5XE6N2RW.js.map
