import {
  a as a2,
  c,
  y
} from "./chunk-UAJ7VMFY.js";
import {
  T
} from "./chunk-OE5AB3OL.js";
import {
  ae,
  j as j3,
  w as w2
} from "./chunk-FQS6ZZHL.js";
import {
  _,
  h2 as h,
  j as j2,
  m2 as m
} from "./chunk-YLQRI5UO.js";
import {
  D,
  E,
  R,
  U,
  W,
  f2 as f,
  g,
  s3 as s2,
  u3 as u
} from "./chunk-6QH5QYZM.js";
import "./chunk-23WGP47N.js";
import "./chunk-QY6LLTZM.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  s
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-N5E3DEQN.js";
import {
  r as r2
} from "./chunk-K7TZXQ7O.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var a3 = e = class extends a2 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
r([r2({ IdentityXform: "identity" })], a3.prototype, "type", void 0), a3 = e = r([a("esri.layers.support.rasterTransforms.IdentityTransform")], a3);
var p = a3;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var n = { GCSShiftXform: c, IdentityXform: p, PolynomialXform: y };
function f2(r3) {
  const o = r3 == null ? void 0 : r3.type;
  if (!o) return null;
  const t = n[r3 == null ? void 0 : r3.type];
  if (t) {
    const o2 = new t();
    return o2.read(r3), o2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var J = class {
  convertVectorFieldData(r3) {
    const e2 = g.fromJSON(r3.pixelBlock), t = f(e2, r3.type);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  computeStatisticsHistograms(r3) {
    const e2 = g.fromJSON(r3.pixelBlock), t = m(e2);
    return Promise.resolve(t);
  }
  async decode(r3) {
    const e2 = await j2(r3.data, r3.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = g.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? w.fromJSON(e2.extent) : null;
    const t = this.symbolizer.symbolize(e2);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  async updateSymbolizer(r3) {
    var _a;
    this.symbolizer = _.fromJSON(r3.symbolizerJSON), r3.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r3.histograms);
  }
  async updateRasterFunction(r3) {
    this.rasterFunction = T(r3.rasterFunctionJSON);
  }
  async process(t) {
    var _a;
    const o = this.rasterFunction.process({ extent: w.fromJSON(t.extent), primaryPixelBlocks: t.primaryPixelBlocks.map((r3) => null != r3 ? g.fromJSON(r3) : null), primaryPixelSizes: (_a = t.primaryPixelSizes) == null ? void 0 : _a.map((r3) => null != r3 ? j.fromJSON(r3) : null), primaryRasterIds: t.primaryRasterIds });
    return null != o ? o.toJSON() : null;
  }
  stretch(r3) {
    const e2 = this.symbolizer.simpleStretch(g.fromJSON(r3.srcPixelBlock), r3.stretchParams);
    return Promise.resolve(e2 == null ? void 0 : e2.toJSON());
  }
  estimateStatisticsHistograms(r3) {
    const e2 = h(g.fromJSON(r3.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r3) {
    const e2 = W(g.fromJSON(r3.srcPixelBlock), r3.tileSize, r3.maximumPyramidLevel ?? 0, false === r3.useBilinear);
    return e2 && e2.forEach((r4, t) => {
      e2.set(t, r4 == null ? void 0 : r4.toJSON());
    }), Promise.resolve(e2);
  }
  clipTile(r3) {
    const e2 = g.fromJSON(r3.pixelBlock), t = E({ ...r3, pixelBlock: e2 });
    return Promise.resolve(t == null ? void 0 : t.toJSON());
  }
  async mosaicAndTransform(r3) {
    const e2 = r3.srcPixelBlocks.map((r4) => r4 ? new g(r4) : null), t = U(e2, r3.srcMosaicSize, { blockWidths: r3.blockWidths, alignmentInfo: r3.alignmentInfo, clipOffset: r3.clipOffset, clipSize: r3.clipSize });
    let o, i = t;
    return r3.coefs && (i = D(t, r3.destDimension, r3.coefs, r3.sampleSpacing, r3.interpolation)), r3.projectDirections && r3.gcsGrid && (o = R(r3.destDimension, r3.gcsGrid), i = u(i, r3.isUV ? "vector-uv" : "vector-magdir", o)), { pixelBlock: i == null ? void 0 : i.toJSON(), localNorthDirections: o };
  }
  async createFlowMesh(r3, e2) {
    const t = { data: new Float32Array(r3.flowData.buffer), mask: new Uint8Array(r3.flowData.maskBuffer), width: r3.flowData.width, height: r3.flowData.height }, { vertexData: s3, indexData: o } = await s2(r3.meshType, r3.simulationSettings, t, e2.signal);
    return { result: { vertexBuffer: s3.buffer, indexBuffer: o.buffer }, transferList: [s3.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(e2) {
    const s3 = w.fromJSON(e2.projectedExtent), o = w.fromJSON(e2.srcBufferExtent);
    let i = null;
    e2.datumTransformationSteps && (i = new s({ steps: e2.datumTransformationSteps })), (e2.includeGCSGrid || w2(s3.spatialReference, o.spatialReference, i)) && await j3();
    const n2 = e2.rasterTransform ? f2(e2.rasterTransform) : null;
    return ae({ ...e2, projectedExtent: s3, srcBufferExtent: o, datumTransformation: i, rasterTransform: n2 });
  }
};
export {
  J as default
};
//# sourceMappingURL=RasterWorker-JRH6X4WK.js.map
