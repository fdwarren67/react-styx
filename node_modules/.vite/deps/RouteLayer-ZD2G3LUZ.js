import {
  S as S5,
  c,
  c2,
  j as j3,
  y as y3
} from "./chunk-7YIEYLZ3.js";
import {
  T,
  T2,
  j as j4,
  n as n3,
  o as o6,
  w as w3
} from "./chunk-NW57PJGO.js";
import {
  a as a4
} from "./chunk-363KKQAV.js";
import {
  D,
  M as M2,
  R as R2,
  U as U2,
  a as a3,
  b as b3,
  f as f4,
  l as l2,
  m as m2,
  n as n2,
  o as o5,
  q,
  r as r4,
  w as w2
} from "./chunk-OGE3WOJW.js";
import {
  i
} from "./chunk-5Y5NK5SR.js";
import "./chunk-SXBN3QCZ.js";
import {
  R
} from "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import {
  f as f3,
  i as i2
} from "./chunk-6W3XFTHW.js";
import {
  o as o4
} from "./chunk-PHUXOQ5V.js";
import "./chunk-QAXPIBME.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-QAP2FVP7.js";
import {
  d as d2
} from "./chunk-6EREU4EG.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import "./chunk-MRPAGZVF.js";
import {
  j as j2
} from "./chunk-K5B7AETB.js";
import {
  E
} from "./chunk-5APVNM2E.js";
import {
  b as b2
} from "./chunk-C6YDI6QX.js";
import "./chunk-DJ5HVIE7.js";
import {
  S as S3
} from "./chunk-KPY4ZIC2.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  O,
  Q
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import {
  S as S2
} from "./chunk-4GYBOMKF.js";
import "./chunk-RO66CZDO.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  p
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t as t2
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f as f2
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b as b4
} from "./chunk-BLF64HON.js";
import {
  q as q2
} from "./chunk-I3JB2EVB.js";
import {
  C,
  M,
  h as h2
} from "./chunk-TCV7UF6X.js";
import {
  l
} from "./chunk-BMNRD4FO.js";
import {
  f
} from "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a2
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import {
  y as y2
} from "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import {
  C as C2
} from "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  v
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import {
  V
} from "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import {
  S as S4
} from "./chunk-GTN3PVPB.js";
import {
  d
} from "./chunk-BF5PIC2K.js";
import {
  r as r3
} from "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import {
  u
} from "./chunk-552ZCNNH.js";
import {
  P as P2
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  U,
  x
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o as o3
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import {
  o
} from "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  y2 as y
} from "./chunk-BECTSF5P.js";
import {
  I,
  bt
} from "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  m,
  o2
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  b
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s as s2
} from "./chunk-OSHCNHH7.js";
import {
  h
} from "./chunk-7LCEUMDD.js";
import {
  e,
  n2 as n,
  s,
  t
} from "./chunk-6II7WQ2F.js";
import {
  G
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p2 = class extends S {
  constructor(o7) {
    super(o7), this.break = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y2({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y2({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y2({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y2({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
r([m({ types: M })], p2.prototype, "break", void 0), r([m({ types: M })], p2.prototype, "first", void 0), r([m({ types: M })], p2.prototype, "unlocated", void 0), r([m({ types: M })], p2.prototype, "last", void 0), r([m({ types: M })], p2.prototype, "middle", void 0), r([m({ types: M })], p2.prototype, "waypoint", void 0), p2 = r([a("esri.layers.support.RouteStopSymbols")], p2);
var l3 = p2;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c3 = class extends S {
  constructor(o7) {
    super(o7), this.directionLines = new d({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y2({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y2({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S4({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new d({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new d({ width: 8, color: [20, 89, 127] }), this.stops = new l3();
  }
};
r([m({ types: C })], c3.prototype, "directionLines", void 0), r([m({ types: M })], c3.prototype, "directionPoints", void 0), r([m({ types: M })], c3.prototype, "pointBarriers", void 0), r([m({ types: h2 })], c3.prototype, "polygonBarriers", void 0), r([m({ types: C })], c3.prototype, "polylineBarriers", void 0), r([m({ types: C })], c3.prototype, "routeInfo", void 0), r([m({ type: l3 })], c3.prototype, "stops", void 0), c3 = r([a("esri.layers.support.RouteSymbols")], c3);
var d3 = c3;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var m3 = class extends S {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
r([m({ type: String })], m3.prototype, "dataType", void 0), r([r3(D, { ignoreUnknown: false })], m3.prototype, "name", void 0), r([m({ type: [String] })], m3.prototype, "parameterNames", void 0), r([m({ type: String })], m3.prototype, "restrictionUsageParameterName", void 0), r([r3(U2, { ignoreUnknown: false })], m3.prototype, "timeNeutralAttributeName", void 0), r([m({ type: String })], m3.prototype, "trafficSupport", void 0), r([r3(n2)], m3.prototype, "units", void 0), r([r3(b3)], m3.prototype, "usageType", void 0), m3 = r([a("esri.rest.support.NetworkAttribute")], m3);
var u2 = m3;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p3 = class extends S {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
r([m({ type: Number })], p3.prototype, "buildTime", void 0), r([m({ type: String })], p3.prototype, "name", void 0), r([m({ type: [u2] })], p3.prototype, "networkAttributes", void 0), r([m()], p3.prototype, "networkSources", void 0), r([m({ type: String })], p3.prototype, "state", void 0), p3 = r([a("esri.rest.support.NetworkDataset")], p3);
var i3 = p3;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c4 = class extends S {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => D.toJSON(t5)));
  }
  get capabilities() {
    return { supportsNow: (this.currentVersion ?? 10) >= 10.81 };
  }
  readDefaultTravelMode(t4, e2) {
    var _a, _b;
    const r5 = ((_a = e2.supportedTravelModes) == null ? void 0 : _a.find(({ id: t5 }) => t5 === e2.defaultTravelMode)) ?? ((_b = e2.supportedTravelModes) == null ? void 0 : _b.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode));
    return r5 ? j3.fromJSON(r5) : null;
  }
};
r([m()], c4.prototype, "accumulateAttributeNames", void 0), r([o3("accumulateAttributeNames")], c4.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributeNames")], c4.prototype, "writeAccumulateAttributes", null), r([m()], c4.prototype, "attributeParameterValues", void 0), r([m()], c4.prototype, "capabilities", null), r([m()], c4.prototype, "currentVersion", void 0), r([m()], c4.prototype, "defaultTravelMode", void 0), r([o3("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c4.prototype, "readDefaultTravelMode", null), r([m()], c4.prototype, "directionsLanguage", void 0), r([r3(a3)], c4.prototype, "directionsLengthUnits", void 0), r([m()], c4.prototype, "directionsSupportedLanguages", void 0), r([r3(U2, { ignoreUnknown: false })], c4.prototype, "directionsTimeAttribute", void 0), r([m()], c4.prototype, "hasZ", void 0), r([r3(D, { ignoreUnknown: false })], c4.prototype, "impedance", void 0), r([m({ type: i3 })], c4.prototype, "networkDataset", void 0), r([m({ type: [j3] })], c4.prototype, "supportedTravelModes", void 0), c4 = r([a("esri.rest.support.NetworkServiceDescription")], c4);
var m4 = c4;

// node_modules/@arcgis/core/rest/networkService.js
var l4 = () => n.getLogger("esri.rest.networkService");
function u3(e2, r5, t4, o7) {
  o7[t4] = [r5.length, r5.length + e2.length], e2.forEach((e3) => {
    r5.push(e3.geometry);
  });
}
function f5(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o7 = e2[r5[t4]];
    if (o7 && o7.length) for (const e3 of o7) e3.z = void 0;
  }
  l4().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c5(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o7 = e2[r5[t4]];
    if (o7 && o7.length) {
      for (const e3 of o7) if (null != e3 && e3.hasZ) return true;
    }
  }
  return false;
}
async function d4(t4, o7, s4) {
  if (!t4) throw new s2("network-service:missing-url", "Url to Network service is missing");
  const n6 = i2({ f: "json", token: o7 }, s4), { data: l7 } = await P(t4, n6), u6 = l7.currentVersion >= 10.4 ? p4(t4, o7, s4) : v2(t4, s4), { defaultTravelMode: f6, supportedTravelModes: c15 } = await u6;
  return l7.defaultTravelMode = f6, l7.supportedTravelModes = c15, m4.fromJSON(l7);
}
async function v2(r5, t4) {
  var _a, _b, _c;
  const i6 = i2({ f: "json" }, t4), { data: l7 } = await P(r5.replace(/\/rest\/.*$/i, "/info"), i6);
  if (!(l7 == null ? void 0 : l7.owningSystemUrl)) return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u6 } = l7, f6 = bt(u6) + "/sharing/rest/portals/self", { data: c15 } = await P(f6, i6), d5 = t("helperServices.routingUtilities.url", c15);
  if (!d5) return { supportedTravelModes: [], defaultTravelMode: null };
  const v3 = f3(u6), p9 = /\/solve$/i.test(v3.path) ? "Route" : /\/solveclosestfacility$/i.test(v3.path) ? "ClosestFacility" : "ServiceAreas", m9 = i2({ f: "json", serviceName: p9 }, t4), h3 = bt(d5) + "/GetTravelModes/execute", g2 = await P(h3, m9), w4 = [];
  let T3 = null;
  if ((_b = (_a = g2 == null ? void 0 : g2.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e2 = g2.data.results;
    for (const r6 of e2) if ("supportedTravelModes" === r6.paramName) {
      if ((_c = r6.value) == null ? void 0 : _c.features) {
        for (const { attributes: e3 } of r6.value.features) if (e3) {
          const r7 = JSON.parse(e3.TravelMode);
          w4.push(r7);
        }
      }
    } else "defaultTravelMode" === r6.paramName && (T3 = r6.value);
  }
  return { supportedTravelModes: w4, defaultTravelMode: T3 };
}
async function p4(t4, o7, n6) {
  try {
    const r5 = i2({ f: "json", token: o7 }, n6), i6 = bt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l7, defaultTravelMode: u6 } } = await P(i6, r5);
    return { supportedTravelModes: l7, defaultTravelMode: u6 };
  } catch (i6) {
    throw new s2("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i6 });
  }
}

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new o({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c6 = class extends a4 {
  constructor(r5) {
    super(r5), this.type = null;
  }
};
r([m({ type: String, json: { read: p5.read, write: p5.write } })], c6.prototype, "type", void 0), c6 = r([a("esri.rest.support.NAMessage")], c6);
var i4 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c7 = class extends S {
  constructor(r5) {
    super(r5);
  }
};
r([m({ json: { read: { source: "string" } } })], c7.prototype, "text", void 0), r([r3(q, { name: "stringType" })], c7.prototype, "type", void 0), c7 = r([a("esri.rest.support.DirectionsString")], c7);
var i5 = c7;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a5 = class extends S {
  constructor(r5) {
    super(r5), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r5, e2) {
    return n3(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r5, e2) {
    return j.fromJSON(e2.point);
  }
};
r([m({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a5.prototype, "arriveTime", void 0), r([m()], a5.prototype, "arriveTimeOffset", void 0), r([o3("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a5.prototype, "readArriveTimeOffset", null), r([m({ type: j })], a5.prototype, "geometry", void 0), r([o3("geometry", ["point"])], a5.prototype, "readGeometry", null), r([m({ type: [i5] })], a5.prototype, "strings", void 0), a5 = r([a("esri.rest.support.DirectionsEvent")], a5);
var c8 = a5;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function c9(r5) {
  if (null == r5 || "" === r5) return null;
  let e2 = 0, t4 = 0, o7 = 0, s4 = 0;
  const p9 = [];
  let n6, i6, c15, a7, m9, l7, u6, y4, d5 = 0, f6 = 0, h3 = 0;
  if (m9 = r5.match(/((\+|-)[^+\-|]+|\|)/g), m9 || (m9 = []), 0 === parseInt(m9[d5], 32)) {
    d5 = 2;
    const r6 = parseInt(m9[d5], 32);
    d5++, l7 = parseInt(m9[d5], 32), d5++, 1 & r6 && (f6 = m9.indexOf("|") + 1, u6 = parseInt(m9[f6], 32), f6++), 2 & r6 && (h3 = m9.indexOf("|", f6) + 1, y4 = parseInt(m9[h3], 32), h3++);
  } else l7 = parseInt(m9[d5], 32), d5++;
  for (; d5 < m9.length && "|" !== m9[d5]; ) {
    n6 = parseInt(m9[d5], 32) + e2, d5++, e2 = n6, i6 = parseInt(m9[d5], 32) + t4, d5++, t4 = i6;
    const r6 = [n6 / l7, i6 / l7];
    f6 && (a7 = parseInt(m9[f6], 32) + o7, f6++, o7 = a7, r6.push(a7 / u6)), h3 && (c15 = parseInt(m9[h3], 32) + s4, h3++, s4 = c15, r6.push(c15 / y4)), p9.push(r6);
  }
  return { paths: [p9], hasZ: f6 > 0, hasM: h3 > 0 };
}
var a6 = class extends b4 {
  constructor(r5) {
    super(r5), this.events = null, this.geometry = null, this.strings = null;
  }
  readGeometry(r5, e2) {
    const t4 = c9(e2.compressedGeometry);
    return null != t4 ? P2.fromJSON(t4) : null;
  }
};
r([m({ type: [c8] })], a6.prototype, "events", void 0), r([m({ type: P2 })], a6.prototype, "geometry", void 0), r([o3("geometry", ["compressedGeometry"])], a6.prototype, "readGeometry", null), r([m({ type: [i5] })], a6.prototype, "strings", void 0), a6 = r([a("esri.rest.support.DirectionsFeature")], a6);
var m5 = a6;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u4(e2, t4) {
  if (0 === e2.length) return new P2({ spatialReference: t4 });
  const r5 = [];
  for (const n6 of e2) for (const e3 of n6.paths) r5.push(...e3);
  const o7 = [];
  r5.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r5[t5 - 1][0] && e3[1] === r5[t5 - 1][1] || o7.push(e3);
  });
  const { hasM: s4, hasZ: a7 } = e2[0];
  return new P2({ hasM: s4, hasZ: a7, paths: [o7], spatialReference: t4 });
}
var m6 = class extends d2 {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2) return [];
    const r5 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o7 = r5 && g.fromJSON(r5);
    return e2.map((e3) => {
      const t5 = m5.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o7), null != t5.events) for (const r6 of t5.events) null != r6.geometry && (r6.geometry.spatialReference = o7);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return u4(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(G);
  }
};
r([m({ type: w, json: { read: { source: "summary.envelope" } } })], m6.prototype, "extent", void 0), r([m({ nonNullable: true })], m6.prototype, "features", void 0), r([o3("features")], m6.prototype, "readFeatures", null), r([m()], m6.prototype, "geometryType", void 0), r([m({ readOnly: true })], m6.prototype, "mergedGeometry", null), r([m()], m6.prototype, "routeId", void 0), r([m()], m6.prototype, "routeName", void 0), r([m({ value: null, readOnly: true })], m6.prototype, "strings", null), r([m({ json: { read: { source: "summary.totalDriveTime" } } })], m6.prototype, "totalDriveTime", void 0), r([m({ json: { read: { source: "summary.totalLength" } } })], m6.prototype, "totalLength", void 0), r([m({ json: { read: { source: "summary.totalTime" } } })], m6.prototype, "totalTime", void 0), m6 = r([a("esri.rest.support.DirectionsFeatureSet")], m6);
var c10 = m6;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n4 = class extends S {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
r([m({ type: d2, json: { write: true } })], n4.prototype, "directionLines", void 0), r([m({ type: d2, json: { write: true } })], n4.prototype, "directionPoints", void 0), r([m({ type: c10, json: { write: true } })], n4.prototype, "directions", void 0), r([m({ type: b4, json: { write: true } })], n4.prototype, "route", void 0), r([m({ type: String, json: { write: true } })], n4.prototype, "routeName", void 0), r([m({ type: [b4], json: { write: true } })], n4.prototype, "stops", void 0), r([m({ type: d2, json: { write: true } })], n4.prototype, "traversedEdges", void 0), r([m({ type: d2, json: { write: true } })], n4.prototype, "traversedJunctions", void 0), r([m({ type: d2, json: { write: true } })], n4.prototype, "traversedTurns", void 0), n4 = r([a("esri.rest.support.RouteResult")], n4);
var u5 = n4;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function n5(r5) {
  return r5 ? d2.fromJSON(r5).features.filter(G) : [];
}
var c11 = class extends S {
  constructor(r5) {
    super(r5), this.checksum = null, this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r5, o7) {
    return n5(o7.barriers);
  }
  readPolylineBarriers(r5) {
    return n5(r5);
  }
  readPolygonBarriers(r5) {
    return n5(r5);
  }
};
r([m({ type: String })], c11.prototype, "checksum", void 0), r([m({ type: [i4] })], c11.prototype, "messages", void 0), r([m({ type: [b4] })], c11.prototype, "pointBarriers", void 0), r([o3("pointBarriers", ["barriers"])], c11.prototype, "readPointBarriers", null), r([m({ type: [b4] })], c11.prototype, "polylineBarriers", void 0), r([o3("polylineBarriers")], c11.prototype, "readPolylineBarriers", null), r([m({ type: [b4] })], c11.prototype, "polygonBarriers", void 0), r([o3("polygonBarriers")], c11.prototype, "readPolygonBarriers", null), r([m({ type: [u5] })], c11.prototype, "routeResults", void 0), c11 = r([a("esri.rest.support.RouteSolveResult")], c11);
var m7 = c11;

// node_modules/@arcgis/core/rest/route.js
function p6(e2) {
  return e2 instanceof d2;
}
async function l5(c15, f6, l7) {
  const y4 = [], d5 = [], h3 = {}, g2 = {}, R4 = f3(c15), { path: v3 } = R4;
  p6(f6.stops) && u3(f6.stops.features, d5, "stops.features", h3), p6(f6.pointBarriers) && u3(f6.pointBarriers.features, d5, "pointBarriers.features", h3), p6(f6.polylineBarriers) && u3(f6.polylineBarriers.features, d5, "polylineBarriers.features", h3), p6(f6.polygonBarriers) && u3(f6.polygonBarriers.features, d5, "polygonBarriers.features", h3);
  const B = await R(d5);
  for (const e2 in h3) {
    const r5 = h3[e2];
    y4.push(e2), g2[e2] = B.slice(r5[0], r5[1]);
  }
  if (c5(g2, y4)) {
    let e2 = null;
    try {
      e2 = await d4(v3, f6.apiKey, l7);
    } catch {
    }
    e2 && !e2.hasZ && f5(g2, y4);
  }
  for (const e2 in g2) g2[e2].forEach((t4, s4) => {
    o2(f6, e2)[s4].geometry = t4;
  });
  const E2 = { ...l7, query: { ...R4.query, ...o6(f6), f: "json" } }, T3 = v3.endsWith("/solve") ? v3 : `${v3}/solve`, { data: b5 } = await P(T3, E2);
  return m8(b5);
}
function m8(e2) {
  const { barriers: r5, checksum: t4, directionLines: s4, directionPoints: o7, directions: a7, messages: u6, polygonBarriers: i6, polylineBarriers: n6, routes: c15, stops: p9, traversedEdges: l7, traversedJunctions: m9, traversedTurns: y4 } = e2, d5 = (e3) => {
    const r6 = g2.find((r7) => r7.routeName === e3);
    if (null != r6) return r6;
    const t5 = { routeId: g2.length + 1, routeName: e3 };
    return g2.push(t5), t5;
  }, h3 = (e3) => {
    const r6 = g2.find((r7) => r7.routeId === e3);
    if (null != r6) return r6;
    const t5 = { routeId: e3, routeName: null };
    return g2.push(t5), t5;
  }, g2 = [];
  c15 == null ? void 0 : c15.features.forEach((e3, r6) => {
    e3.geometry.spatialReference = c15.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s5 = r6 + 1;
    g2.push({ routeId: s5, routeName: t5, route: e3 });
  }), a7 == null ? void 0 : a7.forEach((e3) => {
    const { routeName: r6 } = e3;
    d5(r6).directions = e3;
  });
  const R4 = ((p9 == null ? void 0 : p9.features.every((e3) => null == e3.attributes.RouteName)) ?? false) && g2.length > 0 ? g2[0].routeName : null;
  return p9 == null ? void 0 : p9.features.forEach((e3) => {
    var _a;
    e3.geometry && ((_a = e3.geometry).spatialReference ?? (_a.spatialReference = p9.spatialReference ?? void 0));
    const r6 = R4 ?? e3.attributes.RouteName, t5 = d5(r6);
    t5.stops ?? (t5.stops = []), t5.stops.push(e3);
  }), s4 == null ? void 0 : s4.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h3(r6), { geometryType: o8, spatialReference: a8 } = s4;
    t5.directionLines ?? (t5.directionLines = { features: [], geometryType: o8, spatialReference: a8 }), t5.directionLines.features.push(e3);
  }), o7 == null ? void 0 : o7.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h3(r6), { geometryType: s5, spatialReference: a8 } = o7;
    t5.directionPoints ?? (t5.directionPoints = { features: [], geometryType: s5, spatialReference: a8 }), t5.directionPoints.features.push(e3);
  }), l7 == null ? void 0 : l7.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h3(r6), { geometryType: s5, spatialReference: o8 } = l7;
    t5.traversedEdges ?? (t5.traversedEdges = { features: [], geometryType: s5, spatialReference: o8 }), t5.traversedEdges.features.push(e3);
  }), m9 == null ? void 0 : m9.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h3(r6), { geometryType: s5, spatialReference: o8 } = m9;
    t5.traversedJunctions ?? (t5.traversedJunctions = { features: [], geometryType: s5, spatialReference: o8 }), t5.traversedJunctions.features.push(e3);
  }), y4 == null ? void 0 : y4.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = h3(r6);
    t5.traversedTurns ?? (t5.traversedTurns = { features: [] }), t5.traversedTurns.features.push(e3);
  }), m7.fromJSON({ barriers: r5, checksum: t4, messages: u6, polygonBarriers: i6, polylineBarriers: n6, routeResults: g2 });
}

// node_modules/@arcgis/core/rest/support/commonProperties.js
var t3 = { type: String, json: { read: { source: "token" }, write: { target: "token" } } };

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l6 = class extends a2.ClonableMixin(S) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
r([m({ type: Boolean, json: { write: true } })], l6.prototype, "doNotLocateOnRestrictedElements", void 0), r([m({ types: l, json: { read: f, write: true } })], l6.prototype, "geometry", void 0), r([r3(R2)], l6.prototype, "geometryType", void 0), r([m({ type: String, json: { name: "layerName", write: true } })], l6.prototype, "name", void 0), r([r3(M2, { name: "spatialRel" })], l6.prototype, "spatialRelationship", void 0), r([m({ type: String, json: { write: true } })], l6.prototype, "type", void 0), r([m({ type: String, json: { write: true } })], l6.prototype, "where", void 0), l6 = r([a("esri.rest.support.DataLayer")], l6);
var c12 = l6;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s3;
var c13 = s3 = class extends d2 {
  constructor(e2) {
    super(e2), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s3({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
r([m({ type: Boolean, json: { write: true } })], c13.prototype, "doNotLocateOnRestrictedElements", void 0), c13 = s3 = r([a("esri.rest.support.NetworkFeatureSet")], c13);
var p7 = c13;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p8 = class extends a2.ClonableMixin(S) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
r([m({ type: Boolean, json: { write: true } })], p8.prototype, "doNotLocateOnRestrictedElements", void 0), r([m({ type: String, json: { write: true } })], p8.prototype, "url", void 0), p8 = r([a("esri.rest.support.NetworkUrl")], p8);
var c14 = p8;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N;
var P3 = N = class extends a2.ClonableMixin(S) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.checksum = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return h(N, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => D.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r5) {
    k(t4, e2, r5);
  }
  writePolygonBarrier(t4, e2, r5) {
    k(t4, e2, r5);
  }
  writePolylineBarrier(t4, e2, r5) {
    k(t4, e2, r5);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w2.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => w2.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r5 } = e2;
    return null == r5 ? null : "now" === r5 ? "now" : new Date(r5);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return C3(e2.stops);
  }
  writeStops(t4, e2, r5) {
    k(t4, e2, r5);
  }
};
r([m({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P3.prototype, "accumulateAttributes", void 0), r([o3("accumulateAttributes")], P3.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributes")], P3.prototype, "writeAccumulateAttributes", null), r([m(t3)], P3.prototype, "apiKey", void 0), r([m({ json: { write: true } })], P3.prototype, "attributeParameterValues", void 0), r([m({ type: String, json: { write: true } })], P3.prototype, "checksum", void 0), r([m({ type: String, json: { write: true } })], P3.prototype, "directionsLanguage", void 0), r([r3(a3)], P3.prototype, "directionsLengthUnits", void 0), r([r3(o5)], P3.prototype, "directionsOutputType", void 0), r([r3(f4)], P3.prototype, "directionsStyleName", void 0), r([r3(U2, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P3.prototype, "directionsTimeAttribute", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "findBestSequence", void 0), r([m({ type: Number, json: { write: true } })], P3.prototype, "geometryPrecision", void 0), r([m({ type: Number, json: { write: true } })], P3.prototype, "geometryPrecisionM", void 0), r([m({ type: Number, json: { write: true } })], P3.prototype, "geometryPrecisionZ", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "ignoreInvalidLocations", void 0), r([r3(D, { name: "impedanceAttributeName", ignoreUnknown: false })], P3.prototype, "impedanceAttribute", void 0), r([m({ type: Number, json: { write: true } })], P3.prototype, "outputGeometryPrecision", void 0), r([r3(r4)], P3.prototype, "outputGeometryPrecisionUnits", void 0), r([r3(l2)], P3.prototype, "outputLines", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], P3.prototype, "outSpatialReference", void 0), r([m({ json: { write: true } })], P3.prototype, "overrides", void 0), r([m({ json: { name: "barriers", write: true } })], P3.prototype, "pointBarriers", void 0), r([r2("pointBarriers")], P3.prototype, "writePointBarriers", null), r([m({ json: { write: true } })], P3.prototype, "polygonBarriers", void 0), r([r2("polygonBarriers")], P3.prototype, "writePolygonBarrier", null), r([m({ json: { write: true } })], P3.prototype, "polylineBarriers", void 0), r([r2("polylineBarriers")], P3.prototype, "writePolylineBarrier", null), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "preserveFirstStop", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "preserveLastStop", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "preserveObjectID", void 0), r([m({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P3.prototype, "restrictionAttributes", void 0), r([o3("restrictionAttributes")], P3.prototype, "readRestrictionAttributes", null), r([r2("restrictionAttributes")], P3.prototype, "writeRestrictionAttributes", null), r([r3(m2)], P3.prototype, "restrictUTurns", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnDirections", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnPolygonBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnPolylineBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnRoutes", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnStops", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnTraversedEdges", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnTraversedJunctions", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnTraversedTurns", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "returnZ", void 0), r([m({ json: { write: true } })], P3.prototype, "startTime", void 0), r([o3("startTime")], P3.prototype, "readStartTime", null), r([r2("startTime")], P3.prototype, "writeStartTime", null), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "startTimeIsUTC", void 0), r([m({ json: { write: true } })], P3.prototype, "stops", void 0), r([o3("stops")], P3.prototype, "readStops", null), r([r2("stops")], P3.prototype, "writeStops", null), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "timeWindowsAreUTC", void 0), r([m({ type: j3, json: { write: true } })], P3.prototype, "travelMode", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "useHierarchy", void 0), r([m({ type: Boolean, json: { write: true } })], P3.prototype, "useTimeWindows", void 0), P3 = N = r([a("esri.rest.support.RouteParameters")], P3);
var O2 = P3;
function J(t4) {
  return t4 && "type" in t4;
}
function L(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function R3(t4) {
  return t4 && "url" in t4;
}
function U3(t4) {
  return t4 && "features" in t4;
}
function C3(t4) {
  return J(t4) ? c12.fromJSON(t4) : R3(t4) ? c14.fromJSON(t4) : L(t4) ? p7.fromJSON(t4) : U3(t4) ? d2.fromJSON(t4) : null;
}
function k(t4, e2, o7) {
  null != t4 && (e2[o7] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}

// node_modules/@arcgis/core/layers/RouteLayer.js
function Y(e2) {
  if (!e2.length) return;
  const t4 = e2.toArray(), r5 = t4.map(({ objectId: e3 }) => e3).filter((e3) => null != e3);
  let o7 = Math.max(...r5, 0);
  for (const i6 of t4) null == i6.objectId && (i6.objectId = ++o7);
}
function Z(e2, t4) {
  return !!e2.length && e2.length === t4.length && z(e2) && z(t4);
}
function z(e2) {
  return e2.every(({ objectId: e3 }) => null != e3);
}
function K(e2) {
  return e2.length ? e2 : null;
}
function X(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: X("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: X("esriGeometryPolyline") };
  }
}
function H(e2) {
  return "layers" in e2;
}
function Q2(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function $(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function ee(e2, t4, r5) {
  var _a, _b, _c, _d, _e, _f;
  const o7 = (_a = t4.networkDataset) == null ? void 0 : _a.networkAttributes, i6 = (o7 == null ? void 0 : o7.filter(({ usageType: e3 }) => "cost" === e3)) ?? [], n6 = r5.travelMode ?? t4.defaultTravelMode;
  if (null == n6) return void he().warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: a7, distanceAttributeName: l7 } = n6, u6 = i6.find(({ name: e3 }) => e3 === a7), p9 = i6.find(({ name: e3 }) => e3 === l7), c15 = ((_b = r5.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r5.impedanceAttribute ?? t4.impedance, m9 = u6 == null ? void 0 : u6.units, y4 = p9 == null ? void 0 : p9.units;
  if (!m9 || !y4) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f6 = r5.directionsLanguage ?? t4.directionsLanguage, d5 = r5.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], h3 = new Set(i6.filter(({ name: e3 }) => e3 === a7 || e3 === l7 || e3 === c15 || null != e3 && d5.includes(e3)).map(({ name: e3 }) => e3)), w4 = (e3) => {
    for (const t5 in e3) h3.has(t5) || delete e3[t5];
  };
  for (const s4 of e2.pointBarriers) null != s4.costs && (s4.addedCost = s4.costs[c15] ?? 0, w4(s4.costs));
  for (const s4 of e2.polygonBarriers) null != s4.costs && (s4.scaleFactor = s4.costs[c15] ?? 1, w4(s4.costs));
  for (const s4 of e2.polylineBarriers) null != s4.costs && (s4.scaleFactor = s4.costs[c15] ?? 1, w4(s4.costs));
  const { routeInfo: g2 } = e2, { findBestSequence: S6, preserveFirstStop: b5, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: I2 } = r5;
  g2.analysisSettings = new c2({ accumulateAttributes: d5, directionsLanguage: f6, findBestSequence: S6, preserveFirstStop: b5, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: I2, travelMode: n6 }), g2.totalDuration = ne(((_c = g2.totalCosts) == null ? void 0 : _c[a7]) ?? 0, m9), g2.totalDistance = ae(((_d = g2.totalCosts) == null ? void 0 : _d[l7]) ?? 0, y4), g2.totalLateDuration = ne(((_e = g2.totalViolations) == null ? void 0 : _e[a7]) ?? 0, m9), g2.totalWaitDuration = ne(((_f = g2.totalWait) == null ? void 0 : _f[a7]) ?? 0, m9), null != g2.totalCosts && w4(g2.totalCosts), null != g2.totalViolations && w4(g2.totalViolations), null != g2.totalWait && w4(g2.totalWait);
  for (const s4 of e2.stops) null != s4.serviceCosts && (s4.serviceDuration = ne(s4.serviceCosts[a7] ?? 0, m9), s4.serviceDistance = ae(s4.serviceCosts[l7] ?? 0, y4), w4(s4.serviceCosts)), null != s4.cumulativeCosts && (s4.cumulativeDuration = ne(s4.cumulativeCosts[a7] ?? 0, m9), s4.cumulativeDistance = ae(s4.cumulativeCosts[l7] ?? 0, y4), w4(s4.cumulativeCosts)), null != s4.violations && (s4.lateDuration = ne(s4.violations[a7] ?? 0, m9), w4(s4.violations)), null != s4.wait && (s4.waitDuration = ne(s4.wait[a7] ?? 0, m9), w4(s4.wait));
}
function te(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.addedCost = r5.addedCost, e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.curbApproach = r5.curbApproach, e3.fullEdge = r5.fullEdge, e3.geometry = r5.geometry, e3.name = r5.name, e3.sideOfEdge = r5.sideOfEdge, e3.sourceId = r5.sourceId, e3.sourceOid = r5.sourceOid, e3.status = r5.status, e3.symbol = r5.symbol);
  }
}
function re(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.geometry = r5.geometry, e3.name = r5.name, e3.scaleFactor = r5.scaleFactor, e3.symbol = r5.symbol);
  }
}
function oe(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.barrierType = r5.barrierType, e3.costs = r5.costs, e3.geometry = r5.geometry, e3.name = r5.name, e3.scaleFactor = r5.scaleFactor, e3.symbol = r5.symbol);
  }
}
function ie(e2, t4) {
  for (const r5 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r5.objectId);
    e3 && (e3.arriveCurbApproach = r5.arriveCurbApproach, e3.arriveTime = r5.arriveTime, e3.arriveTimeOffset = r5.arriveTimeOffset, e3.cumulativeCosts = r5.cumulativeCosts, e3.cumulativeDistance = r5.cumulativeDistance, e3.cumulativeDuration = r5.cumulativeDuration, e3.curbApproach = r5.curbApproach, e3.departCurbApproach = r5.departCurbApproach, e3.departTime = r5.departTime, e3.departTimeOffset = r5.departTimeOffset, e3.distanceToNetworkInMeters = r5.distanceToNetworkInMeters, e3.geometry = r5.geometry, e3.lateDuration = r5.lateDuration, e3.name = r5.name, e3.navLatency = r5.navLatency, e3.posAlong = r5.posAlong, e3.routeName = r5.routeName, e3.serviceCosts = r5.serviceCosts, e3.serviceDistance = r5.serviceDistance, e3.serviceDuration = r5.serviceDuration, e3.sequence = r5.sequence, e3.sideOfEdge = r5.sideOfEdge, e3.snapX = r5.snapX, e3.snapY = r5.snapY, e3.snapZ = r5.snapZ, e3.sourceId = r5.sourceId, e3.sourceOid = r5.sourceOid, e3.status = r5.status, e3.symbol = r5.symbol, e3.timeWindowEnd = r5.timeWindowEnd, e3.timeWindowStart = r5.timeWindowStart, e3.violations = r5.violations, e3.waitDuration = r5.waitDuration, e3.wait = r5.wait);
  }
}
async function se(e2) {
  const t4 = g.WGS84;
  return await Q(e2.spatialReference, t4), O(e2, t4);
}
function ne(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ae(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : x(e2, t4, "meters");
}
function le(e2) {
  const { attributes: t4, geometry: r5, popupTemplate: o7, symbol: i6 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r5, popupInfo: o7, symbol: i6 };
}
var ue = V.ofType(c);
var pe = V.ofType(y3);
var ce = V.ofType(T);
var me = V.ofType(T2);
var ye = V.ofType(j4);
var fe = V.ofType(w3);
var de = "esri.layers.RouteLayer";
var he = () => n.getLogger(de);
var we = class extends p(t2(b2(j2(S3(f2))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.checksum = null, this.defaultSymbols = new d3(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ce(), this.polygonBarriers = new me(), this.polylineBarriers = new ye(), this.routeInfo = null, this.spatialReference = g.WGS84, this.stops = new fe(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r5, o7) {
    const i6 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s4 = i6.map((e3, t5) => t5), n6 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    e(n6, i6, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s4;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => c.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => y3.fromGraphic(e3));
  }
  get fullExtent() {
    var _a;
    const e2 = new w({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: g.WGS84 });
    if (null != ((_a = this.routeInfo) == null ? void 0 : _a.geometry)) return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops) return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2) return e2;
    const { spatialReference: r5 } = t4.at(0).geometry;
    if (null == r5) return e2;
    const o7 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new u({ points: o7, spatialReference: r5 }).extent;
  }
  readMaxScale(e2, t4) {
    var _a;
    const r5 = H(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r5 == null ? void 0 : r5.find((e3) => null != e3.layerDefinition.maxScale);
    return (o7 == null ? void 0 : o7.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e2, t4) {
    var _a;
    const r5 = H(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r5 == null ? void 0 : r5.find((e3) => null != e3.layerDefinition.minScale);
    return (o7 == null ? void 0 : o7.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => T.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => T2.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => j4.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    return this._getNetworkFeatures(t4, "RouteInfo", (e3) => S5.fromGraphic(e3)).at(0) ?? null;
  }
  readSpatialReference(e2, t4) {
    var _a, _b;
    const r5 = H(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers;
    if (!(r5 == null ? void 0 : r5.length)) return g.WGS84;
    const { layerDefinition: o7, featureSet: i6 } = r5[0], s4 = i6.features[0], n6 = ((_b = s4 == null ? void 0 : s4.geometry) == null ? void 0 : _b.spatialReference) ?? i6.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? U;
    return g.fromJSON(n6);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => w3.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    var _a;
    return ((_a = this.routeInfo) == null ? void 0 : _a.name) ?? "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y(e2, he())) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r5 } = t4;
    await r5.signIn(), r5.user || await t4.reload();
    const { itemUrl: o7, itemControl: i6 } = t4;
    if ("admin" !== i6 && "update" !== i6) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const n6 = { messages: [], origin: "portal-item", portal: r5, url: o7 ? I(o7) : void 0, writtenProperties: [] }, a7 = this.write(void 0, n6);
    return t4.extent = await se(e2), t4.title = this.title, await t4.update({ data: a7 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    if (await this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r5 = S2.from(e2).clone();
    r5.extent ?? (r5.extent = await se(this.fullExtent)), r5.id = null, r5.portal ?? (r5.portal = C2.getDefault()), r5.title ?? (r5.title = this.title), r5.type = "Feature Collection", r5.typeKeywords = ["Data", "Feature Collection", E.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r5, i6 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const n6 = t4 == null ? void 0 : t4.folder, a7 = this.write(void 0, i6);
    return await o7.user.addItem({ item: r5, folder: n6, data: a7 }), this.portalItem = r5, i(i6), i6.portalItem = r5, r5;
  }
  async solve(e2, t4) {
    Y(this.stops), Y(this.pointBarriers), Y(this.polylineBarriers), Y(this.polygonBarriers);
    const r5 = (e2 == null ? void 0 : e2.stops) ?? this.stops, o7 = (e2 == null ? void 0 : e2.pointBarriers) ?? K(this.pointBarriers), n6 = (e2 == null ? void 0 : e2.polylineBarriers) ?? K(this.polylineBarriers), a7 = (e2 == null ? void 0 : e2.polygonBarriers) ?? K(this.polygonBarriers);
    if (null == r5) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q2(r5) || $(r5)) && r5.features.length < 2 || V.isCollection(r5) && r5.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r5)) for (const i6 of r5) i6.routeName = null;
    const l7 = e2 == null ? void 0 : e2.apiKey, { checksum: p9, url: c15 } = this, m9 = await this._getServiceDescription(c15, l7, t4), y4 = (e2 == null ? void 0 : e2.travelMode) ?? m9.defaultTravelMode, f6 = (e2 == null ? void 0 : e2.accumulateAttributes) ?? [];
    y4 && (f6.push(y4.distanceAttributeName), y4.timeAttributeName && f6.push(y4.timeAttributeName));
    const d5 = { accumulateAttributes: f6, checksum: p9, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: n6, polygonBarriers: a7, preserveObjectID: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!a7, returnPolylineBarriers: !!n6, returnRoutes: true, returnStops: true, stops: r5 }, h3 = O2.from(e2 ?? {});
    let w4;
    h3.set(d5);
    try {
      w4 = await l5(c15, h3, t4);
    } catch (S6) {
      throw b(S6) ? S6 : new s2("routelayer:failed-route-request", "the routing request failed", { error: S6 });
    }
    const g2 = this._toRouteLayerSolution(w4);
    return this._isOverridden("title") || (this.title = g2.routeInfo.name ?? "Route"), ee(g2, m9, h3), g2;
  }
  update(e2) {
    const { checksum: t4, directionLines: r5, directionPoints: o7, pointBarriers: i6, polygonBarriers: s4, polylineBarriers: n6, routeInfo: a7, stops: l7 } = e2;
    Z(l7, this.stops) ? ie(l7, this.stops) : this.set({ stops: l7 }), Z(i6, this.pointBarriers) ? te(i6, this.pointBarriers) : this.set({ pointBarriers: i6 }), Z(n6, this.polylineBarriers) ? re(n6, this.polylineBarriers) : this.set({ polylineBarriers: n6 }), Z(s4, this.polygonBarriers) ? oe(s4, this.polygonBarriers) : this.set({ polygonBarriers: s4 }), this.set({ checksum: t4 }), this._set("directionLines", r5), this._set("directionPoints", o7), this._set("routeInfo", a7), null != a7.geometry && (this.spatialReference = a7.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, s4, n6) {
    var _a;
    const a7 = H(e2) ? e2.layers : (_a = e2.featureCollection) == null ? void 0 : _a.layers, l7 = a7 == null ? void 0 : a7.find((e3) => e3.layerDefinition.name === t4);
    if (null == l7) return new V();
    const { layerDefinition: u6, popupInfo: p9, featureSet: c15 } = l7, m9 = u6.drawingInfo.renderer, { features: y4 } = c15, f6 = c15.spatialReference ?? u6.spatialReference ?? u6.extent.spatialReference ?? U, d5 = m9 && o4(m9), h3 = g.fromJSON(f6), w4 = y4.map((e3) => {
      const i6 = b4.fromJSON(e3);
      null != i6.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i6.geometry.spatialReference = h3);
      const n7 = s4(i6);
      return n7.symbol ?? (n7.symbol = (d5 == null ? void 0 : d5.getSymbol(i6)) ?? this._getNetworkSymbol(t4)), n7.popupTemplate ?? (n7.popupTemplate = p9 && q2.fromJSON(p9)), n7;
    });
    return n6 && w4.some(({ symbol: e3 }) => !e3) && n6(w4), new V(w4);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r5) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2) return this._cachedServiceDescription.serviceDescription;
    const o7 = await d4(e2, t4, r5);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e2 }, o7;
  }
  _setStopSymbol(e2) {
    if (!e2 || !e2.length || !this.defaultSymbols.stops || e2.every(({ symbol: e3 }) => !!e3)) return;
    const { first: t4, last: r5, middle: o7, unlocated: i6, waypoint: s4, break: n6 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e2.length) return void e2.forEach((i7, s5) => {
      switch (s5) {
        case 0:
          i7.symbol = t4;
          break;
        case e2.length - 1:
          i7.symbol = r5;
          break;
        default:
          i7.symbol = o7;
      }
    });
    const a7 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), l7 = Math.min(...a7), u6 = Math.max(...a7);
    for (const p9 of e2) p9.sequence !== l7 ? p9.sequence !== u6 ? "ok" === p9.status || "not-located-on-closest" === p9.status ? "waypoint" !== p9.locationType ? "break" !== p9.locationType ? p9.symbol = o7 : p9.symbol = n6 : p9.symbol = s4 : p9.symbol = i6 : p9.symbol = r5 : p9.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { checksum: t4, routeResults: r5 } = e2, o7 = (_a = r5[0].stops) == null ? void 0 : _a.map((e3) => w3.fromJSON(e3.toJSON()));
    this._setStopSymbol(o7);
    const i6 = new fe(o7), s4 = new me((_b = e2.polygonBarriers) == null ? void 0 : _b.map((e3) => {
      const t5 = T2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), n6 = new ye((_c = e2.polylineBarriers) == null ? void 0 : _c.map((e3) => {
      const t5 = j4.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), a7 = new ce((_d = e2.pointBarriers) == null ? void 0 : _d.map((e3) => {
      const t5 = T.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), l7 = (_e = r5[0].route) == null ? void 0 : _e.toJSON(), u6 = S5.fromJSON(l7);
    u6.symbol = this.defaultSymbols.routeInfo;
    const p9 = new pe((_f = r5[0].directionPoints) == null ? void 0 : _f.features.map((e3) => {
      const t5 = y3.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { checksum: t4, directionLines: new ue((_g = r5[0].directionLines) == null ? void 0 : _g.features.map((e3) => {
      const t5 = c.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: p9, pointBarriers: a7, polygonBarriers: s4, polylineBarriers: n6, routeInfo: u6, stops: i6 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", c.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", y3.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r5, o7, i6, s4) {
    if (!(e2 == null ? void 0 : e2.length)) return null;
    const n6 = this.spatialReference.toJSON(), { fullExtent: a7, maxScale: l7, minScale: u6 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => le(e3)), geometryType: r5, spatialReference: n6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : X(r5) } }, extent: a7.toJSON(), fields: o7, geometryType: r5, hasM: false, hasZ: false, maxScale: l7, minScale: u6, name: i6, objectIdField: "ObjectID", spatialReference: n6, title: s4, type: "Feature Layer", typeIdField: "" } };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", T.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T2.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j4.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S5.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    var _a, _b, _c;
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", w3.fields, "Stops", "Stops");
    if (null == e2) return null;
    const { stops: t4 } = this.defaultSymbols, r5 = (_a = t4 == null ? void 0 : t4.first) == null ? void 0 : _a.toJSON(), o7 = (_b = t4 == null ? void 0 : t4.middle) == null ? void 0 : _b.toJSON(), i6 = (_c = t4 == null ? void 0 : t4.last) == null ? void 0 : _c.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r5, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i6, label: "Last Stop" }] }, e2;
  }
};
r([m({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], we.prototype, "_featureCollection", void 0), r([r2(["web-map", "portal-item"], "_featureCollection")], we.prototype, "writeFeatureCollectionWebmap", null), r([m({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], we.prototype, "_type", void 0), r([m({ type: String })], we.prototype, "checksum", void 0), r([m({ nonNullable: true, type: d3 })], we.prototype, "defaultSymbols", void 0), r([m({ readOnly: true })], we.prototype, "directionLines", void 0), r([o3(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], we.prototype, "readDirectionLines", null), r([m({ readOnly: true })], we.prototype, "directionPoints", void 0), r([o3(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], we.prototype, "readDirectionPoints", null), r([m({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], we.prototype, "featureCollectionType", void 0), r([m({ readOnly: true })], we.prototype, "fullExtent", null), r([m({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], we.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], we.prototype, "listMode", void 0), r([m({ type: Number, nonNullable: true, json: { write: false } })], we.prototype, "maxScale", void 0), r([o3(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], we.prototype, "readMaxScale", null), r([m({ type: Number, nonNullable: true, json: { write: false } })], we.prototype, "minScale", void 0), r([o3(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], we.prototype, "readMinScale", null), r([m({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], we.prototype, "operationalLayerType", void 0), r([m({ nonNullable: true, type: V.ofType(T) })], we.prototype, "pointBarriers", void 0), r([o3(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPointBarriers", null), r([m({ nonNullable: true, type: V.ofType(T2) })], we.prototype, "polygonBarriers", void 0), r([o3(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPolygonBarriers", null), r([m({ nonNullable: true, type: V.ofType(j4) })], we.prototype, "polylineBarriers", void 0), r([o3(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPolylineBarriers", null), r([m({ readOnly: true })], we.prototype, "routeInfo", void 0), r([o3(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], we.prototype, "readRouteInfo", null), r([m({ type: g })], we.prototype, "spatialReference", void 0), r([o3(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], we.prototype, "readSpatialReference", null), r([m({ nonNullable: true, type: V.ofType(w3) })], we.prototype, "stops", void 0), r([o3(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], we.prototype, "readStops", null), r([m()], we.prototype, "title", null), r([m({ readOnly: true, json: { read: false } })], we.prototype, "type", void 0), r([m()], we.prototype, "url", null), we = r([a(de)], we);
var ge = we;
export {
  ge as default
};
//# sourceMappingURL=RouteLayer-ZD2G3LUZ.js.map
