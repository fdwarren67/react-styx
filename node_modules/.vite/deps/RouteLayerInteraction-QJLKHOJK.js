import {
  e as e3
} from "./chunk-2N7GT6QX.js";
import {
  E as E4,
  P as P2,
  r as r5
} from "./chunk-4755QEM3.js";
import {
  r as r6
} from "./chunk-GIVDDPSR.js";
import {
  r as r7
} from "./chunk-V34X57N3.js";
import {
  r as r4
} from "./chunk-ATPQ4DKO.js";
import {
  c as c3,
  l as l2,
  l2 as l3,
  r as r3
} from "./chunk-FNUMBJBP.js";
import {
  g as g2,
  g2 as g3
} from "./chunk-VVNZDHCT.js";
import {
  n as n4,
  p as p5,
  s as s5
} from "./chunk-RMJRRZ57.js";
import "./chunk-5SWTD5RQ.js";
import {
  p as p3
} from "./chunk-UP7QX3XX.js";
import "./chunk-XDIFNUKU.js";
import "./chunk-G577QQ6E.js";
import {
  r as r8
} from "./chunk-KNEUIVA5.js";
import "./chunk-3O7K7CQL.js";
import {
  r as r9
} from "./chunk-TG4CNFA5.js";
import "./chunk-TFOTFKYE.js";
import {
  E as E3,
  N,
  u as u3
} from "./chunk-3T6XYN2R.js";
import {
  E,
  E2,
  h as h5,
  p as p2
} from "./chunk-6IYG6BTI.js";
import {
  p as p4
} from "./chunk-TWM4KR2X.js";
import "./chunk-EIS6L6FC.js";
import {
  T,
  T2,
  j as j2,
  w as w2
} from "./chunk-NW57PJGO.js";
import "./chunk-OGE3WOJW.js";
import {
  f,
  j,
  l,
  v as v2
} from "./chunk-LULXSZFE.js";
import "./chunk-OITDZHA4.js";
import "./chunk-ZGGC3KHK.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-MRUZJ4BJ.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import {
  n as n3
} from "./chunk-U2GWJJ3P.js";
import {
  _
} from "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-PJIFP7OJ.js";
import "./chunk-XOXXDYBM.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-ON7GWFUW.js";
import {
  h as h2
} from "./chunk-VPRLLNNO.js";
import "./chunk-SB6LU3VH.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  K,
  L,
  O,
  Q,
  k
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import {
  m as m2
} from "./chunk-GSNLF6RP.js";
import {
  h as h4
} from "./chunk-M4LYLB6W.js";
import "./chunk-I6AFDEJM.js";
import "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import {
  x
} from "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import {
  c3 as c2,
  h as h3
} from "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import {
  y
} from "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  A,
  C,
  P,
  d as d3,
  p,
  v,
  w
} from "./chunk-UKY33OJN.js";
import {
  d as d2
} from "./chunk-HAWCNM3C.js";
import {
  V
} from "./chunk-BQYXRSVC.js";
import {
  i as i2
} from "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import {
  S
} from "./chunk-GTN3PVPB.js";
import {
  d as d4
} from "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import {
  e as e2
} from "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  s as s3,
  s2 as s4
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  c2 as c,
  d,
  e,
  h,
  i,
  r2,
  s as s2,
  u,
  u3 as u2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2
} from "./chunk-6II7WQ2F.js";
import {
  a,
  n
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshape/isSupportedObject.js
function e4(t) {
  return o(t).result;
}
function o(e6) {
  var _a;
  if (e6.graphic && "graphics" !== ((_a = e6.graphic.layer) == null ? void 0 : _a.type)) return { result: P2.GRAPHICS_LAYER_MISSING };
  if (!e6.operations) return { result: P2.GEOMETRY_MISSING };
  if (v2(e6.elevationInfo)) return { result: P2.ELEVATION_MODE_UNSUPPORTED };
  const o3 = e6.operations.data.type, i5 = e6.operations.data.geometry;
  return "point" === o3 || "mesh" === o3 || "polyline" === o3 || "polygon" === o3 ? { result: P2.SUPPORTED, geometry: i5 } : { result: P2.GEOMETRY_TYPE_UNSUPPORTED };
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transform/isSupportedGraphic.js
function r10(r11) {
  var _a;
  if ("graphics" !== ((_a = r11.layer) == null ? void 0 : _a.type)) return P2.GRAPHICS_LAYER_MISSING;
  if (null == r11.geometry) return P2.GEOMETRY_MISSING;
  switch (r11.geometry.type) {
    case "point":
      break;
    case "polygon":
    case "polyline":
    case "multipoint":
    case "extent":
    case "mesh":
      return P2.SUPPORTED;
    default:
      return P2.GEOMETRY_TYPE_UNSUPPORTED;
  }
  const s6 = null != r11.symbol && "point-3d" === r11.symbol.type && r11.symbol.symbolLayers;
  if (!s6 || !s6.some((e6) => "object" === e6.type)) return P2.SYMBOL_TYPE_UNSUPPORTED;
  return "on-the-ground" !== l(r11) && f(r11) ? P2.ELEVATION_MODE_UNSUPPORTED : P2.SUPPORTED;
}

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingLayerSource.js
var i3 = class extends g {
  constructor(o3) {
    super(o3), this.layer = null, this.enabled = true, this.updating = false, this.availability = 1, this.sublayerSources = new V();
  }
};
r([m({ constructOnly: true })], i3.prototype, "layer", void 0), r([m()], i3.prototype, "enabled", void 0), r([m()], i3.prototype, "updating", void 0), r([m()], i3.prototype, "availability", void 0), r([m()], i3.prototype, "sublayerSources", void 0), i3 = r([a2("esri.views.interactive.snapping.FeatureSnappingLayerSource")], i3);
var p6 = i3;

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOptions.js
var u4 = class extends g {
  constructor(e6) {
    super(e6), this.enabled = false, this.enabledToggled = false, this.forceDisabled = false, this.selfEnabled = true, this.featureEnabled = true, this.gridEnabled = false, this.attributeRulesEnabled = false, this.featureSources = new V(), this.distance = p3.distance, this.touchSensitivityMultiplier = p3.touchSensitivityMultiplier;
  }
  get effectiveEnabled() {
    return !this.forceDisabled && (this.enabledToggled ? !this.enabled : this.enabled);
  }
  get effectiveGridEnabled() {
    return this.effectiveEnabled && this.gridEnabled;
  }
  get effectiveSelfEnabled() {
    return this.effectiveEnabled && this.selfEnabled;
  }
  get effectiveFeatureEnabled() {
    return this.effectiveEnabled && this.featureEnabled;
  }
  get _effectiveFeatureSources() {
    var _a;
    const e6 = this.featureSources;
    e6.some(p7) && n2.getLogger(this).warnOnce("Do not configure SubtypeGroupLayer sources in SnappingOptions.featureSources directly. Create a FeatureSnappingLayerSource for each SubtypeSublayer.");
    const t = e6.filter(f2), s6 = ((_a = this._get("_effectiveFeatureSources")) == null ? void 0 : _a.filter(p7)) ?? new V();
    for (const r11 of t) {
      const e7 = s6.find((e8) => e8.layer === r11.layer.parent);
      if (e7) e7.sublayerSources.includes(r11) || e7.sublayerSources.add(r11);
      else if (r11.layer.parent) {
        const e8 = new p6({ layer: r11.layer.parent });
        e8.sublayerSources.add(r11), s6.add(e8);
      }
    }
    for (const r11 of s6) {
      const e7 = r11.sublayerSources.filter((e8) => !t.includes(e8));
      r11.sublayerSources.removeMany(e7);
    }
    s6.removeMany(s6.filter((e7) => 0 === e7.sublayerSources.length));
    const a3 = e6.filter(d5), l4 = this._get("_effectiveFeatureSources") ?? new V(), { added: u6, removed: c5 } = a(l4.toArray(), [...a3, ...s6]);
    return l4.removeMany(c5), l4.addMany(u6), l4;
  }
};
r([m()], u4.prototype, "enabled", void 0), r([m()], u4.prototype, "enabledToggled", void 0), r([m()], u4.prototype, "forceDisabled", void 0), r([m()], u4.prototype, "selfEnabled", void 0), r([m()], u4.prototype, "featureEnabled", void 0), r([m()], u4.prototype, "gridEnabled", void 0), r([m()], u4.prototype, "attributeRulesEnabled", void 0), r([m({ type: V.ofType(p6) })], u4.prototype, "featureSources", void 0), r([m()], u4.prototype, "distance", void 0), r([m()], u4.prototype, "touchSensitivityMultiplier", void 0), r([m({ readOnly: true })], u4.prototype, "effectiveEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveGridEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveSelfEnabled", null), r([m({ readOnly: true })], u4.prototype, "effectiveFeatureEnabled", null), r([m({ readOnly: true })], u4.prototype, "_effectiveFeatureSources", null), u4 = r([a2("esri.views.interactive.snapping.SnappingOptions")], u4);
var c4 = u4;
function p7(e6) {
  return "subtype-group" === e6.layer.type;
}
function d5(e6) {
  return "subtype-group" !== e6.layer.type;
}
function f2(e6) {
  return "subtype-sublayer" === e6.layer.type;
}

// node_modules/@arcgis/core/views/interactive/snapping/SnappingManager.js
var I = class extends i2.EventedMixin(g) {
  constructor(e6) {
    super(e6), this.options = new c4(), this._engineCache = /* @__PURE__ */ new Map(), this._loadTask = null, this._engines = [], this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = x2.MAIN;
  }
  initialize() {
    this.addHandles([d3(() => {
      const { distance: e6, touchSensitivityMultiplier: t, effectiveSelfEnabled: n7, effectiveFeatureEnabled: i5, effectiveGridEnabled: s6 } = this.options;
      return { selfEnabled: n7, featureEnabled: i5, gridEnabled: "2d" === this.view.type && s6, viewReady: this.view.ready, viewSpatialReference: this.view.spatialReference, distance: e6, touchSensitivityMultiplier: t };
    }, (e6, t) => {
      var _a;
      t && (this.doneSnapping(), this.emit("changed")), (_a = this._loadTask) == null ? void 0 : _a.abort(), this._loadTask = d2((n7) => this._updateEngines(e6, t, n7));
    }, A), d3(() => this.options, (e6) => {
      for (const t of this._engines) t.options = e6;
    }, C)]);
  }
  destroy() {
    var _a;
    (_a = this._loadTask) == null ? void 0 : _a.abort(), this._destroyEngines();
  }
  get updating() {
    var _a;
    return this._engines.some((e6) => e6.updating) || !((_a = this._loadTask) == null ? void 0 : _a.finished);
  }
  _destroyEngines() {
    this._engineCache.forEach((e6) => e6.destroy()), this._engineCache.clear(), this._engines = [];
  }
  async _updateEngines(e6, t, n7) {
    var _a;
    if (!e6.viewReady) return void this._destroyEngines();
    (t == null ? void 0 : t.viewSpatialReference) !== e6.viewSpatialReference && this._destroyEngines();
    const i5 = this._engineCache, s6 = await Promise.allSettled([e6.featureEnabled && !i5.has("feature") ? this._createFeatureSnappingEngine(n7) : void 0, e6.selfEnabled && !i5.has("self") ? this._createSelfSnappingEngine(n7) : void 0, e6.gridEnabled && !i5.has("grid") ? this._createGridSnappingEngine(n7) : void 0]);
    if (n7.aborted) for (const a3 of s6) "fulfilled" === a3.status && ((_a = a3.value) == null ? void 0 : _a.engine.destroy());
    else {
      for (const e7 of s6) "fulfilled" === e7.status && e7.value && i5.set(e7.value.type, e7.value.engine);
      this._engines = Array.from(i5.values());
    }
  }
  async _createSelfSnappingEngine(e6) {
    const { SelfSnappingEngine: t } = await import("./SelfSnappingEngine-QVB6RR67.js");
    return s2(e6), { type: "self", engine: new t({ view: this.view, options: this.options }) };
  }
  async _createGridSnappingEngine(e6) {
    const { view: t } = this;
    if ("2d" !== t.type) return;
    const { GridSnappingEngine: n7 } = await import("./GridSnappingEngine-ICKQCAVM.js");
    return s2(e6), { type: "grid", engine: new n7({ view: t, options: this.options }) };
  }
  async _createFeatureSnappingEngine(e6) {
    const { FeatureSnappingEngine: t } = await import("./FeatureSnappingEngine-LR4OESIG.js");
    s2(e6);
    const { view: n7, options: i5 } = this, { spatialReference: a3 } = n7;
    return { type: "feature", engine: new t({ view: n7, options: i5, spatialReference: a3 }) };
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: e6, touchSensitivityMultiplier: t } = this.options, n7 = e6 * t;
    return n7 * n7;
  }
  snap(e6) {
    return H(e6) ? this._snapMultiPoint(e6) : this._snapSinglePoint(e6);
  }
  update(e6) {
    const { point: t, context: n7 } = e6;
    this._removeVisualization();
    const i5 = this._currentMainCandidate;
    if (null == i5) return t;
    const s6 = this._selectUpdateInput(e6);
    if (null == s6) return t;
    const { spatialReference: a3 } = n7, r11 = O(s6, a3);
    if (null == r11) return t;
    const { view: o3 } = this, { elevationInfo: p9, visualizer: d6 } = n7, c5 = [], l4 = E(r11, o3, p9), u6 = i5.constraint.closestTo(l4);
    if (!this._arePointsWithinScreenThreshold(l4, u6, n7) || !N2(i5, n7.drawConstraints)) return this._resetSnappingState(), t;
    i5.targetPoint = p2(u6), c5.push(...i5.hints);
    for (const h6 of this._currentOtherActiveCandidates) N2(h6, n7.drawConstraints) && (h6.targetPoint = p2(u6), c5.push(...h6.hints));
    return null != d6 && this.addHandles(d6.draw(c5, { spatialReference: a3, elevationInfo: L2(n7), view: o3, selfSnappingZ: n7.selfSnappingZ }), b), h5(u6, o3, t, n7);
  }
  doneSnapping() {
    this._removeVisualization(), this._resetSnappingState();
  }
  _selectUpdateInput({ point: e6, scenePoint: t }) {
    switch (this._currentSnappedType) {
      case x2.MAIN:
        return e6;
      case x2.SCENE:
        return t;
    }
  }
  _resetSnappingState() {
    this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = x2.MAIN;
  }
  _removeVisualization() {
    this.removeHandles(b);
  }
  async _snapSinglePoint({ point: e6, context: t, signal: n7 }) {
    const { view: i5 } = this, { elevationInfo: s6 } = t, a3 = E(e6, i5, s6), r11 = await this._fetchCandidates(a3, E2.ALL, t, n7);
    return this._createSnapResult(a3, x2.MAIN, r11, i5, e6, t, n7);
  }
  async _snapMultiPoint({ point: e6, scenePoint: t, context: n7, signal: i5 }) {
    const { view: s6 } = this, { coordinateHelper: a3, elevationInfo: r11, spatialReference: o3 } = n7;
    await Q(t.spatialReference, o3);
    const p9 = O(t, o3), d6 = E(p9, s6, r11), c5 = await this._fetchCandidates(d6, E2.FEATURE, n7, i5);
    if (c5.length > 0) {
      const e7 = await this._fetchCandidates(d6, E2.SELF, n7, i5);
      return this._createSnapResult(d6, x2.SCENE, [...c5, ...e7], s6, p9, n7, i5);
    }
    const u6 = E(e6, s6, r11), g5 = await this._fetchCandidates(u6, E2.SELF, n7, i5);
    return this._createSnapResult(u6, x2.MAIN, g5, s6, { z: a3.hasZ() && e6.hasZ ? e6.z ?? 0 : void 0, m: a3.hasM() && e6.hasM ? e6.m ?? 0 : void 0 }, n7, i5);
  }
  async _fetchCandidates(e6, t, n7, i5) {
    return (await Promise.all(this._engines.map((s6) => s6.fetchCandidates(e6, t, n7, i5)))).flat();
  }
  _createSnapResult(e6, t, n7, i5, s6, r11, o3) {
    return { get valid() {
      return !c(o3);
    }, apply: () => {
      const { spatialReference: a3 } = r11, { snappedPoint: o4, hints: p9 } = this._processCandidates(e6, t, n7, r11);
      return this._removeVisualization(), null != r11.visualizer && this.addHandles(r11.visualizer.draw(p9, { spatialReference: a3, elevationInfo: j, view: i5, selfSnappingZ: r11.selfSnappingZ }), b), h5(o4, i5, s6, r11);
    } };
  }
  _processCandidates(e6, t, n7, i5) {
    if (n7.length < 1) return this.doneSnapping(), { snappedPoint: e6, hints: [] };
    this._currentSnappedType !== t && this._resetSnappingState(), E3(e6, n7);
    const s6 = this._currentMainCandidate;
    if (null != s6) {
      const a3 = O2(s6, n7);
      if (a3 >= 0) {
        if (!(n7[a3] instanceof r8)) return this._intersectWithOtherCandidates(a3, n7, e6, t, i5);
        if (this._arePointsWithinScreenThreshold(e6, s6.targetPoint, i5)) return this._updateSnappingCandidate(s6, t, n7, i5);
      }
    }
    return this._intersectWithOtherCandidates(0, n7, e6, t, i5);
  }
  _intersectWithOtherCandidates(e6, t, n7, i5, s6) {
    const { coordinateHelper: a3 } = s6, r11 = t[e6], o3 = [];
    for (let p9 = 0; p9 < t.length; ++p9) {
      if (p9 === e6) continue;
      const i6 = t[p9], s7 = r11.constraint.intersect(i6.constraint);
      if (s7) for (const e7 of s7.closestPoints(r11.targetPoint)) o3.push([new r8(p2(e7), r11, i6, i6.isDraped), this._squaredScreenDistance(n7, e7, a3)]);
    }
    return o3.length > 0 && (o3.sort((e7, t2) => e7[1] - t2[1]), o3[0][1] < this._squaredPointProximityThreshold(s6.pointer)) ? this._updateSnappingCandidate(o3[0][0], i5, t, s6) : N2(r11, s6.drawConstraints) ? this._updateSnappingCandidate(r11, i5, t, s6) : { snappedPoint: n7, hints: [] };
  }
  _updateSnappingCandidate(e6, t, n7, i5) {
    this.doneSnapping(), this._currentMainCandidate = e6, this._currentSnappedType = t;
    const s6 = this._currentMainCandidate.targetPoint, a3 = [];
    a3.push(...e6.hints);
    for (const r11 of n7) {
      if (e6 instanceof r8) {
        if (r11.constraint.equals(e6.first.constraint) || r11.constraint.equals(e6.second.constraint)) continue;
      } else if (r11.constraint.equals(e6.constraint)) continue;
      const t2 = r11.constraint.closestTo(s6);
      this._squaredScreenDistance(t2, s6, i5.coordinateHelper) < z() && (r11.targetPoint = s6, this._currentOtherActiveCandidates.push(r11), a3.push(...r11.hints));
    }
    return { snappedPoint: s6, hints: a3 };
  }
  _squaredPointProximityThreshold(e6) {
    return "touch" === e6 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  _arePointsWithinScreenThreshold(e6, t, n7) {
    return this._squaredScreenDistance(e6, t, n7.coordinateHelper) < this._squaredPointProximityThreshold(n7.pointer);
  }
  _squaredScreenDistance(e6, t, n7) {
    return u3(this._toScreen(e6, n7), this._toScreen(t, n7));
  }
  _toScreen(e6, t) {
    return s5(e6, t.spatialReference, j, this.view);
  }
  get test() {
  }
};
var x2;
r([m({ constructOnly: true })], I.prototype, "view", void 0), r([m()], I.prototype, "options", void 0), r([m({ readOnly: true })], I.prototype, "updating", null), r([m()], I.prototype, "_loadTask", void 0), r([m()], I.prototype, "_engines", void 0), r([m()], I.prototype, "_squaredMouseProximityThreshold", null), r([m()], I.prototype, "_squaredTouchProximityThreshold", null), I = r([a2("esri.views.interactive.snapping.SnappingManager")], I), function(e6) {
  e6[e6.MAIN = 0] = "MAIN", e6[e6.SCENE = 1] = "SCENE";
}(x2 || (x2 = {}));
var b = "visualization-handle";
function z() {
  return p3.satisfiesConstraintScreenThreshold * p3.satisfiesConstraintScreenThreshold;
}
function N2(e6, t) {
  return !t || null == t.direction && null == t.distance || !(e6 instanceof r6 || e6 instanceof r7 || e6 instanceof r9 || e6 instanceof g2 || e6 instanceof g3) && (!(e6 instanceof n4) || null == t.direction && e6.selfSnappingType === p5.LastVertex);
}
function O2(e6, t) {
  return e6 instanceof r8 ? k2(t, e6.first) >= 0 && k2(t, e6.second) >= 0 ? 0 : -1 : k2(t, e6);
}
function k2(e6, t) {
  let n7 = -1;
  for (let i5 = 0; i5 < e6.length; ++i5) if (t.constraint.equals(e6[i5].constraint)) {
    n7 = i5;
    break;
  }
  return n7;
}
function H(e6) {
  return null != e6.scenePoint;
}
function L2({ coordinateHelper: e6, elevationInfo: t }) {
  return e6.hasZ() ? j : t;
}

// node_modules/@arcgis/core/widgets/Sketch/support/OperationHandle.js
var n5 = class extends i2.EventedAccessor {
  constructor(e6) {
    super(e6), this.cancelled = false, this.history = { undo: [], redo: [] }, this.type = null;
  }
  get tool() {
    if (!this.activeComponent) return null;
    switch (this.activeComponent.type) {
      case "graphic-mover":
      case "move-3d":
        return "move";
      case "box":
      case "transform-3d":
        return "transform";
      case "reshape":
      case "reshape-3d":
        return "reshape";
      case "draw-2d":
      case "draw-3d":
        return this.activeComponent.geometryType;
      default:
        n(this.activeComponent);
    }
    return null;
  }
  addToHistory(e6) {
    this.history.redo = [], this.history.undo.push(e6);
  }
  resetHistory() {
    this.history.redo = [], this.history.undo = [];
  }
  canUndo() {
    return this.history.undo.length > 0;
  }
  canRedo() {
    return this.history.redo.length > 0;
  }
  complete() {
    this._reset(), this.onEnd(), this.emit("complete");
  }
  cancel() {
    this.cancelled = true, this.complete();
  }
  _reset() {
    var _a;
    (_a = this.activeComponent) == null ? void 0 : _a.reset();
  }
  refreshComponent() {
    const e6 = this.activeComponent;
    e6 && ("box" !== e6.type && "reshape" !== e6.type && "graphic-mover" !== e6.type || e6.refresh());
  }
  set undo(e6) {
    this._set("undo", () => {
      this.canUndo() && e6();
    });
  }
  set redo(e6) {
    this._set("redo", () => {
      this.canRedo() && e6();
    });
  }
};
r([m()], n5.prototype, "activeComponent", void 0), r([m()], n5.prototype, "cancelled", void 0), r([m()], n5.prototype, "history", void 0), r([m()], n5.prototype, "tool", null), r([m()], n5.prototype, "type", void 0), r([m()], n5.prototype, "canUndo", null), r([m()], n5.prototype, "canRedo", null), r([m()], n5.prototype, "onEnd", void 0), r([m()], n5.prototype, "undo", null), r([m()], n5.prototype, "redo", null), r([m()], n5.prototype, "toggleTool", void 0), r([m()], n5.prototype, "addToSelection", void 0), r([m()], n5.prototype, "removeFromSelection", void 0), n5 = r([a2("esri.widgets.Sketch.support.OperationHandle")], n5);
var p8 = class extends n5 {
};
r([m()], p8.prototype, "activeComponent", void 0), p8 = r([a2("esri.widgets.Sketch.support.OperationHandle.CreateOperationHandle")], p8);
var i4 = class extends n5 {
};
r([m()], i4.prototype, "activeComponent", void 0), i4 = r([a2("esri.widgets.Sketch.support.OperationHandle.UpdateOperationHandle")], i4);

// node_modules/@arcgis/core/widgets/Sketch/support/sketchUtils.js
function e5(e6, n7) {
  if ("freehandPolygon" === n7 || "freehandPolyline" === n7) return "freehand";
  return e6 ?? ("rectangle" === n7 || "circle" === n7 ? "hybrid" : "click");
}
function n6(e6) {
  switch (e6) {
    case "freehandPolygon":
      return "polygon";
    case "freehandPolyline":
      return "polyline";
    default:
      return e6;
  }
}
var o2;
!function(e6) {
  e6[e6.ForceCollapse = -1] = "ForceCollapse", e6[e6.Low = 0] = "Low", e6[e6.Medium = 10] = "Medium", e6[e6.High = 100] = "High", e6[e6.Max = 1e3] = "Max";
}(o2 || (o2 = {}));

// node_modules/@arcgis/core/widgets/Sketch/SketchViewModel.js
var te = { defaultZ: 0 };
var oe = { reshapeOptions: { edgeOperation: "split", shapeOperation: "move", vertexOperation: "move" }, enableMoveAllGraphics: true, enableRotation: true, enableScaling: true, multipleSelectionEnabled: true, preserveAspectRatio: false, toggleToolOnClick: true, enableZ: true, highlightOptions: { enabled: true }, tool: "transform" };
var ie = class extends i2.EventedAccessor {
  constructor(e6) {
    var _a;
    super(e6), this._defaultSnappingManager = null, this._updatingHandles = new h2(), this._internalGraphicsLayer = new h4({ listMode: "hide", internal: true, title: "SVM Internal" }), this._operationHandle = null, this._viewHandlesKey = "viewHandles", this.activeFillSymbol = null, this.activeLineSymbol = null, this.activeVertexSymbol = null, this.allowDeleteKey = true, this.layer = null, this.pointSymbol = new y({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.polygonSymbol = new S({ color: [150, 150, 150, 0.2], outline: { color: [50, 50, 50], width: 2 } }), this.polylineSymbol = new d4({ color: [130, 130, 130, 1], width: 2 }), this.meshSymbol = new c2({ symbolLayers: new V([new h3()]) }), this.updateGraphics = new V(), this.updateOnGraphicClick = true, this.creationMode = "single", this.vertexSymbol = new y({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.sketchOptions = new l3(), this._moduleLoaderAbortController = null, this._viewReadyAbortController = null, this._sketchContinuationFlag = false, this._originalPopupEnabled = null, this.defaultCreateOptions = te, this.defaultUpdateOptions = oe, this.snappingOptions = ((_a = e6 == null ? void 0 : e6.snappingManager) == null ? void 0 : _a.options) ?? (e6 == null ? void 0 : e6.snappingOptions) ?? new c4();
  }
  initialize() {
    this.addHandles([v(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.layers;
    }, "change", (e6) => {
      e6.removed.includes(this.layer) && this.cancel();
    }), v(() => {
      var _a;
      return (_a = this.layer) == null ? void 0 : _a.graphics;
    }, "change", (e6) => {
      if (null != this._operationHandle) for (const t of e6.removed) this.updateGraphics.includes(t) && (this.updateGraphics.length > 1 ? this._operationHandle.removeFromSelection(t) : this._operationHandle.cancel());
    }), d3(() => {
      var _a;
      return ((_a = this.layer) == null ? void 0 : _a.elevationInfo) ?? null;
    }, (e6) => {
      e6 !== this._internalGraphicsLayer.elevationInfo && (this.cancel(), this._internalGraphicsLayer.elevationInfo = e6);
    }, A), d3(() => this.view, (e6) => {
      this._defaultSnappingManager = u(this._defaultSnappingManager), e6 && (this.snappingManager || (this._defaultSnappingManager = new I({ view: e6, options: this.snappingOptions })), "2d" === e6.type ? import("./editingTools-ERE2A6AU.js") : "3d" === e6.type && (import("./editingTools-LV3DVN2W.js"), import("./GraphicsLayerView3D-SZTGYXOQ.js")));
    }, A), d3(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.spatialReference;
    }, (e6, t) => {
      e6 && t && !e6.equals(t) && this.cancel();
    })]), N(this);
  }
  destroy() {
    this.cancel(), this._removeDefaultLayer(), this._defaultSnappingManager = u(this._defaultSnappingManager), this._set("snappingManager", null), this._set("view", null), this._updatingHandles.destroy(), this.emit("destroy");
  }
  get updating() {
    return this._updatingHandles.updating || null != this.snappingManager && this.snappingManager.updating;
  }
  get activeTool() {
    var _a;
    return ((_a = this._operationHandle) == null ? void 0 : _a.tool) ?? null;
  }
  get activeCreateToolDrawMode() {
    var _a;
    return "create" === ((_a = this._operationHandle) == null ? void 0 : _a.type) && this._operationHandle.activeComponent && "mode" in this._operationHandle.activeComponent ? this._operationHandle.activeComponent.mode : null;
  }
  get activeTooltip() {
    const { activeComponent: e6, destroyed: t } = this, o3 = !t && e6 && "tooltip" in e6 ? e6.tooltip : null;
    return (o3 == null ? void 0 : o3.visible) ? o3 : null;
  }
  get activeComponent() {
    var _a;
    return ((_a = this._operationHandle) == null ? void 0 : _a.activeComponent) ?? null;
  }
  get createGraphic() {
    return null == this.activeComponent || "draw-3d" !== this.activeComponent.type && "draw-2d" !== this.activeComponent.type ? this._get("createGraphic") : this.activeComponent.graphic;
  }
  get defaultCreateOptions() {
    return this._get("defaultCreateOptions");
  }
  set defaultCreateOptions(e6) {
    this._set("defaultCreateOptions", { ...te, ...e6 });
  }
  get defaultUpdateOptions() {
    return this._get("defaultUpdateOptions");
  }
  set defaultUpdateOptions(e6) {
    this._set("defaultUpdateOptions", { ...oe, ...e6, reshapeOptions: { ...oe.reshapeOptions, ...e6 == null ? void 0 : e6.reshapeOptions }, highlightOptions: { ...oe.highlightOptions, ...e6 == null ? void 0 : e6.highlightOptions } });
  }
  get labelOptions() {
    return this.sketchOptions.labels;
  }
  set labelOptions(e6) {
    this.sketchOptions.labels = e6;
  }
  get snappingOptions() {
    var _a;
    return ((_a = this.snappingManager) == null ? void 0 : _a.options) ?? this._get("snappingOptions");
  }
  set snappingOptions(e6) {
    null != this._defaultSnappingManager && (this._defaultSnappingManager.options = e6), this._set("snappingOptions", e6);
  }
  get snappingManager() {
    return this._isOverridden("snappingManager") && this._get("snappingManager"), this._defaultSnappingManager;
  }
  set snappingManager(e6) {
    if (e6) this._isOverridden("snappingManager") || (this._defaultSnappingManager = u(this._defaultSnappingManager)), this._override("snappingManager", e6);
    else {
      const { view: e7 } = this;
      !this._defaultSnappingManager && e7 && (this._defaultSnappingManager = new I({ options: this.snappingOptions, view: e7 })), this._clearOverride("snappingManager");
    }
  }
  get state() {
    var _a;
    const e6 = !(!((_a = this.view) == null ? void 0 : _a.ready) || !this.layer), t = this._operationHandle;
    return e6 && t ? "active" : e6 ? "ready" : "disabled";
  }
  get tooltipOptions() {
    return this.sketchOptions.tooltips;
  }
  set tooltipOptions(e6) {
    this.sketchOptions.tooltips = e6;
  }
  get valueOptions() {
    return this.sketchOptions.values;
  }
  set valueOptions(e6) {
    this.sketchOptions.values = e6;
  }
  get view() {
    return this._get("view");
  }
  set view(e6) {
    const t = this._get("view");
    if (t) {
      const { container: e7, map: o4 } = t;
      e7 && (t.cursor = null), o4 == null ? void 0 : o4.remove(this._internalGraphicsLayer), this.removeHandles(this._viewHandlesKey), this.cancel();
    }
    const o3 = "view-ready";
    this.removeHandles(o3), e6 && this.addHandles(p(() => e6.ready, (t2) => {
      this.removeHandles(this._viewHandlesKey), t2 && this.addHandles(this._generateViewHandles(e6), this._viewHandlesKey);
    }, A), o3), this._set("view", e6);
  }
  cancel() {
    this._moduleLoaderAbortController = e(this._moduleLoaderAbortController), this._viewReadyAbortController = e(this._viewReadyAbortController), this._sketchContinuationFlag = true, this._operationHandle && this._operationHandle.cancel();
  }
  complete() {
    this._operationHandle && this._operationHandle.complete();
  }
  delete() {
    const { state: e6, updateGraphics: t } = this;
    if ("active" === e6 && t.length) {
      const { activeTool: e7, layer: o3 } = this, i5 = t.toArray();
      o3.removeMany(i5), this.cancel(), this._emitDeleteEvent({ graphics: i5, tool: e7 });
    }
  }
  duplicate() {
    if ("active" === this.state && this.updateGraphics.length) {
      const e6 = this.updateGraphics.map((e7) => e7.clone()).toArray();
      return this.layer.addMany(e6), this.emit("duplicate", { graphics: e6, type: "duplicate" }), e6;
    }
    return [];
  }
  async create(e6, t) {
    this.cancel(), await this._waitViewReady();
    const { view: o3, layer: i5 } = this;
    if (!o3 || "disabled" === this.state) throw i5 || this._logMissingLayer(), u2();
    if (null != o3.activeTool && (o3.activeTool = null), !e6) return void this._logError("sketch:missing-parameter", "Missing parameter 'tool'.");
    e3(o3, this._internalGraphicsLayer);
    const a3 = await this._updatingHandles.addPromise(this._setupCreateOperation(e6, t));
    if (null == a3 || this.destroyed) return void o3.map.remove(this._internalGraphicsLayer);
    const s6 = () => {
      var _a;
      if (a3 === this._operationHandle) {
        const o4 = this.createGraphic, s7 = this._operationHandle.cancelled;
        if (this._operationHandle.destroy(), this._operationHandle = null, this._set("createGraphic", null), ((_a = this.view) == null ? void 0 : _a.map) && this.view.map.remove(this._internalGraphicsLayer), a3.cancelled || null == o4 || i5.add(o4), this._sketchContinuationFlag = false, this.emit("create", { graphic: o4, state: s7 ? "cancel" : "complete", tool: e6, toolEventInfo: null, type: "create" }), s7 || this._sketchContinuationFlag) return;
        const { creationMode: r11 } = this;
        if ("continuous" === r11) {
          if (t == null ? void 0 : t.geometryToPlace) return;
          this._updatingHandles.addPromise(d(this.create(e6, t)));
        } else "update" === r11 && o4 && this._updatingHandles.addPromise(d(this.update([o4])));
      }
    };
    a3.on("complete", s6), this._operationHandle = a3, o3.ready && o3.focus();
  }
  async place(e6, t) {
    return this.create("mesh", { mode: "click", hasZ: e6.hasZ, geometryToPlace: e6, ...t });
  }
  async update(e6, t) {
    this.cancel(), await this._waitViewReady();
    const { layer: o3, view: i5, state: a3 } = this;
    if (!i5 || "disabled" === a3) throw o3 || this._logMissingLayer(), u2();
    null != i5.activeTool && (i5.activeTool = null);
    const s6 = Array.isArray(e6) ? e6 : [e6];
    if (null == e6 || !(s6 == null ? void 0 : s6.length)) return void this._logError("sketch:missing-parameter", "Missing parameter 'graphics'.");
    if (s6.some((e7) => e7.layer !== o3 ? (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics missing from the supplied GraphicsLayer."), true) : null == e7.geometry && (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics with an unsupported geometry."), true))) return;
    const r11 = await this._updatingHandles.addPromise(this._setupUpdateOperation(s6, t));
    this.destroyed || null == r11 || ue(r11) || (e3(i5, this._internalGraphicsLayer), this._setUpdateOperationHandle(r11, t), this.emit("update", { graphics: s6, state: "start", aborted: false, tool: r11.tool, toolEventInfo: null, type: "update" }));
  }
  async _updateSpatialReference(e6) {
    const t = this.view;
    if (t) {
      e6 = Array.isArray(e6) ? e6 : [e6];
      for (const o3 of e6) null == o3.geometry || "mesh" === o3.geometry.type || s3(o3.geometry.spatialReference, t.spatialReference) || (L(o3.geometry.spatialReference, t.spatialReference) || k() || await K(), o3.geometry = O(o3.geometry, t.spatialReference));
    } else this._logMissingView();
  }
  undo() {
    var _a;
    this.canUndo() && ((_a = this._operationHandle) == null ? void 0 : _a.undo());
  }
  redo() {
    var _a;
    this.canRedo() && ((_a = this._operationHandle) == null ? void 0 : _a.redo());
  }
  canUndo() {
    var _a;
    return !!((_a = this._operationHandle) == null ? void 0 : _a.canUndo());
  }
  canRedo() {
    var _a;
    return !!((_a = this._operationHandle) == null ? void 0 : _a.canRedo());
  }
  toggleUpdateTool() {
    var _a;
    (_a = this._operationHandle) == null ? void 0 : _a.toggleTool();
  }
  async _getFirstHit(e6) {
    const t = this.view;
    if (!t) return this._logMissingView(), null;
    if ("2d" === t.type) {
      const o4 = [];
      t.map.allLayers.forEach((e7) => {
        "vector-tile" !== e7.type && "imagery" !== e7.type || o4.push(e7);
      });
      const i6 = await t.hitTest(e6, { exclude: o4 });
      return r4(i6.results);
    }
    const o3 = [t.map.ground];
    t.map.allLayers.forEach((e7) => {
      m2(e7.type) && o3.push(e7);
    });
    const i5 = await t.hitTest(e6, { exclude: o3 });
    if (i5.results.length > 0) {
      const e7 = i5.results[0];
      if (null != e7 && "graphic" === e7.type && e7.graphic && (!i5.ground.mapPoint || t.map.ground.opacity < 1 || i5.ground.distance - (e7.distance ?? 0) > -Math.min(3 * i5.ground.distance, "global" === t.viewingMode ? s4(t.renderCoordsHelper.spatialReference).radius / t.renderCoordsHelper.unitInMeters : Number.POSITIVE_INFINITY))) return e7;
    }
    return null;
  }
  _generateViewHandles(e6) {
    return [e6.on("immediate-click", async (e7) => {
      var _a;
      const t = "active" === this.state && "create" === ((_a = this._operationHandle) == null ? void 0 : _a.type);
      "disabled" !== this.state && !t && this.updateOnGraphicClick && await this._updatingHandles.addPromise(this._handleImmediateClick(e7));
    }, _.WIDGET)];
  }
  async _handleImmediateClick(e6) {
    var _a;
    const t = await e6.async(() => this._getFirstHit(n3(e6)));
    let o3 = null;
    if (null != t) {
      const i5 = t.graphic;
      this.updateGraphics.includes(i5) || i5.layer === this.layer ? (e6.stopPropagation(), o3 = i5) : "2d" !== ((_a = this.view) == null ? void 0 : _a.type) || this._isComponentGraphic(i5) || "active" !== this.state || this.cancel();
    } else "active" === this.state && this.cancel();
    null == o3 || this.updateGraphics.includes(o3) || await this.update([o3], { ...this.defaultUpdateOptions, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions } });
  }
  async _setupCreateOperation(e6, t) {
    const o3 = this.view;
    if (!o3) return this._logMissingView(), null;
    const i5 = { hasZ: "3d" === o3.type, ...this.defaultCreateOptions, ...t }, a3 = await this._setupDrawGraphicTool(e6, o3, i5);
    return null == a3 ? null : (o3.tools.add(a3), o3.activeTool = a3, this._setupCreateOperationHandle(a3));
  }
  async _setupDrawGraphicTool(e6, t, o3) {
    var _a;
    if ("multipoint" === e6 && "3d" === t.type) return this._logError("sketch:create", "Multipoint geometries are not supported in SceneView."), null;
    if (!t) return this._logMissingView(), null;
    const { cursor: i5, defaultZ: a3, hasZ: s6, geometryToPlace: r11, graphicProperties: n7, mode: p9, preserveAspectRatio: l4 } = o3, h6 = e5(p9, e6), c5 = n6(e6), d6 = ((_a = o3 == null ? void 0 : o3.optionsPerTool) == null ? void 0 : _a.has(e6)) ? o3.optionsPerTool.get(e6) : {}, u6 = (d6 == null ? void 0 : d6.preserveAspectRatio) ?? l4 ?? "rectangle" !== e6, y2 = { centered: "rectangle" !== e6 && !("circle" === e6 && !u6), cursor: i5, defaultZ: a3, forceUniformSize: u6, graphicProperties: { ...n7, attributes: { ...n7 == null ? void 0 : n7.attributes } }, geometryToPlace: r11, geometryType: c5, mode: h6, graphicSymbol: this._getGraphicSymbolFromTool(e6), hasZ: s6, snappingManager: this.snappingManager, snapToScene: false, view: t, ...d6 };
    return "2d" === t.type ? this._makeDrawGraphicTool2D(y2) : this._makeDrawGraphicTool3D(y2);
  }
  async _makeDrawGraphicTool2D(e6) {
    const t = await this._requireModule(import("./editingTools-ERE2A6AU.js"));
    return ue(t) || this.destroyed ? null : new t.module.DrawGraphicTool2D({ ...e6, activeVertexSymbol: this.activeVertexSymbol, regularVerticesSymbol: this.vertexSymbol, activeLineSymbol: this.activeLineSymbol, activeFillSymbol: re(e6.geometryType) ? this.activeFillSymbol : null, sketchOptions: this.sketchOptions });
  }
  async _makeDrawGraphicTool3D(e6) {
    const t = await this._requireModule(import("./editingTools-LV3DVN2W.js"));
    if (ue(t) || this.destroyed) return null;
    const { elevationInfo: o3 } = this.layer;
    return new t.module.DrawGraphicTool3D({ ...e6, elevationInfo: o3, snapToScene: true, sketchOptions: this.sketchOptions });
  }
  _setupCreateOperationHandle(e6) {
    const t = this.view;
    if (!t) return this._logMissingView(), null;
    let o3 = null;
    const i5 = e6.forceUniformSize, s6 = e6.centered, r11 = [t.on("key-down", (t2) => {
      if (t2.key === p4.pan) t2.stopPropagation(), t2.repeat || (e6.enabled = false);
      else if (t2.key === p4.complete) t2.stopPropagation(), e6.completeCreateOperation();
      else if (t2.key !== p4.vertexAdd || t2.repeat) t2.key === p4.undo ? (t2.stopPropagation(), n7.undo()) : t2.key === p4.redo ? (t2.stopPropagation(), n7.redo()) : t2.key !== p4.constraint || "rectangle" !== e6.geometryType && "circle" !== e6.geometryType || t2.repeat ? t2.key === p4.center && (t2.repeat || (e6.centered = !s6, t2.stopPropagation())) : (e6.forceUniformSize = !i5, t2.stopPropagation());
      else {
        const o4 = e6.drawOperation.geometryType;
        "polyline" !== o4 && "polygon" !== o4 && "multipoint" !== o4 || (t2.stopPropagation(), e6.drawOperation.commitStagedVertex());
      }
    }, _.WIDGET), t.on("key-up", (t2) => {
      t2.key === p4.pan ? e6.enabled = true : t2.key !== p4.constraint || "rectangle" !== e6.geometryType && "circle" !== e6.geometryType ? t2.key === p4.center && (e6.centered = s6, t2.stopPropagation()) : (e6.forceUniformSize = i5, t2.stopPropagation());
    }, _.WIDGET), e6.on("vertex-add", (t2) => {
      switch (o3 = null == o3 ? "start" : "active", t2.operation) {
        case "apply":
          this.emit("create", { graphic: e6.graphic, state: o3, tool: this.activeTool, toolEventInfo: t2, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
      }
    }), e6.on("cursor-update", (t2) => {
      e6.drawOperation.numCommittedVertices > 0 && this.emit("create", { graphic: e6.graphic, state: "active", tool: this.activeTool, toolEventInfo: { coordinates: t2.vertices[0].coordinates, type: "cursor-update" }, type: "create" });
    }), e6.on("vertex-remove", (t2) => {
      switch (t2.operation) {
        case "apply":
          this.emit("create", { graphic: e6.graphic, state: "active", tool: this.activeTool, toolEventInfo: t2, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e6.graphic], tool: e6.geometryType });
      }
    }), e6.on("complete", (e7) => {
      this._set("createGraphic", e7.graphic), o3 = "complete", e7.aborted ? n7 && n7.cancel() : n7 && n7.complete();
    }), d3(() => this._getGraphicSymbolFromTool(e6.geometryType), (t2) => {
      e6.graphicSymbol = t2;
    })], n7 = new p8({ activeComponent: e6, tool: e6.geometryType, type: "create", onEnd: () => {
      var _a;
      r2(r11), (_a = t.tools) == null ? void 0 : _a.remove(e6);
    }, undo: () => {
      e6.canUndo && e6.undo();
    }, redo: () => {
      e6.canRedo && e6.redo();
    }, canUndo: () => e6.canUndo, canRedo: () => e6.canRedo });
    return n7;
  }
  _getGraphicSymbolFromTool(e6) {
    switch (e6) {
      case "point":
      case "multipoint":
        return this.pointSymbol;
      case "polyline":
      case "freehandPolyline":
        return this.polylineSymbol;
      case "circle":
      case "rectangle":
      case "polygon":
      case "freehandPolygon":
        return this.polygonSymbol;
      case "mesh":
        return this.meshSymbol;
    }
  }
  async _setupUpdateOperation(e6, t) {
    var _a;
    const { layer: o3, view: i5 } = this;
    if (!i5) return this._logMissingView(), null;
    const a3 = { ...this.defaultUpdateOptions, ...t, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions, ...t == null ? void 0 : t.reshapeOptions }, highlightOptions: { ...this.defaultUpdateOptions.highlightOptions, ...t == null ? void 0 : t.highlightOptions } };
    let s6 = a3.tool ?? oe.tool;
    for (const r11 of e6) o3.remove(r11), o3.add(r11);
    if ("3d" === i5.type) {
      if (0 === e6.length) return null;
      switch (s6) {
        case "move":
          return this._setupMove3DOperation(e6, a3, i5, s6);
        case "reshape":
          return e6.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupReshape3DOperation(e6[0], a3, i5);
        case "transform":
          return this._setupGraphicTransform3DOperation(e6, a3, i5);
      }
    }
    switch (s6) {
      case "move":
        return this._setupMove2DOperation(e6, a3, i5);
      case "reshape":
        return e6.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupTransformOrReshape2DOperation(e6, s6, a3, i5);
      case "transform":
        if (1 === e6.length) {
          const t2 = (_a = e6[0].geometry) == null ? void 0 : _a.type;
          "point" !== t2 && "multipoint" !== t2 || (s6 = "reshape");
        }
        return this._setupTransformOrReshape2DOperation(e6, s6, a3, i5);
    }
  }
  async _setupMove3DOperation(e6, t, o3, i5, s6 = false) {
    const r11 = await this._requireModule(import("./editingTools-LV3DVN2W.js"));
    if (ue(r11)) return r11;
    const { ManipulatedObject3DGraphic: n7, MoveTool3D: p9 } = r11.module, l4 = /* @__PURE__ */ new Map(), h6 = () => {
      l4.forEach((e7) => e7.destroy()), l4.clear();
    };
    for (const a3 of e6) {
      const e7 = new n7({ view: o3, graphic: a3 }), t2 = r5(e7);
      if (t2 !== P2.SUPPORTED) return h6(), this._logError("sketch:move", `Move operation not supported for provided graphic(s) (${E4(t2)}).`), null;
      l4.set(a3, e7);
    }
    const c5 = new p9({ view: o3, enableZ: t.enableZ, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o3.tools.add(c5), c5.objects.addMany(Array.from(l4.values())), s6 || this.updateGraphics.addMany(e6);
    const d6 = [], u6 = new i4({ activeComponent: c5, tool: i5, type: "update", onEnd: () => {
      r2(d6), de(o3, c5), h6();
    }, undo: () => {
      he(this.view, c5), ne(u6, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, redo: () => {
      pe(u6, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, addToSelection: (e7) => {
      this.updateGraphics.push(e7);
      const t2 = new n7({ view: o3, graphic: e7 });
      l4.set(e7, t2), c5.objects.push(t2), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e7) => {
      const t2 = this.updateGraphics.indexOf(e7);
      if (u6.history.undo.forEach((e8) => e8.updates.splice(t2, 1)), u6.history.redo.forEach((e8) => e8.updates.splice(t2, 1)), this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), 0 === this.updateGraphics.length) return void u6.complete();
      const o4 = l4.get(e7);
      o4 && (c5.objects.remove(o4), o4.destroy(), l4.delete(e7));
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t.toggleToolOnClick) return;
      if ("transform" !== i5) return;
      const e7 = this.updateGraphics.at(0), a3 = await this._setupReshape3DOperation(e7, t, o3, true);
      a3 && !ue(a3) && (u6.onEnd(), u6.destroy(), this._setUpdateOperationHandle(a3, t));
    } });
    return d6.push(...this._getHandlesForComponent(u6, t), o3.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(u6, e7, t), _.WIDGET), o3.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(u6, e7);
    }, _.WIDGET)), u6;
  }
  _setupGraphicTransform3DOperation(e6, t, o3, i5 = false) {
    if (1 === e6.length && r10(e6[0]) === P2.SUPPORTED) {
      const a3 = e6[0], s6 = a3.geometry;
      if (null != s6 && ("point" === s6.type || "mesh" === s6.type)) return this._setupPointTransform3DOperation(a3, t, o3);
      if (null != s6 && ("polygon" === s6.type || "polyline" === s6.type)) return this._setupPolyTransform3DOperation(a3, t, o3, i5);
    }
    return this._setupMove3DOperation(e6, t, o3, "transform", i5);
  }
  async _setupPointTransform3DOperation(e6, t, o3) {
    const i5 = "transform", { enableRotation: s6, enableScaling: r11, enableZ: n7 } = t, p9 = await this._requireModule(import("./editingTools-LV3DVN2W.js"));
    if (ue(p9)) return p9;
    const { TransformTool3D: l4, ManipulatedObject3DGraphic: h6 } = p9.module, c5 = new h6({ graphic: e6, view: o3 }), d6 = new l4({ object: c5, view: o3, enableRotation: s6, enableScaling: r11, enableZ: n7, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o3.tools.add(d6), this.updateGraphics.add(e6);
    const u6 = [], y2 = new i4({ activeComponent: d6, tool: i5, type: "update", onEnd: () => {
      r2(u6), de(o3, d6), c5.destroy();
    }, undo: () => {
      he(this.view, d6), ne(y2, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, redo: () => {
      pe(y2, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), y2.onEnd(), y2.destroy();
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o3, "transform", true);
      ue(i6) || this._setUpdateOperationHandle(i6, t);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), y2.complete();
    }, toggleTool: () => {
    } });
    return u6.push(...this._getHandlesForComponent(y2, t), o3.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(y2, e7, t), _.WIDGET), o3.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(y2, e7);
    }, _.WIDGET)), y2;
  }
  async _setupPolyTransform3DOperation(e6, t, o3, i5 = false) {
    var _a, _b;
    const s6 = "transform", { enableRotation: r11, enableScaling: n7, enableZ: p9, preserveAspectRatio: l4 } = t, h6 = await this._requireModule(import("./editingTools-LV3DVN2W.js"));
    if (ue(h6)) return h6;
    const { ManipulatedObject3DGraphic: c5, ExtentTransformTool: d6 } = h6.module, u6 = (_b = (_a = this.view) == null ? void 0 : _a.inputManager) == null ? void 0 : _b.isModifierKeyDown(p4.constraint), y2 = new c5({ view: o3, graphic: e6 }), m3 = new d6({ object: y2, view: o3, enableRotation: r11, enableScaling: n7, enableZ: p9, preserveAspectRatio: !!l4 != !!u6, sketchOptions: this.sketchOptions });
    o3.tools.add(m3), i5 || this.updateGraphics.add(e6);
    const g5 = [], v3 = new i4({ activeComponent: m3, tool: s6, type: "update", onEnd: () => {
      r2(g5), de(o3, m3), y2.destroy();
    }, canUndo: () => !m3.destroyed && m3.canUndo, undo: () => {
      m3.destroyed || (m3.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: s6 }));
    }, canRedo: () => !m3.destroyed && m3.canRedo, redo: () => {
      m3.destroyed || (m3.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: s6 }));
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), v3.onEnd(), v3.destroy();
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o3, "transform", true);
      ue(i6) || this._setUpdateOperationHandle(i6, t);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), v3.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t.toggleToolOnClick) return;
      const i6 = await this._setupReshape3DOperation(e6, t, o3, true);
      i6 && !ue(i6) && (v3.onEnd(), v3.destroy(), this._setUpdateOperationHandle(i6, t));
    } });
    return g5.push(...this._getHandlesForComponent(v3, t), o3.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(v3, e7, t), _.WIDGET), o3.on("key-down", (e7) => this._getCommonUpdateOperationKeyDownHandlers(v3, e7), _.WIDGET), o3.on("key-down", (e7) => {
      e7.key !== p4.constraint || e7.repeat || (m3.preserveAspectRatio = !m3.preserveAspectRatio, e7.stopPropagation());
    }, _.WIDGET), o3.on("key-up", (e7) => {
      e7.key === p4.constraint && (m3.preserveAspectRatio = !m3.preserveAspectRatio, e7.stopPropagation());
    }, _.WIDGET)), v3;
  }
  async _setupMove2DOperation(e6, t, o3) {
    const i5 = "move";
    this.updateGraphics.addMany(e6), await this._updatingHandles.addPromise(this._updateSpatialReference(e6));
    const s6 = await this._getGraphicMover(e6, t, o3);
    if (ue(s6)) return s6;
    const r11 = new i4({ activeComponent: s6, tool: i5, type: "update", onEnd: () => {
      var _a;
      this._displayDefaultCursor(), r2(l4), r2(p9), s6.destroy(), (_a = this._internalGraphicsLayer) == null ? void 0 : _a.removeMany([...this.updateGraphics.toArray()]);
    }, undo: () => {
      const e7 = this.updateGraphics.toArray();
      ne(r11, e7), r11.refreshComponent(), this._emitUndoEvent({ graphics: e7, tool: i5 });
    }, redo: () => {
      const e7 = this.updateGraphics.toArray();
      pe(r11, e7), r11.refreshComponent(), this._emitRedoEvent({ graphics: e7, tool: i5 });
    }, addToSelection: async (e7) => {
      await this._updatingHandles.addPromise(this._updateSpatialReference(e7)), this.updateGraphics.push(e7), s6.graphics = this.updateGraphics.toArray(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e7) => {
      const t2 = this.updateGraphics.indexOf(e7);
      r11.history.undo.forEach((e8) => e8.updates.splice(t2, 1)), r11.history.redo.forEach((e8) => e8.updates.splice(t2, 1)), this.updateGraphics.remove(e7);
      const o4 = this.updateGraphics.toArray();
      this.emit("update", { graphics: o4, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? s6.graphics = o4 : r11.complete();
    } });
    let n7 = false;
    const p9 = [o3.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(r11, e7, t), _.WIDGET), o3.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(r11, e7), e7.key !== p4.constraint || e7.repeat || (n7 = true, s6.enableMoveAllGraphics = !s6.enableMoveAllGraphics);
    }, _.WIDGET), o3.on("key-up", (e7) => {
      e7.key === p4.constraint && n7 && (n7 = false, s6.enableMoveAllGraphics = !s6.enableMoveAllGraphics);
    }, _.WIDGET)], l4 = this._getHandlesForComponent(r11, t);
    return r11;
  }
  async _setupReshape3DOperation(e6, t, o3, i5 = false) {
    const s6 = "reshape", r11 = await this._requireModule(import("./editingTools-LV3DVN2W.js"));
    if (ue(r11)) return r11;
    const { ManipulatedObject3DGraphic: n7, ReshapeTool3D: p9 } = r11.module, l4 = new n7({ view: o3, graphic: e6 }), h6 = e4(l4);
    if (h6 !== P2.SUPPORTED) return l4.destroy(), this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${E4(h6)}).`), null;
    const c5 = t.reshapeOptions, d6 = new p9({ view: o3, object: l4, enableZVertex: t.enableZ && "move" === (c5 == null ? void 0 : c5.vertexOperation), enableZShape: t.enableZ && "move" === (c5 == null ? void 0 : c5.shapeOperation), enableMoveObject: "move" === (c5 == null ? void 0 : c5.shapeOperation) || "move-xy" === (c5 == null ? void 0 : c5.shapeOperation), enableMidpoints: "split" === (c5 == null ? void 0 : c5.edgeOperation), enableEdgeOffset: "offset" === (c5 == null ? void 0 : c5.edgeOperation), snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o3.tools.add(d6), i5 || this.updateGraphics.add(l4.graphic);
    const u6 = [], y2 = new i4({ activeComponent: d6, tool: s6, type: "update", onEnd: () => {
      r2(u6), de(o3, d6), l4.destroy();
    }, canUndo: () => !d6.destroyed && d6.canUndo, undo: () => {
      d6.destroyed || (d6.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: s6 }));
    }, canRedo: () => !d6.destroyed && d6.canRedo, redo: () => {
      d6.destroyed || (d6.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: s6 }));
    }, addToSelection: async (e7) => {
      this.updateGraphics.add(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" }), y2.onEnd(), y2.destroy();
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o3, "transform", true);
      ue(i6) || this._setUpdateOperationHandle(i6, t);
    }, removeFromSelection: (e7) => {
      this.updateGraphics.remove(e7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" }), y2.complete();
    }, toggleTool: async () => {
      if (false === t.toggleToolOnClick) return;
      y2.onEnd(), y2.destroy();
      const e7 = await this._setupGraphicTransform3DOperation(this.updateGraphics.toArray(), t, o3, true);
      ue(e7) || this._setUpdateOperationHandle(e7, t);
    } });
    return u6.push(...this._getHandlesForComponent(y2, t), o3.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(y2, e7, t), _.WIDGET), o3.on("key-down", (e7) => {
      this._getCommonUpdateOperationKeyDownHandlers(y2, e7);
    }, _.WIDGET)), y2;
  }
  async _setupTransformOrReshape2DOperation(e6, t, o3, i5) {
    this.updateGraphics.addMany(e6), await this._updatingHandles.addPromise(this._updateSpatialReference(e6));
    const s6 = "transform" === t ? await this._getBox(e6, o3, i5) : await this._getReshape(e6, o3, i5);
    if (ue(s6)) return s6;
    const r11 = new i4({ activeComponent: s6, type: "update", onEnd: () => {
      r2(p9), r2(n7), r11.activeComponent && !r11.activeComponent.destroyed && r11.activeComponent.destroy(), this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray());
    }, undo: () => {
      ne(r11, this.updateGraphics.toArray()), r11.refreshComponent(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: r11.tool });
    }, redo: () => {
      pe(r11, this.updateGraphics.toArray()), r11.refreshComponent(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: r11.tool });
    }, addToSelection: async (e7) => {
      let t2 = r11.activeComponent;
      if ("reshape" === (t2 == null ? void 0 : t2.type)) {
        const t3 = [...this.updateGraphics, e7];
        this.updateGraphics.removeAll(), r11.onEnd(), r11.destroy();
        const a3 = await this._setupTransformOrReshape2DOperation(t3, "transform", o3, i5);
        if (ue(a3)) return;
        this._setUpdateOperationHandle(a3, o3);
      } else this.updateGraphics.add(e7), t2.graphics = this.updateGraphics.toArray(), t2.refresh(), r11.resetHistory();
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e7], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: async (e7) => {
      const t2 = this.updateGraphics.indexOf(e7);
      r11.history.undo.forEach((e8) => e8.updates.splice(t2, 1)), r11.history.redo.forEach((e8) => e8.updates.splice(t2, 1)), this.updateGraphics.remove(e7);
      const o4 = this.updateGraphics.toArray();
      if (0 === o4.length) r11.complete();
      else {
        const e8 = o4[0].geometry;
        1 !== o4.length || null == e8 || "point" !== e8.type && "multipoint" !== e8.type ? r11.activeComponent.graphics = o4 : r11.toggleTool();
      }
      this.emit("update", { graphics: o4, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e7], type: "selection-change" }, type: "update" });
    }, toggleTool: async () => {
      var _a;
      if (this.updateGraphics.length > 1) return;
      const e7 = this.updateGraphics.at(0), t2 = e7.geometry;
      if (null != t2 && ("reshape" === r11.tool && ("point" === t2.type || "multipoint" === t2.type) || "transform" === r11.tool && "extent" === t2.type)) return;
      let s7 = null;
      "transform" === r11.tool ? s7 = await this._getReshape([e7], o3, i5) : "reshape" === r11.tool && (s7 = await this._getBox([e7], o3, i5)), ue(s7) || ((_a = r11.activeComponent) == null ? void 0 : _a.destroy(), r11.activeComponent = s7, r11.activeComponent && (r2(p9), p9 = this._getHandlesForComponent(r11, o3)));
    } }), n7 = [i5.on("immediate-click", (e7) => this._getCommonUpdateOperationClickHandlers(r11, e7, o3), _.WIDGET), i5.on("key-down", (e7) => {
      if (this._getCommonUpdateOperationKeyDownHandlers(r11, e7), e7.key === p4.constraint && !e7.repeat && r11) {
        const e8 = r11.activeComponent;
        e8 && "box" === e8.type && (e8.preserveAspectRatio = !e8.preserveAspectRatio);
      }
    }, _.WIDGET), i5.on("key-up", (e7) => {
      if (e7.key === p4.constraint && r11) {
        const e8 = r11.activeComponent;
        e8 && "box" === e8.type && (e8.preserveAspectRatio = !e8.preserveAspectRatio);
      }
    }, _.WIDGET)];
    let p9 = this._getHandlesForComponent(r11, o3);
    return r11;
  }
  async _getGraphicMover(e6, t, o3) {
    const { enableMoveAllGraphics: i5, highlightOptions: a3 } = t, s6 = await this._requireModule(import("./GraphicMover-HXLGT324.js"));
    return ue(s6) ? s6 : new s6.module.default({ enableMoveAllGraphics: i5, highlightsEnabled: !!(a3 == null ? void 0 : a3.enabled), indicatorsEnabled: false, graphics: e6, view: o3, callbacks: { onGraphicMoveStart: ({ dx: e7, dy: t2, graphic: o4 }) => {
      this._displayGrabbingCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: "move-start" }, type: "update" });
    }, onGraphicMove: ({ dx: e7, dy: t2, graphic: o4 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: "move" }, type: "update" }), onGraphicMoveStop: ({ dx: e7, dy: t2, graphic: o4 }) => {
      this._displayPointerCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: "move-stop" }, type: "update" });
    }, onGraphicPointerOver: () => this._displayPointerCursor(), onGraphicPointerOut: () => this._displayDefaultCursor() } });
  }
  async _getBox(e6, t, o3) {
    var _a, _b;
    const { enableRotation: i5, enableScaling: a3, highlightOptions: s6, preserveAspectRatio: r11 } = t, n7 = await this._requireModule(import("./Box-C6KNKHOY.js"));
    if (ue(n7)) return n7;
    const p9 = (_b = (_a = this.view) == null ? void 0 : _a.inputManager) == null ? void 0 : _b.isModifierKeyDown(p4.constraint);
    return new n7.module.default({ graphics: e6, enableRotation: i5, enableScaling: a3, highlightsEnabled: !!(s6 == null ? void 0 : s6.enabled), preserveAspectRatio: !!r11 != !!p9, layer: this._internalGraphicsLayer, view: o3, sketchOptions: this.sketchOptions, callbacks: { onMoveStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onMove: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onMoveStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScaleStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScale: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onScaleStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotateStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotate: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onRotateStop: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }) } });
  }
  async _getReshape(e6, t, o3) {
    var _a, _b, _c;
    const i5 = "split" === ((_a = t.reshapeOptions) == null ? void 0 : _a.edgeOperation), a3 = "move" === ((_b = t.reshapeOptions) == null ? void 0 : _b.shapeOperation), s6 = !!((_c = t.highlightOptions) == null ? void 0 : _c.enabled), r11 = await this._requireModule(import("./Reshape-2GGQWONQ.js"));
    return ue(r11) ? r11 : new r11.module.default({ enableMidpoints: i5, enableMovement: a3, graphic: e6[0], highlightsEnabled: s6, layer: this._internalGraphicsLayer, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, view: o3, callbacks: { onReshapeStart: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onReshape: (e7) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7 }, type: "update" }), onReshapeStop: ({ mover: e7, type: t2 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7, type: t2 }, type: "update" }), onMoveStart: ({ dx: e7, dy: t2, mover: o4, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: i6 }, type: "update" }), onMove: ({ dx: e7, dy: t2, mover: o4, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: i6 }, type: "update" }), onMoveStop: ({ dx: e7, dy: t2, mover: o4, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7, dy: t2, mover: o4, type: i6 }, type: "update" }), onVertexAdd: ({ added: e7, type: t2, vertices: o4 }) => {
      const i6 = e7.map((e8) => e2(e8.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: i6, vertices: o4, type: t2 }, type: "update" });
    }, onVertexRemove: ({ removed: e7, type: t2, vertices: o4 }) => {
      const i6 = e7.map((e8) => e2(e8.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { removed: i6, vertices: o4, type: t2 }, type: "update" });
    } } });
  }
  _getHandlesForComponent(e6, t) {
    const o3 = e6.activeComponent;
    if (!o3) return [];
    switch (o3.type) {
      case "graphic-mover":
        return [o3.on("graphic-click", ({ graphic: t2, viewEvent: o4 }) => {
          var _a;
          ((_a = o4.native) == null ? void 0 : _a.shiftKey) && (o4.stopPropagation(), e6.removeFromSelection(t2));
        }), o3.on("graphic-move-start", (t2) => e6.addToHistory(ce(t2.allGraphics)))];
      case "box":
        return [o3.on("graphic-click", (o4) => this._onTransformOrReshape2DGraphicClick(e6, t, o4)), o3.on("move-start", (t2) => e6.addToHistory(ce(t2.graphics))), o3.on("rotate-start", (t2) => e6.addToHistory(ce(t2.graphics))), o3.on("scale-start", (t2) => e6.addToHistory(ce(t2.graphics)))];
      case "reshape":
        return [o3.on("graphic-click", (o4) => this._onTransformOrReshape2DGraphicClick(e6, t, o4)), o3.on("move-start", (t2) => e6.addToHistory(ce([t2.mover]))), o3.on("reshape-start", (t2) => e6.addToHistory(ce([t2.graphic]))), o3.on("vertex-add", (t2) => e6.addToHistory(ce([t2.oldGraphic]))), o3.on("vertex-remove", (t2) => e6.addToHistory(ce([t2.oldGraphic])))];
      case "move-3d":
        return [o3.events.on("record-undo", ({ updates: t2 }) => {
          e6.addToHistory({ updates: t2 });
        }), o3.events.on("move-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move-start" }, type: "update" });
        }), o3.events.on("move", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e7.dx, dy: e7.dy, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move" }, type: "update" });
        }), o3.events.on("move-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e7.objects.length > 0 ? e7.objects[0].graphic : null, type: "move-stop" }, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e6, t) : e6.toggleTool();
        })];
      case "transform-3d":
        return [o3.events.on("record-undo", ({ updates: t2 }) => {
          e6.addToHistory({ updates: t2 });
        }), o3.events.on("translate-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move-start" }, type: "update" });
        }), o3.events.on("translate-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move-stop" }, type: "update" });
        }), o3.events.on("rotate-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate-start" }, type: "update" });
        }), o3.events.on("rotate-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate-stop" }, type: "update" });
        }), o3.events.on("scale-start", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale-start" }, type: "update" });
        }), o3.events.on("scale-stop", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale-stop" }, type: "update" });
        }), o3.events.on("translate", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, dx: e7.dxScreen, dy: e7.dyScreen, type: "move" }, type: "update" });
        }), o3.events.on("rotate", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, angle: e7.angle, type: "rotate" }, type: "update" });
        }), o3.events.on("scale", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e7.object.graphic, xScale: e7.xScale, yScale: e7.yScale, type: "scale" }, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e6, t) : e6.toggleTool();
        })];
      case "reshape-3d":
        return [o3.events.on("reshape", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7, mover: e7.object.graphic }, type: "update" });
        }), o3.events.on("move", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e7, mover: e7.object.graphic }, type: "update" });
        }), o3.events.on("vertex-add", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e7, type: "update" });
        }), o3.events.on("vertex-remove", (e7) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e7, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e6, t) : e6.toggleTool();
        })];
    }
  }
  _onTransformOrReshape2DGraphicClick(e6, t, o3) {
    var _a;
    const { graphic: i5, viewEvent: a3 } = o3;
    return ((_a = a3.native) == null ? void 0 : _a.shiftKey) && i5.layer === this.layer ? (a3.stopPropagation(), e6.removeFromSelection(i5)) : t.toggleToolOnClick ? (a3.stopPropagation(), e6.toggleTool()) : void 0;
  }
  _setUpdateOperationHandle(e6, t) {
    var _a;
    this._operationHandle = e6;
    const o3 = (_a = this.view) == null ? void 0 : _a.map;
    this._disablePopup(t);
    const i5 = () => {
      if (e6 === this._operationHandle) {
        const i6 = this.updateGraphics.toArray(), a3 = this._operationHandle.tool;
        this._operationHandle.destroy(), this._operationHandle = null, this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray()), this.updateGraphics.removeAll(), o3 && o3.remove(this._internalGraphicsLayer), this._restorePopup(t), this.emit("update", { graphics: i6, state: "complete", aborted: e6.cancelled, tool: a3, toolEventInfo: null, type: "update" });
      }
    };
    e6.on("complete", i5);
  }
  async _getCommonUpdateOperationClickHandlers(e6, t, o3) {
    const i5 = n3(t), a3 = await t.async(() => this._getFirstHit(i5));
    if (null == a3) return void e6.complete();
    if (t.native.shiftKey && this._toggleSelection([a3.graphic], e6, o3)) return void t.stopPropagation();
    this.updateGraphics.includes(a3.graphic) ? t.stopPropagation() : e6.complete();
  }
  _toggleSelection(e6, t, o3) {
    const i5 = !!o3.multipleSelectionEnabled;
    return e6.some((e7) => null != e7 && (!(!i5 || e7.layer !== this.layer) && (this.updateGraphics.includes(e7) ? t.removeFromSelection(e7) : t.addToSelection(e7), true)));
  }
  _getCommonUpdateOperationKeyDownHandlers(e6, t) {
    if (!e6) return;
    const o3 = t.key;
    o3 === p4.undo && e6.canUndo() ? (t.stopPropagation(), e6.undo()) : o3 === p4.redo && e6.canRedo() ? (t.stopPropagation(), e6.redo()) : o3 === p4.cancel ? (t.stopPropagation(), e6.cancel()) : this.allowDeleteKey && p4.delete.includes(o3) && this._onDeleteKey(t);
  }
  _onDeleteKey(e6) {
    var _a;
    if (!this._operationHandle || "update" !== this._operationHandle.type) return;
    const t = this.activeComponent, o3 = this.updateGraphics.toArray();
    null != t && ("reshape" !== t.type || 1 === o3.length && "point" === ((_a = o3[0].geometry) == null ? void 0 : _a.type)) && (e6.stopPropagation(), this.delete());
  }
  _removeDefaultLayer() {
    var _a, _b;
    this._internalGraphicsLayer && ((_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.remove(this._internalGraphicsLayer), this._internalGraphicsLayer = u(this._internalGraphicsLayer));
  }
  _isComponentGraphic(e6) {
    var _a;
    const { activeComponent: t } = this;
    return !(!e6 || null == t) && (((_a = e6.attributes) == null ? void 0 : _a.esriSketchTool) || "draw-2d" === t.type && t.graphic === e6 || ("box" === t.type || "reshape" === t.type) && t.isUIGraphic(e6));
  }
  _displayPointerCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && "pointer" !== this.view.cursor && (this.view.cursor = "pointer");
  }
  _displayGrabbingCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && "grabbing" !== this.view.cursor && (this.view.cursor = "grabbing");
  }
  _displayDefaultCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && null !== this.view.cursor && (this.view.cursor = null);
  }
  _logError(e6, t, i5) {
    n2.getLogger(this).error(new s(e6, t, i5));
  }
  async _requireModule(e6) {
    const t = new AbortController();
    this._moduleLoaderAbortController = t;
    const o3 = await e6;
    return this._moduleLoaderAbortController !== t || t.signal.aborted ? { requireError: "aborted" } : { module: o3 };
  }
  _emitUndoEvent(e6) {
    this.emit("undo", { ...e6, type: "undo" });
  }
  _emitRedoEvent(e6) {
    this.emit("redo", { ...e6, type: "redo" });
  }
  _emitDeleteEvent(e6) {
    this.emit("delete", { ...e6, type: "delete" });
  }
  get test() {
  }
  wait() {
    return w(() => !this.updating);
  }
  _disablePopupEnabled(e6) {
    var _a;
    return "3d" !== ((_a = this.view) == null ? void 0 : _a.type) || this.updateOnGraphicClick || ((e6 == null ? void 0 : e6.toggleToolOnClick) ?? false);
  }
  _disablePopup(e6) {
    this._disablePopupEnabled(e6) && this.view && null == this._originalPopupEnabled && (this._originalPopupEnabled = this.view.popupEnabled, this.view.popupEnabled = false);
  }
  _restorePopup(e6) {
    this._disablePopupEnabled(e6) && this.view && null != this._originalPopupEnabled && (this.view.popupEnabled = this._originalPopupEnabled, this._originalPopupEnabled = null);
  }
  async _waitViewReady() {
    const e6 = this.view;
    e6 ? (e(this._viewReadyAbortController), this._viewReadyAbortController = new AbortController(), await h(w(() => e6 == null ? void 0 : e6.ready), this._viewReadyAbortController.signal)) : this._logMissingView();
  }
  _logMissingView() {
    this._logError("sketch:missing-property", se("view"));
  }
  _logMissingLayer() {
    this._logError(ae, se("layer"));
  }
};
r([m()], ie.prototype, "_defaultSnappingManager", void 0), r([m()], ie.prototype, "updating", null), r([m({ readOnly: true })], ie.prototype, "_updatingHandles", void 0), r([m()], ie.prototype, "_operationHandle", void 0), r([m({ readOnly: true })], ie.prototype, "activeTool", null), r([m({ readOnly: true })], ie.prototype, "activeCreateToolDrawMode", null), r([m()], ie.prototype, "activeTooltip", null), r([m({ types: x })], ie.prototype, "activeFillSymbol", void 0), r([m()], ie.prototype, "activeLineSymbol", void 0), r([m()], ie.prototype, "activeVertexSymbol", void 0), r([m()], ie.prototype, "allowDeleteKey", void 0), r([m({ readOnly: true })], ie.prototype, "createGraphic", null), r([m()], ie.prototype, "defaultCreateOptions", null), r([m()], ie.prototype, "defaultUpdateOptions", null), r([m({ type: c3, nonNullable: true })], ie.prototype, "labelOptions", null), r([m()], ie.prototype, "layer", void 0), r([m({ types: x })], ie.prototype, "pointSymbol", void 0), r([m({ types: x })], ie.prototype, "polygonSymbol", void 0), r([m({ types: x })], ie.prototype, "polylineSymbol", void 0), r([m()], ie.prototype, "meshSymbol", void 0), r([m({ type: c4, nonNullable: true })], ie.prototype, "snappingOptions", null), r([m()], ie.prototype, "snappingManager", null), r([m({ readOnly: true })], ie.prototype, "state", null), r([m({ type: r3, nonNullable: true })], ie.prototype, "tooltipOptions", null), r([m({ readOnly: true })], ie.prototype, "updateGraphics", void 0), r([m()], ie.prototype, "updateOnGraphicClick", void 0), r([m()], ie.prototype, "creationMode", void 0), r([m({ type: l2, nonNullable: true })], ie.prototype, "valueOptions", null), r([m({ types: x })], ie.prototype, "vertexSymbol", void 0), r([m({ value: null })], ie.prototype, "view", null), r([m({ constructOnly: true, type: l3 })], ie.prototype, "sketchOptions", void 0), ie = r([a2("esri.widgets.Sketch.SketchViewModel")], ie);
var ae = "sketch:missing-property";
var se = (e6) => `Property '${e6}' is missing on SketchViewModel.`;
function re(e6) {
  return "polygon" === e6 || "rectangle" === e6 || "circle" === e6;
}
function ne(e6, t) {
  le("undo", e6.history.undo, e6.history.redo, t);
}
function pe(e6, t) {
  le("redo", e6.history.redo, e6.history.undo, t);
}
function le(e6, t, o3, i5) {
  const a3 = t.pop();
  if (!a3) return;
  const s6 = a3.updates, r11 = [];
  i5.forEach((t2, o4) => {
    const i6 = s6[o4];
    null != i6 && ("geometry" in i6 && null != i6.geometry && (r11.push({ geometry: t2.geometry }), t2.geometry = i6.geometry), "symbol" in i6 && null != i6.symbol && (r11.push({ symbol: t2.symbol }), t2.symbol = i6.symbol), "undo" in i6 && (r11.push(i6), i6[e6](t2)));
  }), o3.push({ updates: r11 });
}
function he(e6, t) {
  null != e6 && t.hasGrabbedManipulators && (e6.activeTool = null);
}
function ce(e6) {
  return { updates: e6.map(({ geometry: e7 }) => "mesh" === (e7 == null ? void 0 : e7.type) ? { geometry: e7.cloneShallow() } : { geometry: e7 }) };
}
function de(e6, t) {
  var _a;
  (_a = e6.tools) == null ? void 0 : _a.remove(t), t.destroyed || t.destroy();
}
function ue(e6) {
  return "requireError" in e6 && "aborted" === e6.requireError;
}
var ye = ie;

// node_modules/@arcgis/core/views/2d/layers/support/RouteLayerInteraction.js
function g4(e6, r11) {
  e6.networkFeature = r11;
}
function u5(e6) {
  const r11 = w3(e6.graphic);
  return { ...e6, networkFeature: r11 };
}
function b2(e6) {
  const r11 = e6.graphics.map((e7) => w3(e7));
  return { ...e6, networkFeatures: r11 };
}
function w3(e6) {
  return e6.networkFeature;
}
function k3(e6) {
  return "point" === (e6 == null ? void 0 : e6.type) || "polyline" === (e6 == null ? void 0 : e6.type) || "polygon" === (e6 == null ? void 0 : e6.type);
}
var _2 = class extends g {
  constructor(e6) {
    super(e6), this._createMode = null, this._graphicsLayer = new h4({ internal: true, listMode: "hide", title: "Banana" }), this._updatingHandles = new h2(), this.enabled = true, this._handleSketchViewModelEvents = async (e7) => {
      var _a, _b;
      switch (e7.type) {
        case "update":
          switch (e7.state) {
            case "active":
            case "complete":
              for (const r11 of e7.graphics) {
                w3(r11).geometry = k3(r11.geometry) ? r11.geometry.clone() : null;
              }
          }
          break;
        case "undo":
        case "redo":
          break;
        case "delete":
          for (const r11 of e7.graphics) {
            const e8 = w3(r11);
            this._removeNetworkFeature(e8);
          }
          break;
        case "create":
          if (e7.graphic && "complete" === e7.state && this._createMode) {
            const r11 = (_a = e7.graphic.geometry) == null ? void 0 : _a.clone(), t = (_b = e7.graphic.symbol) == null ? void 0 : _b.clone();
            if (!r11) break;
            switch (this._createMode) {
              case "stop": {
                if ("point" !== r11.type) break;
                const { stops: t2 } = this.layer;
                if (t2.length > 0 && t2.every(({ geometry: e8 }) => !e8)) {
                  t2.at(0).geometry = r11;
                  break;
                }
                if (t2.length > 1 && t2.filter((e8, r12) => 0 !== r12).every(({ geometry: e8 }) => !e8)) {
                  t2.at(1).geometry = r11;
                  break;
                }
                const o3 = new w2({ geometry: r11 });
                t2.add(o3), g4(e7.graphic, o3);
                break;
              }
              case "point-barrier": {
                if ("point" !== r11.type) break;
                const o3 = new T({ geometry: r11, symbol: t });
                this.layer.pointBarriers.add(o3), g4(e7.graphic, o3);
                break;
              }
              case "polyline-barrier": {
                if ("polyline" !== r11.type) break;
                const o3 = new j2({ geometry: r11, symbol: t });
                this.layer.polylineBarriers.add(o3), g4(e7.graphic, o3);
                break;
              }
              case "polygon-barrier": {
                if ("polygon" !== r11.type) break;
                const o3 = new T2({ geometry: r11, symbol: t });
                this.layer.polygonBarriers.add(o3), g4(e7.graphic, o3);
                break;
              }
            }
          }
      }
      (await this.view.whenLayerView(this.layer)).emit(e7.type, "create" === e7.type ? u5(e7) : b2(e7));
    };
  }
  initialize() {
    this._sketchViewModel = new ye({ layer: this._graphicsLayer, view: this.view }), this.addHandles([d3(() => this.enabled, (e6) => {
      e6 ? this._activate() : this._deactivate();
    }, P), d3(() => {
      const { stops: e6, pointBarriers: r11, polylineBarriers: t, polygonBarriers: o3 } = this.layer;
      return { stops: e6, pointBarriers: r11, polylineBarriers: t, polygonBarriers: o3 };
    }, () => {
      this.enabled && this._loadClonedGraphics();
    }), this._sketchViewModel.on(["create", "delete", "redo", "undo", "update"], this._handleSketchViewModelEvents), i(this._updatingHandles)]);
  }
  destroy() {
    this.view.map.remove(this._graphicsLayer), this._graphicsLayer.removeAll(), this._graphicsLayer = u(this._graphicsLayer), this._sketchViewModel = u(this._sketchViewModel);
  }
  get selectedNetworkFeatures() {
    return this._sketchViewModel.updateGraphics.map((e6) => w3(e6));
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  create(e6) {
    var _a;
    switch (this._createMode = e6, e6) {
      case "stop":
        ((_a = this.layer.defaultSymbols.stops) == null ? void 0 : _a.unlocated) && (this._sketchViewModel.pointSymbol = this.layer.defaultSymbols.stops.unlocated.clone());
        break;
      case "point-barrier":
        this.layer.defaultSymbols.pointBarriers && (this._sketchViewModel.pointSymbol = this.layer.defaultSymbols.pointBarriers.clone());
        break;
      case "polyline-barrier":
        this.layer.defaultSymbols.polylineBarriers && (this._sketchViewModel.polylineSymbol = this.layer.defaultSymbols.polylineBarriers.clone());
        break;
      case "polygon-barrier":
        this.layer.defaultSymbols.polygonBarriers && (this._sketchViewModel.polygonSymbol = this.layer.defaultSymbols.polygonBarriers.clone());
    }
    switch (e6) {
      case "stop":
      case "point-barrier":
        return this._sketchViewModel.create("point");
      case "polyline-barrier":
        return this._sketchViewModel.create("polyline");
      case "polygon-barrier":
        return this._sketchViewModel.create("polygon");
    }
  }
  remove(e6) {
    const r11 = this._graphicsLayer.graphics.find((r12) => w3(r12) === e6);
    r11 && this._graphicsLayer.remove(r11), this._removeNetworkFeature(e6);
  }
  _activate() {
    this._loadClonedGraphics(), this.view.map.add(this._graphicsLayer);
  }
  _deactivate() {
    var _a;
    this._sketchViewModel.cancel(), (_a = this.view.map) == null ? void 0 : _a.remove(this._graphicsLayer), this._graphicsLayer.removeAll();
  }
  _loadClonedGraphics() {
    const e6 = [this.layer.stops, this.layer.pointBarriers, this.layer.polylineBarriers, this.layer.polygonBarriers].flatMap((e7) => e7.toArray().map((e8) => {
      const r11 = e8.toGraphic();
      return r11.networkFeature = e8, r11;
    }));
    this._graphicsLayer.removeAll().addMany(e6);
  }
  _removeNetworkFeature(e6) {
    switch (e6.type) {
      case "stop":
        this.layer.stops.remove(e6);
        break;
      case "point-barrier":
        this.layer.pointBarriers.remove(e6);
        break;
      case "polyline-barrier":
        this.layer.polylineBarriers.remove(e6);
        break;
      case "polygon-barrier":
        this.layer.polygonBarriers.remove(e6);
    }
  }
};
r([m()], _2.prototype, "enabled", void 0), r([m({ constructOnly: true })], _2.prototype, "layer", void 0), r([m({ readOnly: true })], _2.prototype, "selectedNetworkFeatures", null), r([m()], _2.prototype, "updating", null), r([m({ constructOnly: true })], _2.prototype, "view", void 0), _2 = r([a2("esri.views.2d.layers.support.RouteLayerInteraction")], _2);
export {
  _2 as RouteLayerInteraction
};
//# sourceMappingURL=RouteLayerInteraction-QJLKHOJK.js.map
