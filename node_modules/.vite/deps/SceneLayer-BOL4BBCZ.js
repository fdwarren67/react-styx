import {
  v as v2
} from "./chunk-SGYJ7J7R.js";
import "./chunk-FDGPK3YS.js";
import {
  n as n4,
  p as p8
} from "./chunk-IVPVPFYU.js";
import {
  t as t6
} from "./chunk-QHKIY2YB.js";
import {
  a as a5,
  m as m3,
  p as p7,
  y
} from "./chunk-AAJ7HOPE.js";
import {
  R,
  V as V4
} from "./chunk-Q6AGOKIE.js";
import {
  $,
  P as P2,
  w as w2
} from "./chunk-LULXSZFE.js";
import {
  i as i2,
  m as m2,
  t2 as t5
} from "./chunk-VULXPVJR.js";
import "./chunk-QU4L2TYC.js";
import "./chunk-QBDJCOUK.js";
import {
  V as V3
} from "./chunk-TS22YKT7.js";
import "./chunk-GZUQTA6H.js";
import "./chunk-MAX4GY2G.js";
import "./chunk-OITDZHA4.js";
import "./chunk-ZGGC3KHK.js";
import "./chunk-UM5QMFZV.js";
import "./chunk-MD2QBQPV.js";
import "./chunk-CBFRSYD6.js";
import "./chunk-2CY5SLAC.js";
import "./chunk-LQHBJ3TA.js";
import "./chunk-MKVF6I7G.js";
import "./chunk-457CK7GN.js";
import "./chunk-EVDBYOW7.js";
import "./chunk-QQOUESXA.js";
import "./chunk-EQ5WRTBD.js";
import "./chunk-6QXEI4OT.js";
import "./chunk-55SEMSMA.js";
import "./chunk-BUZ7I3MJ.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-CUWQEJ5X.js";
import "./chunk-NE7GYHUP.js";
import "./chunk-EXHR7CRN.js";
import "./chunk-HX6OAJGI.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-HYT6FDCG.js";
import "./chunk-MRUZJ4BJ.js";
import "./chunk-YZF7OTID.js";
import "./chunk-KLBFJ6WQ.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import "./chunk-6AWA6GOC.js";
import "./chunk-5Y5NK5SR.js";
import "./chunk-SXBN3QCZ.js";
import "./chunk-XD7AJMUV.js";
import "./chunk-6TUECH7E.js";
import {
  a as a6
} from "./chunk-AL5QEXF5.js";
import {
  s as s3
} from "./chunk-B3W47DKN.js";
import "./chunk-3ECUFCNI.js";
import "./chunk-6WERKJTM.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-ON7GWFUW.js";
import {
  p as p5,
  t as t4
} from "./chunk-XBF3Q5CM.js";
import "./chunk-BSQH3I7W.js";
import {
  p as p4
} from "./chunk-LVHCS2TZ.js";
import {
  i
} from "./chunk-5GYWQFHA.js";
import {
  s as s5
} from "./chunk-S4AV6MOI.js";
import {
  C as C2,
  n as n3
} from "./chunk-RMOE6XHW.js";
import {
  u as u2
} from "./chunk-QAXPIBME.js";
import {
  l as l2
} from "./chunk-WOB72RZU.js";
import {
  f as f2
} from "./chunk-HKTC3ZVY.js";
import {
  d as d2,
  l as l3
} from "./chunk-MQ3WYGQ2.js";
import {
  p as p6
} from "./chunk-S4QLDBOB.js";
import {
  e as e2
} from "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import {
  N,
  Y,
  ne
} from "./chunk-XZDT5RTS.js";
import "./chunk-QAP2FVP7.js";
import "./chunk-7DHQ2VMC.js";
import {
  F
} from "./chunk-Z5UGTZ3C.js";
import {
  n as n2,
  r as r3
} from "./chunk-ZXHHBJMH.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-ZDLUQDDX.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import {
  Z
} from "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import {
  j as j3
} from "./chunk-K5B7AETB.js";
import {
  t as t2
} from "./chunk-KLCKQJVO.js";
import "./chunk-5APVNM2E.js";
import {
  b as b2
} from "./chunk-C6YDI6QX.js";
import {
  c,
  d,
  l,
  p as p3,
  s as s4
} from "./chunk-DJ5HVIE7.js";
import {
  S as S2
} from "./chunk-KPY4ZIC2.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-WO43UGNC.js";
import "./chunk-GPMU6IW4.js";
import {
  b as b3
} from "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  L,
  sn
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-BBPRJCMB.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-RO66CZDO.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  t as t3
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import {
  p as p2
} from "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b as b4
} from "./chunk-BLF64HON.js";
import {
  q
} from "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a4
} from "./chunk-SPVEONZ2.js";
import {
  I,
  g as g2,
  h
} from "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import {
  r as r2
} from "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  C,
  v,
  w
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import {
  V as V2
} from "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j as j2
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  g2 as g,
  p
} from "./chunk-BECTSF5P.js";
import {
  V
} from "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  e,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3,
  s as s2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import {
  t
} from "./chunk-EAFC6V23.js";
import {
  a as a2,
  b,
  u
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  a,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/sceneLayerCacheUtils.js
function e3({ associatedLayer: e5, serviceUpdateTimeStamp: t8 }) {
  var _a;
  const n5 = (_a = e5 == null ? void 0 : e5.editingInfo) == null ? void 0 : _a.lastEditDate, r4 = e5 == null ? void 0 : e5.serverGens, a8 = null != n5, i4 = null != t8, s7 = a8 && i4 && t8.lastUpdate !== n5.getTime();
  return a8 && (s7 || !i4 && (r4 == null ? void 0 : r4.minServerGen) !== (r4 == null ? void 0 : r4.serverGen));
}

// node_modules/@arcgis/core/layers/mixins/TemporalSceneLayer.js
var a7 = (t8) => {
  let a8 = class extends t8 {
    constructor() {
      super(...arguments), this.serviceTimeInfo = null;
    }
    get timeInfo() {
      var _a;
      const e5 = (_a = this.associatedLayer) == null ? void 0 : _a.timeInfo;
      if (null == e5) return null;
      const t9 = e5.clone();
      return I(t9, this.fieldsIndex), t9;
    }
    set timeInfo(e5) {
      I(e5, this.fieldsIndex), this._override("timeInfo", e5);
    }
    get timeExtent() {
      var _a;
      return (_a = this.associatedLayer) == null ? void 0 : _a.timeExtent;
    }
    set timeExtent(e5) {
      this._override("timeExtent", e5);
    }
    get timeOffset() {
      var _a;
      return (_a = this.associatedLayer) == null ? void 0 : _a.timeOffset;
    }
    set timeOffset(e5) {
      this._override("timeOffset", e5);
    }
    get datesInUnknownTimezone() {
      var _a;
      return ((_a = this.associatedLayer) == null ? void 0 : _a.datesInUnknownTimezone) ?? false;
    }
    set datesInUnknownTimezone(e5) {
      this._override("datesInUnknownTimezone", e5);
    }
    async loadTimeInfoFromService(e5) {
      const { serviceTimeInfo: t9 } = this;
      if (null == t9) return;
      const { startTimeField: r4, endTimeField: i4 } = t9;
      if (null == r4 && null == i4) return;
      if (e3({ associatedLayer: this.associatedLayer, serviceUpdateTimeStamp: this.serviceUpdateTimeStamp })) return;
      const s7 = async (t10) => {
        var _a;
        let i5 = null;
        try {
          const r5 = await ((_a = this.fetchStatistics) == null ? void 0 : _a.call(this, t10, e5));
          i5 = r5 == null ? void 0 : r5.stats;
        } catch {
        }
        if (null == i5) return null;
        const { minTimeStr: s8, min: n5, maxTimeStr: o2, max: l5 } = i5, m5 = t10 === r4 ? s8 ?? n5 : o2 ?? l5;
        return null != m5 ? new Date(m5) : null;
      }, [m4, a9] = await Promise.all([s7(r4), s7(i4)]);
      if (null != r4 && null == m4 || null != i4 && null == a9) return;
      const c4 = new p2({ start: m4, end: a9 });
      this.setAtOrigin("timeInfo", new d2({ endField: i4, startField: r4, fullTimeExtent: c4 }), "service");
    }
  };
  return r([m({ type: d2, json: { read: false, write: false } })], a8.prototype, "timeInfo", null), r([m({ type: p2, json: { read: false, write: false } })], a8.prototype, "timeExtent", null), r([m({ type: l3, json: { read: false, write: false } })], a8.prototype, "timeOffset", null), r([m({ type: Boolean, nonNullable: true, json: { read: false, write: false } })], a8.prototype, "datesInUnknownTimezone", null), r([m({ type: c2, readOnly: true, json: { read: { source: "timeInfo" } } })], a8.prototype, "serviceTimeInfo", void 0), a8 = r([a3("esri.layers.mixins.TemporalSceneLayer")], a8), a8;
};
var c2 = class extends S {
  constructor() {
    super(...arguments), this.endTimeField = null, this.startTimeField = null;
  }
};
r([m({ type: String })], c2.prototype, "endTimeField", void 0), r([m({ type: String })], c2.prototype, "startTimeField", void 0), c2 = r([a3("esri.layers.mixins.TemporalSceneLayer.SceneServiceTimeInfo")], c2);

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s6 = class extends S {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
r([m({ type: String, json: { read: true, write: { isRequired: true } } })], s6.prototype, "name", void 0), r([m({ type: String, json: { read: true, write: { isRequired: true } } })], s6.prototype, "field", void 0), r([m({ type: [Number], json: { read: true, write: true } })], s6.prototype, "currentRangeExtent", void 0), r([m({ type: [Number], json: { read: true, write: true } })], s6.prototype, "fullRangeExtent", void 0), r([m({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: { isRequired: true } } })], s6.prototype, "type", void 0), s6 = r([a3("esri.layers.support.RangeInfo")], s6);

// node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c3;
var p9 = c3 = class extends S.JSONSupportMixin(V2.ofType(j2)) {
  constructor(e5) {
    super(e5);
  }
  clone() {
    return new c3(this.items.map((e5) => e5.clone()));
  }
  write(e5, r4) {
    return this.toJSON(r4);
  }
  toJSON(e5) {
    var _a, _b;
    const r4 = (_a = e5 == null ? void 0 : e5.layer) == null ? void 0 : _a.spatialReference;
    return r4 ? this.toArray().map((t8) => {
      var _a2;
      if (!r4.equals(t8.spatialReference)) {
        if (!L(t8.spatialReference, r4)) return (_a2 = e5 == null ? void 0 : e5.messages) == null ? void 0 : _a2.push(new s2("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e5.layer.spatialReference, context: e5 })), null;
        const s8 = new j2();
        sn(t8, s8, r4), t8 = s8;
      }
      const s7 = t8.toJSON(e5);
      return delete s7.spatialReference, s7;
    }).filter((e6) => null != e6) : ((_b = e5 == null ? void 0 : e5.messages) == null ? void 0 : _b.push(new s2("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e5.layer.spatialReference, context: e5 })), this.toArray().map((r5) => r5.toJSON(e5)));
  }
  static fromJSON(e5, r4) {
    const t8 = new c3();
    return e5.forEach((e6) => t8.add(j2.fromJSON(e6, r4))), t8;
  }
};
p9 = c3 = r([a3("esri.layers.support.PolygonCollection")], p9);
var l4 = p9;

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var u3;
var g3 = u3 = class extends S {
  constructor(e5) {
    super(e5), this.spatialRelationship = "disjoint", this.geometries = new l4(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(v(() => this.geometries, "after-changes", () => this.geometries = this.geometries, C));
  }
  readGeometries(e5, r4, o2) {
    Array.isArray(e5) ? this.geometries = l4.fromJSON(e5, o2) : this._geometriesSource = { url: p(e5, o2), context: o2 };
  }
  async loadGeometries(e5, o2) {
    if (null == this._geometriesSource) return;
    const { url: s7, context: t8 } = this._geometriesSource, i4 = await P(s7, { responseType: "json", signal: o2 == null ? void 0 : o2.signal }), a8 = e5.toJSON(), p10 = i4.data.map((e6) => ({ ...e6, spatialReference: a8 }));
    this.geometries = l4.fromJSON(p10, t8), this._geometriesSource = null;
  }
  clone() {
    const e5 = new u3({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e5._geometriesSource = this._geometriesSource, e5;
  }
};
r([m({ type: ["disjoint", "contains"], nonNullable: true, json: { write: { isRequired: true } } })], g3.prototype, "spatialRelationship", void 0), r([m({ type: l4, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), v2({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g3.prototype, "geometries", void 0), r([o(["web-scene", "portal-item"], "geometries")], g3.prototype, "readGeometries", null), g3 = u3 = r([a3("esri.layers.support.SceneFilter")], g3);
var h2 = g3;

// node_modules/@arcgis/core/layers/support/sceneLayerStatistics.js
async function i3({ fieldName: i4, statisticsInfo: a8, errorContext: o2, fieldsIndex: r4, path: n5, customParameters: l5, apiKey: c4, signal: f3 }) {
  if (null == a8) throw new s(`${o2}:no-cached-statistics`, "Cached statistics are not available for this layer");
  const d3 = r4.get(i4);
  if (null == d3) throw new s(`${o2}:field-unexisting`, `Field '${i4}' does not exist on the layer`);
  const h3 = a8.find((t8) => t8.name === d3.name);
  if (null == h3) throw new s(`${o2}:no-cached-statistics`, "Cached statistics for this attribute are not available");
  const m4 = V(n5, h3.href), { data: u4 } = await P(m4, { query: { f: "json", ...l5, token: c4 }, responseType: "json", signal: f3 });
  return u4;
}

// node_modules/@arcgis/core/support/zipUtils.js
async function e4(e5) {
  const r4 = [];
  for (const n5 of e5) n5.name.toLowerCase().endsWith(".zip") ? r4.push(t7(n5)) : r4.push(Promise.resolve(n5));
  return (await Promise.all(r4)).flat();
}
async function t7(e5) {
  const { BlobReader: t8, ZipReader: r4, BlobWriter: n5 } = await import("./zipjs-wrapper-AZB2EI46.js"), a8 = [], i4 = new r4(new t8(e5));
  return (await i4.getEntries()).forEach((e6) => {
    var _a;
    if (e6.directory || /^__MACOS/i.test(e6.filename)) return;
    const t9 = new n5(), r5 = (_a = e6.getData) == null ? void 0 : _a.call(e6, t9).then((t10) => new File([t10], e6.filename));
    r5 && a8.push(r5);
  }), Promise.all(a8);
}

// node_modules/@arcgis/core/layers/SceneLayer.js
var Le = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var je = s5();
var Fe = class extends a7(F(R(l2(b2(j3(t3(S2(e2(i(a4.ClonableMixin(f))))))))))) {
  constructor(...e5) {
    super(...e5), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V2(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e5, t8) {
    return "string" == typeof e5 ? { url: e5, ...t8 } : e5;
  }
  destroy() {
    this._set("renderer", null), this.associatedLayer = u(this.associatedLayer);
  }
  getField(e5) {
    return this.fieldsIndex.get(e5);
  }
  getFieldDomain(e5, t8) {
    var _a;
    const r4 = ((_a = this.getField(e5)) == null ? void 0 : _a.domain) ?? null;
    return this.associatedLayer ? N(this.associatedLayer, e5, t8, r4) : r4;
  }
  getFeatureType(e5) {
    return e5 && this.associatedLayer ? this.associatedLayer.getFeatureType(e5) : null;
  }
  get types() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.types) ?? [];
  }
  get typeIdField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.typeIdField) ?? null;
  }
  get templates() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.templates) ?? null;
  }
  get formTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.formTemplate) ?? null;
  }
  get attributeTableTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.attributeTableTemplate) ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e5, t8, r4) {
    return "Point" === t8.layerType && (e5 = t8.pointNodePages), null == e5 || "object" != typeof e5 ? null : p7.fromJSON(e5, r4);
  }
  set elevationInfo(e5) {
    this._set("elevationInfo", e5), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && Y(this.associatedLayer);
  }
  get geometryType() {
    return _e[this.profile] || "mesh";
  }
  set renderer(e5) {
    g2(e5, this.fieldsIndex), this._set("renderer", e5);
  }
  readCachedDrawingInfo(e5) {
    return null != e5 && "object" == typeof e5 || (e5 = {}), null == e5.color && (e5.color = false), e5;
  }
  get capabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e5) {
    var _a;
    e5 = null != e5 ? e5 : t6;
    const { query: t8, queryRelated: r4, editing: { supportsGlobalId: i4, supportsRollbackOnFailure: s7, supportsUploadWithItemId: o2, supportsGeometryUpdate: a8, supportsReturnServiceEditsInSourceSpatialReference: n5 }, data: { supportsZ: l5, supportsM: p10, isVersioned: d3, supportsAttachment: u4 }, operations: { supportsEditing: y2, supportsAdd: c4, supportsUpdate: h3, supportsDelete: f3, supportsQuery: m4, supportsQueryAttachments: g4, supportsAsyncConvert3D: v3 } } = e5, b5 = e5.operations.supportsChangeTracking, w3 = !!((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D);
    return { query: t8, queryRelated: r4, editing: { supportsGlobalId: i4, supportsReturnServiceEditsInSourceSpatialReference: n5, supportsRollbackOnFailure: s7, supportsGeometryUpdate: w3 && a8, supportsUploadWithItemId: o2 }, data: { supportsAttachment: u4, supportsZ: l5, supportsM: p10, isVersioned: d3 }, operations: { supportsQuery: m4, supportsQueryAttachments: g4, supportsEditing: y2 && b5, supportsAdd: w3 && c4 && b5, supportsDelete: w3 && f3 && b5, supportsUpdate: h3 && b5, supportsAsyncConvert3D: v3 } };
  }
  get editingEnabled() {
    var _a;
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : ((_a = this.associatedLayer) == null ? void 0 : _a.editingEnabled) ?? false;
  }
  set editingEnabled(e5) {
    this._overrideIfSome("editingEnabled", e5);
  }
  get infoFor3D() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) ?? null;
  }
  get relationships() {
    var _a;
    return (_a = this.associatedLayer) == null ? void 0 : _a.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e5, t8) {
    return !e5 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeOID" === t9.type && (e5 = t9.name), !!e5)), e5 || void 0;
  }
  readGlobalIdField(e5, t8) {
    return !e5 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeGlobalID" === t9.type && (e5 = t9.name), !!e5)), e5 || void 0;
  }
  get displayField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.displayField) ?? null;
  }
  readProfile(e5, t8) {
    const r4 = t8.store.profile;
    return null != r4 && Se[r4] ? Se[r4] : (n.getLogger(this).error("Unknown or missing profile", { profile: r4, layer: this }), "mesh-pyramids");
  }
  get useViewTime() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.useViewTime) ?? true;
  }
  set useViewTime(e5) {
    this._override("useViewTime", e5);
  }
  load(e5) {
    return this.addResolvingPromise(this._load(e5)), Promise.resolve(this);
  }
  async _load(e5) {
    const t8 = null != e5 ? e5.signal : null;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e5).catch(a2), await this._fetchService(t8), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t8), this._setAssociatedFeatureLayer(t8), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await this.loadTimeInfoFromService(e5), await t2(this, { origin: "service" }, t8), g2(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e5);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter) try {
      await this.filter.loadGeometries(this.spatialReference);
    } catch (e5) {
      n.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e5 }), this.filter = null;
    }
  }
  createQuery() {
    const e5 = new b3();
    return "mesh" === this.geometryType ? this.capabilities.query.supportsReturnMesh && (e5.returnGeometry = true) : (e5.returnGeometry = true, e5.returnZ = true), e5.where = this.definitionExpression || "1=1", e5.sqlFormat = "standard", e5.outFields = ["*"], e5;
  }
  queryExtent(e5, t8) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryExtent(e5 || this.createQuery(), t8));
  }
  queryFeatureCount(e5, t8) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatureCount(e5 || this.createQuery(), t8));
  }
  queryFeatures(e5, t8) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatures(e5 || this.createQuery(), t8)).then((e6) => {
      if (e6 == null ? void 0 : e6.features) for (const t9 of e6.features) t9.layer = this, t9.sourceLayer = this;
      return e6;
    });
  }
  async queryRelatedFeatures(e5, t8) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e5, t8);
  }
  async queryRelatedFeaturesCount(e5, t8) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e5, t8);
  }
  async queryCachedAttributes(e5, t8) {
    var _a;
    const r4 = h(this.fieldsIndex, await n4(this, p8(this)));
    return V3(((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "", this.attributeStorageInfo ?? [], e5, t8, r4, this.apiKey, this.customParameters);
  }
  async queryCachedFeature(e5, r4) {
    const i4 = await this.queryCachedAttributes(e5, [r4]);
    if (!i4 || 0 === i4.length) throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s7 = new b4();
    return s7.attributes = i4[0], s7.layer = this, s7.sourceLayer = this, s7;
  }
  queryObjectIds(e5, t8) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryObjectIds(e5 || this.createQuery(), t8));
  }
  queryAttachments(e5, t8) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryAttachments(e5, t8));
  }
  getFieldUsageInfo(e5) {
    const t8 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e5] || t8 : (n.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t8);
  }
  createPopupTemplate(e5) {
    return p6(this, e5);
  }
  _getAssociatedLayerForQuery() {
    const e5 = this.associatedLayer;
    return (e5 == null ? void 0 : e5.loaded) ? Promise.resolve(e5) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e5) {
      throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e5 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e5) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t8) => t8.name === e5);
  }
  async queryCachedStatistics(e5, t8) {
    return await this.load(t8), await this.fetchStatistics(e5, t8);
  }
  async saveAs(e5, t8) {
    return this._debouncedSaveOperations(V4.SAVE_AS, { ...t8, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e5);
  }
  async save() {
    const e5 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(V4.SAVE, e5);
  }
  async applyEdits(e5, t8) {
    const { applyEdits: r4 } = await import("./editingSupport-ALBRZ4DN.js");
    let i4 = t8;
    await this.load();
    const s7 = this.associatedLayer;
    if (!s7) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    await s7.load();
    const { globalIdField: a8 } = s7, n5 = !!s7.infoFor3D, l5 = (i4 == null ? void 0 : i4.globalIdUsed) ?? true;
    if (n5 && null == a8) throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (n5 && !l5) throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return g(s7.url) && n5 && null != e5.deleteFeatures && null != a8 && (i4 = { ...i4, globalIdToObjectId: await ne(s7, e5.deleteFeatures, a8) }), r4(this, s7.source, e5, i4);
  }
  async uploadAssets(e5, t8) {
    if (await this.load(), null == this.associatedLayer) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e5, t8);
  }
  on(e5, t8) {
    return super.on(e5, t8);
  }
  async convertMesh(e5, t8) {
    t8 ?? (t8 = {});
    const r4 = (e6) => {
      throw n.getLogger(this).error(".convertMesh()", e6.message), e6;
    };
    await this.load(), this.infoFor3D || r4(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
    const i4 = await this.extractAndFilterFiles(e5), s7 = i4.reduce((e6, t9) => r3(this.infoFor3D, t9) ? e6 + 1 : e6, 0);
    0 === s7 && r4(new i2()), s7 > 1 && r4(new m2());
    const n5 = this.spatialReference, l5 = t8.location ?? new j({ x: 0, y: 0, z: 0, spatialReference: n5 }), p10 = l5.spatialReference.isGeographic ? "local" : "georeferenced", { default: d3 } = await import("./Mesh-FISBWMLN.js"), u4 = d3.createWithExternalSource(l5, i4, { vertexSpace: p10, transform: t5(l5.spatialReference), unitConversionDisabled: true }), [y2] = await this.uploadAssets([u4], { ...t8, useAssetOrigin: !t8.location });
    return y2;
  }
  async extractAndFilterFiles(e5) {
    await this.load();
    const t8 = this.infoFor3D;
    if (!t8) return e5;
    return (await e4(e5)).filter((e6) => n2(t8, e6));
  }
  validateLayer(e5) {
    if (e5.layerType && !Le.has(e5.layerType)) throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e5.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t8(e6, t9) {
      let r4 = false, i4 = false;
      if (null == e6) r4 = true, i4 = true;
      else {
        const s7 = t9 && t9.isGeographic;
        switch (e6) {
          case "east-north-up":
          case "earth-centered":
            r4 = true, i4 = s7;
            break;
          case "vertex-reference-frame":
            r4 = true, i4 = !s7;
            break;
          default:
            r4 = false;
        }
      }
      if (!r4) throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i4) throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t8(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e5 = [];
    if ("points" === this.profile) e5.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile) throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e5.push("3DObject");
    }
    return e5;
  }
  _populateFieldUsageInfo() {
    var _a, _b, _c;
    if (this._fieldUsageInfo = {}, this.fields) for (const e5 of this.fields) {
      const t8 = !!((_a = this.attributeStorageInfo) == null ? void 0 : _a.some((t9) => t9.name === e5.name)), r4 = !!((_c = (_b = this.associatedLayer) == null ? void 0 : _b.fields) == null ? void 0 : _c.some((t9) => t9 && e5.name === t9.name)), i4 = { supportsLabelingInfo: t8, supportsRenderer: t8, supportsPopupTemplate: t8 || r4, supportsLayerQuery: r4 };
      this._fieldUsageInfo[e5.name] = i4;
    }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    var _a;
    if (!((_a = this.associatedLayer) == null ? void 0 : _a.fields)) return;
    let e5 = null;
    for (const t8 of this.associatedLayer.fields) {
      const r4 = this.getField(t8.name);
      r4 ? (!r4.domain && t8.domain && (r4.domain = t8.domain.clone()), r4.editable = t8.editable, r4.nullable = t8.nullable, r4.length = t8.length) : (e5 || (e5 = this.fields ? this.fields.slice() : []), e5.push(t8.clone()));
    }
    e5 && this._set("fields", e5);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer) return;
    const e5 = ["popupTemplate", "popupEnabled"], t8 = t(this);
    for (let r4 = 0; r4 < e5.length; r4++) {
      const i4 = e5[r4], s7 = this.originIdOf(i4), o2 = this.associatedLayer.originIdOf(i4);
      s7 < o2 && (o2 === e.SERVICE || o2 === e.PORTAL_ITEM) && t8.setAtOrigin(i4, this.associatedLayer[i4], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    var _a, _b, _c;
    const e5 = (_a = this.associatedLayer) == null ? void 0 : _a.getAtOrigin("fullExtent", "service");
    if (null == ((_b = this.associatedLayer) == null ? void 0 : _b.infoFor3D) || !e5 || !g((_c = this.associatedLayer) == null ? void 0 : _c.url) || !e3(this)) return;
    t(this).setAtOrigin("fullExtent", e5.clone(), e.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e5 = this.associatedLayer;
    e5 && (this._set("userHasEditingPrivileges", e5.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e5.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e5.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e5) {
    if (["mesh-pyramids", "points"].includes(this.profile)) try {
      const { serverUrl: t8, layerId: r4, portalItem: i4 } = await s3(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, customParameters: this.customParameters, apiKey: this.apiKey, signal: e5 }), s7 = await a6.FeatureLayer();
      this.associatedLayer = new s7({ url: t8, customParameters: this.customParameters, layerId: r4, portalItem: i4 }), await this.associatedLayer.load();
    } catch (t8) {
      b(t8) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    await w(() => this.popupEnabled && null != this.popupTemplate);
    const e5 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? n.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e5}`) : n.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e5}`);
  }
  _validateElevationInfo() {
    const e5 = this.elevationInfo;
    "mesh-pyramids" === this.profile && $(n.getLogger(this), P2("Mesh scene layers", "relative-to-scene", e5)), $(n.getLogger(this), w2("Scene layers", e5));
  }
  async fetchStatistics(e5, t8) {
    var _a;
    return await i3({ fieldName: e5, statisticsInfo: this.statisticsInfo, errorContext: "scenelayer", fieldsIndex: this.fieldsIndex, path: ((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "", customParameters: this.customParameters, apiKey: this.apiKey, signal: t8 == null ? void 0 : t8.signal });
  }
};
r([m({ types: { key: "type", base: t4, typeMap: { selection: p5 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], Fe.prototype, "featureReduction", void 0), r([m({ type: [s6], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], Fe.prototype, "rangeInfos", void 0), r([m({ json: { read: false } })], Fe.prototype, "associatedLayer", void 0), r([m({ type: ["show", "hide"] })], Fe.prototype, "listMode", void 0), r([m({ type: ["ArcGISSceneServiceLayer"] })], Fe.prototype, "operationalLayerType", void 0), r([m({ json: { read: false }, readOnly: true })], Fe.prototype, "type", void 0), r([m({ ...je.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Fe.prototype, "fields", void 0), r([m()], Fe.prototype, "types", null), r([m()], Fe.prototype, "typeIdField", null), r([m()], Fe.prototype, "templates", null), r([m()], Fe.prototype, "formTemplate", null), r([m()], Fe.prototype, "attributeTableTemplate", null), r([m({ readOnly: true, clonable: false })], Fe.prototype, "fieldsIndex", null), r([m({ type: p4, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], Fe.prototype, "floorInfo", void 0), r([m(je.outFields)], Fe.prototype, "outFields", void 0), r([m({ type: p7, readOnly: true, json: { read: false } })], Fe.prototype, "nodePages", void 0), r([o("service", "nodePages", ["nodePages", "pointNodePages"])], Fe.prototype, "readNodePages", null), r([m({ type: [a5], readOnly: true })], Fe.prototype, "materialDefinitions", void 0), r([m({ type: [y], readOnly: true })], Fe.prototype, "textureSetDefinitions", void 0), r([m({ type: [m3], readOnly: true })], Fe.prototype, "geometryDefinitions", void 0), r([m({ readOnly: true })], Fe.prototype, "serviceUpdateTimeStamp", void 0), r([m({ readOnly: true })], Fe.prototype, "attributeStorageInfo", void 0), r([m({ readOnly: true })], Fe.prototype, "statisticsInfo", void 0), r([m({ type: V2.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], Fe.prototype, "excludeObjectIds", void 0), r([m({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], Fe.prototype, "definitionExpression", void 0), r([m({ type: h2, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], Fe.prototype, "filter", void 0), r([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Fe.prototype, "path", void 0), r([m(c)], Fe.prototype, "elevationInfo", null), r([m({ readOnly: true, json: { read: false } })], Fe.prototype, "effectiveCapabilities", null), r([m({ readOnly: true })], Fe.prototype, "effectiveEditingEnabled", null), r([m({ type: String })], Fe.prototype, "geometryType", null), r([m(p3)], Fe.prototype, "labelsVisible", void 0), r([m({ type: [C2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: n3 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: n3 }, write: true } })], Fe.prototype, "labelingInfo", void 0), r([m(d)], Fe.prototype, "legendEnabled", void 0), r([m({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e5, t8) {
  var _a, _b;
  if ("number" == typeof e5 && e5 >= 0 && e5 <= 1) return e5;
  const r4 = (_b = (_a = t8.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r4 ? r2(r4) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], Fe.prototype, "opacity", void 0), r([m({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Fe.prototype, "priority", void 0), r([m({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Fe.prototype, "semantic", void 0), r([m({ types: u2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], Fe.prototype, "renderer", null), r([m({ json: { read: false } })], Fe.prototype, "cachedDrawingInfo", void 0), r([o("service", "cachedDrawingInfo")], Fe.prototype, "readCachedDrawingInfo", null), r([m({ readOnly: true, json: { read: false } })], Fe.prototype, "capabilities", null), r([m({ type: Boolean, json: { read: false } })], Fe.prototype, "editingEnabled", null), r([m({ readOnly: true, json: { write: false, read: false } })], Fe.prototype, "infoFor3D", null), r([m({ readOnly: true, json: { write: false, read: false } })], Fe.prototype, "relationships", null), r([m(l)], Fe.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], Fe.prototype, "popupTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], Fe.prototype, "defaultPopupTemplate", null), r([m({ type: String, json: { read: false } })], Fe.prototype, "objectIdField", void 0), r([o("service", "objectIdField", ["objectIdField", "fields"])], Fe.prototype, "readObjectIdField", null), r([m({ type: String, json: { read: false } })], Fe.prototype, "globalIdField", void 0), r([o("service", "globalIdField", ["globalIdField", "fields"])], Fe.prototype, "readGlobalIdField", null), r([m({ readOnly: true, type: String, json: { read: false } })], Fe.prototype, "displayField", null), r([m({ type: String, json: { read: false } })], Fe.prototype, "profile", void 0), r([o("service", "profile", ["store.profile"])], Fe.prototype, "readProfile", null), r([m({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], Fe.prototype, "normalReferenceFrame", void 0), r([m(s4)], Fe.prototype, "screenSizePerspectiveEnabled", void 0), r([m({ json: { read: false, origins: { service: { read: true } } } })], Fe.prototype, "serviceItemId", void 0), r([m(f2)], Fe.prototype, "useViewTime", null), Fe = r([a3("esri.layers.SceneLayer")], Fe);
var Se = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var _e = { "mesh-pyramids": "mesh", points: "point" };
var Ae = Fe;
export {
  Ae as default
};
//# sourceMappingURL=SceneLayer-BOL4BBCZ.js.map
