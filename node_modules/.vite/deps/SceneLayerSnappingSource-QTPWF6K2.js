import {
  r as r3
} from "./chunk-FNR27W4O.js";
import {
  r as r2
} from "./chunk-V34X57N3.js";
import "./chunk-OSI4PMXO.js";
import "./chunk-TFOTFKYE.js";
import "./chunk-3T6XYN2R.js";
import {
  a as a3,
  p
} from "./chunk-6IYG6BTI.js";
import "./chunk-TWM4KR2X.js";
import "./chunk-LULXSZFE.js";
import {
  h as h2
} from "./chunk-G4TWQWZ5.js";
import "./chunk-ZGGC3KHK.js";
import {
  V
} from "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import {
  t
} from "./chunk-JPRFCG7I.js";
import {
  f
} from "./chunk-YBPXQBRJ.js";
import "./chunk-KYY6OGOF.js";
import "./chunk-O647AAAL.js";
import "./chunk-BBNY45W4.js";
import "./chunk-BG4BZEWI.js";
import "./chunk-HE2KJFY5.js";
import "./chunk-MFRTZACF.js";
import "./chunk-374VFTLO.js";
import "./chunk-OBVDE24U.js";
import "./chunk-HYT6FDCG.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import "./chunk-QAWD6UDA.js";
import "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-PJIFP7OJ.js";
import "./chunk-QNYMCEB7.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-ON7GWFUW.js";
import {
  h
} from "./chunk-VPRLLNNO.js";
import "./chunk-SB6LU3VH.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-GPMU6IW4.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-JOQ2ZFQV.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-RAVPBO4Z.js";
import {
  n
} from "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  g,
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  c2 as c,
  e,
  i,
  l,
  s as s2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import {
  G,
  a2 as a,
  s2 as s
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/EdgeWorkerHandle.js
var a4 = class extends h2 {
  constructor(e2) {
    super("EdgeProcessingWorker", "extract", { extract: (e3) => [e3.dataBuffer], extractComponentsEdgeLocations: (e3) => [e3.dataBuffer], extractEdgeLocations: (e3) => [e3.dataBuffer] }, e2);
  }
  async process(e2, t2, r4) {
    if (r4) return f(e2);
    return i2(await this.invoke(new o(e2), t2));
  }
  async extractEdgeLocations(e2, t2) {
    const r4 = await this.invokeMethod("extractEdgeLocations", new o(e2), t2);
    return t(r4);
  }
  async extractComponentsEdgeLocations(e2, t2) {
    const r4 = await this.invokeMethod("extractComponentsEdgeLocations", new o(e2), t2);
    return t(r4);
  }
};
function i2(e2) {
  return { regular: { instancesData: t(e2.regular.instancesData), lodInfo: { lengths: new Float32Array(e2.regular.lodInfo.lengths) } }, silhouette: { instancesData: t(e2.silhouette.instancesData), lodInfo: { lengths: new Float32Array(e2.silhouette.lodInfo.lengths) } }, averageEdgeLength: e2.averageEdgeLength };
}
var o = class {
  constructor(r4) {
    this.dataBuffer = r4.data.buffer, this.writerSettings = r4.writerSettings, this.skipDeduplicate = r4.skipDeduplicate, this.indices = s(r4.indices) ? r4.indices.buffer : r4.indices, this.indicesType = s(r4.indices) ? a(r4.indices) ? "Uint32Array" : "Uint16Array" : "Array", this.indicesLength = r4.indicesLength;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorkerHandle.js
var l2 = class extends g {
  constructor(e2) {
    super(e2), this.availability = 0, this._ids = /* @__PURE__ */ new Set();
  }
  destroy() {
    this._workerHandle.destroy(), this._workerHandle = null;
  }
  initialize() {
    this._workerHandle = new h3(this.schedule, { fetchAllEdgeLocations: (e2, t2) => this._fetchAllEdgeLocations(e2, t2) });
  }
  async fetchCandidates(e2, t2) {
    const r4 = e2.coordinateHelper, { point: o2 } = e2, s3 = u;
    this.renderCoordsHelper.toRenderCoords(o2, r4.spatialReference, s3);
    const n2 = e2.distance, a5 = "number" == typeof n2 ? n2 : n2.distance, d = await this._workerHandle.invoke({ bounds: V(s3[0], s3[1], s3[2], a5), returnEdge: e2.returnEdge, returnVertex: "none" !== e2.vertexMode }, t2);
    return d.candidates.sort((e3, t3) => e3.distance - t3.distance), d.candidates.map((e3) => this._convertCandidate(r4, e3));
  }
  async add(e2, t2) {
    this._ids.add(e2.id), await this._workerHandle.invokeMethod("add", e2, t2);
  }
  async remove(e2, t2) {
    this._ids.delete(e2.id), await this._workerHandle.invokeMethod("remove", e2, t2);
  }
  _convertCandidate(e2, t2) {
    switch (t2.type) {
      case "edge":
        return new r2({ objectId: t2.objectId, targetPoint: p(this._convertRenderCoordinate(e2, t2.target)), edgeStart: this._convertRenderCoordinate(e2, t2.start), edgeEnd: this._convertRenderCoordinate(e2, t2.end), isDraped: false });
      case "vertex":
        return new r3({ objectId: t2.objectId, targetPoint: p(this._convertRenderCoordinate(e2, t2.target)), isDraped: false });
    }
  }
  _convertRenderCoordinate({ spatialReference: e2 }, t2) {
    const r4 = n();
    return this.renderCoordsHelper.fromRenderCoords(t2, r4, e2), a3(r4);
  }
  async _fetchAllEdgeLocations(e2, t2) {
    const r4 = [], o2 = [];
    for (const { id: s3, uid: n2 } of e2.components) this._ids.has(s3) && r4.push((async () => {
      const e3 = await this.fetchEdgeLocations(s3, t2.signal), r5 = e3.locations.buffer;
      return o2.push(r5), { id: s3, uid: n2, objectIds: e3.objectIds, locations: r5, origin: e3.origin, type: e3.type };
    })());
    return { result: { components: (await Promise.all(r4)).filter(({ id: e3 }) => this._ids.has(e3)) }, transferList: o2 };
  }
};
r([m({ constructOnly: true })], l2.prototype, "renderCoordsHelper", void 0), r([m({ constructOnly: true })], l2.prototype, "fetchEdgeLocations", void 0), r([m({ constructOnly: true })], l2.prototype, "schedule", void 0), r([m({ readOnly: true })], l2.prototype, "availability", void 0), l2 = r([a2("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorkerHandle")], l2);
var h3 = class extends h2 {
  constructor(e2, t2) {
    super("SceneLayerSnappingSourceWorker", "fetchCandidates", {}, e2, { strategy: "dedicated", client: t2 });
  }
};
var u = n();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/I3SSnappingSource.js
var p2 = class extends g {
  get updating() {
    return this._updatingHandles.updating;
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._updatingHandles = new h(), this._abortController = new AbortController();
  }
  destroy() {
    this._tracker = l(this._tracker), this._abortController = e(this._abortController), this._updatingHandles.destroy();
  }
  initialize() {
    const { view: e2 } = this, r4 = e2.resourceController;
    this._edgeWorker = new a4(h4(r4)), this._workerHandle = new l2({ renderCoordsHelper: this.view.renderCoordsHelper, schedule: h4(r4), fetchEdgeLocations: async (e3, r5) => {
      if (null == this._tracker) throw new Error("tracker-not-initialized");
      return this._tracker.fetchEdgeLocations(e3, this._edgeWorker, r5);
    } }), this._updatingHandles.addPromise(this._setupLayerView()), this.addHandles([i(this._workerHandle), i(this._edgeWorker)]);
  }
  async fetchCandidates(e2, r4) {
    return this._workerHandle.fetchCandidates(e2, r4);
  }
  refresh() {
  }
  async _setupLayerView() {
    var _a;
    if (this.destroyed) return;
    const e2 = (_a = this._abortController) == null ? void 0 : _a.signal, r4 = await this.getLayerView();
    null == r4 || c(e2) || (this._tracker = r4.trackSnappingSources({ add: (r5, t2) => {
      this._updatingHandles.addPromise(this._workerHandle.add({ id: r5, bounds: t2 }, e2));
    }, remove: (r5) => {
      this._updatingHandles.addPromise(this._workerHandle.remove({ id: r5 }, e2));
    } }));
  }
};
function h4(e2) {
  return (r4) => e2.immediate.schedule(r4);
}
r([m({ constructOnly: true })], p2.prototype, "getLayerView", void 0), r([m({ constructOnly: true })], p2.prototype, "view", void 0), r([m({ readOnly: true })], p2.prototype, "updating", null), r([m({ readOnly: true })], p2.prototype, "availability", void 0), p2 = r([a2("esri.views.interactive.snapping.featureSources.I3SSnappingSource")], p2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/SceneLayerSnappingSource.js
var c2 = class extends g {
  get updating() {
    return this._i3sSources.some((e2) => e2.updating);
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._i3sSources = [];
  }
  destroy() {
    this._i3sSources.forEach((e2) => e2.destroy()), this._i3sSources.length = 0;
  }
  initialize() {
    const { view: e2 } = this, r4 = this.layerSource.layer;
    this._i3sSources = "building-scene" === r4.type ? this._getBuildingSceneI3SSources(e2, r4) : [this._getSceneLayerI3SSource(e2, r4)];
  }
  async fetchCandidates(e2, r4) {
    const t2 = await Promise.all(this._i3sSources.map((t3) => t3.fetchCandidates(e2, r4)));
    return s2(r4), t2.flat();
  }
  refresh() {
    this._i3sSources.forEach((e2) => e2.refresh());
  }
  _getBuildingSceneI3SSources(e2, r4) {
    return r4.allSublayers.toArray().map((t2) => "building-component" === t2.type ? new p2({ getLayerView: async () => (await e2.whenLayerView(r4)).whenSublayerView(t2), view: e2 }) : null).filter(G);
  }
  _getSceneLayerI3SSource(e2, r4) {
    return new p2({ getLayerView: async () => {
      const t2 = await e2.whenLayerView(r4);
      return "scene-layer-graphics-3d" === t2.type ? void 0 : t2;
    }, view: e2 });
  }
};
r([m({ constructOnly: true })], c2.prototype, "layerSource", void 0), r([m({ constructOnly: true })], c2.prototype, "view", void 0), r([m({ readOnly: true })], c2.prototype, "updating", null), r([m({ readOnly: true })], c2.prototype, "availability", void 0), c2 = r([a2("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")], c2);
export {
  c2 as SceneLayerSnappingSource
};
//# sourceMappingURL=SceneLayerSnappingSource-QTPWF6K2.js.map
