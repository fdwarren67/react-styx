import "./chunk-G4TWQWZ5.js";
import "./chunk-TS22YKT7.js";
import "./chunk-GZUQTA6H.js";
import "./chunk-MAX4GY2G.js";
import "./chunk-OITDZHA4.js";
import "./chunk-ZGGC3KHK.js";
import "./chunk-UM5QMFZV.js";
import "./chunk-MD2QBQPV.js";
import "./chunk-CBFRSYD6.js";
import "./chunk-2CY5SLAC.js";
import "./chunk-LQHBJ3TA.js";
import "./chunk-MKVF6I7G.js";
import "./chunk-457CK7GN.js";
import "./chunk-EVDBYOW7.js";
import "./chunk-QQOUESXA.js";
import "./chunk-EQ5WRTBD.js";
import "./chunk-6QXEI4OT.js";
import "./chunk-55SEMSMA.js";
import "./chunk-BUZ7I3MJ.js";
import "./chunk-I7JIAECC.js";
import "./chunk-ZXD5CGBL.js";
import "./chunk-CUWQEJ5X.js";
import "./chunk-NE7GYHUP.js";
import "./chunk-EXHR7CRN.js";
import "./chunk-HX6OAJGI.js";
import "./chunk-F64YCQYI.js";
import "./chunk-3L7KPDW7.js";
import "./chunk-HYT6FDCG.js";
import {
  d,
  n as n4
} from "./chunk-JGZQANAC.js";
import "./chunk-MRUZJ4BJ.js";
import {
  a,
  n as n3
} from "./chunk-H2QUYHU5.js";
import "./chunk-YZF7OTID.js";
import "./chunk-KLBFJ6WQ.js";
import "./chunk-HHSHKUKB.js";
import "./chunk-OBRCQKKM.js";
import "./chunk-6WERKJTM.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-FWVSIQMR.js";
import "./chunk-ON7GWFUW.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-LILYILCM.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-SPVEONZ2.js";
import {
  n as n2
} from "./chunk-D3P3E2RE.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  T
} from "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import {
  n
} from "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import {
  r
} from "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n5;
var e;
!function(n10) {
  n10[n10.None = 0] = "None", n10[n10.Int16 = 1] = "Int16", n10[n10.Int32 = 2] = "Int32";
}(n5 || (n5 = {})), function(n10) {
  n10[n10.Replace = 0] = "Replace", n10[n10.Outside = 1] = "Outside", n10[n10.Inside = 2] = "Inside", n10[n10.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n6 || (n6 = new Promise((t) => import("./i3s-U3WFAFLN.js").then((t2) => t2.i).then(({ default: e4 }) => {
    const n10 = e4({ locateFile: i, onRuntimeInitialized: () => t(n10) });
    delete n10.then;
  })).catch((t) => {
    throw t;
  })), n6;
}
function i(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n6;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var n9 = class {
  constructor(s, e4, t, o2, r4, i2) {
    this.layout = s, this.interleavedVertexData = e4, this.indices = t, this.hasColors = o2, this.hasModifications = r4, this.positionData = i2;
  }
};
var p = class {
  constructor(s, e4, t, o2, r4, i2, h3) {
    this.componentOffsets = s, this.featureIds = e4, this.anchorIds = t, this.anchors = o2, this.transformedGeometry = r4, this.globalTrafo = i2, this.obb = h3;
  }
};
var u = new r({ deallocator: null });
var c = n2();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r3;
var a2;
var d2;
var c2;
!function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
}(o || (o = {})), function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
}(r3 || (r3 = {}));
!function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
}(a2 || (a2 = {})), function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(d2 || (d2 = {})), function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
}(c2 || (c2 = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function u2(e4) {
  E = await M();
  const r4 = [e4.geometryBuffer];
  return { result: A(E, e4, r4), transferList: r4 };
}
async function m(e4) {
  var _a;
  E = await M();
  const r4 = [e4.geometryBuffer], { geometryBuffer: t } = e4, o2 = t.byteLength, n10 = E._malloc(o2), s = new Uint8Array(E.HEAPU8.buffer, n10, o2);
  s.set(new Uint8Array(t));
  const i2 = E.dracoDecompressPointCloudData(n10, s.byteLength);
  if (E._free(n10), i2.error.length > 0) throw new Error(`i3s.wasm: ${i2.error}`);
  const a3 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f = i2.positions.slice();
  return a3 && r4.push(a3.buffer), r4.push(f.buffer), { result: { positions: f, featureIds: a3 }, transferList: r4 };
}
async function y(e4) {
  await M(), S(e4);
  const r4 = { buffer: e4.buffer };
  return { result: r4, transferList: [r4.buffer] };
}
async function p2(e4) {
  await M(), j(e4);
}
async function d3(e4) {
  E = await M(), E.setLegacySchema(e4.context, e4.jsonSchema);
}
async function h2(e4) {
  const { localMatrix: n10, origin: s, positions: i2, vertexSpace: a3 } = e4, f = g.fromJSON(e4.inSpatialReference), c3 = g.fromJSON(e4.outSpatialReference);
  let l;
  const [{ projectBuffer: u3 }, { initializeProjection: m2 }] = await Promise.all([import("./projectBuffer-465CLJFQ.js"), import("./projection-MXTSGSE5.js")]);
  await m2(f, c3);
  const y2 = [0, 0, 0];
  if (!u3(s, f, 0, y2, c3, 0)) throw new Error("Failed to project");
  if ("georeferenced" === a3.type && null == a3.origin) {
    if (l = new Float64Array(i2.length), !u3(i2, f, 0, l, c3, 0, l.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === a3.type ? n3.fromJSON(a3) : a.fromJSON(a3), { projectMeshVertexPositions: r4 } = await import("./projectMeshVertexPositions-VHGBXAIU.js"), s2 = r4({ vertexAttributes: { position: i2 }, transform: n10 ? { localMatrix: n10 } : void 0, vertexSpace: e5, spatialReference: f }, c3);
    if (!s2) throw new Error("Failed to project");
    l = s2;
  }
  const p3 = l.length, [d4, h3, b2] = y2;
  for (let r4 = 0; r4 < p3; r4 += 3) l[r4] -= d4, l[r4 + 1] -= h3, l[r4 + 2] -= b2;
  return { result: { projected: l, original: i2, projectedOrigin: y2 }, transferList: [l.buffer, i2.buffer] };
}
async function b({ normalMatrix: r4, normals: t }) {
  const o2 = new Float32Array(t.length);
  return n4(o2, t, r4), T(r4) && d(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function g2(e4) {
  x(e4);
}
var w;
var E;
function j(e4) {
  if (!E) return;
  const r4 = e4.modifications, t = E._malloc(8 * r4.length), o2 = new Float64Array(E.HEAPU8.buffer, t, r4.length);
  for (let n10 = 0; n10 < r4.length; ++n10) o2[n10] = r4[n10];
  E.setModifications(e4.context, t, r4.length, e4.isGeodetic), E._free(t);
}
function A(e4, r4, t) {
  const { context: o2, globalTrafo: n10, mbs: s, obbData: a3, elevationOffset: l, geometryBuffer: u3, geometryDescriptor: m2, indexToVertexProjector: y2, vertexToRenderProjector: p3 } = r4, d4 = e4._malloc(u3.byteLength), h3 = 33, b2 = e4._malloc(h3 * Float64Array.BYTES_PER_ELEMENT), g3 = new Uint8Array(e4.HEAPU8.buffer, d4, u3.byteLength);
  g3.set(new Uint8Array(u3));
  const w2 = new Float64Array(e4.HEAPU8.buffer, b2, h3);
  _(w2, [NaN, NaN, NaN]);
  let E2 = w2.byteOffset + 3 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2);
  _(j2, n10), E2 += 16 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2), _(j2, s), E2 += 4 * w2.BYTES_PER_ELEMENT, a3 && (j2 = new Float64Array(w2.buffer, E2), _(j2, a3));
  const A2 = m2, L3 = { isDraco: false, isLegacy: false, color: r4.layouts.some((e5) => e5.some((e6) => "color" === e6.name)), normal: r4.needNormals && r4.layouts.some((e5) => e5.some((e6) => "normalCompressed" === e6.name)), uv0: r4.layouts.some((e5) => e5.some((e6) => "uv0" === e6.name)), uvRegion: r4.layouts.some((e5) => e5.some((e6) => "uvRegion" === e6.name)), featureIndex: A2.featureIndex }, S2 = e4.process(o2, !!r4.obbData, d4, g3.byteLength, A2, L3, b2, l, y2, p3, r4.normalReferenceFrame);
  if (e4._free(b2), e4._free(d4), S2.error.length > 0) throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded) return null;
  const x2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, P2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, M2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, N2 = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, U = S2.interleavedVertedData.slice().buffer, I = S2.indicesType === n5.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), F = S2.positions.slice(), { buffer: T2, byteOffset: B, byteLength: O } = S2.positionIndices, R = S2.positionIndicesType === n5.Int16 ? new Uint16Array(T2, B, O / 2).slice() : new Uint32Array(T2, B, O / 4).slice(), v = new n9(r4.layouts[0], U, I, S2.hasColors, S2.hasModifications, { data: F, indices: R });
  return P2 && t.push(P2.buffer), x2 && t.push(x2.buffer), t.push(U), t.push(I.buffer), t.push(F.buffer), t.push(R.buffer), new p(x2, P2, M2, N2, v, n10, S2.obb);
}
function L2(e4) {
  return 0 === e4 ? r3.Unmodified : 1 === e4 ? r3.PotentiallyModified : 2 === e4 ? r3.Culled : r3.Unknown;
}
function S(e4) {
  if (!E) return;
  const { context: r4, buffer: t } = e4, o2 = E._malloc(t.byteLength), n10 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(E.HEAPU8.buffer, o2, n10), i2 = new Float64Array(t);
  s.set(i2), E.filterOBBs(r4, o2, n10), i2.set(s), E._free(o2);
}
function x(e4) {
  E && 0 === E.destroy(e4) && (E = null);
}
function _(e4, r4) {
  for (let t = 0; t < r4.length; ++t) e4[t] = r4[t];
}
async function P() {
  E || await M();
}
async function M() {
  return E || (E = await (w ?? (w = e2()))), E;
}
var N = { transform: (e4, r4) => E && A(E, e4, r4), destroy: x };
export {
  g2 as destroyContext,
  m as dracoDecompressPointCloudData,
  y as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  P as initialize,
  L2 as interpretObbModificationResults,
  u2 as process,
  h2 as project,
  d3 as setLegacySchema,
  p2 as setModifications,
  j as setModificationsSync,
  N as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-D46AKC5V.js.map
