import {
  p as p3
} from "./chunk-QNWGXX56.js";
import "./chunk-XIL65DCI.js";
import {
  T
} from "./chunk-3TEY2BPT.js";
import {
  l
} from "./chunk-PVSDTWLJ.js";
import "./chunk-PQUUCIML.js";
import "./chunk-NBFYN6KG.js";
import "./chunk-23WGP47N.js";
import "./chunk-E7IFPXEX.js";
import "./chunk-OBVDE24U.js";
import "./chunk-EKEKHPBG.js";
import "./chunk-RDHJUEBL.js";
import {
  e
} from "./chunk-XD7AJMUV.js";
import {
  t as t2
} from "./chunk-AU4QUDF3.js";
import "./chunk-QBRBJ5XN.js";
import {
  e as e2
} from "./chunk-WMLTK6KE.js";
import "./chunk-PONPGREB.js";
import "./chunk-QNYMCEB7.js";
import {
  p as p2,
  z
} from "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import {
  i
} from "./chunk-5GYWQFHA.js";
import {
  l as l2
} from "./chunk-WOB72RZU.js";
import {
  e as e3
} from "./chunk-RTA3XNM7.js";
import "./chunk-OQEC2EUK.js";
import {
  j as j3
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f2
} from "./chunk-73NNNHMH.js";
import {
  b as b3
} from "./chunk-C6YDI6QX.js";
import "./chunk-DJ5HVIE7.js";
import {
  S
} from "./chunk-KPY4ZIC2.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-GSNLF6RP.js";
import {
  p
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import {
  d
} from "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import {
  j,
  j2
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  U,
  h
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import {
  r as r3
} from "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  x
} from "./chunk-BECTSF5P.js";
import {
  Et,
  I,
  K,
  Rt,
  V,
  Y,
  b as b2,
  bt,
  pt,
  s as s3,
  v
} from "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  m as m2
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a as a2,
  b,
  c2 as c,
  m,
  s as s2,
  u as u2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r as r2
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  r
} from "./chunk-7LCEUMDD.js";
import {
  a,
  n2
} from "./chunk-6II7WQ2F.js";
import {
  n2 as n,
  u
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A = null;
function o2(o4) {
  if (A) return A;
  const l6 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A = new Promise((A3) => {
    const n4 = new Image();
    n4.onload = () => {
      n4.onload = n4.onerror = null, A3(n4.width > 0 && n4.height > 0);
    }, n4.onerror = () => {
      n4.onload = n4.onerror = null, A3(false);
    }, n4.src = "data:image/webp;base64," + l6[o4];
  }), A;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h2 = 1.15;
var n3 = class {
  constructor(t3, e4) {
    this._spriteSource = t3, this._maxTextureSize = e4, this.devicePixelRatio = 1, this._spriteImageFormat = "png", this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded", "url" === t3.type && t3.spriteFormat && (this._spriteImageFormat = t3.spriteFormat), t3.pixelRatio && (this.devicePixelRatio = t3.pixelRatio), this.baseURL = t3.spriteUrl;
  }
  get spriteNames() {
    const t3 = [];
    for (const e4 in this._spritesData) t3.push(e4);
    return t3.sort(), t3;
  }
  getSpriteInfo(t3) {
    return this._spritesData ? this._spritesData[t3] : null;
  }
  async load(t3) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t3), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else this.loadStatus = "failed";
  }
  async _loadSprites(t3) {
    this._isRetina = this.devicePixelRatio > h2;
    const { width: s5, height: r5, data: a5, json: o4 } = await this._getSpriteData(this._spriteSource, t3), n4 = Object.keys(o4);
    if (!n4 || 0 === n4.length || !a5) return this._spritesData = this.image = null, void (this.width = this.height = 0);
    this._spritesData = o4, this.width = s5, this.height = r5;
    const d4 = Math.max(this._maxTextureSize, 4096);
    if (s5 > d4 || r5 > d4) {
      const t4 = `Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${d4} pixels}`;
      throw n2.getLogger("esri.layers.support.SpriteSource").error(t4), new s("SpriteSource", t4);
    }
    let p5;
    for (let e4 = 0; e4 < a5.length; e4 += 4) p5 = a5[e4 + 3] / 255, a5[e4] = a5[e4] * p5, a5[e4 + 1] = a5[e4 + 1] * p5, a5[e4 + 2] = a5[e4 + 2] * p5;
    this.image = a5;
  }
  async _getSpriteData(i2, n4) {
    if ("image" === i2.type) {
      let t3, a5;
      if (this.devicePixelRatio < h2) {
        if (!i2.spriteSource1x) throw new s("SpriteSource", "no image data provided for low resolution sprites!");
        t3 = i2.spriteSource1x.image, a5 = i2.spriteSource1x.json;
      } else {
        if (!i2.spriteSource2x) throw new s("SpriteSource", "no image data provided for high resolution sprites!");
        t3 = i2.spriteSource2x.image, a5 = i2.spriteSource2x.json;
      }
      return "width" in t3 && "height" in t3 && "data" in t3 && (n(t3.data) || u(t3.data)) ? { width: t3.width, height: t3.height, data: new Uint8Array(t3.data), json: a5 } : { ...d2(t3), json: a5 };
    }
    const p5 = I(this.baseURL), l6 = p5.query ? "?" + v(p5.query) : "", g3 = this._isRetina ? "@2x" : "", u3 = `${p5.path}${g3}.${this._spriteImageFormat}${l6}`, c3 = `${p5.path}${g3}.json${l6}`, [m4, S3] = await Promise.all([P(c3, n4), P(u3, { responseType: "image", ...n4 })]);
    return { ...d2(S3.data), json: m4.data };
  }
};
function d2(t3) {
  const e4 = document.createElement("canvas"), i2 = e4.getContext("2d");
  e4.width = t3.width, e4.height = t3.height, i2.drawImage(t3, 0, 0, t3.width, t3.height);
  const s5 = i2.getImageData(0, 0, t3.width, t3.height);
  return { width: t3.width, height: t3.height, data: new Uint8Array(s5.data) };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l3 = class {
  constructor(e4) {
    this.url = e4;
  }
  destroy() {
    this._tileIndexPromise = null;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = P(this.url).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  async dataKey(e4, r5) {
    const l6 = await this.fetchTileIndex();
    return s2(r5), this._getIndexedDataKey(l6, e4);
  }
  _getIndexedDataKey(e4, t3) {
    const l6 = [t3];
    if (t3.level < 0 || t3.row < 0 || t3.col < 0 || t3.row >> t3.level > 0 || t3.col >> t3.level > 0) return null;
    let i2 = t3;
    for (; 0 !== i2.level; ) i2 = new e2(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l6.push(i2);
    let o4, s5, n4 = e4, a5 = l6.pop();
    if (1 === n4) return a5;
    for (; l6.length; ) if (o4 = l6.pop(), s5 = (1 & o4.col) + ((1 & o4.row) << 1), n4) {
      if (0 === n4[s5]) {
        a5 = null;
        break;
      }
      if (1 === n4[s5]) {
        a5 = o4;
        break;
      }
      a5 = o4, n4 = n4[s5];
    }
    return a5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var l4 = class {
  constructor(e4, t3) {
    this._tilemap = e4, this._tileIndexUrl = t3;
  }
  destroy() {
    this._tilemap = u2(this._tilemap), this._tileIndexPromise = null;
  }
  async fetchTileIndex(t3) {
    return this._tileIndexPromise || (this._tileIndexPromise = P(this._tileIndexUrl, { query: { ...t3 == null ? void 0 : t3.query } }).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  dataKey(e4, t3) {
    const { level: l6, row: s5, col: o4 } = e4, n4 = new e2(e4);
    return this._tilemap.fetchAvailabilityUpsample(l6, s5, o4, n4, t3).then(() => (n4.world = e4.world, n4)).catch((e5) => {
      if (b(e5)) throw e5;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var l5 = class {
  constructor(t3) {
    this._tileUrl = t3, this._promise = null, this._abortController = null, this._abortOptions = [];
  }
  getData(t3) {
    var _a;
    (null == this._promise || c((_a = this._abortController) == null ? void 0 : _a.signal)) && (this._promise = this._makeRequest(this._tileUrl));
    const o4 = this._abortOptions;
    return o4.push(t3), m(t3, () => {
      o4.every((t4) => c(t4)) && this._abortController.abort();
    }), this._promise.then((t4) => a(t4));
  }
  async _makeRequest(r5) {
    this._abortController = new AbortController();
    const { data: o4 } = await P(r5, { responseType: "array-buffer", signal: this._abortController.signal });
    return o4;
  }
};
var a4 = /* @__PURE__ */ new Map();
function c2(t3, r5, o4, e4, s5) {
  const l6 = I(t3), a5 = l6.query;
  if (a5) for (const [i2, n4] of Object.entries(a5)) switch (n4) {
    case "{x}":
      a5[i2] = e4.toString();
      break;
    case "{y}":
      a5[i2] = o4.toString();
      break;
    case "{z}":
      a5[i2] = r5.toString();
  }
  const c3 = l6.path;
  return p4(Et(c3.replaceAll(/\{z\}/gi, r5.toString()).replaceAll(/\{y\}/gi, o4.toString()).replaceAll(/\{x\}/gi, e4.toString()), { ...l6.query }), s5);
}
function p4(t3, r5) {
  return r(a4, t3, () => new l5(t3)).getData(r5).finally(() => a4.delete(t3));
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var m3 = class {
  constructor(h4, m4, u3) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.initialExtent = null, this.name = h4, this.sourceUrl = m4;
    const f3 = I(this.sourceUrl), c3 = a(u3), x3 = c3.tiles;
    if (f3) for (let t3 = 0; t3 < x3.length; t3++) {
      const r5 = I(x3[t3]);
      r5 && (Y(r5.path) || (r5.path = V(f3.path, r5.path)), x3[t3] = Et(r5.path, { ...f3.query, ...r5.query }));
    }
    this.tileServers = x3;
    const d4 = u3.capabilities && u3.capabilities.split(",").map((t3) => t3.toLowerCase().trim()), y = true === (u3 == null ? void 0 : u3.exportTilesAllowed), T2 = true === (d4 == null ? void 0 : d4.includes("tilemap")), I2 = y && u3.hasOwnProperty("maxExportTilesCount") ? u3.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y, supportsTileMap: T2 }, exportTiles: y ? { maxExportTilesCount: +I2 } : null }, this.tileInfo = z.fromJSON(c3.tileInfo);
    const g3 = u3.tileMap ? Et(V(f3.path, u3.tileMap), f3.query ?? {}) : null;
    T2 ? (this.type = "vector-tile", this.tilemap = new l4(new T({ layer: { parsedUrl: f3, tileInfo: this.tileInfo }, minLOD: c3.minLOD ?? this.tileInfo.lods[0].level, maxLOD: c3.maxLOD ?? this.tileInfo.lods[this.tileInfo.lods.length - 1].level }), g3)) : g3 && (this.tilemap = new l3(g3)), this.fullExtent = w.fromJSON(u3.fullExtent), this.initialExtent = w.fromJSON(u3.initialExtent);
  }
  destroy() {
    var _a;
    (_a = this.tilemap) == null ? void 0 : _a.destroy();
  }
  async getRefKey(t3, e4) {
    return this.tilemap ? this.tilemap.dataKey(t3, e4) : t3;
  }
  requestTile(t3, e4, i2, l6) {
    const s5 = this.tileServers[e4 % this.tileServers.length];
    return c2(s5, t3, e4, i2, l6);
  }
  isCompatibleWith(t3) {
    const e4 = this.tileInfo, i2 = t3.tileInfo;
    if (!e4.spatialReference.equals(i2.spatialReference)) return false;
    if (!e4.origin.equals(i2.origin)) return false;
    if (Math.round(e4.dpi) !== Math.round(i2.dpi)) return false;
    const l6 = e4.lods, s5 = i2.lods, r5 = Math.min(l6.length, s5.length);
    for (let o4 = 0; o4 < r5; o4++) {
      const t4 = l6[o4], e5 = s5[o4];
      if (t4.level !== e5.level || Math.round(t4.scale) !== Math.round(e5.scale)) return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
async function x2(e4, t3) {
  const r5 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [o4, s5] = "string" == typeof e4 ? [e4, null] : [null, e4.jsonUrl];
  await S2(r5, "esri", e4, s5, t3);
  return { layerDefinition: r5.validatedSource, url: o4, serviceUrl: r5.sourceUrl, style: r5.style, styleUrl: r5.styleUrl, spriteUrl: r5.style.sprite && d3(r5.styleBase, r5.style.sprite), spriteFormat: r5.spriteFormat, glyphsUrl: r5.style.glyphs && d3(r5.styleBase, r5.style.glyphs), sourceNameToSource: r5.sourceNameToSource, primarySourceName: r5.primarySourceName };
}
function d3(...e4) {
  let t3;
  for (const r5 of e4) if (null != r5) if (pt(r5)) {
    if (t3) {
      const e5 = t3.split("://")[0];
      t3 = e5 + ":" + r5.trim();
    }
  } else t3 = Y(r5) ? r5 : V(t3, r5);
  return t3 ? bt(t3) : void 0;
}
async function S2(t3, o4, s5, l6, n4) {
  let u3, c3, a5;
  if (s2(n4), "string" == typeof s5) {
    const t4 = K(s5);
    a5 = await P(t4, { ...n4, responseType: "json", query: { f: "json", ...n4 == null ? void 0 : n4.query } }), a5.ssl && (u3 && (u3 = u3.replace(/^http:/i, "https:")), c3 && (c3 = c3.replace(/^http:/i, "https:"))), u3 = t4, c3 = t4;
  } else null != s5 && (a5 = { data: s5 }, u3 = s5.jsonUrl || null, c3 = l6);
  const f3 = a5 == null ? void 0 : a5.data;
  if (w2(f3)) return t3.styleUrl = u3 || null, j4(t3, f3, c3, n4);
  if (U2(f3)) return t3.sourceUrl ? g2(t3, f3, c3, false, o4, n4) : (t3.sourceUrl = u3 || null, g2(t3, f3, c3, true, o4, n4));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function h3(e4) {
  return "object" == typeof e4 && !!e4 && "tilejson" in e4 && null != e4.tilejson;
}
function w2(e4) {
  return !!e4 && "sources" in e4 && !!e4.sources;
}
function U2(e4) {
  return !w2(e4);
}
async function j4(e4, t3, r5, o4) {
  const s5 = r5 ? Rt(r5) : b2();
  e4.styleBase = s5, e4.style = t3, t3["sprite-format"] && "webp" === t3["sprite-format"].toLowerCase() && (e4.spriteFormat = "webp");
  const l6 = [];
  if (t3.sources && t3.sources.esri) {
    const r6 = t3.sources.esri;
    r6.url ? await S2(e4, "esri", d3(s5, r6.url), void 0, o4) : l6.push(S2(e4, "esri", r6, s5, o4));
  }
  for (const n4 of Object.keys(t3.sources)) "esri" !== n4 && "vector" === t3.sources[n4].type && (t3.sources[n4].url ? l6.push(S2(e4, n4, d3(s5, t3.sources[n4].url), void 0, o4)) : t3.sources[n4].tiles && l6.push(S2(e4, n4, t3.sources[n4], s5, o4)));
  await Promise.all(l6);
}
async function g2(e4, t3, r5, o4, s5, l6) {
  const i2 = r5 ? bt(r5) + "/" : b2(), u3 = v2(t3), f3 = new m3(s5, Et(i2, (l6 == null ? void 0 : l6.query) ?? {}), u3);
  if (!o4 && e4.primarySourceName in e4.sourceNameToSource) {
    const t4 = e4.sourceNameToSource[e4.primarySourceName];
    if (!t4.isCompatibleWith(f3)) return;
    null != f3.fullExtent && (null != t4.fullExtent ? t4.fullExtent.union(f3.fullExtent) : t4.fullExtent = f3.fullExtent.clone()), t4.tileInfo && f3.tileInfo && t4.tileInfo.lods.length < f3.tileInfo.lods.length && (t4.tileInfo = f3.tileInfo);
  }
  if (o4 && (e4.sourceBase = i2, e4.source = t3, e4.validatedSource = u3, e4.primarySourceName = s5), e4.sourceNameToSource[s5] = f3, !h3(e4) && "defaultStyles" in t3 && !e4.style) {
    if (null == t3.defaultStyles) throw new Error();
    return "string" == typeof t3.defaultStyles ? S2(e4, "", d3(i2, t3.defaultStyles, "root.json"), void 0, l6) : S2(e4, "", t3.defaultStyles, d3(i2, "root.json"), l6);
  }
}
function v2(e4) {
  const r5 = 512;
  if (N(e4)) {
    const t3 = e4 == null ? void 0 : e4.tileInfo;
    return null != t3 && (null == t3.rows && (t3.rows = r5), null == t3.cols && (t3.cols = r5)), e4;
  }
  const o4 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100, latestWkid: 3857 } };
  let s5 = null;
  if (h3(e4)) {
    const { bounds: r6 } = e4;
    if (r6) {
      const e5 = j({ x: r6[0], y: r6[1], spatialReference: a(U) }), o5 = j({ x: r6[2], y: r6[3], spatialReference: a(U) });
      s5 = { xmin: e5.x, ymin: e5.y, xmax: o5.x, ymax: o5.y, spatialReference: a(h) };
    }
  }
  null === s5 && (s5 = o4);
  let l6 = 78271.51696400007, n4 = 2958287637957775e-7;
  const i2 = [], u3 = e4.hasOwnProperty("maxzoom") && null != e4.maxzoom ? +e4.maxzoom : 22, c3 = 0, a5 = 0;
  for (let t3 = 0; t3 <= u3; t3++) i2.push({ level: t3, scale: n4, resolution: l6 }), l6 /= 2, n4 /= 2;
  return { capabilities: "TilesOnly", initialExtent: s5, fullExtent: o4, minScale: c3, maxScale: a5, tiles: e4.tiles, tileInfo: { rows: r5, cols: r5, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: i2, spatialReference: a(h) } };
}
function N(e4) {
  return e4.hasOwnProperty("tileInfo");
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var s4 = 1e-6;
function r4(l6, e4) {
  if (l6 === e4) return true;
  if (null == l6 && null != e4) return false;
  if (null != l6 && null == e4) return false;
  if (null == l6 || null == e4) return false;
  if (!l6.spatialReference.equals(e4.spatialReference) || l6.dpi !== e4.dpi) return false;
  const n4 = l6.origin, r5 = e4.origin;
  if (Math.abs(n4.x - r5.x) >= s4 || Math.abs(n4.y - r5.y) >= s4) return false;
  let o4, t3;
  l6.lods[0].scale > e4.lods[0].scale ? (o4 = l6, t3 = e4) : (t3 = l6, o4 = e4);
  for (let i2 = o4.lods[0].scale; i2 >= t3.lods[t3.lods.length - 1].scale - s4; i2 /= 2) if (Math.abs(i2 - t3.lods[0].scale) < s4) return true;
  return false;
}
function o3(s5, r5) {
  if (s5 === r5) return s5;
  if (null == s5 && null != r5) return r5;
  if (null != s5 && null == r5) return s5;
  if (null == s5 || null == r5) return null;
  const o4 = s5.size[0], t3 = s5.format, i2 = s5.dpi, u3 = new j2({ x: s5.origin.x, y: s5.origin.y }), a5 = s5.spatialReference, f3 = s5.lods[0].scale > r5.lods[0].scale ? s5.lods[0] : r5.lods[0], d4 = s5.lods[s5.lods.length - 1].scale <= r5.lods[r5.lods.length - 1].scale ? s5.lods[s5.lods.length - 1] : r5.lods[r5.lods.length - 1], c3 = f3.scale, p5 = f3.resolution, g3 = d4.scale, h4 = [];
  let m4 = c3, y = p5, x3 = 0;
  for (; m4 >= g3; ) h4.push(new p2({ level: x3, resolution: y, scale: m4 })), x3++, m4 /= 2, y /= 2;
  return new z({ size: [o4, o4], dpi: i2, format: t3 || "pbf", origin: u3, lods: h4, spatialReference: a5 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var B = class extends p(t(f2(p3(l2(b3(j3(e3(i(S(f)))))))))) {
  constructor(...e4) {
    super(...e4), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.path = null, this.refreshInterval = 0, this.style = null, this.tilemapCache = null, this.type = "vector-tile", this.url = null;
  }
  normalizeCtorArgs(e4, t3) {
    return "string" == typeof e4 ? { url: e4, ...t3 } : e4;
  }
  destroy() {
    var _a;
    if (this.sourceNameToSource) for (const e4 of Object.values(this.sourceNameToSource)) e4 == null ? void 0 : e4.destroy();
    (_a = this.primarySource) == null ? void 0 : _a.destroy(), this._spriteSourceMap.clear();
  }
  async prefetchResources(e4) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e4);
  }
  load(e4) {
    const r5 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e4).catch(a2).then(async () => {
      var _a;
      if (!((_a = this.portalItem) == null ? void 0 : _a.id)) return;
      const r6 = `${this.portalItem.itemCdnUrl}/resources/styles/root.json`;
      (await P(r6, { ...e4, query: { f: "json", ...this.customParameters, token: this.apiKey }, authMode: this.portalItem.portal.authMode })).data && this.read({ url: r6 }, e(this.portalItem, "portal-item"));
    }).catch(a2).then(() => this._loadStyle(e4));
    return this.addResolvingPromise(r5), Promise.resolve(this);
  }
  get attributionDataUrl() {
    const e4 = this.currentStyleInfo, t3 = (e4 == null ? void 0 : e4.serviceUrl) && I(e4.serviceUrl);
    if (!t3) return null;
    const r5 = this._getDefaultAttribution(t3.path);
    return r5 ? Et(r5, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e4 = this.primarySource;
    return e4 ? e4.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.fullExtent) || null;
  }
  get initialExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.initialExtent) || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? I(this.serviceUrl) : null;
  }
  get serviceUrl() {
    var _a;
    return ((_a = this.currentStyleInfo) == null ? void 0 : _a.serviceUrl) || null;
  }
  get spatialReference() {
    var _a;
    return ((_a = this.tileInfo) == null ? void 0 : _a.spatialReference) ?? null;
  }
  get styleUrl() {
    var _a;
    return ((_a = this.currentStyleInfo) == null ? void 0 : _a.styleUrl) || null;
  }
  writeStyleUrl(e4, t3) {
    e4 && pt(e4) && (e4 = `https:${e4}`);
    const r5 = s3(e4);
    t3.styleUrl = x(e4, r5);
  }
  get tileInfo() {
    var _a;
    const e4 = [];
    for (const r5 in this.sourceNameToSource) e4.push(this.sourceNameToSource[r5]);
    let t3 = ((_a = this.primarySource) == null ? void 0 : _a.tileInfo) || new z();
    if (e4.length > 1) for (let r5 = 0; r5 < e4.length; r5++) r4(t3, e4[r5].tileInfo) && (t3 = o3(t3, e4[r5].tileInfo));
    return t3;
  }
  readTilemapCache(e4, t3) {
    var _a;
    const r5 = (_a = t3.capabilities) == null ? void 0 : _a.includes("Tilemap");
    return r5 ? new T({ layer: this }) : null;
  }
  readVersion(e4, t3) {
    return t3.version ? parseFloat(t3.version) : parseFloat(t3.currentVersion);
  }
  async loadSpriteSource(e4 = 1, t3) {
    var _a, _b;
    if (!this._spriteSourceMap.has(e4)) {
      const r5 = t2().maxTextureSize, i2 = ((_a = this.currentStyleInfo) == null ? void 0 : _a.spriteUrl) ? Et(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, o4 = new n3({ type: "url", spriteUrl: i2, pixelRatio: e4, spriteFormat: (_b = this.currentStyleInfo) == null ? void 0 : _b.spriteFormat }, r5);
      await o4.load(t3), this._spriteSourceMap.set(e4, o4);
    }
    return this._spriteSourceMap.get(e4);
  }
  async setSpriteSource(e4, t3) {
    if (!e4) return null;
    const r5 = t2().maxTextureSize, i2 = e4.spriteUrl, o4 = i2 ? Et(i2, { ...this.customParameters, token: this.apiKey }) : null;
    if (!o4 && "url" === e4.type) return null;
    const s5 = new n3(e4, r5);
    try {
      await s5.load(t3);
      const r6 = e4.pixelRatio || 1;
      return this._spriteSourceMap.clear(), this._spriteSourceMap.set(r6, s5), o4 && this.currentStyleInfo && (this.currentStyleInfo.spriteUrl = o4), this.emit("spriteSource-change", { spriteSource: s5 }), s5;
    } catch (a5) {
      a2(a5);
    }
    return null;
  }
  async loadStyle(e4, t3) {
    var _a;
    const i2 = e4 || this.style || this.url;
    return this._loadingTask && "string" == typeof i2 && this.url === i2 || ((_a = this._loadingTask) == null ? void 0 : _a.abort(), this._loadingTask = d((e5) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(i2, { signal: e5 })), t3)), this._loadingTask.promise;
  }
  getStyleLayerId(e4) {
    return this.styleRepository.getStyleLayerId(e4);
  }
  getStyleLayerIndex(e4) {
    return this.styleRepository.getStyleLayerIndex(e4);
  }
  getPaintProperties(e4) {
    var _a;
    return a((_a = this.styleRepository) == null ? void 0 : _a.getPaintProperties(e4));
  }
  setPaintProperties(e4, t3) {
    const r5 = this.styleRepository.isPainterDataDriven(e4);
    this.styleRepository.setPaintProperties(e4, t3);
    const i2 = this.styleRepository.isPainterDataDriven(e4);
    this.emit("paint-change", { layer: e4, paint: t3, isDataDriven: r5 || i2 });
  }
  getStyleLayer(e4) {
    return a(this.styleRepository.getStyleLayer(e4));
  }
  setStyleLayer(e4, t3) {
    this.styleRepository.setStyleLayer(e4, t3), this.emit("style-layer-change", { layer: e4, index: t3 });
  }
  deleteStyleLayer(e4) {
    this.styleRepository.deleteStyleLayer(e4), this.emit("delete-style-layer", { layer: e4 });
  }
  getLayoutProperties(e4) {
    return a(this.styleRepository.getLayoutProperties(e4));
  }
  setLayoutProperties(e4, t3) {
    this.styleRepository.setLayoutProperties(e4, t3), this.emit("layout-change", { layer: e4, layout: t3 });
  }
  setStyleLayerVisibility(e4, t3) {
    this.styleRepository.setStyleLayerVisibility(e4, t3), this.emit("style-layer-visibility-change", { layer: e4, visibility: t3 });
  }
  getStyleLayerVisibility(e4) {
    return this.styleRepository.getStyleLayerVisibility(e4);
  }
  write(e4, t3) {
    return (t3 == null ? void 0 : t3.origin) && !this.styleUrl ? (t3.messages && t3.messages.push(new s("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e4, t3);
  }
  getTileUrl(e4, t3, r5) {
    return null;
  }
  async _getSourceAndStyle(e4, t3) {
    if (!e4) throw new Error("invalid style!");
    const r5 = await x2(e4, { ...t3, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r5.spriteFormat) {
      await o2("lossy") || (r5.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r5 }), "string" == typeof e4 ? (this.url = e4, this.style = null) : (this.url = null, this.style = e4), this._set("sourceNameToSource", r5.sourceNameToSource), this._set("primarySource", r5.sourceNameToSource[r5.primarySourceName]), this._set("styleRepository", new l(r5.style)), this.read(r5.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e4) {
    const t3 = e4.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^/]+)?\/arcgis\/rest\/services\/([^/]+(\/[^/]+)*)\/vectortileserver/i), r5 = ["OpenBasemap_v2", "OpenBasemap_GCS_v2", "OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2", "World_Hillshade_v2"];
    if (!t3) return;
    const i2 = t3[2] && t3[2].toLowerCase();
    if (!i2) return;
    const o4 = t3[1] || "";
    for (const s5 of r5) if (s5.toLowerCase().includes(i2)) return K(`//static.arcgis.com/attribution/Vector${o4}/${s5}`);
  }
  async _loadStyle(e4) {
    var _a;
    return ((_a = this._loadingTask) == null ? void 0 : _a.promise) ?? this.loadStyle(null, e4);
  }
};
r2([m2({ readOnly: true })], B.prototype, "attributionDataUrl", null), r2([m2({ type: ["show", "hide"] })], B.prototype, "listMode", void 0), r2([m2({ json: { read: true, write: true } })], B.prototype, "blendMode", void 0), r2([m2({ readOnly: true, json: { read: false } })], B.prototype, "capabilities", null), r2([m2({ readOnly: true })], B.prototype, "currentStyleInfo", void 0), r2([m2({ json: { read: false }, readOnly: true, type: w })], B.prototype, "fullExtent", null), r2([m2({ json: { read: false }, readOnly: true, type: w })], B.prototype, "initialExtent", null), r2([m2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], B.prototype, "isReference", void 0), r2([m2({ type: ["VectorTileLayer"] })], B.prototype, "operationalLayerType", void 0), r2([m2({ readOnly: true })], B.prototype, "parsedUrl", null), r2([m2({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], B.prototype, "path", void 0), r2([m2({ type: Number, json: { write: false, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], B.prototype, "refreshInterval", void 0), r2([m2()], B.prototype, "style", void 0), r2([m2({ readOnly: true })], B.prototype, "serviceUrl", null), r2([m2({ type: g, readOnly: true })], B.prototype, "spatialReference", null), r2([m2({ readOnly: true })], B.prototype, "styleRepository", void 0), r2([m2({ readOnly: true })], B.prototype, "sourceNameToSource", void 0), r2([m2({ readOnly: true })], B.prototype, "primarySource", void 0), r2([m2({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], B.prototype, "styleUrl", null), r2([r3(["portal-item", "web-document"], "styleUrl")], B.prototype, "writeStyleUrl", null), r2([m2({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: z })], B.prototype, "tileInfo", null), r2([m2()], B.prototype, "tilemapCache", void 0), r2([o("service", "tilemapCache", ["capabilities", "tileInfo"])], B.prototype, "readTilemapCache", null), r2([m2({ json: { read: false }, readOnly: true, value: "vector-tile" })], B.prototype, "type", void 0), r2([m2({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } })], B.prototype, "url", void 0), r2([m2({ readOnly: true })], B.prototype, "version", void 0), r2([o("version", ["version", "currentVersion"])], B.prototype, "readVersion", null), B = r2([a3("esri.layers.VectorTileLayer")], B);
var A2 = B;
export {
  A2 as default
};
//# sourceMappingURL=VectorTileLayer-UPCTOLDV.js.map
