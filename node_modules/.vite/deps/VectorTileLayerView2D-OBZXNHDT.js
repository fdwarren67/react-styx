import {
  i as i3
} from "./chunk-4YDWJUBU.js";
import {
  i as i4
} from "./chunk-YISRE3T5.js";
import {
  r as r7
} from "./chunk-DTPSE2SE.js";
import {
  S
} from "./chunk-6ODLL4CO.js";
import {
  y as y3
} from "./chunk-ZMZA5FVA.js";
import "./chunk-IZJLQDI2.js";
import "./chunk-AWVDCINM.js";
import {
  E as E2,
  o as o2
} from "./chunk-NJX7X3PO.js";
import "./chunk-MAX4GY2G.js";
import {
  e as e5,
  s as s4
} from "./chunk-DGCCEGJE.js";
import {
  c,
  e as e4,
  t as t2
} from "./chunk-J2QYVOHP.js";
import {
  L,
  l as l2
} from "./chunk-PVSDTWLJ.js";
import {
  E,
  I as I2
} from "./chunk-PQUUCIML.js";
import {
  a as a6,
  i as i2,
  l,
  n as n2,
  r as r5
} from "./chunk-NBFYN6KG.js";
import "./chunk-23WGP47N.js";
import "./chunk-T5R43RTD.js";
import {
  u as u3
} from "./chunk-F6YRPEY7.js";
import "./chunk-CCPDXL7V.js";
import "./chunk-CUWQEJ5X.js";
import {
  t
} from "./chunk-6VF5U3IZ.js";
import {
  d,
  w
} from "./chunk-E7IFPXEX.js";
import "./chunk-OK5AUMBT.js";
import "./chunk-R2ZUOHHV.js";
import "./chunk-OBVDE24U.js";
import {
  a as a5
} from "./chunk-W5QWJI4E.js";
import "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import {
  i
} from "./chunk-RDHJUEBL.js";
import {
  s as s2
} from "./chunk-3WB47P7Q.js";
import "./chunk-NPEU24W6.js";
import "./chunk-I75Q3UU4.js";
import {
  E as E3,
  e as e6,
  r as r6
} from "./chunk-TOU5KPOG.js";
import "./chunk-5BSH2ZN2.js";
import {
  p as p3,
  w as w2
} from "./chunk-HQ2GCCLQ.js";
import "./chunk-QBRBJ5XN.js";
import {
  p as p2
} from "./chunk-74GH4Z6V.js";
import {
  h as h2,
  s as s3
} from "./chunk-PXBFVQ6M.js";
import "./chunk-TYJV2BHR.js";
import "./chunk-I6H2R562.js";
import {
  e as e3
} from "./chunk-WMLTK6KE.js";
import "./chunk-SURICA27.js";
import "./chunk-PBHST2SF.js";
import "./chunk-PONPGREB.js";
import {
  D,
  F,
  G,
  I,
  O,
  R as R2
} from "./chunk-QNYMCEB7.js";
import "./chunk-T7CHWWE2.js";
import {
  M,
  f as f2,
  h,
  o
} from "./chunk-FWVSIQMR.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-ON7GWFUW.js";
import "./chunk-VPRLLNNO.js";
import {
  g
} from "./chunk-64ZXKK6G.js";
import "./chunk-UCM2ZG62.js";
import "./chunk-ZPDG5M3T.js";
import {
  z
} from "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import "./chunk-YUQ6PSJ2.js";
import {
  r as r4
} from "./chunk-SB6LU3VH.js";
import {
  p,
  y as y2
} from "./chunk-XAZEJYKE.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import {
  e as e2
} from "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import {
  p as p4
} from "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-C33DSFWF.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import {
  b as b2
} from "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import {
  R,
  a as a4,
  u as u2
} from "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import {
  j2 as j
} from "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  s
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import {
  Et
} from "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a as a2,
  b,
  e,
  f2 as f,
  r as r3,
  u,
  y
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r as r2
} from "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import {
  r
} from "./chunk-7LCEUMDD.js";
import {
  a,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e7 = class {
  constructor(e9, t8) {
    this._width = 0, this._height = 0, this._free = [], this._width = e9, this._height = t8, this._free.push(new t(0, 0, e9, t8));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e9, t8) {
    if (e9 > this._width || t8 > this._height) return new t();
    let i9 = null, s7 = -1;
    for (let h7 = 0; h7 < this._free.length; ++h7) {
      const w3 = this._free[h7];
      e9 <= w3.width && t8 <= w3.height && (null === i9 || w3.y <= i9.y && w3.x <= i9.x) && (i9 = w3, s7 = h7);
    }
    return null === i9 ? new t() : (this._free.splice(s7, 1), i9.width < i9.height ? (i9.width > e9 && this._free.push(new t(i9.x + e9, i9.y, i9.width - e9, t8)), i9.height > t8 && this._free.push(new t(i9.x, i9.y + t8, i9.width, i9.height - t8))) : (i9.width > e9 && this._free.push(new t(i9.x + e9, i9.y, i9.width - e9, i9.height)), i9.height > t8 && this._free.push(new t(i9.x, i9.y + t8, e9, i9.height - t8))), new t(i9.x, i9.y, e9, t8));
  }
  release(h7) {
    for (let e9 = 0; e9 < this._free.length; ++e9) {
      const t8 = this._free[e9];
      if (t8.y === h7.y && t8.height === h7.height && t8.x + t8.width === h7.x) t8.width += h7.width;
      else if (t8.x === h7.x && t8.width === h7.width && t8.y + t8.height === h7.y) t8.height += h7.height;
      else if (h7.y === t8.y && h7.height === t8.height && h7.x + h7.width === t8.x) t8.x = h7.x, t8.width += h7.width;
      else {
        if (h7.x !== t8.x || h7.width !== t8.width || h7.y + h7.height !== t8.y) continue;
        t8.y = h7.y, t8.height += h7.height;
      }
      this._free.splice(e9, 1), this.release(h7);
    }
    this._free.push(h7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n3 = class {
  constructor(e9, s7, i9) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e9, this.height = s7, this._glyphSource = i9, this._binPack = new e7(e9 - 4, s7 - 4), this._glyphData.push(new Uint8Array(e9 * s7)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s7, i9) {
    const h7 = [], r13 = this._glyphSource, n8 = /* @__PURE__ */ new Set(), o6 = 1 / 256;
    for (const t8 of i9) {
      const e9 = Math.floor(t8 * o6);
      n8.add(e9);
    }
    const a9 = [];
    return n8.forEach((t8) => {
      const e9 = s7 + t8;
      if (this._rangePromises.has(e9)) a9.push(this._rangePromises.get(e9));
      else {
        const i10 = r13.getRange(s7, t8).then(() => {
          this._rangePromises.delete(e9);
        }, () => {
          this._rangePromises.delete(e9);
        });
        this._rangePromises.set(e9, i10), a9.push(i10);
      }
    }), Promise.all(a9).then(() => {
      let n9 = this._glyphIndex[s7];
      n9 || (n9 = {}, this._glyphIndex[s7] = n9);
      for (const o7 of i9) {
        const i10 = n9[o7];
        if (i10) {
          h7[o7] = { sdf: true, rect: i10.rect, metrics: i10.metrics, page: i10.page, code: o7 };
          continue;
        }
        const a10 = r13.getGlyph(s7, o7);
        if (!(a10 == null ? void 0 : a10.metrics)) continue;
        const l6 = a10.metrics;
        let c7;
        if (0 === l6.width) c7 = new t(0, 0, 0, 0);
        else {
          const e9 = 3, s8 = l6.width + 2 * e9, i11 = l6.height + 2 * e9;
          let h8 = s8 % 4 ? 4 - s8 % 4 : 4, r14 = i11 % 4 ? 4 - i11 % 4 : 4;
          1 === h8 && (h8 = 5), 1 === r14 && (r14 = 5), c7 = this._binPack.allocate(s8 + h8, i11 + r14), c7.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e7(this.width - 4, this.height - 4), c7 = this._binPack.allocate(s8 + h8, i11 + r14));
          const n10 = this._glyphData[this._currentPage], o8 = a10.bitmap;
          let g2, _3;
          if (o8) for (let t8 = 0; t8 < i11; t8++) {
            g2 = s8 * t8, _3 = this.width * (c7.y + t8 + 1) + c7.x;
            for (let t9 = 0; t9 < s8; t9++) n10[_3 + t9 + 1] = o8.at(g2 + t9);
          }
        }
        n9[o7] = { rect: c7, metrics: l6, tileIDs: null, page: this._currentPage }, h7[o7] = { sdf: true, rect: c7, metrics: l6, page: this._currentPage, code: o7 }, this._dirties[this._currentPage] = true;
      }
      return h7;
    });
  }
  removeGlyphs(t8) {
    for (const e9 in this._glyphIndex) {
      const s7 = this._glyphIndex[e9];
      if (!s7) continue;
      let i9;
      for (const e10 in s7) if (i9 = s7[e10], i9.tileIDs.delete(t8), 0 === i9.tileIDs.size) {
        const t9 = this._glyphData[i9.page], h7 = i9.rect;
        let r13, n8;
        for (let e11 = 0; e11 < h7.height; e11++) for (r13 = this.width * (h7.y + e11) + h7.x, n8 = 0; n8 < h7.width; n8++) t9[r13 + n8] = 0;
        delete s7[e10], this._dirties[i9.page] = true;
      }
    }
  }
  bind(t8, e9, n8, o6 = 0) {
    if (!this._textures[n8]) {
      const e10 = new p3();
      e10.pixelFormat = G.ALPHA, e10.wrapMode = D.CLAMP_TO_EDGE, e10.width = this.width, e10.height = this.height, this._textures[n8] = new w2(t8, e10, new Uint8Array(this.width * this.height));
    }
    const a9 = this._textures[n8];
    a9.setSamplingMode(e9), this._dirties[n8] && a9.setData(this._glyphData[n8]), t8.bindTexture(a9, o6), this._dirties[n8] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s5 = class {
  constructor(t8) {
    if (this._metrics = [], !t8) return void (this._allBitmaps = null);
    const e9 = /* @__PURE__ */ new Map();
    let s7 = 0;
    for (; t8.next(); ) switch (t8.tag()) {
      case 1: {
        const a10 = t8.getMessage();
        for (; a10.next(); ) switch (a10.tag()) {
          case 3: {
            const t9 = a10.getMessage();
            let r14, n8, i9, c7, o6, g2, h7;
            for (; t9.next(); ) switch (t9.tag()) {
              case 1:
                r14 = t9.getUInt32();
                break;
              case 2:
                n8 = t9.getBytes();
                break;
              case 3:
                i9 = t9.getUInt32();
                break;
              case 4:
                c7 = t9.getUInt32();
                break;
              case 5:
                o6 = t9.getSInt32();
                break;
              case 6:
                g2 = t9.getSInt32();
                break;
              case 7:
                h7 = t9.getUInt32();
                break;
              default:
                t9.skip();
            }
            if (t9.release(), r14) {
              const t10 = (n8 == null ? void 0 : n8.length) ?? 0;
              this._metrics[r14] = { width: i9, height: c7, left: o6, top: g2, advance: h7, startOffset: s7, length: t10 }, e9.set(r14, n8), s7 += t10;
            }
            break;
          }
          default:
            a10.skip();
        }
        a10.release();
        break;
      }
      default:
        t8.skip();
    }
    const a9 = new Uint8Array(s7), r13 = this._metrics;
    for (const [n8, i9] of e9) {
      const { startOffset: t9, length: e10 } = r13[n8];
      if (i9) for (let s8 = 0; s8 < e10; ++s8) a9[t9 + s8] = i9[s8];
    }
    this._allBitmaps = a9;
  }
  getMetrics(t8) {
    return this._metrics[t8];
  }
  getBitmap(t8) {
    if (!this._allBitmaps) return;
    const e9 = this._metrics[t8];
    if (void 0 === e9) return;
    const { startOffset: s7, length: a9 } = e9;
    return 0 !== a9 ? new n4(this._allBitmaps, s7, a9) : void 0;
  }
};
var a7 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t8) {
    return this._ranges[t8];
  }
  addRange(t8, e9) {
    this._ranges[t8] = e9;
  }
};
var r8 = class {
  constructor(t8) {
    this._glyphInfo = {}, this._baseURL = t8;
  }
  getRange(a9, r13) {
    const n8 = this._getFontStack(a9);
    if (n8.getRange(r13)) return Promise.resolve();
    const i9 = 256 * r13, c7 = i9 + 255;
    if (this._baseURL) {
      const o6 = this._baseURL.replace("{fontstack}", a9).replace("{range}", i9 + "-" + c7);
      return P(o6, { responseType: "array-buffer" }).then((t8) => {
        n8.addRange(r13, new s5(new a5(new Uint8Array(t8.data), new DataView(t8.data))));
      }).catch(() => {
        n8.addRange(r13, new s5());
      });
    }
    return n8.addRange(r13, new s5()), Promise.resolve();
  }
  getGlyph(t8, e9) {
    const s7 = this._getFontStack(t8);
    if (!s7) return;
    const a9 = Math.floor(e9 / 256), r13 = s7.getRange(a9);
    return r13 ? { metrics: r13.getMetrics(e9), bitmap: r13.getBitmap(e9) } : void 0;
  }
  _getFontStack(t8) {
    let e9 = this._glyphInfo[t8];
    return e9 || (e9 = this._glyphInfo[t8] = new a7()), e9;
  }
};
var n4 = class {
  constructor(t8, e9, s7) {
    this._array = t8, this._start = e9, this.length = s7;
  }
  at(t8) {
    return 0 <= t8 && t8 < this.length ? this._array[this._start + t8] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r9 = "dasharray-";
var o3 = class _o {
  constructor(t8, s7, e9 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, s7 <= 0 && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t8, this._pageHeight = s7, e9 > 0 && (this._maxItemSize = e9), this._binPack = new e7(t8 - 4, s7 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
  getWidth(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][0];
  }
  getHeight(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][1];
  }
  getPageSize(t8) {
    return t8 >= this._size.length ? null : this._size[t8];
  }
  setSpriteSource(t8) {
    if (this.dispose(), this.pixelRatio = t8.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4);
      const t9 = Math.floor(this._pageWidth), s7 = Math.floor(this._pageHeight), e9 = new Uint32Array(t9 * s7);
      this._mosaicsData[0] = e9, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t8;
  }
  getSpriteItem(t8, i9 = false) {
    let s7, e9, h7 = this._mosaicRects[t8];
    if (h7) return h7;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus) return null;
    if (t8 && t8.startsWith(r9) ? ([s7, e9] = this._rasterizeDash(t8), i9 = true) : s7 = this._sprites.getSpriteInfo(t8), !(s7 == null ? void 0 : s7.width) || !s7.height || s7.width < 0 || s7.height < 0) return null;
    const a9 = s7.width, o6 = s7.height, [n8, _3, g2] = this._allocateImage(a9, o6);
    return n8.width <= 0 ? null : (this._copy(n8, s7, _3, g2, i9, e9), h7 = { type: "sprite", rect: n8, width: a9, height: o6, sdf: s7.sdf, simplePattern: false, rasterizationScale: s7.pixelRatio ?? 1, samplingMode: "Linear", page: _3 }, this._mosaicRects[t8] = h7, h7);
  }
  getSpriteItems(t8) {
    const i9 = {};
    for (const s7 of t8) i9[s7.name] = this.getSpriteItem(s7.name, s7.repeat);
    return i9;
  }
  getMosaicItemPosition(t8, i9) {
    const s7 = this.getSpriteItem(t8, i9), e9 = s7 == null ? void 0 : s7.rect;
    if (!e9) return null;
    e9.width = s7.width, e9.height = s7.height;
    const h7 = s7.width, a9 = s7.height, r13 = 2;
    return { tl: [e9.x + r13, e9.y + r13], br: [e9.x + r13 + h7, e9.y + r13 + a9], page: s7.page };
  }
  bind(t8, i9, s7 = 0, r13 = 0) {
    if (s7 >= this._size.length || s7 >= this._mosaicsData.length) return;
    if (!this._textures[s7]) {
      const i10 = new p3();
      i10.wrapMode = D.CLAMP_TO_EDGE, i10.width = this._size[s7][0], i10.height = this._size[s7][1], this._textures[s7] = new w2(t8, i10, new Uint8Array(this._mosaicsData[s7].buffer));
    }
    const o6 = this._textures[s7];
    o6.setSamplingMode(i9), this._dirties[s7] && o6.setData(new Uint8Array(this._mosaicsData[s7].buffer)), t8.bindTexture(o6, r13), this._dirties[s7] = false;
  }
  static _copyBits(t8, i9, s7, e9, h7, a9, r13, o6, n8, _3, g2) {
    let p7 = e9 * i9 + s7, c7 = o6 * a9 + r13;
    if (g2) {
      c7 -= a9;
      for (let r14 = -1; r14 <= _3; r14++, p7 = ((r14 + _3) % _3 + e9) * i9 + s7, c7 += a9) for (let i10 = -1; i10 <= n8; i10++) h7[c7 + i10] = t8[p7 + (i10 + n8) % n8];
    } else for (let l6 = 0; l6 < _3; l6++) {
      for (let i10 = 0; i10 < n8; i10++) h7[c7 + i10] = t8[p7 + i10];
      p7 += i9, c7 += a9;
    }
  }
  _copy(t8, i9, s7, e9, h7, a9) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || s7 >= this._mosaicsData.length) return;
    const r13 = new Uint32Array(a9 ? a9.buffer : this._sprites.image.buffer), n8 = this._mosaicsData[s7], _3 = 2, g2 = a9 ? i9.width : this._sprites.width;
    _o._copyBits(r13, g2, i9.x, i9.y, n8, e9[0], t8.x + _3, t8.y + _3, i9.width, i9.height, h7), this._dirties[s7] = true;
  }
  _allocateImage(t8, e9) {
    t8 += 2, e9 += 2;
    const h7 = Math.max(t8, e9);
    if (this._maxItemSize && this._maxItemSize < h7) {
      const i9 = new t(0, 0, t8, e9);
      return this._mosaicsData.push(new Uint32Array(t8 * e9)), this._dirties.push(true), this._size.push([t8, e9]), this._textures.push(void 0), [i9, this._mosaicsData.length - 1, [t8, e9]];
    }
    let a9 = t8 % 4 ? 4 - t8 % 4 : 4, r13 = e9 % 4 ? 4 - e9 % 4 : 4;
    1 === a9 && (a9 = 5), 1 === r13 && (r13 = 5);
    const o6 = this._binPack.allocate(t8 + a9, e9 + r13);
    return o6.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t8, e9)) : [o6, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i9) {
    const s7 = /\[(.*?)\]/, e9 = i9.match(s7);
    if (!e9) return null;
    const h7 = e9[1].split(",").map(Number), a9 = i9.slice(i9.lastIndexOf("-") + 1), [r13, o6, n8] = u3(h7, a9);
    return [{ x: 0, y: 0, width: o6, height: n8, sdf: true, pixelRatio: 1 }, new Uint8Array(r13.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var p5 = class {
  constructor(t8, e9, s7, r13) {
    this._layer = t8, this._styleRepository = e9, this.devicePixelRatio = s7, this._sourceDataMaxLOD = r13, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, (_b = this._spriteMosaic) == null ? void 0 : _b.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_c = this._startOptionsInputSignal) == null ? void 0 : _c.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t8) {
    this._requestSprite(t8);
    const s7 = this._layer.currentStyleInfo.glyphsUrl, r13 = new r8(s7 ? Et(s7, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n3(1024, 1024, r13), this._broadcastPromise = p4("WorkerTileHandler", { client: this, schedule: t8.schedule, signal: t8.signal }).then((s8) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s8, this._layer && !this._connection.closed)) {
        const r14 = s8.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t8);
        Promise.all(r14).catch((t9) => f(t9));
      }
    });
  }
  _requestSprite(t8) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e9 = new AbortController();
    this._spriteSourceAbortController = e9;
    const r13 = t8 == null ? void 0 : t8.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r13 && (this._inputSignalEventListener = _(e9), r13.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i9 } = e9, o6 = { ...t8, signal: i9 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o6), this._spriteSourcePromise.then((t9) => {
      a2(i9), this._spriteMosaic = new o3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t9);
    });
  }
  async updateStyle(t8) {
    const e9 = [];
    for (const s7 of t8) s7.type === I2.SPRITES_CHANGED ? e9.push({ type: I2.SPRITES_CHANGED, data: { spriteSource: null } }) : e9.push(s7);
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e9)), this._broadcastPromise;
  }
  setSpriteSource(t8) {
    const e9 = new o3(1024, 1024, 250);
    return e9.setSpriteSource(t8), this._spriteMosaic = e9, this._spriteSourcePromise = Promise.resolve(t8), this._spriteSourceAbortController = null, e9;
  }
  async setStyle(t8, e9, s7) {
    await this._broadcastPromise, this._styleRepository = t8, this._sourceDataMaxLOD = s7, this._requestSprite();
    const r13 = new r8(this._layer.currentStyleInfo.glyphsUrl ? Et(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n3(1024, 1024, r13), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e9, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t8, e9) {
    const s7 = await this._getRefKeys(t8, e9);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s7, e9);
  }
  async fetchTilePBFs(t8) {
    const e9 = Object.keys(this._layer.sourceNameToSource), s7 = {}, r13 = await this._getRefKeys(t8, s7), i9 = [], o6 = [];
    for (let n8 = 0; n8 < r13.length; n8++) if (null == r13[n8].value || null == e9[n8]) o6.push(null);
    else {
      const t9 = r13[n8].value, a9 = this._getTilePayload(t9, e9[n8], s7);
      a9.then((e10) => {
        i9.push({ ...e10, key: t9 });
      }), o6.push(a9);
    }
    return Promise.all(o6).then(() => i9);
  }
  async parseTileData(t8, e9) {
    const s7 = t8 && t8.data;
    if (!s7) return null;
    const { sourceName2DataAndRefKey: r13, transferList: i9 } = s7;
    return 0 === Object.keys(r13).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t8.key.id, sourceName2DataAndRefKey: r13, styleLayerUIDs: t8.styleLayerUIDs }, { ...e9, transferList: i9 }));
  }
  async getSprites(t8) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t8);
  }
  getGlyphs(t8) {
    return this._glyphMosaic.getGlyphItems(t8.font, t8.codePoints);
  }
  async _getTilePayload(t8, e9, s7) {
    const i9 = e3.pool.acquire(t8.id), o6 = this._layer.sourceNameToSource[e9], { level: n8, row: a9, col: l6 } = i9;
    e3.pool.release(i9);
    try {
      return { protobuff: await o6.requestTile(n8, a9, l6, s7), sourceName: e9 };
    } catch (c7) {
      if (b(c7)) throw c7;
      return { protobuff: null, sourceName: e9 };
    }
  }
  async _getRefKeys(t8, e9) {
    const s7 = this._layer.sourceNameToSource, r13 = new Array();
    for (const i9 in s7) {
      const o6 = s7[i9].getRefKey(t8, e9);
      r13.push(o6);
    }
    return y(r13);
  }
  _getSourcesData(t8, e9, s7) {
    const r13 = [];
    for (let i9 = 0; i9 < e9.length; i9++) if (null == e9[i9].value || null == t8[i9]) r13.push(null);
    else {
      const o6 = e9[i9].value, n8 = this._getTilePayload(o6, t8[i9], s7);
      r13.push(n8);
    }
    return y(r13).then((t9) => {
      const s8 = {}, r14 = [];
      for (let i9 = 0; i9 < t9.length; i9++) {
        const o6 = t9[i9].value;
        if (o6 && (o6.protobuff && o6.protobuff.byteLength > 0)) {
          const t10 = e9[i9].value.id;
          s8[o6.sourceName] = { refKey: t10, protobuff: o6.protobuff }, r14.push(o6.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s8, transferList: r14 };
    });
  }
};
function _(t8) {
  return () => t8.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r10 = 512;
var n5 = 1e-6;
var a8 = (e9, i9) => e9 + 1 / (1 << 2 * i9);
var h3 = class {
  constructor(i9, t8) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e2(40, (e9) => e9.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i9.acquireTile, this.releaseTile = i9.releaseTile, this.tileInfoView = i9.tileInfoView, this._container = t8;
  }
  destroy() {
    for (const e9 of this._tiles.values()) e9.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e9) {
    this._updateCacheSize(e9);
    const i9 = this.tileInfoView, t8 = i9.getTileCoverage(e9.state, 0, true, "smallest");
    if (!t8) return true;
    const { spans: l6, lodInfo: r13 } = t8, { level: n8 } = r13, a9 = this._tiles, h7 = /* @__PURE__ */ new Set(), c7 = /* @__PURE__ */ new Set();
    for (const { row: s7, colFrom: _3, colTo: f4 } of l6) for (let e10 = _3; e10 <= f4; e10++) {
      const i10 = e3.getId(n8, s7, r13.normalizeCol(e10), r13.getWorldForColumn(e10)), t9 = this._getOrAcquireTile(i10);
      h7.add(i10), t9.processed() ? this._addToContainer(t9) : c7.add(new e3(i10));
    }
    for (const [s7, o6] of a9) o6.isCoverage = h7.has(s7);
    for (const s7 of c7) this._findPlaceholdersForMissingTiles(s7, h7);
    let d4 = false;
    for (const [s7, o6] of a9) o6.neededForCoverage = h7.has(s7), o6.neededForCoverage || o6.isHoldingForFade && i9.intersects(t8, o6.key) && h7.add(s7), o6.isFading && (d4 = true);
    for (const s7 of this._tiles.keys()) h7.has(s7) || this._releaseTile(s7);
    return s3.pool.release(t8), !d4;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e9, s7, o6, r13, n8) {
    const a9 = [0, 0], h7 = [0, 0];
    r13.toMap(a9, e9 - o6, s7 + o6), r13.toMap(h7, e9 + o6, s7 - o6);
    const c7 = Math.min(a9[0], h7[0]), d4 = Math.min(a9[1], h7[1]), _3 = Math.max(a9[0], h7[0]), f4 = Math.max(a9[1], h7[1]), T = a4(c7, d4, _3, f4), u6 = u2(), p7 = [];
    for (const i9 of this._visibleTiles.values()) this.tileInfoView.getTileBounds(u6, i9.key), R(T, u6) && p7.push(i9);
    if (null != n8 && n8.length > 0) {
      const e10 = new Set(p7.map((e11) => e11.id)), i9 = n8.filter((i10) => !e10.has(i10.tileKey.id)).map((e11) => this._visibleTiles.get(e11.tileKey.id)).filter((e11) => void 0 !== e11);
      p7.push(...i9);
    }
    return p7;
  }
  _findPlaceholdersForMissingTiles(e9, i9) {
    const t8 = [];
    for (const s7 of this._tiles.values()) this._addPlaceholderChild(t8, s7, e9, i9);
    const l6 = t8.reduce(a8, 0);
    Math.abs(1 - l6) < n5 || this._addPlaceholderParent(e9.id, i9);
  }
  _addPlaceholderChild(e9, i9, t8, l6) {
    i9.key.level <= t8.level || !i9.hasData() || d2(t8, i9.key) && (this._addToContainer(i9), l6.add(i9.id), e9.push(i9.key.level - t8.level));
  }
  _addPlaceholderParent(e9, i9) {
    const t8 = this._tiles;
    let l6 = e9;
    for (; ; ) {
      if (l6 = c2(l6), !l6 || i9.has(l6)) return;
      const e10 = t8.get(l6);
      if (e10 == null ? void 0 : e10.hasData()) return this._addToContainer(e10), void i9.add(e10.id);
    }
  }
  _getOrAcquireTile(e9) {
    let i9 = this._tiles.get(e9);
    return i9 || (i9 = this._tileCache.pop(e9), i9 || (i9 = this.acquireTile(new e3(e9))), this._tiles.set(e9, i9), i9);
  }
  _releaseTile(e9) {
    const i9 = this._tiles.get(e9);
    this.releaseTile(i9), this._removeFromContainer(i9), this._tiles.delete(e9), i9.hasData() ? this._tileCache.put(e9, i9, 1) : i9.dispose();
  }
  _addToContainer(e9) {
    let i9;
    const t8 = [], l6 = this._container;
    if (l6.contains(e9)) return;
    const s7 = this._visibleTiles;
    for (const o6 of s7.values()) this._canConnectDirectly(e9, o6) && t8.push(o6), null == i9 && this._canConnectDirectly(o6, e9) && (i9 = o6);
    if (null != i9) {
      for (const l7 of t8) i9.childrenTiles.delete(l7), e9.childrenTiles.add(l7), l7.parentTile = e9;
      i9.childrenTiles.add(e9), e9.parentTile = i9;
    } else for (const o6 of t8) e9.childrenTiles.add(o6), o6.parentTile = e9;
    s7.set(e9.id, e9), l6.addChild(e9);
  }
  _removeFromContainer(e9) {
    if (this._visibleTiles.delete(e9.id), this._container.removeChild(e9), null != e9.parentTile) {
      e9.parentTile.childrenTiles.delete(e9);
      for (const i9 of e9.childrenTiles) null != e9.parentTile && e9.parentTile.childrenTiles.add(i9);
    }
    for (const i9 of e9.childrenTiles) i9.parentTile = e9.parentTile;
    e9.parentTile = null, e9.childrenTiles.clear();
  }
  _canConnectDirectly(e9, i9) {
    const t8 = e9.key;
    let { level: l6, row: s7, col: o6, world: r13 } = i9.key;
    const n8 = this._visibleTiles;
    for (; l6 > 0; ) {
      if (l6--, s7 >>= 1, o6 >>= 1, t8.level === l6 && t8.row === s7 && t8.col === o6 && t8.world === r13) return true;
      if (n8.has(`${l6}/${s7}/${o6}/${r13}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e9) {
    const i9 = e9.state.size;
    if (i9[0] === this._viewSize[0] && i9[1] === this._viewSize[1]) return;
    const t8 = Math.ceil(i9[0] / r10) + 1, l6 = Math.ceil(i9[1] / r10) + 1;
    this._viewSize[0] = i9[0], this._viewSize[1] = i9[1], this._tileCache.maxSize = 5 * t8 * l6;
  }
};
function c2(e9) {
  const [i9, t8, l6, s7] = e9.split("/"), o6 = parseInt(i9, 10);
  return 0 === o6 ? null : `${o6 - 1}/${parseInt(t8, 10) >> 1}/${parseInt(l6, 10) >> 1}/${parseInt(s7, 10)}`;
}
function d2(e9, i9) {
  const t8 = i9.level - e9.level;
  return e9.row === i9.row >> t8 && e9.col === i9.col >> t8 && e9.world === i9.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t3 = class {
  constructor(t8, s7) {
    this.sourceTile = s7, this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.featureIndex = 0, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t8;
  }
};
var s6 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function o4(t8, e9, s7, o6, i9, l6) {
  const r13 = s7 - i9;
  if (r13 >= 0) return (e9 >> r13) + (o6 - (l6 << r13)) * (t8 >> r13);
  const n8 = -r13;
  return e9 - (l6 - (o6 << n8)) * (t8 >> n8) << n8;
}
var i5 = class {
  constructor(t8, e9, s7) {
    this._rows = Math.ceil(e9 / s7), this._columns = Math.ceil(t8 / s7), this._cellSize = s7, this.cells = new Array(this._rows);
    for (let o6 = 0; o6 < this._rows; o6++) {
      this.cells[o6] = new Array(this._columns);
      for (let t9 = 0; t9 < this._columns; t9++) this.cells[o6][t9] = [];
    }
  }
  getCell(t8, e9) {
    const s7 = Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this._rows - 1), o6 = Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this._columns - 1);
    return this.cells[s7] && this.cells[s7][o6] || null;
  }
  getCellSpan(t8, e9, s7, o6) {
    return [Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s7 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l3(t8, e9, o6, i9, l6, r13, n8) {
  const c7 = e9[i9++];
  for (let a9 = 0; a9 < c7; a9++) {
    const c8 = new t3(r13, n8);
    c8.xTile = e9[i9++], c8.yTile = e9[i9++], c8.hash = e9[i9++], c8.priority = e9[i9++], c8.featureIndex = e9[i9++];
    const a10 = e9[i9++];
    for (let t9 = 0; t9 < a10; t9++) {
      const t10 = e9[i9++], s7 = e9[i9++], l7 = e9[i9++], r14 = e9[i9++], n9 = !!e9[i9++], a11 = e9[i9++], h8 = o6[i9++], u7 = o6[i9++], f4 = e9[i9++], m4 = e9[i9++];
      c8.colliders.push({ xTile: t10, yTile: s7, dxPixels: l7, dyPixels: r14, hard: n9, partIndex: a11, width: f4, height: m4, minLod: h8, maxLod: u7 });
    }
    const h7 = t8[i9++];
    for (let e10 = 0; e10 < h7; e10++) c8.textVertexRanges.push([t8[i9++], t8[i9++]]);
    const u6 = t8[i9++];
    for (let e10 = 0; e10 < u6; e10++) c8.iconVertexRanges.push([t8[i9++], t8[i9++]]);
    l6.push(c8);
  }
  return i9;
}
function r11(t8, e9, s7) {
  for (const [o6, i9] of t8.symbols) n6(t8, e9, s7, i9, o6);
}
function n6(e9, s7, o6, i9, l6) {
  const r13 = e9.layerData.get(l6);
  if (r13.type === E.SYMBOL) {
    for (const t8 of i9) {
      const s8 = t8.unique;
      let i10;
      if (t8.selectedForRendering) {
        const t9 = s8.parts[0], l7 = t9.startOpacity, r14 = t9.targetOpacity;
        e9.allSymbolsFadingOut = e9.allSymbolsFadingOut && 0 === r14;
        const n8 = o6 ? Math.floor(127 * l7) | r14 << 7 : r14 ? 255 : 0;
        i10 = n8 << 24 | n8 << 16 | n8 << 8 | n8;
      } else i10 = 0;
      for (const [e10, o7] of t8.iconVertexRanges) for (let t9 = e10; t9 < e10 + o7; t9 += 4) r13.iconOpacity[t9 / 4] = i10;
      if (t8.selectedForRendering) {
        const t9 = s8.parts[1], l7 = t9.startOpacity, r14 = t9.targetOpacity;
        e9.allSymbolsFadingOut = e9.allSymbolsFadingOut && 0 === r14;
        const n8 = o6 ? Math.floor(127 * l7) | r14 << 7 : r14 ? 255 : 0;
        i10 = n8 << 24 | n8 << 16 | n8 << 8 | n8;
      } else i10 = 0;
      for (const [e10, o7] of t8.textVertexRanges) for (let t9 = e10; t9 < e10 + o7; t9 += 4) r13.textOpacity[t9 / 4] = i10;
    }
    r13.lastOpacityUpdate = s7, r13.opacityChanged = true;
  }
}
function c3(t8, s7, o6, i9) {
  const l6 = t8.colliders;
  let r13, n8, c7, a9;
  for (const h7 of l6) {
    if (t8.unique.show && t8.unique.parts[h7.partIndex].show && (r13 = h7.xScreen - i9[0] + h7.dxScreen, n8 = h7.yScreen - i9[1] + h7.dyScreen, c7 = r13 + h7.width, a9 = n8 + h7.height, w(o6, s7.x, s7.y, r13, n8, c7, a9))) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var h4 = class {
  constructor(t8, e9) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t8;
    let r13 = 1;
    const n8 = new Uint32Array(t8);
    this.layerUIDs = [];
    const i9 = n8[r13++];
    for (let s7 = 0; s7 < i9; s7++) this.layerUIDs[s7] = n8[r13++];
    this.bufferDataOffset = r13, e9 && (this.layer = e9.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this._data = null, this.isDestroyed = true);
  }
  prepareForRendering(t8) {
    null != this._data && (this.doPrepareForRendering(t8, this._data, this.bufferDataOffset), this._data = null);
  }
};
var c4 = class extends h4 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let i9 = this.bufferDataOffset;
    this.lineIndexStart = r13[i9++], this.lineIndexCount = r13[i9++];
    const s7 = r13[i9++];
    if (s7 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < s7; t9++) {
        const t10 = r13[i9++], e10 = r13[i9++], n8 = r13[i9++];
        this.patternMap.set(t10, [e10, n8]);
      }
    }
    this.bufferDataOffset = i9;
  }
  get usedMemory() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.cachedMemory) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = r3(this.vao);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n8 = new Uint32Array(e9), i9 = new Int32Array(n8.buffer), h7 = n8[r13++], c7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, h7));
    r13 += h7;
    const f4 = n8[r13++], l6 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, f4));
    r13 += f4;
    const u6 = this.layer.lineMaterial;
    this.vao = new o2(t8, u6.getAttributeLocations(), u6.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", c7]]), l6);
  }
};
var f3 = class extends h4 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let i9 = this.bufferDataOffset;
    this.fillIndexStart = r13[i9++], this.fillIndexCount = r13[i9++], this.outlineIndexStart = r13[i9++], this.outlineIndexCount = r13[i9++];
    const s7 = r13[i9++];
    if (s7 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < s7; t9++) {
        const t10 = r13[i9++], e10 = r13[i9++], n8 = r13[i9++];
        this.patternMap.set(t10, [e10, n8]);
      }
    }
    this.bufferDataOffset = i9;
  }
  get usedMemory() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.cachedMemory) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.cachedMemory) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = r3(this.fillVAO), this.outlineVAO = r3(this.outlineVAO);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n8 = new Uint32Array(e9), i9 = new Int32Array(n8.buffer), h7 = n8[r13++], c7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, h7));
    r13 += h7;
    const f4 = n8[r13++], l6 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, f4));
    r13 += f4;
    const u6 = n8[r13++], y7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, u6));
    r13 += u6;
    const d4 = n8[r13++], A2 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, d4));
    r13 += d4;
    const p7 = this.layer, I3 = p7.fillMaterial, g2 = p7.outlineMaterial;
    this.fillVAO = new o2(t8, I3.getAttributeLocations(), I3.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", c7]]), l6), this.outlineVAO = new o2(t8, g2.getAttributeLocations(), g2.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", y7]]), A2);
  }
};
var l4 = class extends h4 {
  constructor(t8, e9, s7) {
    super(t8, e9), this.type = E.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const a9 = new Uint32Array(t8), o6 = new Int32Array(t8), h7 = new Float32Array(t8);
    let c7 = this.bufferDataOffset;
    this.isIconSDF = !!a9[c7++];
    const f4 = a9[c7++], l6 = a9[c7++], u6 = a9[c7++], y7 = new e3(f4, l6, u6, 0), d4 = a9[c7++];
    for (let r13 = 0; r13 < d4; r13++) {
      const t9 = a9[c7++], e10 = a9[c7++], r14 = a9[c7++];
      this.iconPerPageElementsMap.set(t9, [e10, r14]);
    }
    const A2 = a9[c7++];
    for (let r13 = 0; r13 < A2; r13++) {
      const t9 = a9[c7++], e10 = a9[c7++], r14 = a9[c7++];
      this.glyphPerPageElementsMap.set(t9, [e10, r14]);
    }
    const p7 = a9[c7++], I3 = a9[c7++];
    this.iconOpacity = new Int32Array(p7), this.textOpacity = new Int32Array(I3), c7 = l3(a9, o6, h7, c7, this.symbols, s7, y7), this.bufferDataOffset = c7;
  }
  get usedMemory() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.cachedMemory) ?? 0) + (((_c = this.textVAO) == null ? void 0 : _c.cachedMemory) ?? 0) + i(this.iconOpacity) + i(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t8 = 0;
    for (const e9 of this.iconPerPageElementsMap.values()) t8 += e9[1];
    for (const e9 of this.glyphPerPageElementsMap.values()) t8 += e9[1];
    return t8 / 3;
  }
  doDestroy() {
    this.iconVAO = r3(this.iconVAO), this.textVAO = r3(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged) return;
    this.opacityChanged = false;
    const t8 = this.iconOpacity, e9 = this.iconVAO.vertexBuffers.get("opacity");
    t8.length > 0 && t8.byteLength === e9.usedMemory && e9.setSubData(t8, 0, 0, t8.length);
    const r13 = this.textOpacity, n8 = this.textVAO.vertexBuffers.get("opacity");
    r13.length > 0 && r13.byteLength === n8.usedMemory && n8.setSubData(r13, 0, 0, r13.length);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n8 = new Uint32Array(e9), i9 = new Int32Array(n8.buffer), h7 = n8[r13++], c7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, h7));
    r13 += h7;
    const f4 = n8[r13++], l6 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, f4));
    r13 += f4;
    const u6 = n8[r13++], y7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, u6));
    r13 += u6;
    const d4 = n8[r13++], A2 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, d4));
    r13 += d4;
    const p7 = E2.createVertex(t8, F.STATIC_DRAW, this.iconOpacity.buffer), I3 = E2.createVertex(t8, F.STATIC_DRAW, this.textOpacity.buffer), g2 = this.layer, x = g2.iconMaterial, m4 = g2.textMaterial;
    this.iconVAO = new o2(t8, x.getAttributeLocations(), x.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", c7], ["opacity", p7]]), l6), this.textVAO = new o2(t8, m4.getAttributeLocations(), m4.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", y7], ["opacity", I3]]), A2);
  }
};
var u4 = class extends h4 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let i9 = this.bufferDataOffset;
    this.circleIndexStart = r13[i9++], this.circleIndexCount = r13[i9++], this.bufferDataOffset = i9;
  }
  get usedMemory() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.cachedMemory) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = r3(this.vao);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n8 = new Uint32Array(e9), i9 = new Int32Array(n8.buffer), h7 = n8[r13++], c7 = E2.createVertex(t8, F.STATIC_DRAW, new Int32Array(i9.buffer, 4 * r13, h7));
    r13 += h7;
    const f4 = n8[r13++], l6 = E2.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n8.buffer, 4 * r13, f4));
    r13 += f4;
    const u6 = this.layer.circleMaterial;
    this.vao = new o2(t8, u6.getAttributeLocations(), u6.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", c7]]), l6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var y4 = class _y extends r7 {
  constructor(e9, t8, s7, r13, a9, i9, o6, h7 = null) {
    super(e9, t8, s7, r13, a9, i9, 4096, 4096), this.styleRepository = o6, this._memCache = h7, this.type = "vector-tile", this._referenced = 1, this._hasSymbolBuckets = false, this._usedMemory = 256, this.layerData = /* @__PURE__ */ new Map(), this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this.featureIndex = null, this.triangleCount = 0, this._processed = false, this.id = e9.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e4;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e4);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e9) {
    this.changeDataImpl(e9), this.requestRender(), this.ready(), this._processed = true;
  }
  deleteLayerData(e9) {
    var _a, _b;
    let t8 = false;
    for (const s7 of e9) {
      const e10 = this.layerData.get(s7);
      e10 && (this._usedMemory -= e10.usedMemory, e10.type === E.SYMBOL && this.symbols.delete(s7) && (t8 = true), e10.destroy(), this.layerData.delete(s7));
    }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this), t8 && ((_b = this.featureIndex) == null ? void 0 : _b.clear(), this.emit("symbols-changed")), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerData.size > 0;
  }
  hasFeatures() {
    const e9 = this.layerData.values();
    for (const t8 of e9) if (t8.hasData()) return true;
    return false;
  }
  dispose() {
    "unloaded" !== this.status && (_y._destroyRenderBuckets(this.layerData), this.layerData.clear(), this.featureIndex = null, this._usedMemory = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    0 == --this._referenced && (this.dispose(), this.stage = null);
  }
  retain() {
    ++this._referenced;
  }
  get cachedMemory() {
    return this._usedMemory;
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get usedMemoryPerReference() {
    return this._usedMemory / (this._referenced || 1);
  }
  changeDataImpl(e9) {
    var _a, _b;
    (_a = this.featureIndex) == null ? void 0 : _a.clear();
    let t8 = false;
    if (e9) {
      const { bucketsWithData: s7, emptyBuckets: r13 } = e9, a9 = this._createRenderBuckets(s7);
      if (r13 && r13.byteLength > 0) {
        const e10 = new Uint32Array(r13);
        for (const t9 of e10) this._deleteLayerData(t9);
      }
      for (const [e10, o6] of a9) this._deleteLayerData(e10), o6.type === E.SYMBOL && (this.symbols.set(e10, o6.symbols), t8 = true), this._usedMemory += o6.usedMemory, this.layerData.set(e10, o6);
      (_b = this._memCache) == null ? void 0 : _b.updateSize(this.key.id, this);
    }
    this._hasSymbolBuckets = false;
    for (const s7 of this.layerData.values()) s7.type === E.SYMBOL && (this._hasSymbolBuckets = true);
    t8 && this.emit("symbols-changed");
  }
  attachWithContext(e9) {
    this.stage = { context: e9, trashDisplayObject(e10) {
      e10.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(a9) {
    super.setTransform(a9);
    const i9 = this.resolution / (a9.resolution * a9.pixelRatio), o6 = this.width / this.rangeX * i9, h7 = this.height / this.rangeY * i9, n8 = [0, 0];
    a9.toScreen(n8, [this.x, this.y]);
    const l6 = this.transforms.tileUnitsToPixels;
    o(l6), M(l6, l6, n8), h(l6, l6, Math.PI * a9.rotation / 180), f2(l6, l6, [o6, h7, 1]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6(), tileMat3: e6(), tileUnitsToPixels: e6() };
  }
  static _destroyRenderBuckets(e9) {
    if (!e9) return;
    const t8 = /* @__PURE__ */ new Set();
    for (const s7 of e9.values()) t8.has(s7) || (s7.destroy(), t8.add(s7));
    e9.clear();
  }
  _createRenderBuckets(e9) {
    const t8 = /* @__PURE__ */ new Map(), s7 = /* @__PURE__ */ new Map();
    for (const r13 of e9) {
      const e10 = this._deserializeBucket(r13, s7);
      for (const s8 of e10.layerUIDs) t8.set(s8, e10);
    }
    return t8;
  }
  _deserializeBucket(e9, t8) {
    let s7 = t8.get(e9);
    if (s7) return s7;
    switch (new Uint32Array(e9)[0]) {
      case E.FILL:
        s7 = new f3(e9, this.styleRepository);
        break;
      case E.LINE:
        s7 = new c4(e9, this.styleRepository);
        break;
      case E.SYMBOL:
        s7 = new l4(e9, this.styleRepository, this);
        break;
      case E.CIRCLE:
        s7 = new u4(e9, this.styleRepository);
    }
    return t8.set(e9, s7), s7;
  }
  _deleteLayerData(e9) {
    if (!this.layerData.has(e9)) return;
    const t8 = this.layerData.get(e9);
    this._usedMemory -= t8.usedMemory, t8.destroy(), this.layerData.delete(e9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i6(e9, t8, n8, o6, i9, l6) {
  const { iconRotationAlignment: a9, textRotationAlignment: c7, iconTranslate: h7, iconTranslateAnchor: u6, textTranslate: d4, textTranslateAnchor: y7 } = o6;
  let x = 0;
  for (const g2 of e9.colliders) {
    const [e10, o7] = 0 === g2.partIndex ? h7 : d4, m4 = 0 === g2.partIndex ? u6 : y7, f4 = g2.minLod <= l6 && l6 <= g2.maxLod;
    x += f4 ? 0 : 1, g2.enabled = f4, g2.xScreen = g2.xTile * i9[0] + g2.yTile * i9[3] + i9[6], g2.yScreen = g2.xTile * i9[1] + g2.yTile * i9[4] + i9[7], m4 === r5.MAP ? (g2.xScreen += n8 * e10 - t8 * o7, g2.yScreen += t8 * e10 + n8 * o7) : (g2.xScreen += e10, g2.yScreen += o7), l.VIEWPORT === (0 === g2.partIndex ? a9 : c7) ? (g2.dxScreen = g2.dxPixels, g2.dyScreen = g2.dyPixels) : (g2.dxScreen = n8 * (g2.dxPixels + g2.width / 2) - t8 * (g2.dyPixels + g2.height / 2) - g2.width / 2, g2.dyScreen = t8 * (g2.dxPixels + g2.width / 2) + n8 * (g2.dyPixels + g2.height / 2) - g2.height / 2);
  }
  e9.colliders.length > 0 && x === e9.colliders.length && (e9.unique.show = false);
}
var l5 = class {
  constructor(o6, r13, s7, i9, l6, a9) {
    this._symbols = o6, this._styleRepository = i9, this._zoom = l6, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new i5(r13, s7, t2), this._si = Math.sin(Math.PI * a9 / 180), this._co = Math.cos(Math.PI * a9 / 180);
    for (const t8 of o6) for (const n8 of t8.symbols) this._allNeededMatrices.has(n8.tile) || this._allNeededMatrices.set(n8.tile, r6(n8.tile.transforms.tileUnitsToPixels));
  }
  work(e9) {
    const t8 = this._gridIndex;
    function n8(e10) {
      const n9 = e10.xScreen + e10.dxScreen, o7 = e10.yScreen + e10.dyScreen, r13 = n9 + e10.width, s7 = o7 + e10.height, [i9, l6, a9, c7] = t8.getCellSpan(n9, o7, r13, s7);
      for (let h7 = l6; h7 <= c7; h7++) for (let e11 = i9; e11 <= a9; e11++) {
        const i10 = t8.cells[h7][e11];
        for (const e12 of i10) {
          const t9 = e12.xScreen + e12.dxScreen, i11 = e12.yScreen + e12.dyScreen, l7 = t9 + e12.width, a10 = i11 + e12.height;
          if (!(r13 < t9 || n9 > l7 || s7 < i11 || o7 > a10)) return true;
        }
      }
      return false;
    }
    const o6 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t9 = this._symbols[this._currentLayerCursor], r13 = this._getProperties(t9.styleLayerUID);
      for (; this._currentSymbolCursor < t9.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o6 > e9) return false;
        const s7 = t9.symbols[this._currentSymbolCursor];
        if (!s7.unique.show) continue;
        i6(s7, this._si, this._co, r13, this._allNeededMatrices.get(s7.tile), this._zoom);
        const l6 = s7.unique;
        if (!l6.show) continue;
        const { iconAllowOverlap: a9, iconIgnorePlacement: c7, textAllowOverlap: h7, textIgnorePlacement: u6 } = r13;
        for (const e10 of s7.colliders) {
          if (!e10.enabled) continue;
          const t10 = l6.parts[e10.partIndex];
          if (!t10.show) continue;
          !(e10.partIndex ? h7 : a9) && n8(e10) && (e10.hard ? l6.show = false : t10.show = false);
        }
        if (l6.show) for (const e10 of s7.colliders) {
          if (!e10.enabled) continue;
          if (e10.partIndex ? u6 : c7) continue;
          if (!l6.parts[e10.partIndex].show) continue;
          const t10 = e10.xScreen + e10.dxScreen, n9 = e10.yScreen + e10.dyScreen, o7 = t10 + e10.width, r14 = n9 + e10.height, [s8, i9, a10, h8] = this._gridIndex.getCellSpan(t10, n9, o7, r14);
          for (let l7 = i9; l7 <= h8; l7++) for (let t11 = s8; t11 <= a10; t11++) {
            this._gridIndex.cells[l7][t11].push(e10);
          }
        }
      }
    }
    return true;
  }
  _getProperties(e9) {
    const t8 = this._styleProps.get(e9);
    if (t8) return t8;
    const n8 = this._zoom, s7 = this._styleRepository.getStyleLayerByUID(e9), i9 = s7.getLayoutValue("symbol-placement", n8) !== n2.POINT;
    let l6 = s7.getLayoutValue("icon-rotation-alignment", n8);
    l6 === l.AUTO && (l6 = i9 ? l.MAP : l.VIEWPORT);
    let a9 = s7.getLayoutValue("text-rotation-alignment", n8);
    a9 === l.AUTO && (a9 = i9 ? l.MAP : l.VIEWPORT);
    const c7 = s7.getPaintValue("icon-translate", n8), h7 = s7.getPaintValue("icon-translate-anchor", n8), u6 = s7.getPaintValue("text-translate", n8), d4 = s7.getPaintValue("text-translate-anchor", n8), y7 = { iconAllowOverlap: s7.getLayoutValue("icon-allow-overlap", n8), iconIgnorePlacement: s7.getLayoutValue("icon-ignore-placement", n8), textAllowOverlap: s7.getLayoutValue("text-allow-overlap", n8), textIgnorePlacement: s7.getLayoutValue("text-ignore-placement", n8), iconRotationAlignment: l6, textRotationAlignment: a9, iconTranslateAnchor: h7, iconTranslate: c7, textTranslateAnchor: d4, textTranslate: u6 };
    return this._styleProps.set(e9, y7), y7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function e8(o6, e9) {
  if (o6.priority - e9.priority) return o6.priority - e9.priority;
  const t8 = o6.tile.key, i9 = e9.tile.key;
  return t8.world - i9.world ? t8.world - i9.world : t8.level - i9.level ? t8.level - i9.level : t8.row - i9.row ? t8.row - i9.row : t8.col - i9.col ? t8.col - i9.col : o6.xTile - e9.xTile ? o6.xTile - e9.xTile : o6.yTile - e9.yTile;
}
var t4 = class {
  get running() {
    return this._running;
  }
  constructor(o6, e9, t8, i9, s7, n8) {
    this._visibleTiles = o6, this._symbolRepository = e9, this._createCollisionJob = t8, this._assignTileSymbolsOpacity = i9, this._symbolLayerSorter = s7, this._isLayerVisible = n8, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o6, e9) {
    this._screenWidth === o6 && this._screenHeight === e9 || this.restart(), this._screenWidth = o6, this._screenHeight = e9;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o6) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const e9 = performance.now();
      if (!this._selectionJob.work(o6)) return false;
      if (this._selectionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const e9 = performance.now();
      if (!this._collisionJob.work(o6)) return false;
      if (this._collisionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const e9 = performance.now();
      if (!this._opacityJob.work(o6)) return false;
      if (this._opacityJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o6 = this._symbolRepository.uniqueSymbols;
    for (let e9 = 0; e9 < o6.length; e9++) {
      const t9 = o6[e9];
      for (let o7 = 0; o7 < t9.uniqueSymbols.length; o7++) {
        const e10 = t9.uniqueSymbols[o7];
        for (const o8 of e10.tileSymbols) o8.selectedForRendering = false;
      }
    }
    const t8 = [];
    let i9 = 0, s7 = 0;
    const n8 = this._isLayerVisible;
    function r13(r14) {
      let l7;
      const c7 = performance.now();
      for (; s7 < o6.length; s7++, i9 = 0) {
        const e9 = o6[s7], h7 = e9.styleLayerUID;
        if (!n8(h7)) {
          t8[s7] || (t8[s7] = { styleLayerUID: h7, symbols: [] });
          continue;
        }
        t8[s7] = t8[s7] || { styleLayerUID: h7, symbols: [] };
        const a9 = t8[s7];
        for (; i9 < e9.uniqueSymbols.length; i9++) {
          if (l7 = e9.uniqueSymbols[i9], i9 % 100 == 99 && performance.now() - c7 > r14) return false;
          let o7 = null, t9 = false, s8 = false;
          for (const e10 of l7.tileSymbols) if (!s8 || !t9) {
            const i10 = e10.tile;
            (!o7 || i10.isCoverage || i10.neededForCoverage && !t9) && (o7 = e10, (i10.neededForCoverage || i10.isCoverage) && (s8 = true), i10.isCoverage && (t9 = true));
          }
          if (o7.selectedForRendering = true, s8) {
            a9.symbols.push(o7), l7.show = true;
            for (const o8 of l7.parts) o8.show = true;
          } else l7.show = false;
        }
      }
      for (const o7 of t8) o7.symbols.sort(e8);
      return true;
    }
    const l6 = this._symbolLayerSorter;
    return { work: r13, get sortedSymbols() {
      return t8.sort(l6);
    } };
  }
  _createOpacityJob() {
    const o6 = this._assignTileSymbolsOpacity, e9 = this._visibleTiles;
    let t8 = 0;
    function s7(e10, t9) {
      for (const o7 of e10.symbols.values()) i7(o7, t9);
      o6(e10, t9);
      for (const o7 of e10.childrenTiles) s7(o7, t9);
    }
    return { work(o7) {
      const i9 = performance.now();
      for (; t8 < e9.length; t8++) {
        if (performance.now() - i9 > o7) return false;
        const n8 = e9[t8];
        if (null != n8.parentTile) continue;
        s7(n8, performance.now());
      }
      return true;
    } };
  }
};
function i7(e9, t8) {
  for (const i9 of e9) {
    const e10 = i9.unique;
    for (const i10 of e10.parts) {
      const s7 = i10.targetOpacity > 0.5 ? 1 : -1;
      i10.startOpacity += s7 * ((t8 - i10.startTime) / e4), i10.startOpacity = Math.min(Math.max(i10.startOpacity, 0), 1), i10.startTime = t8, i10.targetOpacity = e10.show && i10.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var o5 = 32;
var t5 = 8;
var i8 = 64;
var n7 = 20;
var r12 = class {
  constructor(e9, s7, l6) {
    this.tileCoordRange = e9, this._visibleTiles = s7, this._createUnique = l6, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  get uniqueSymbolsReferences() {
    return this._uniqueSymbolsReferences;
  }
  add(s7, l6) {
    this._uniqueSymbolLayerArray = null;
    let n8 = this._tiles.get(s7.id);
    n8 || (n8 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s7.id, n8));
    const r13 = /* @__PURE__ */ new Map();
    if (l6) for (const e9 of l6) n8.symbols.has(e9) && (r13.set(e9, n8.symbols.get(e9)), n8.symbols.delete(e9));
    else for (const [e9, o6] of s7.layerData) n8.symbols.has(e9) && (r13.set(e9, n8.symbols.get(e9)), n8.symbols.delete(e9));
    this._removeSymbols(r13);
    const y7 = s7.symbols, a9 = /* @__PURE__ */ new Map();
    for (const [f4, u6] of y7) {
      let s8 = u6.length;
      if (s8 >= o5) {
        let l7 = this.tileCoordRange;
        do {
          l7 /= 2, s8 /= 4;
        } while (s8 > t5 && l7 > i8);
        const o6 = new i5(this.tileCoordRange, this.tileCoordRange, l7);
        a9.set(f4, { flat: u6, index: o6 }), n8.symbols.set(f4, { flat: u6, index: o6 });
        for (const e9 of u6) o6.getCell(e9.xTile, e9.yTile).push(e9);
      } else a9.set(f4, { flat: u6 }), n8.symbols.set(f4, { flat: u6 });
    }
    this._addSymbols(s7.key, y7);
  }
  deleteStyleLayers(e9) {
    this._uniqueSymbolLayerArray = null;
    for (const [s7, l6] of this._tiles) {
      const o6 = /* @__PURE__ */ new Map();
      for (const s8 of e9) l6.symbols.has(s8) && (o6.set(s8, l6.symbols.get(s8)), l6.symbols.delete(s8));
      this._removeSymbols(o6), 0 === l6.symbols.size && this._tiles.delete(s7);
    }
  }
  removeTile(e9) {
    this._uniqueSymbolLayerArray = null;
    const s7 = this._tiles.get(e9.id);
    if (!s7) return;
    const l6 = /* @__PURE__ */ new Map();
    for (const [o6, t8] of e9.symbols) s7.symbols.has(o6) && (l6.set(o6, s7.symbols.get(o6)), s7.symbols.delete(o6));
    this._removeSymbols(l6), 0 === s7.symbols.size && this._tiles.delete(e9.id);
  }
  querySymbols(e9, l6, o6, t8) {
    const i9 = [], n8 = this.uniqueSymbols;
    for (const r13 of n8) {
      const t9 = r13.styleLayerUID, n9 = r13.uniqueSymbols;
      for (const r14 of n9) {
        const n10 = r14.tileSymbols.find((e10) => e10.selectedForRendering);
        n10 && c3(n10, e9, l6 * (window.devicePixelRatio || 1), o6) && i9.push({ vtlSymbol: n10, styleLayerUID: t9, tileKey: n10.tile.key });
      }
    }
    return i9;
  }
  _removeSymbols(e9) {
    for (const [s7, { flat: l6 }] of e9) for (const e10 of l6) {
      const l7 = e10.unique, o6 = l7.tileSymbols, t8 = o6.length - 1;
      for (let s8 = 0; s8 < t8; s8++) if (o6[s8] === e10) {
        o6[s8] = o6[t8];
        break;
      }
      if (o6.length = t8, 0 === t8) {
        const e11 = this._uniqueSymbolsReferences.get(s7);
        e11.delete(l7), 0 === e11.size && this._uniqueSymbolsReferences.delete(s7);
      }
      e10.unique = null;
    }
  }
  _addSymbols(e9, s7) {
    if (0 === s7.size) return;
    const l6 = this._visibleTiles;
    for (const o6 of l6) o6.parentTile || o6.key.world !== e9.world || o6.key.level === e9.level && !o6.key.equals(e9) || this._matchSymbols(o6, e9, s7);
    for (const [o6, t8] of s7) for (const e10 of t8) if (null == e10.unique) {
      const s8 = this._createUnique();
      e10.unique = s8, s8.tileSymbols.push(e10);
      let l7 = this._uniqueSymbolsReferences.get(o6);
      l7 || (l7 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o6, l7)), l7.add(s8);
    }
  }
  _matchSymbols(e9, s7, o6) {
    if (e9.key.level > s7.level) {
      const l6 = e9.key.level - s7.level;
      if (e9.key.row >> l6 !== s7.row || e9.key.col >> l6 !== s7.col) return;
    }
    if (s7.level > e9.key.level) {
      const l6 = s7.level - e9.key.level;
      if (s7.row >> l6 !== e9.key.row || s7.col >> l6 !== e9.key.col) return;
    }
    if (s7.equals(e9.key)) {
      for (const l6 of e9.childrenTiles) this._matchSymbols(l6, s7, o6);
      return;
    }
    const t8 = /* @__PURE__ */ new Map();
    for (const [i9, r13] of o6) {
      const o7 = [];
      for (const t9 of r13) {
        const i10 = o4(this.tileCoordRange, t9.xTile, s7.level, s7.col, e9.key.level, e9.key.col), n8 = o4(this.tileCoordRange, t9.yTile, s7.level, s7.row, e9.key.level, e9.key.row);
        i10 >= 0 && i10 < this.tileCoordRange && n8 >= 0 && n8 < this.tileCoordRange && o7.push({ symbol: t9, xTransformed: i10, yTransformed: n8 });
      }
      const y7 = [], a9 = (e9.key.level < s7.level ? 1 : 1 << e9.key.level - s7.level) + n7, f4 = this._tiles.get(e9.id).symbols.get(i9);
      if (f4) {
        const e10 = f4.flat;
        for (const s8 of o7) {
          let l6, o8 = false;
          const t9 = s8.xTransformed, i10 = s8.yTransformed;
          l6 = null != f4.index ? f4.index.getCell(t9, i10) : e10;
          const n8 = s8.symbol, r14 = n8.hash;
          for (const e11 of l6) if (r14 === e11.hash && Math.abs(t9 - e11.xTile) <= a9 && Math.abs(i10 - e11.yTile) <= a9) {
            const s9 = e11.unique;
            n8.unique = s9, s9.tileSymbols.push(n8), o8 = true;
            break;
          }
          o8 || y7.push(n8);
        }
      }
      y7.length > 0 && t8.set(i9, y7);
    }
    for (const l6 of e9.childrenTiles) this._matchSymbols(l6, s7, t8);
  }
  _createUniqueSymbolLayerArray() {
    const e9 = this._uniqueSymbolsReferences, s7 = new Array(e9.size);
    let l6, o6 = 0;
    for (const [t8, i9] of e9) {
      const e10 = new Array(i9.size);
      l6 = 0;
      for (const s8 of i9) e10[l6++] = s8;
      s7[o6] = { styleLayerUID: t8, uniqueSymbols: e10 }, o6++;
    }
    return s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c5 = 0.5;
var h5 = 1e-6;
var _2 = class {
  constructor(e9, i9) {
    this.styleRepository = e9, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r4(false), this._symbolRepository = new r12(4096, i9, () => new s6()), this._symbolDeclutterer = new t4(i9, this._symbolRepository, (t8, e10, i10) => this._createCollisionJob(t8, e10, i10), (t8, e10) => {
      t8.allSymbolsFadingOut = true, t8.lastOpacityUpdate = e10, r11(t8, e10, true), t8.decluttered = true, t8.requestRender();
    }, (t8, e10) => this.styleRepository.getStyleLayerByUID(t8.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e10.styleLayerUID).z, (t8) => {
      const e10 = this.styleRepository.getStyleLayerByUID(t8);
      if (this._zoom + h5 < e10.minzoom || this._zoom - h5 >= e10.maxzoom) return false;
      const i10 = e10.getLayoutProperty("visibility");
      return !i10 || i10.getValue() !== i2.NONE;
    });
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t8, e9, i9) {
    return this.updateDecluttererViewState(), new l5(t8, e9, i9, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  addTile(t8) {
    t8.decluttered = false, this._tileToHandle.set(t8, t8.on("symbols-changed", () => {
      this._symbolRepository.add(t8), this.restartDeclutter();
    })), this._symbolRepository.add(t8), this.restartDeclutter();
  }
  removeTile(t8) {
    const e9 = this._tileToHandle.get(t8);
    e9 && (this._symbolRepository.removeTile(t8), this.restartDeclutter(), e9.remove(), this._tileToHandle.delete(t8));
  }
  update(t8, e9) {
    this._zoom = t8, this._viewState = { scale: e9.scale, rotation: e9.rotation, center: [e9.center[0], e9.center[1]], size: [e9.size[0], e9.size[1]] };
    const i9 = [0, 0];
    e9.toScreen(i9, e9.center);
    const s7 = [0, 0];
    return e9.toScreen(s7, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i9[0] - s7[0], this._offsetFromScreenCenter[1] = i9[1] - s7[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t8) => t8.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t8) {
    this._symbolRepository.deleteStyleLayers(t8);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + c5) * e4);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t6 = class extends r7 {
  _createTransforms() {
    return { displayViewScreenMat3: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y5 = 1e-6;
function p6(e9, t8) {
  if (e9) {
    const s7 = e9.getLayoutProperty("visibility");
    if (!s7 || s7.getValue() !== i2.NONE && (void 0 === e9.minzoom || e9.minzoom < t8 + y5) && (void 0 === e9.maxzoom || e9.maxzoom >= t8 - y5)) return true;
  }
  return false;
}
var m2 = class extends i3 {
  constructor(e9) {
    super(e9), this._backgroundTiles = [], this._computeDisplayInfoView(e9);
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    var _a;
    return ((_a = this._symbolFader) == null ? void 0 : _a.fading) ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    var _a;
    return (_a = this._symbolFader) == null ? void 0 : _a.symbolRepository;
  }
  setStyleResources(e9, t8, r13, i9) {
    this._spriteMosaic = e9, this._glyphMosaic = t8, this._styleRepository = r13, this.tileInfoView = i9, this._computeDisplayInfoView(i9), null == this._symbolFader && (this._symbolFader = new _2(this._styleRepository, this.children)), this._symbolFader.styleRepository = r13;
  }
  setSpriteMosaic(e9) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e9;
  }
  deleteStyleLayers(e9) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e9);
  }
  createRenderParams(e9) {
    return { ...super.createRenderParams(e9), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e9) {
    !this.visible || e9.drawPhase !== E3.MAP && e9.drawPhase !== E3.DEBUG || void 0 === this._spriteMosaic || super.doRender(e9);
  }
  addChild(e9) {
    return super.addChild(e9), null != this._symbolFader ? this._symbolFader.addTile(e9) : e9.decluttered = true, this.requestRender(), e9;
  }
  removeChild(e9) {
    return null != this._symbolFader && this._symbolFader.removeTile(e9), this.requestRender(), super.removeChild(e9);
  }
  renderChildren(e9) {
    const { drawPhase: t8 } = e9;
    t8 !== E3.DEBUG ? this._doRender(e9) : super.renderChildren(e9);
  }
  removeAllChildren() {
    for (let e9 = 0; e9 < this.children.length; e9++) {
      const t8 = this.children[e9];
      null != this._symbolFader && this._symbolFader.removeTile(t8), t8.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e9) => e9.neededForCoverage && e9.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e9) {
    const { context: t8, state: s7 } = e9, r13 = this._styleRepository;
    if (!r13) return;
    const i9 = r13.layers, o6 = this._displayInfo.scaleToZoom(s7.scale);
    r13.backgroundBucketIds.length > 0 && (e9.renderPass = "background", this._renderBackgroundLayers(e9, r13.backgroundBucketIds, o6)), super.renderChildren(e9), e9.drawPhase === E3.MAP && this._fade(o6, s7);
    const n8 = this.children.filter((e10) => e10.visible && e10.hasData());
    if (!n8 || 0 === n8.length) return t8.bindVAO(), t8.setStencilTestEnabled(true), void t8.setBlendingEnabled(true);
    for (const l6 of n8) l6.triangleCount = 0;
    t8.setStencilWriteMask(0), t8.setColorMask(true, true, true, true), t8.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(false), t8.setDepthTestEnabled(true), t8.setDepthWriteEnabled(true), t8.setDepthFunction(O.LEQUAL), t8.setClearDepth(1), t8.clear(t8.gl.DEPTH_BUFFER_BIT), e9.renderPass = "opaque";
    for (let l6 = i9.length - 1; l6 >= 0; l6--) this._renderStyleLayer(i9[l6], e9, n8);
    t8.setDepthWriteEnabled(false), t8.setBlendingEnabled(true), t8.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e9.renderPass = "translucent";
    for (let l6 = 0; l6 < i9.length; l6++) this._renderStyleLayer(i9[l6], e9, n8);
    t8.bindVAO(), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(true);
    for (const l6 of n8) l6.debugInfo.display.triangleCount = l6.triangleCount;
  }
  _fade(e9, t8) {
    null != this._symbolFader && (this._symbolFader.update(e9, t8) || this.requestRender());
  }
  _renderStyleLayer(e9, t8, s7) {
    const { displayLevel: l6, painter: o6, renderPass: n8 } = t8;
    if (void 0 === e9) return;
    const a9 = e9.getLayoutProperty("visibility");
    if (a9 && a9.getValue() === i2.NONE) return;
    let d4;
    switch (e9.type) {
      case a6.BACKGROUND:
        return;
      case a6.FILL:
        if ("opaque" !== n8 && "translucent" !== t8.renderPass) return;
        d4 = "vtlFill";
        break;
      case a6.LINE:
        if ("translucent" !== n8) return;
        d4 = "vtlLine";
        break;
      case a6.CIRCLE:
        if ("translucent" !== n8) return;
        d4 = "vtlCircle";
        break;
      case a6.SYMBOL:
        if ("translucent" !== n8) return;
        d4 = "vtlSymbol";
    }
    if (s7 = e9.type === a6.SYMBOL ? s7.filter((e10) => e10.decluttered) : s7.filter((e10) => e10.neededForCoverage), "vtlSymbol" !== d4 && (0 === s7.length || void 0 !== e9.minzoom && e9.minzoom >= l6 + y5 || void 0 !== e9.maxzoom && e9.maxzoom < l6 - y5)) return;
    const h7 = e9.uid;
    t8.styleLayerUID = h7, t8.styleLayer = e9;
    for (const r13 of s7) if (r13.layerData.has(h7)) {
      o6.renderObjects(t8, s7, d4);
      break;
    }
  }
  _renderBackgroundLayers(t8, s7, r13) {
    const { context: l6, painter: n8, state: u6 } = t8, y7 = this._styleRepository;
    let m4 = false;
    for (const e9 of s7) {
      if (y7.getLayerById(e9).type === a6.BACKGROUND && p6(y7.getLayerById(e9), r13)) {
        m4 = true;
        break;
      }
    }
    if (!m4) return;
    const f4 = this.tileInfoView, g2 = f4.getTileCoverage(t8.state, 0, true, "smallest"), { spans: _3, lodInfo: b3 } = g2, { level: E5 } = b3, C = u2(), F2 = [];
    if (this._renderPasses) {
      const e9 = this._renderPasses[0];
      null != this._clippingInfos && (e9.brushes[0].prepareState(t8), e9.brushes[0].drawMany(t8, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let R3, v = 0;
    for (const { row: i9, colFrom: a9, colTo: h7 } of _3) for (let t9 = a9; t9 <= h7; t9++) {
      if (v < L2.length) R3 = L2[v], R3.key.set(E5, i9, b3.normalizeCol(t9), b3.getWorldForColumn(t9)), f4.getTileBounds(C, R3.key, false), R3.x = C[0], R3.y = C[3], R3.resolution = f4.getTileResolution(E5);
      else {
        const s8 = new e3(E5, i9, b3.normalizeCol(t9), b3.getWorldForColumn(t9)), r14 = f4.getTileBounds(u2(), s8), l7 = f4.getTileResolution(E5);
        R3 = new t6(s8, l7, r14[0], r14[3], 512, 512, 4096, 4096), L2.push(R3);
      }
      R3.setTransform(u6), F2.push(R3), v++;
    }
    l6.setStencilWriteMask(0), l6.setColorMask(true, true, true, true), l6.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), l6.setStencilFunction(O.EQUAL, 0, 255), l6.setStencilTestEnabled(true);
    for (const e9 of s7) {
      const s8 = y7.getLayerById(e9);
      s8.type === a6.BACKGROUND && p6(s8, r13) && (t8.styleLayerUID = s8.uid, t8.styleLayer = s8, n8.renderObjects(t8, F2, "vtlBackground"));
    }
    s3.pool.release(g2);
  }
  _computeDisplayInfoView(e9) {
    let s7 = e9.tileInfo.lods[0].scale;
    const r13 = Math.max(25, e9.tileInfo.lods.length), i9 = [];
    for (let t8 = 0; t8 <= r13; t8++) i9.push(s7), s7 /= 2;
    this._displayInfo = z.create({ scales: i9, size: 512, spatialReference: e9.spatialReference, numLODs: r13 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var y6 = 8;
var c6 = 512;
var u5 = 4096;
var h6 = (e9, t8) => {
  const s7 = e9.vtlSymbol.sourceTile, r13 = t8.vtlSymbol.sourceTile;
  return s7.level !== r13.level ? s7.level - r13.level : s7.row !== r13.row ? s7.row - r13.row : s7.col !== r13.col ? s7.col - r13.col : e9.styleLayerUID - t8.styleLayerUID;
};
var d3 = class _d {
  constructor(e9, t8, s7, r13, i9) {
    this.tileKey = e9, this._tileLayerData = t8, this._styleRepository = s7, this._tileHandler = r13, this._parentLayer = i9, this._index = null, this._tileKeyToPBF = /* @__PURE__ */ new Map();
  }
  static create(e9, t8, s7, r13, i9) {
    return new _d(e9, t8, s7, r13, i9);
  }
  clear() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e9, t8, s7, i9, o6) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
    null === this._index && (this._index = new s2(100, m3), await this._indexLayers());
    const l6 = [];
    return this._queryIndex(l6, e9, t8, s7, this.tileKey.level, i9), o6 && (o6 == null ? void 0 : o6.length) > 0 && await this._getSymbolsAttributes(l6, o6), l6;
  }
  async _indexLayers() {
    const e9 = this.tileKey, t8 = this._styleRepository.layers, s7 = await this._getTilePayload(e9);
    for (const [r13, o6] of this._tileLayerData) {
      const l6 = t8[r13], a9 = s7.find((e10) => e10.sourceName === l6.source);
      if (!a9) continue;
      const { protobuff: n8, key: y7 } = a9;
      if (o6.type !== E.SYMBOL) {
        const t9 = 1 << e9.level - y7.level, s8 = e9.row - y7.row * t9, r14 = e9.col - y7.col * t9;
        this._indexLayer(l6, n8, e9.level, t9, s8, r14);
      }
    }
  }
  _indexLayer(e9, t8, r13, i9, y7, h7) {
    const d4 = e9.sourceLayer, m4 = e9.getFeatureFilter(), f4 = r13, _3 = r13 + 1, p7 = d(f4), g2 = new a5(new Uint8Array(t8), new DataView(t8));
    for (; g2.next(); ) switch (g2.tag()) {
      case 3: {
        const t9 = g2.getMessage(), s7 = new e5(t9);
        if (t9.release(), s7.name !== d4) continue;
        const l6 = s7.getData(), w3 = s7.extent / i9, x = w3 * h7 - p7, b3 = w3 * y7 - p7, I3 = x + w3 + 2 * p7, L2 = b3 + w3 + 2 * p7, v = w3 / c6, D3 = u5 / w3, T = w3 * h7, S3 = w3 * y7;
        for (; l6.nextTag(2); ) {
          const t10 = l6.getMessage(), i10 = new s4(t10, s7);
          if (t10.release(), m4 && !m4.filter(i10, r13)) continue;
          const a9 = i10.values || {}, y8 = a9._minzoom, c7 = a9._maxzoom;
          if (y8 && y8 >= 10 * _3 || c7 && c7 <= 10 * f4) continue;
          const u6 = e9.getFeatureInflatedBounds(i10, f4, s7.extent, v);
          null == u6 || u6[0] > I3 || u6[1] > L2 || u6[2] < x || u6[3] < b3 || (u6[0] = (u6[0] - T) * D3, u6[1] = (u6[1] - S3) * D3, u6[2] = (u6[2] - T) * D3, u6[3] = (u6[3] - S3) * D3, this._index.insert(new L(e9, i10, u6, D3, T, S3)));
        }
        break;
      }
      default:
        g2.skip();
    }
  }
  async _getSymbolsAttributes(e9, t8) {
    if (!t8 || 0 === t8.length) return e9;
    const s7 = [];
    t8.sort(h6);
    let r13 = t8[0].styleLayerUID, i9 = 0;
    for (let l6 = 0; l6 < t8.length; l6++) r13 !== t8[l6].styleLayerUID && (s7.push({ from: i9, to: l6, styleLayerUID: r13, sourceTileKey: t8[l6].vtlSymbol.sourceTile }), i9 = l6, r13 = t8[l6].styleLayerUID);
    s7.push({ from: i9, to: t8.length, styleLayerUID: r13, sourceTileKey: t8[t8.length - 1].vtlSymbol.sourceTile });
    const o6 = this._styleRepository.layers;
    for (const l6 of s7) {
      const s8 = await this._getTilePayload(l6.sourceTileKey), i10 = o6[l6.styleLayerUID], a9 = !!i10 && s8.find((e10) => e10.sourceName === i10.source);
      a9 && this._addSymbolsAttributes(e9, t8.slice(l6.from, l6.to).map((e10) => e10.vtlSymbol), r13, a9);
    }
    return e9;
  }
  _addSymbolsAttributes(t8, s7, r13, i9) {
    const o6 = this._styleRepository.layers, l6 = i9.key, a9 = this.tileKey, n8 = 1 << a9.level - l6.level, y7 = a9.row - l6.row * n8, c7 = a9.col - l6.col * n8;
    this._getSymbolAttributes(i9.protobuff, s7, r13, n8, y7, c7).forEach((s8) => {
      const { attributes: i10, tilePoint: l7 } = s8;
      t8.push({ layerId: o6[r13].id, layerIndex: r13, graphic: new b2({ attributes: i10, origin: { type: "vector-tile", layerId: o6[r13].id, layerIndex: r13, layer: this._parentLayer } }), tilePoint: l7 });
    });
  }
  _getSymbolAttributes(e9, t8, r13, i9, l6, n8) {
    const y7 = [], c7 = this._styleRepository.layers;
    let h7 = 0;
    t8.sort((e10, t9) => e10.featureIndex - t9.featureIndex);
    const d4 = new a5(new Uint8Array(e9), new DataView(e9));
    for (; d4.next(); ) switch (d4.tag()) {
      case 3: {
        const e10 = d4.getMessage(), s7 = new e5(e10);
        if (e10.release(), s7.name !== c7[r13].sourceLayer) continue;
        const m4 = s7.getData(), f4 = s7.extent / i9, _3 = u5 / f4, p7 = f4 * n8, g2 = f4 * l6;
        let w3 = 0;
        for (; m4.nextTag(2); ) {
          const e11 = m4.getMessage();
          if (w3++ === t8[h7].featureIndex) {
            const t9 = new s4(e11, s7), r14 = t9.values, i10 = t9.getGeometry(), l7 = null != i10 ? [_3 * (i10[0][0].x - p7), _3 * (i10[0][0].y - g2)] : null;
            y7.push({ attributes: r14, tilePoint: l7 }), h7++;
          }
          if (e11.release(), h7 === t8.length) return y7;
        }
        break;
      }
      default:
        d4.skip();
    }
    return y7;
  }
  _queryIndex(t8, s7, r13, i9, o6, l6) {
    var _a;
    const a9 = y6 * i9 * (window.devicePixelRatio || 1);
    return (_a = this._index) == null ? void 0 : _a.search({ minX: s7 - a9, minY: r13 - a9, maxX: s7 + a9, maxY: r13 + a9 }, (a10) => {
      const { layer: n8, feature: y7 } = a10;
      n8.isIntersectingFeature(s7, r13, i9, y7, o6, l6, a10) && t8.push({ layerId: n8.id, layerIndex: n8.uid, tilePoint: null, graphic: new b2({ attributes: y7.values, origin: { type: "vector-tile", layerId: a10.layer.id, layerIndex: a10.layer.uid, layer: this._parentLayer } }) });
    }), t8;
  }
  async _getTilePayload(e9) {
    return r(this._tileKeyToPBF, e9.id, () => this._tileHandler.fetchTilePBFs(e9)).then((e10) => e10);
  }
};
var m3 = (e9) => ({ minX: e9.bounds[0], minY: e9.bounds[1], maxX: e9.bounds[2], maxY: e9.bounds[3] });

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t7 = class extends h2 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e9) {
    const l6 = e3.pool.acquire(e9), t8 = 0 === l6.level ? null : e3.getId(l6.level - 1, l6.row >> 1, l6.col >> 1, l6.world);
    return e3.pool.release(l6), t8;
  }
  getTileCoverage(e9, l6, s7 = true, t8) {
    const o6 = super.getTileCoverage(e9, l6, s7, t8);
    if (!o6) return o6;
    const i9 = 1 << o6.lodInfo.level;
    return o6.spans = o6.spans.filter((e10) => e10.row >= 0 && e10.row < i9), o6;
  }
  scaleToLevel(e9) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e9]) return this._levelByScale[e9];
    {
      const l6 = this._fullCacheLodInfos;
      if (e9 > l6[0].scale) return l6[0].level;
      let s7, t8;
      for (let o6 = 0; o6 < l6.length - 1; o6++) if (t8 = l6[o6 + 1], e9 > t8.scale) return s7 = l6[o6], s7.level + (s7.scale - e9) / (s7.scale - t8.scale);
      return l6[l6.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l6) {
    let s7;
    if (0 === l6[0].level) s7 = l6.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    else {
      const l7 = this.tileInfo.size[0], t8 = this.tileInfo.spatialReference;
      s7 = z.create({ size: l7, spatialReference: t8 }).lods.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    }
    for (let e9 = 0; e9 < s7.length; e9++) this._levelByScale[s7[e9].scale] = s7[e9].level;
    this._fullCacheLodInfos = s7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var S2 = 2;
var D2 = 8;
var P2 = 512;
var Q = class extends i4(S(y3)) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._styeChanged = false, this._spriteSourceChanged = false;
  }
  get fading() {
    var _a;
    return ((_a = this._vectorTileContainer) == null ? void 0 : _a.fading) ?? false;
  }
  get hasVisibleFeatures() {
    const e9 = this._vectorTileContainer.children;
    for (const t8 of e9) if (t8.hasFeatures()) return true;
    return false;
  }
  get spriteSourceChanged() {
    return this._spriteSourceChanged;
  }
  get styleChanged() {
    return this._styeChanged;
  }
  async hitTest(e9, t8) {
    var _a, _b;
    const i9 = this._tileHandlerPromise, s7 = (_a = this._vectorTileContainer) == null ? void 0 : _a.symbolFader;
    if (!i9 || !this._isTileHandlerReady || !s7) return;
    await i9;
    let r13 = null;
    const a9 = (_b = this._vectorTileContainer) == null ? void 0 : _b.symbolRepository;
    a9 && (r13 = a9.querySymbols(t8, S2, s7.decluttererOffset, {}));
    const l6 = this.view.state, n8 = this._tileManager.getIntersectingTiles(t8.x, t8.y, S2, l6, r13);
    if ((!n8 || 0 === n8.length) && 0 === (r13 == null ? void 0 : r13.length)) return null;
    e9 = e9.clone().normalize();
    const o6 = [], h7 = [];
    for (const u6 of n8) o6.push(this._queryTile(h7, e9, S2, this.view.state.rotation, u6, r13 == null ? void 0 : r13.filter((e10) => e10.tileKey.id === u6.id)));
    return await Promise.all(o6), h7;
  }
  update(e9) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e9.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e9.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._pauseQueues(), this._fetchQueue.state = e9.state, this._parseQueue.state = e9.state, this._tileManager.update(e9) || this.requestUpdate(), this._resumeQueues()));
  }
  attach() {
    const { style: e9 } = this.layer.currentStyleInfo;
    this._styleRepository = new l2(e9), this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m2(this._tileInfoView), this._tileHandler = new p5(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e10) => {
      var _a, _b;
      if (this._styeChanged = true, e10.isDataDriven) this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e10 }), this.requestUpdate();
      else {
        const t8 = this._styleRepository, i9 = t8.getLayerById(e10.layer);
        if (!i9) return;
        const s7 = i9.type === a6.SYMBOL;
        t8.setPaintProperties(e10.layer, e10.paint), s7 && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender();
      }
    }), this.layer.on("layout-change", (e10) => {
      var _a, _b;
      const t8 = this._styleRepository, i9 = t8.getLayerById(e10.layer);
      if (!i9) return;
      this._styeChanged = true;
      const s7 = y2(i9.layout, e10.layout);
      if (null != s7) {
        if (p(s7, "visibility") && 1 === E4(s7)) return t8.setLayoutProperties(e10.layer, e10.layout), i9.type === a6.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), void ((_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e10 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e10) => {
      var _a, _b;
      const t8 = this._styleRepository, i9 = t8.getLayerById(e10.layer);
      i9 && (this._styeChanged = true, t8.setStyleLayerVisibility(e10.layer, e10.visibility), i9.type === a6.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
    }), this.layer.on("style-layer-change", (e10) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e10 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e10) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e10 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e10) => {
      this._spriteSourceChanged = true, this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: e10 });
      const t8 = this._styleRepository.layers;
      for (const i9 of t8) switch (i9.type) {
        case a6.SYMBOL:
          i9.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i9.id, layout: i9.layout } });
          break;
        case a6.LINE:
          i9.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i9.id, paint: i9.paint, isDataDriven: i9.isPainterDataDriven() } });
          break;
        case a6.FILL:
          i9.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i9.id, paint: i9.paint, isDataDriven: i9.isPainterDataDriven() } });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e9) {
    var _a;
    return s((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e9);
  }
  canResume() {
    let e9 = super.canResume();
    const { currentStyleInfo: t8 } = this.layer;
    if (e9 && (t8 == null ? void 0 : t8.layerDefinition)) {
      const i9 = this.view.scale, { minScale: s7, maxScale: r13 } = t8.layerDefinition;
      (t8 == null ? void 0 : t8.layerDefinition) && (s7 && s7 < i9 && (e9 = false), r13 && r13 > i9 && (e9 = false));
    }
    return e9;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e9) {
    const t8 = this._createVectorTile(e9);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t8.key).then((e10) => this._parseQueue.push({ key: t8.key, data: e10 })).then((e10) => {
      t8.once("attach", () => this.requestUpdate()), t8.setData(e10), this.requestUpdate();
    }).catch((e10) => {
      b(e10) || n.getLogger(this).error(e10);
    })), t8;
  }
  releaseTile(e9) {
    const t8 = e9.key.id;
    this._fetchQueue.abort(t8), this._parseQueue.abort(t8), this.requestUpdate();
  }
  async doRefresh() {
    if (!this.attached) return;
    if (this.suspended) return this._tileManager.clear(), void this.requestUpdate();
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache(), this._resumeQueues();
    const e9 = this._vectorTileContainer.children, t8 = [];
    try {
      for (const i9 of e9) {
        const e10 = this._updatingHandles.addPromise(this._fetchQueue.push(i9.key).then((e11) => this._parseQueue.push({ key: i9.key, data: e11 })).then((e11) => i9.setData(e11)).finally(() => i9.featureIndex = null));
        t8.push(e10);
      }
      await Promise.all(t8);
    } catch (s7) {
      n.getLogger(this).error("error refreshing vector-tiles layer-view", s7), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    this._isTileHandlerReady = true, this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new h3({ acquireTile: (e10) => this.acquireTile(e10), releaseTile: (e10) => this.releaseTile(e10), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e9 = new AbortController(), t8 = this._tileHandler.start({ signal: e9.signal }).then(() => {
      this._fetchQueue = new p2({ tileInfoView: this._tileInfoView, process: (e10, t9) => this._getTileData(e10, t9), concurrency: 15, scheduler: this.scheduler, priority: g.MAPVIEW_FETCH_QUEUE }), this._parseQueue = new p2({ tileInfoView: this._tileInfoView, process: (e10, t9) => this._parseTileData(e10, t9), concurrency: 8, scheduler: this.scheduler, priority: g.MAPVIEW_VECTOR_TILE_PARSING_QUEUE }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e10) => {
      this._vectorTileContainer.setStyleResources(e10, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e9, this._tileHandlerPromise = t8;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e9 = this._tileHandlerAbortController;
    e9 && e9.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e9, t8) {
    return this._tileHandler.fetchTileData(e9, t8);
  }
  async _parseTileData(e9, t8) {
    return this._tileHandler.parseTileData(e9, t8);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache();
    const e9 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e9);
    } catch (l6) {
      n.getLogger(this).error("error applying vector-tiles style update", l6.message), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    const t8 = this._styleRepository, s7 = /* @__PURE__ */ new Set();
    e9.forEach((e10) => {
      if (e10.type !== I2.LAYER_REMOVED) return;
      const i9 = e10.data, r14 = t8.getLayerById(i9.layer);
      r14 && s7.add(r14.uid);
    });
    const r13 = /* @__PURE__ */ new Set();
    e9.forEach((e10) => {
      let i9;
      switch (e10.type) {
        case I2.PAINTER_CHANGED:
          t8.setPaintProperties(e10.data.layer, e10.data.paint), i9 = e10.data.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t8.setLayoutProperties(e10.data.layer, e10.data.layout), i9 = e10.data.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t8.deleteStyleLayer(e10.data.layer);
        case I2.LAYER_CHANGED:
          t8.setStyleLayer(e10.data.layer, e10.data.index), i9 = e10.data.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e10.data.spriteSource));
      }
      if (i9) {
        const e11 = t8.getLayerById(i9);
        e11 && r13.add(e11.uid);
      }
    });
    const a9 = this._vectorTileContainer.children;
    if (s7.size > 0) {
      const e10 = Array.from(s7);
      this._vectorTileContainer.deleteStyleLayers(e10);
      for (const t9 of a9) t9.deleteLayerData(e10);
    }
    if (this._resumeQueues(), r13.size > 0) {
      const e10 = Array.from(r13), t9 = [];
      for (const i9 of a9) {
        const s8 = this._updatingHandles.addPromise(this._fetchQueue.push(i9.key).then((t10) => this._parseQueue.push({ key: i9.key, data: t10, styleLayerUIDs: e10 })).then((e11) => i9.setData(e11)).finally(() => i9.featureIndex = null));
        t9.push(s8);
      }
      await Promise.all(t9);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e9 } = this.layer.currentStyleInfo, i9 = a(e9);
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._styleRepository = new l2(i9), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s7 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i9, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n8) {
      if (!b(n8)) throw n8;
    }
    if (s7.aborted) return this._resumeQueues(), this._isTileHandlerReady = true, this._styeChanged = false, this._spriteSourceChanged = false, void this.requestUpdate();
    const a9 = await this._tileHandler.spriteMosaic, l6 = this._vectorTileContainer;
    this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), l6.setStyleResources(a9, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new h3({ acquireTile: (e10) => this.acquireTile(e10), releaseTile: (e10) => this.releaseTile(e10), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._resumeQueues(), this._isTileHandlerReady = true, this.requestUpdate(), this._styeChanged = false, this._spriteSourceChanged = false;
  }
  _createVectorTile(e9) {
    const t8 = this._tileInfoView.getTileBounds(u2(), e9), i9 = this._tileInfoView.getTileResolution(e9.level);
    return new y4(e9, i9, t8[0], t8[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e9, t8, i9, s7, r13, a9) {
    if (0 === r13.layerData.size) return;
    const l6 = this._ensureTileIndex(r13), n8 = this._tileInfoView.getTileBounds(u2(), r13.key, true), o6 = D2 * P2 * ((t8.x - n8[0]) / (n8[2] - n8[0])), h7 = D2 * P2 * (1 - (t8.y - n8[1]) / (n8[3] - n8[1])), y7 = await l6.queryAttributes(o6, h7, i9, s7, a9);
    for (const u6 of y7) u6.graphic.geometry = this._tileToMapPoint(u6.tilePoint, r13.transforms.tileUnitsToPixels), e9.push({ type: "graphic", layer: this.layer, graphic: u6.graphic, mapPoint: t8.clone() });
    e9.sort((e10, t9) => t9.graphic.origin.layerIndex - e10.graphic.origin.layerIndex);
  }
  _tileToMapPoint(e9, t8) {
    if (!e9) return null;
    const i9 = e9[0] * t8[0] + e9[1] * t8[3] + t8[6], s7 = e9[0] * t8[1] + e9[1] * t8[4] + t8[7], r13 = this.view.state, a9 = [0, 0];
    return r13.toMap(a9, [i9, s7]), new j({ x: a9[0], y: a9[1], spatialReference: r13.spatialReference });
  }
  _ensureTileIndex(e9) {
    let t8 = e9.featureIndex;
    return t8 || (t8 = d3.create(e9.key, e9.layerData, this._styleRepository, this._tileHandler, this.layer), e9.featureIndex = t8), t8;
  }
  _pauseQueues() {
    this._fetchQueue.pause(), this._parseQueue.pause();
  }
  _resumeQueues() {
    this._fetchQueue.resume(), this._parseQueue.resume();
  }
  _clearQueues() {
    this._fetchQueue.clear(), this._parseQueue.clear();
  }
};
function E4(e9) {
  if (null == e9) return 0;
  switch (e9.type) {
    case "partial":
      return Object.keys(e9.diff).length;
    case "complete":
      return Math.max(Object.keys(e9.oldValue).length, Object.keys(e9.newValue).length);
    case "collection":
      return Object.keys(e9.added).length + Object.keys(e9.changed).length + Object.keys(e9.removed).length;
  }
}
r2([m()], Q.prototype, "_isTileHandlerReady", void 0), Q = r2([a3("esri.views.2d.layers.VectorTileLayerView2D")], Q);
var A = Q;
export {
  A as default
};
//# sourceMappingURL=VectorTileLayerView2D-OBZXNHDT.js.map
