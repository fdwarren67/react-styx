import {
  o as o2
} from "./chunk-IJ3INJ7A.js";
import {
  K,
  X,
  c,
  e as e2,
  i,
  l as l3,
  n as n2,
  r as r2,
  t as t2
} from "./chunk-F2BQZJI3.js";
import "./chunk-WZ5XGARC.js";
import "./chunk-LM5DVV6Z.js";
import {
  D,
  o,
  p as p3,
  w as w2
} from "./chunk-AAIKSZFL.js";
import "./chunk-GHPQVNNU.js";
import "./chunk-VBE5VFL5.js";
import "./chunk-OE5AB3OL.js";
import "./chunk-FQS6ZZHL.js";
import {
  P as P2,
  d as d3
} from "./chunk-YLQRI5UO.js";
import {
  P as P3
} from "./chunk-6QH5QYZM.js";
import "./chunk-23WGP47N.js";
import "./chunk-IZJWCIYF.js";
import "./chunk-32RP26YL.js";
import "./chunk-QY6LLTZM.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-Q44EAKHA.js";
import "./chunk-4HTLBMKF.js";
import "./chunk-YUQ6PSJ2.js";
import "./chunk-SB6LU3VH.js";
import {
  l as l2
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import {
  p as p2
} from "./chunk-S4QLDBOB.js";
import {
  e
} from "./chunk-RTA3XNM7.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-QAP2FVP7.js";
import "./chunk-6EREU4EG.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import {
  A
} from "./chunk-NBXBK3QW.js";
import {
  j as j2
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f2
} from "./chunk-73NNNHMH.js";
import {
  b as b2
} from "./chunk-C6YDI6QX.js";
import {
  d as d2,
  l
} from "./chunk-DJ5HVIE7.js";
import {
  S
} from "./chunk-KPY4ZIC2.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import {
  y
} from "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import {
  p
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BLF64HON.js";
import {
  q
} from "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import {
  a as a3
} from "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  d
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import {
  j
} from "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w
} from "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a,
  b,
  k
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCapabilitiesParser.js
function l4(e4) {
  return e4.endsWith("?") ? e4.slice(0, -1) : e4;
}
function u(e4) {
  return e4.filter(({ coverageSubType: e5 }) => null == e5 || "" === e5 || /^rectified(grid|dataset)/i.test(e5));
}
function p4(e4) {
  var _a, _b, _c;
  const a4 = t2(e4, "Service/name"), s2 = e2(e4, "Capability"), c2 = ((_a = e2(s2, "GetCapabilities/Get/OnlineResource")) == null ? void 0 : _a.getAttribute("xlink:href")) ?? "", p5 = ((_b = e2(s2, "DescribeCoverage/Get/OnlineResource")) == null ? void 0 : _b.getAttribute("xlink:href")) ?? "", m3 = ((_c = e2(s2, "GetCoverage/Get/OnlineResource")) == null ? void 0 : _c.getAttribute("xlink:href")) ?? "", g4 = { getCapabilities: l4(c2), describeCoverage: l4(p5), getCoverage: l4(m3) }, v4 = n2(e4, "CoverageOfferingBrief"), d6 = [];
  for (let o3 = 0; o3 < v4.length; o3++) {
    const e5 = v4[o3], a5 = t2(e5, "name"), s3 = n2(e5, "pos"), c3 = r2(s3[0]), l5 = r2(s3[1]), u2 = new w({ xmin: c3[0], ymin: c3[1], xmax: l5[0], ymax: l5[1], spatialReference: { wkid: 4326 } });
    d6.push({ id: a5, lonLatEnvelope: u2 });
  }
  return { name: a4, onlineResources: g4, coverages: d6, gridCoverages: u(d6), supportedVersions: ["1.0.0"], version: "1.0.0" };
}
function m2(e4) {
  const o3 = {};
  for (let i3 = 0; i3 < e4.childNodes.length; i3++) {
    const a4 = e4.childNodes[i3];
    if (1 !== a4.nodeType) continue;
    const s2 = c(a4).toLowerCase();
    switch (s2) {
      case "title":
      case "abstract":
        o3[s2] = t2(a4);
        break;
      case "identifier":
        o3.id = t2(a4);
        break;
      case "wgs84boundingbox":
        {
          const e5 = r2(a4, "LowerCorner"), r4 = r2(a4, "UpperCorner");
          o3.lonLatEnvelope = new w({ xmin: e5[0], ymin: e5[1], xmax: r4[0], ymax: r4[1], spatialReference: { wkid: 4326 } });
        }
        break;
      case "coveragesummary":
        o3.coverageSummaries = o3.coverageSummaries || [], o3.coverageSummaries.push(m2(a4));
    }
  }
  return o3;
}
function g(e4, t4) {
  if (e4.coverageSummaries) for (let r4 = 0; r4 < e4.coverageSummaries.length; r4++) e4.coverageSummaries[r4].abstract = e4.coverageSummaries[r4].abstract || e4.abstract, e4.coverageSummaries[r4].lonLatEnvelope = e4.coverageSummaries[r4].lonLatEnvelope || e4.lonLatEnvelope, e4.coverageSummaries[r4].title = e4.coverageSummaries[r4].title || e4.title, g(e4.coverageSummaries[r4], t4);
  null != e4.id && t4.push(e4);
}
function v(e4) {
  var _a, _b, _c;
  const t4 = ((_a = e2(e4.querySelector("Operation[name=GetCapabilities]"), "Get")) == null ? void 0 : _a.getAttribute("xlink:href")) || "", r4 = ((_b = e2(e4.querySelector("Operation[name=DescribeCoverage]"), "Get")) == null ? void 0 : _b.getAttribute("xlink:href")) || "", i3 = ((_c = e2(e4.querySelector("Operation[name=GetCoverage]"), "Get")) == null ? void 0 : _c.getAttribute("xlink:href")) || "";
  return { getCapabilities: l4(t4), describeCoverage: l4(r4), getCoverage: l4(i3) };
}
function d4(e4) {
  const t4 = t2(e4, "ServiceIdentification/Title"), i3 = l3(e4, "ServiceIdentification/ServiceTypeVersion"), n5 = v(e2(e4, "OperationsMetadata")), c2 = [], l5 = e2(e4, "Contents");
  for (let r4 = 0; r4 < l5.childNodes.length; r4++) {
    const e5 = l5.childNodes[r4];
    1 === e5.nodeType && (i(e5, "CoverageSummary") && g(m2(e5), c2));
  }
  const p5 = l3(l5, "SupportedFormat");
  return { name: t4, onlineResources: n5, coverages: c2, gridCoverages: u(c2), supportedVersions: i3, supportedFormats: p5, version: "1.1.0" };
}
function f3(e4) {
  const s2 = e2(e4, "ServiceIdentification"), c2 = t2(s2, "Title"), l5 = l3(s2, "ServiceTypeVersion"), p5 = l3(s2, "Profile"), m3 = v(e2(e4, "OperationsMetadata")), g4 = n2(e4, "Contents/CoverageSummary"), d6 = [];
  for (let i3 = 0; i3 < g4.length; i3++) {
    const e5 = g4[i3], a4 = t2(e5, "CoverageId"), s3 = e2(e5, "WGS84BoundingBox");
    let c3;
    if (s3) {
      const e6 = r2(s3, "LowerCorner"), r4 = r2(s3, "UpperCorner");
      c3 = new w({ xmin: e6[0], ymin: e6[1], xmax: r4[0], ymax: r4[1], spatialReference: { wkid: 4326 } });
    }
    const l6 = t2(e5, "CoverageSubtype") || "RectifiedGridCoverage";
    d6.push({ id: a4, lonLatEnvelope: c3, coverageSubType: l6 });
  }
  const f5 = e2(e4, "ServiceMetadata");
  return { name: c2, supportedVersions: l5, supportedFormats: l3(f5, "formatSupported"), supportedInterpolations: l3(f5, "interpolationSupported").concat(l3(f5, "InterpolationSupported")), onlineResources: m3, profiles: p5, coverages: d6, gridCoverages: u(d6), version: "2.0.1" };
}
function S2(e4) {
  let t4 = null;
  if ("string" == typeof e4) {
    t4 = new DOMParser().parseFromString(e4, "text/xml");
  } else t4 = e4;
  const r4 = t4.documentElement.getAttribute("version"), o3 = r4 == null ? void 0 : r4.slice(0, 3);
  return null != o3 && o3 < "2.1";
}
function b3(t4, r4 = null) {
  let o3 = null;
  if ("string" == typeof t4) {
    o3 = new DOMParser().parseFromString(t4, "text/xml");
  } else o3 = t4;
  let i3 = o3.documentElement.getAttribute("version");
  "1.0" === i3 ? i3 = "1.0.0" : "1.1" === i3 && (i3 = "1.1.0");
  const n5 = i3 || r4 || "1.0.0", a4 = n5.slice(0, 3);
  let s2;
  if ("2.0" === a4) s2 = f3(o3);
  else if ("1.1" === a4) s2 = d4(o3);
  else {
    if ("1.0" !== a4) throw new s("wcsraster:parsecapabilities", "the capabilities version is not supported");
    s2 = p4(o3);
  }
  return s2.version = n5, s2;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCoverageParser.js
function d5(e4) {
  e4.variables.forEach((e5) => e5.dimensions.forEach((e6) => e6.values ?? (e6.values = D(e6))));
}
function f4(e4) {
  return { requestResponseCRSs: l3(e4, "requestResponseCRSs").map((e5) => e5.split(":")[1]), nativeCRSs: l3(e4, "nativeCRSs").map((e5) => e5.split(":")[1]) };
}
function g2(e4, t4) {
  const n5 = l3(e4, "1.0.0" === t4 ? "interpolationMethod" : "InterpolationMethod"), i3 = "1.0.0" === t4 ? e4.getAttribute("default") : t2(e4, "InterpolationMethods/Default");
  return null != i3 ? [i3].concat(n5.filter((e5) => e5.toLowerCase() !== i3.toLowerCase())) : n5;
}
function h(e4) {
  return null == e4 ? ["nearest"] : e4.map((e5) => {
    const t4 = e5.toLowerCase();
    return t4.includes("nearest") ? "nearest" : t4.includes("linear") ? "bilinear" : t4.includes("cubic") ? "cubic" : null;
  }).filter((e5) => !!e5);
}
function b4(t4) {
  const n5 = n2(t4, "pos"), i3 = r2(n5[0]), s2 = r2(n5[1]);
  return new w({ xmin: i3[0], ymin: i3[1], xmax: s2[0], ymax: s2[1], spatialReference: { wkid: 4326 } });
}
function x(e4, t4) {
  const n5 = l3(e4, t4);
  return (n5 == null ? void 0 : n5.length) && "" !== n5[0] && !isNaN(Number(n5[0])) ? n5.map((e5) => Number(e5)) : null;
}
function v2(e4) {
  const t4 = r2(e4, "MinimumValue"), n5 = r2(e4, "MaximumValue");
  return t4.length && n5.length ? t4.map((e5, t5) => ({ min: e5, max: n5[t5], avg: -1, stddev: -1 })) : null;
}
function D2(e4) {
  return null == e4 ? null : e4.every((t4) => t4 === e4[0]) ? e4[0] : e4;
}
function y2(e4) {
  const t4 = [], n5 = n2(e4, "RangeSet");
  let i3 = [];
  for (let s2 = 0; s2 < n5.length; s2++) {
    const e5 = t2(n5[s2], "name"), a4 = t2(n5[s2], "label"), l5 = [], m3 = x(n5[s2], "nullValues/singleValue"), p5 = n2(n5[s2], "AxisDescription");
    for (let t5 = 0; t5 < p5.length; t5++) {
      const e6 = t2(p5[t5], "name"), n6 = t2(p5[t5], "label"), s3 = l3(p5[t5], "singleValue");
      if (0 === s3.length) {
        const e7 = t2(p5[t5], "min"), n7 = t2(p5[t5], "max"), i4 = Number(t2(p5[t5], "res")) || 1;
        if (null !== e7 && null !== n7) for (let t6 = parseInt(e7, 10); t6 <= parseInt(n7, 10); t6 += i4) s3.push(t6.toString());
      }
      "band" === e6.toLowerCase() && (i3 = s3), l5.push({ name: e6, label: n6, values: s3 });
    }
    t4.push({ name: e5, label: a4, nullValues: m3, axis: l5 });
  }
  return { rangeSet: t4, bandNames: i3 };
}
function w3(e4 = null) {
  if (!e4) return { resolution: null, units: null };
  let t4 = e4.toUpperCase();
  const n5 = ["Y", "M", "D"], i3 = ["H", "M", "S"], s2 = ["Years", "Months", "Days", "Hours", "Minutes", "Seconds"];
  let a4, o3, l5;
  return t4.includes("PT") ? (t4 = t4.slice(2), l5 = i3.findIndex((e5) => t4.includes(e5)), a4 = s2[3 + l5], o3 = parseFloat(t4.slice(0, -1))) : (t4 = t4.slice(1), l5 = n5.findIndex((e5) => t4.includes(e5)), l5 > -1 && (a4 = s2[l5]), o3 = parseFloat(t4.slice(0, -1))), { resolution: o3, units: a4 };
}
function S3(e4) {
  const t4 = n2(e4, "timeposition");
  if (t4.length > 0) {
    const e5 = [];
    for (let n6 = 0; n6 < t4.length; n6++) e5.push(new Date(t2(t4[n6])));
    return { begin: e5[0], end: e5[e5.length - 1], values: e5 };
  }
  const n5 = e2(e4, "timePeriod") || e2(e4, "TimePeriod");
  if (n5) {
    return { begin: new Date(t2(n5, "beginPosition") || t2(n5, "BeginPosition")), end: new Date(t2(n5, "endPosition") || t2(n5, "EndPosition")), ...w3(t2(n5, "timeResolution") || t2(n5, "TimeResolution")) };
  }
  return null;
}
function I(t4) {
  const n5 = e2(t4, "spatialDomain"), i3 = e2(n5, "Envelope") || e2(n5, "EnvelopeWithTimePeriod"), s2 = i3.getAttribute("srsName").split(":"), a4 = s2[s2.length - 1], l5 = n2(i3, "pos"), u2 = r2(l5[0]), m3 = r2(l5[1]), d6 = parseInt(a4, 10), f5 = isNaN(d6) ? null : { wkid: d6 }, g4 = new w({ xmin: u2[0], ymin: u2[1], xmax: m3[0], ymax: m3[1], spatialReference: f5 }), h2 = e2(n5, "RectifiedGrid"), b6 = t2(h2, "low").split(" "), x3 = t2(h2, "high").split(" "), v4 = parseInt(x3[0], 10) - parseInt(b6[0], 10) + 1, D3 = parseInt(x3[1], 10) - parseInt(b6[1], 10) + 1, y4 = r2(n5, "origin/pos"), w5 = n2(n5, "offsetVector"), I3 = { envelope: g4, columns: v4, rows: D3, offset: { x: parseFloat(t2(w5[0]).split(" ")[0]), y: parseFloat(t2(w5[1]).split(" ")[1]) }, origin: { x: y4[0], y: y4[1] } }, L2 = e2(t4, "temporalDomain") || e2(t4, "TemporalDomain");
  return { spatialDomain: I3, temporalDomain: L2 ? S3(L2) : null };
}
function L(e4) {
  const t4 = { version: "1.0" };
  let n5, s2 = [];
  for (let i3 = 0; i3 < e4.childNodes.length; i3++) {
    const a5 = e4.childNodes[i3];
    if (1 === a5.nodeType) if (i(a5, "description")) t4.description = t2(a5);
    else if (i(a5, "name")) t4.name = t2(a5);
    else if (i(a5, "label")) t4.label = t2(a5);
    else if (i(a5, "supportedFormats")) t4.supportedFormats = l3(a5, "formats");
    else if (i(a5, "supportedCRSs")) t4.supportedCRSs = f4(a5);
    else if (i(a5, "supportedInterpolations")) t4.supportedInterpolations = g2(a5, "1.0.0");
    else if (i(a5, "lonLatEnvelope")) t4.lonLatEnvelope = b4(a5);
    else if (i(a5, "rangeSet")) {
      const e5 = y2(a5);
      t4.rangeSet = e5.rangeSet, s2 = e5.bandNames;
      const i4 = e5.rangeSet[0].nullValues;
      (i4 == null ? void 0 : i4.length) && (n5 = D2(i4));
    } else i(a5, "domainSet") && (t4.domainSet = I(a5));
  }
  const a4 = h(t4.supportedInterpolations), { name: o3, description: m3, label: p5, lonLatEnvelope: c2, supportedFormats: d6 } = t4, { spatialDomain: x3 } = t4.domainSet, v4 = { x: Math.abs(x3.offset.x), y: Math.abs(x3.offset.y) }, w5 = C(t4.domainSet), S5 = new d3({ width: x3.columns, height: x3.rows, pixelSize: v4, pixelType: "unknown", extent: x3.envelope, spatialReference: x3.envelope.spatialReference, bandCount: s2.length || 1, noDataValue: n5, multidimensionalInfo: w5 });
  return { id: o3, title: t4.name, description: m3 || p5, lonLatEnvelope: c2, rasterInfo: S5, bandNames: s2, supportedFormats: d6, supportedInterpolations: a4, coverageDescription: t4, version: "1.0.0", useEPSGAxis: false };
}
function C(e4) {
  if (!e4.temporalDomain) return null;
  const { begin: t4, end: n5, values: i3, units: s2, resolution: a4 } = e4.temporalDomain, o3 = { variables: [{ name: "default", description: "", dimensions: [{ name: "StdTime", description: "", unit: "ISO8601", values: i3 == null ? void 0 : i3.map((e5) => e5.getTime()), hasRegularIntervals: !i3, interval: a4, intervalUnit: s2, extent: [t4.getTime(), n5.getTime()] }] }] };
  return d5(o3), o3;
}
function T(e4, t4) {
  const n5 = [], i3 = n2(e4, "Field");
  let s2, a4 = [];
  for (let l5 = 0; l5 < i3.length; l5++) {
    const e5 = t2(i3[l5], "Identifier"), m3 = t2(i3[l5], "Description"), c2 = t2(i3[l5], "Definition"), d6 = t2(i3[l5], "Abstract"), f5 = t2(i3[l5], "Title"), h2 = x(i3[l5], "NullValue"), b6 = e2(i3[l5], "AllowedValues"), D3 = b6 ? v2(b6) : null, y4 = g2(i3[l5], "1.1.0"), w5 = [], S5 = n2(i3[l5], "Axis");
    for (let n6 = 0; n6 < S5.length; n6++) {
      const e6 = S5[n6].getAttribute("identifier"), i4 = t2(S5[n6], "UOM"), o3 = t2(S5[n6], "DataType"), l6 = l3(S5[n6], "Key");
      t4 && !e6.toLowerCase().includes("band") || (a4 = l6, s2 = h2), w5.push({ identifier: e6, uom: i4, dataType: o3, values: l6, bandNoDataValues: s2 });
    }
    n5.push({ identifier: e5, description: m3, definition: c2, abstract: d6, title: f5, supportedInterpolations: y4, axis: w5, nullValues: h2, statistics: D3 });
  }
  return { rangeSet: n5, bandNames: a4, bandNoDataValues: s2, statistics: n5[0].statistics };
}
function R(e4, t4) {
  if (!t4.temporalDomain) return null;
  const n5 = e4.filter((e5) => !e5.identifier.toLowerCase().includes("field_1") && !e5.axis.some((e6) => e6.identifier.includes("band"))), i3 = [];
  if (n5.length && n5.forEach((e5) => {
    var _a;
    const t5 = e5.axis.map((e6) => {
      const t6 = e6.values.map((t7) => {
        if ("ISO8601" === e6.uom) {
          return (t7 = t7.trim()).toLowerCase().includes("z") ? new Date(t7).getTime() : (/* @__PURE__ */ new Date(t7 + "Z")).getTime();
        }
        return parseFloat(t7.trim());
      }), n6 = [Math.min.apply(null, t6), Math.max.apply(null, t6)];
      return { name: e6.identifier.trim(), description: "", field: e6.identifier.trim(), unit: e6.uom ? e6.uom.trim() : "", hasRegularIntervals: false, values: t6, extent: n6 };
    });
    i3.push({ name: e5.identifier.trim(), description: ((_a = e5.description) == null ? void 0 : _a.trim()) ?? "", unit: "", dimensions: t5, statistics: e5.statistics });
  }), t4.temporalDomain) {
    const { begin: e5, end: n6, values: s2, units: a4, resolution: o3 } = t4.temporalDomain;
    i3.some((e6) => e6.dimensions.some((e7) => "stdtime" === e7.name.toLowerCase())) || i3.forEach((t5) => {
      t5.dimensions.push({ name: "StdTime", description: "", unit: "ISO8601", values: s2 == null ? void 0 : s2.map((e6) => e6.getTime()), hasRegularIntervals: !s2, interval: o3, intervalUnit: a4, extent: [e5.getTime(), n6.getTime()] });
    });
  }
  if (i3.length) {
    const e5 = { variables: i3 };
    return d5(e5), e5;
  }
  return null;
}
function M(t4) {
  var _a;
  const i3 = e2(t4, "SpatialDomain"), s2 = e2(i3, "GridCRS"), a4 = t2(s2, "GridBaseCRS"), l5 = t2(s2, "GridOrigin"), u2 = (l5 == null ? void 0 : l5.split(" ").map((e4) => parseFloat(e4))) ?? [0, 0], m3 = r2(s2, "GridOffsets"), d6 = n2(i3, "BoundingBox");
  let f5, g4, h2, b6;
  for (let n5 = 0; n5 < d6.length; n5++) {
    const t5 = (_a = d6[n5].getAttribute("crs")) == null ? void 0 : _a.toLowerCase();
    if (null != t5) {
      if (t5.includes("imagecrs")) {
        const e4 = r2(d6[n5], "LowerCorner"), t6 = r2(d6[n5], "UpperCorner");
        f5 = t6[0] - e4[0] + 1, g4 = t6[1] - e4[1] + 1;
      } else if (t5.indexOf("epsg") > 0) {
        const i4 = t5.split(":");
        h2 = parseInt(i4[i4.length - 1], 10);
        const s3 = r2(d6[n5], "LowerCorner"), a5 = r2(d6[n5], "UpperCorner");
        b6 = new w({ xmin: s3[0], ymin: s3[1], xmax: a5[0], ymax: a5[1], spatialReference: { wkid: h2 } });
      }
    }
  }
  const x3 = f5 > g4, v4 = b6.xmax - b6.xmin > b6.ymax - b6.ymin;
  let D3 = false;
  o2(h2) && (x3 === v4 ? D3 = false : (D3 = true, b6 = new w({ xmin: b6.ymin, ymin: b6.xmin, xmax: b6.ymax, ymax: b6.xmax, spatialReference: { wkid: h2 } })));
  const y4 = { columns: f5, rows: g4, origin: { x: u2[0], y: u2[1] }, offset: { x: m3[0], y: m3[m3.length - 1] }, gridBaseCRS: a4, envelope: b6, useEPSGAxis: D3 }, w5 = e2(t4, "temporalDomain") || e2(t4, "TemporalDomain");
  return { spatialDomain: y4, temporalDomain: w5 ? S3(w5) : null };
}
function N(e4, t4) {
  var _a;
  const n5 = [], s2 = [], a4 = { supportedFormats: n5, supportedCRSs: s2, version: "1.1" };
  let o3, l5, u2 = [];
  for (let i3 = 0; i3 < e4.childNodes.length; i3++) {
    const t5 = e4.childNodes[i3];
    if (1 !== t5.nodeType) continue;
    const p6 = c(t5).toLowerCase();
    switch (p6) {
      case "title":
      case "abstract":
      case "identifier":
        a4[p6] = t2(t5);
        break;
      case "supportedformat":
        {
          const e5 = t2(t5);
          n5.includes(e5) || n5.push(e5);
        }
        break;
      case "supportedcrs":
        {
          const e5 = t2(t5);
          s2.includes(e5) || s2.push(e5);
        }
        break;
      case "range":
        {
          const e5 = T(t5, !!((_a = a4.domain) == null ? void 0 : _a.temporalDomain));
          a4.range = e5.rangeSet, u2 = e5.bandNames;
          const { bandNoDataValues: n6 } = e5;
          (n6 == null ? void 0 : n6.length) && (o3 = D2(n6)), l5 = e5.statistics;
        }
        break;
      case "domain":
        a4.domain = M(t5);
    }
  }
  const p5 = h(a4.range[0].supportedInterpolations), { identifier: c2, abstract: d6, title: f5, domain: g4, range: b6 } = a4, x3 = { x: Math.abs(g4.spatialDomain.offset.x), y: Math.abs(g4.spatialDomain.offset.y) }, v4 = R(b6, g4);
  v4 && (o3 = b6[0].nullValues, 1 === (o3 == null ? void 0 : o3.length) && (o3 = o3[0]));
  const y4 = new d3({ width: g4.spatialDomain.columns, height: g4.spatialDomain.rows, pixelSize: x3, pixelType: "unknown", extent: g4.spatialDomain.envelope, spatialReference: g4.spatialDomain.envelope.spatialReference, bandCount: u2.length || 1, noDataValue: o3, statistics: l5, multidimensionalInfo: v4 });
  return { id: c2, title: a4.title, description: d6 || f5, bandNames: u2, rasterInfo: y4, supportedFormats: n5, supportedInterpolations: p5, coverageDescription: a4, version: t4, useEPSGAxis: g4.spatialDomain.useEPSGAxis };
}
function P4(t4) {
  const n5 = e2(t4, "Envelope") || e2(t4, "EnvelopeWithTimePeriod"), i3 = n5.getAttribute("srsName"), s2 = i3.slice(i3.lastIndexOf("/") + 1), a4 = n5.getAttribute("axisLabels").split(" ").map((e4) => e4.trim()).filter((e4) => "" !== e4.trim()), o3 = r2(n5, "lowerCorner"), u2 = r2(n5, "upperCorner"), m3 = !["y", "lat", "latitude", "north", "nor", "n", "b"].includes(a4[0].toLowerCase());
  let d6;
  const f5 = parseInt(s2, 10), g4 = isNaN(f5) ? null : { wkid: f5 };
  d6 = new w(m3 ? { xmin: o3[0], ymin: o3[1], xmax: u2[0], ymax: u2[1], spatialReference: g4 } : { xmin: o3[1], ymin: o3[0], xmax: u2[1], ymax: u2[0], spatialReference: g4 });
  const h2 = { mins: o3, maxs: u2 }, b6 = n5.getAttribute("uomLabels").trim().split(" ");
  let x3, v4;
  if (i(n5, "EnvelopeWithTimePeriod")) {
    x3 = new Date(t2(t4, "beginPosition") || t2(t4, "BeginPosition")), v4 = new Date(t2(t4, "endPosition") || t2(t4, "EndPosition"));
    const e4 = b6 == null ? void 0 : b6.findIndex((e5) => "oledatetime" === (e5 == null ? void 0 : e5.toLowerCase()));
    e4 > -1 && (b6[e4] = "ISO8601");
  }
  return { envelope: d6, axisLabels: a4, uomLabels: b6.length ? b6 : null, envelopeAllDims: h2, beginPosition: x3, endPosition: v4, isEastFirst: m3 };
}
function E(e4, t4) {
  var _a, _b;
  const n5 = [], i3 = n2(e4, "DataRecord"), s2 = [];
  let a4, l5 = [];
  for (let u2 = 0; u2 < i3.length; u2++) {
    const e5 = n2(i3[u2], "field"), m3 = [];
    for (let n6 = 0; n6 < e5.length; n6++) {
      const i4 = e5[n6].getAttribute("name"), o3 = t2(e5[n6], "description") || "", u3 = ((_a = e2(e5[n6], "uom")) == null ? void 0 : _a.getAttribute("code")) || "", d6 = r2(e5[n6], "interval"), f5 = (_b = x(e5[n6], "nilValue")) == null ? void 0 : _b[0];
      t4 && !i4.toLowerCase().includes("band") || (s2.push(i4), (d6 == null ? void 0 : d6.length) && (a4 = a4 || [], a4.push({ min: d6[0], max: d6[1], avg: -1, stddev: -1 })), l5.push(f5)), m3.push({ name: i4, description: o3, uom: u3, allowedValues: d6, nilValue: f5 });
    }
    n5.push(m3);
  }
  return l5.some((e5) => null != e5) || (l5 = null), { rangeType: n5, bandNames: s2, bandStats: a4, bandNoDataValues: l5 };
}
function V(e4) {
  let t4 = 1, n5 = "";
  const i3 = 0.01;
  return Math.abs(e4 - 1 / 24) < 1 / 24 * i3 ? n5 = "Hours" : Math.abs(e4 - 1) < 1 * i3 ? n5 = "Days" : e4 < 1 ? (t4 = Math.round(24 * e4), n5 = "Hours") : e4 > 28 - i3 && e4 < 31 + i3 || Math.round(e4 / 30) < 12 ? n5 = "Months" : e4 > 365 - i3 && e4 < 366 + i3 && (n5 = "Years"), { interval: t4, intervalUnit: n5 };
}
function A2(e4, t4, n5) {
  var _a, _b;
  if (n5.axisLabels.length <= 2) return null;
  const i3 = [];
  for (let a4 = 0; a4 < e4.length; a4++) {
    const t5 = e4[a4];
    for (let e5 = 0; e5 < t5.length; e5++) t5[e5].name.toLowerCase().includes("band") || i3.push(t5[e5]);
  }
  const s2 = [];
  if (i3.length) {
    const e5 = [];
    for (let i4 = 2; i4 < n5.axisLabels.length; i4++) {
      const s3 = ((_b = (_a = t4.uomLabels) == null ? void 0 : _a[i4]) == null ? void 0 : _b.trim()) ?? "", o3 = n5.axisLabels[i4].toLowerCase().includes("time") || "iso8601" === s3.toLowerCase() || "oledatetime" === s3.toLowerCase();
      let l5, r4;
      if (o3) {
        const e6 = V(n5.offset[i4]);
        l5 = e6.interval, r4 = e6.intervalUnit;
      } else l5 = n5.offset[i4], r4 = s3;
      const u2 = [];
      o3 ? (u2.push(w2(t4.envelopeAllDims.mins[i4])), u2.push(w2(t4.envelopeAllDims.maxs[i4]))) : (u2.push(t4.envelopeAllDims.mins[i4]), u2.push(t4.envelopeAllDims.maxs[i4])), e5.push({ name: n5.axisLabels[i4].trim(), description: n5.axisLabels[i4].trim(), unit: o3 ? "ISO8601" : s3, hasRegularIntervals: true, extent: u2, interval: l5, intervalUnit: r4 });
    }
    if (i3.forEach((t5) => {
      var _a2;
      const { allowedValues: n6 } = t5, i4 = 2 === (n6 == null ? void 0 : n6.length) ? [{ min: n6[0], max: n6[1], avg: -1, stddev: -1 }] : null;
      s2.push({ name: t5.name.trim(), description: ((_a2 = t5.description) == null ? void 0 : _a2.trim()) ?? "", unit: t5.uom.trim(), statistics: i4, dimensions: [...e5] });
    }), s2.length) {
      const e6 = { variables: s2 };
      return d5(e6), e6;
    }
  }
  return null;
}
function F(e4, t4) {
  const n5 = e2(e4, "RectifiedGrid"), i3 = r2(n5, "low"), s2 = r2(n5, "high"), a4 = [];
  for (let o3 = 0; o3 < i3.length; o3++) a4.push(s2[o3] - i3[o3] + 1);
  const l5 = t2(n5, "axisLabels").split(" "), u2 = r2(n5, "origin/pos"), m3 = n2(n5, "offsetVector"), d6 = [];
  for (let o3 = 0; o3 < m3.length; o3++) {
    const e5 = r2(m3[o3]), t5 = e5.findIndex((e6) => 0 !== e6);
    d6[t5] = e5[t5];
  }
  const f5 = ["y", "lat", "latitude", "north", "nor", "n", "b"];
  let g4 = false;
  if ((t4 == null ? void 0 : t4.length) && (l5 == null ? void 0 : l5.length)) {
    g4 = [...t4].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",") === [...l5].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",");
  }
  const h2 = g4 ? l5 : t4;
  let b6, x3, v4;
  return f5.includes(h2[0].toLowerCase()) ? (b6 = a4[1], x3 = a4[0], v4 = { y: Math.abs(d6[0]), x: Math.abs(d6[1]) }) : (b6 = a4[0], x3 = a4[1], v4 = { x: Math.abs(d6[0]), y: Math.abs(d6[1]) }), { columns: b6, rows: x3, origin: u2, offset: d6, resolution: v4, gridSamples: a4, axisLabels: l5, hasSameAxisLabelsAsBoundedBy: g4 };
}
function O(e4) {
  const n5 = e2(e4, "EarthObservation");
  if (!n5) return null;
  const i3 = e2(n5, "phenomenonTime"), s2 = i3 ? S3(i3) : null, a4 = e2(n5, "phenomenonTime"), o3 = a4 ? S3(a4) : null, l5 = t2(n5, "featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");
  let u2 = null;
  if (l5) {
    const e5 = l5.split(" ").map((e6) => e6.trim()).filter((e6) => null != e6 && "" !== e6).map(Number);
    if (e5.length) {
      const n6 = [];
      for (let t4 = 0; t4 < e5.length / 2; t4 += 2) n6.push(e5[t4], e5[t4 + 1]);
      u2 = new j({ rings: [[n6]] });
    }
  }
  return { observation: { phenomenonTime: s2, resultTime: o3, footprint: u2, identifier: t2(e4, "metaDataProperty/EarthObservationMetaData/identifier"), acquisitionType: t2(e4, "metaDataProperty/EarthObservationMetaData/acquisitionType"), status: t2(e4, "metaDataProperty/EarthObservationMetaData/status") } };
}
function B(e4) {
  var _a, _b, _c;
  const t4 = { version: "2.0" };
  let n5, s2, a4 = [];
  for (let i3 = 0; i3 < e4.childNodes.length; i3++) {
    const o4 = e4.childNodes[i3];
    if (1 === o4.nodeType) {
      if (i(o4, "coverageId")) t4.coverageId = t2(o4);
      else if (i(o4, "ServiceParameters")) t4.serviceParameters = { supportedFormats: l3(o4, "nativeFormat") };
      else if (i(o4, "boundedBy")) t4.boundedBy = P4(o4);
      else if (i(o4, "rangeType")) {
        const e5 = E(o4, ((_a = t4.boundedBy) == null ? void 0 : _a.axisLabels.length) > 2 || ((_b = t4.domainSet) == null ? void 0 : _b.axisLabels.length) > 2);
        t4.rangeType = e5.rangeType, a4 = e5.bandNames, n5 = e5.bandStats;
        const { bandNoDataValues: i4 } = e5;
        (i4 == null ? void 0 : i4.length) && (s2 = D2(i4));
      } else if (i(o4, "domainSet")) t4.domainSet = F(o4, (_c = t4.boundedBy) == null ? void 0 : _c.axisLabels);
      else if (i(o4, "metadata")) {
        const e5 = e2(o4, "EOMetadata");
        t4.eoMetadata = e5 ? O(e5) : null;
      }
    }
  }
  const { coverageId: o3, boundedBy: m3, domainSet: c2, rangeType: d6, serviceParameters: f5 } = t4, g4 = A2(d6, m3, c2);
  !n5 && g4 && (n5 = g4 == null ? void 0 : g4.variables[0].statistics), null != g4 && (s2 = d6[0][0].nilValue);
  return { id: o3, title: o3, description: o3, bandNames: a4, rasterInfo: new d3({ width: c2.columns, height: c2.rows, pixelSize: c2.resolution, pixelType: "unknown", extent: m3.envelope, spatialReference: m3.envelope.spatialReference, bandCount: a4.length || 1, statistics: n5, noDataValue: s2, multidimensionalInfo: g4 }), supportedFormats: f5.supportedFormats, coverageDescription: t4, version: "2.0.1", useEPSGAxis: false };
}
function k2(e4, t4) {
  let n5 = null;
  if ("string" == typeof e4) {
    n5 = new DOMParser().parseFromString(e4, "text/xml");
  } else n5 = e4;
  if ("1.0.0" === t4) {
    return n2(n5, "CoverageOffering").map((e5) => L(e5));
  }
  const i3 = n2(n5, "CoverageDescription");
  return "1.1.0" === t4 || "1.1.1" === t4 || "1.1.2" === t4 ? i3.map((e5) => N(e5, t4)) : i3.map((e5) => B(e5));
}

// node_modules/@arcgis/core/layers/ogc/wcsUtils.js
async function i2(a4, i3) {
  const { version: n5, customParameters: c2, signal: p5 } = i3 ?? {}, l5 = (n5 == null ? void 0 : n5.startsWith("1.0")) ? "version" : "acceptVersions", m3 = { service: "WCS", request: "GetCapabilities", [l5]: n5, ...c2 };
  try {
    let { data: r4 } = await P(a4, { query: m3, responseType: "xml", signal: p5 });
    return (i3 == null ? void 0 : i3.version) || S2(r4) || (m3[l5] = "2.0.1", { data: r4 } = await P(a4, { query: m3, responseType: "xml", signal: p5 })), b3(r4);
  } catch (u2) {
    if (!b(u2)) throw new s("wcslayer:open", "wcs capabilities is not valid or supported");
    throw u2;
  }
}
async function n3(t4, o3) {
  const { coverageIds: i3, version: n5, customParameters: c2, signal: p5 } = o3, l5 = n5.slice(0, 3), m3 = "1.0" === l5 ? "coverage" : "1.1" === l5 ? "identifiers" : "coverageId", u2 = { service: "WCS", request: "DescribeCoverage", version: n5, [m3]: i3.join(","), ...c2 };
  try {
    const { data: r4 } = await P(t4, { query: u2, responseType: "xml", signal: p5 });
    return k2(r4, n5);
  } catch (v4) {
    if (!b(v4)) throw new s("wcslayer:open", "wcs coverage description is not valid or supported");
    throw v4;
  }
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/multipartParser.js
function t3(t4) {
  const r4 = e3(t4);
  return r4 ? { isMultipart: true, data: r4.boundary ? n4(t4.data, r4, 0) : null } : { isMultipart: false, data: null };
}
function n4(t4, n5, e4 = 0) {
  const o3 = "--" + n5.boundary, i3 = [];
  for (let r4 = 0; r4 < o3.length; r4++) i3.push(o3.charCodeAt(r4));
  const a4 = [], s2 = "\n--" + n5.boundary + "--";
  for (let r4 = 0; r4 < s2.length; r4++) a4.push(s2.charCodeAt(r4));
  const l5 = [10], c2 = [13, 10], f5 = [], u2 = i3.length, h2 = new Uint8Array(t4, e4), g4 = h2.length - u2;
  let p5 = 0, d6 = 0;
  for (let b6 = 0; b6 < g4; b6++) {
    for (d6 = 0; d6 < u2 && h2[b6 + d6] === i3[d6]; d6++) ;
    if (d6 !== u2) continue;
    let t5 = false;
    if (p5) {
      const e5 = r3(h2.subarray(p5, b6), n5);
      f5.push(e5), t5 = !!e5.isValidImage;
    }
    if (b6 += u2 - 1, h2[b6 + 1] === l5[0] ? b6 += 1 : h2[b6 + 1] === c2[0] && h2[b6 + 2] === c2[1] && (b6 += 2), p5 = b6 + 1, t5) break;
  }
  const y4 = a4.length;
  for (let b6 = h2.length - y4 - 10; b6 < h2.length - y4; b6++) {
    for (d6 = 0; d6 < y4 && h2[b6 + d6] === a4[d6]; d6++) ;
    if (d6 === y4) {
      f5.push(r3(h2.subarray(p5, b6), n5));
      break;
    }
  }
  return f5;
}
function e3(t4) {
  var _a, _b;
  const n5 = (_b = (_a = t4.getHeader) == null ? void 0 : _a.call(t4, "Content-Type")) == null ? void 0 : _b.split(";");
  if (!n5) return null;
  if (!(n5[0].trim() ?? "").startsWith("multipart/")) return null;
  const e4 = { boundary: "", start: "", type: "" };
  for (let r4 = 1; r4 < n5.length; r4++) {
    const t5 = n5[r4].indexOf("=");
    if (t5 > 0) {
      const o3 = n5[r4].slice(0, t5).trim(), i3 = n5[r4].slice(t5 + 1).trim();
      e4[o3] = i3.startsWith('"') ? i3.slice(1, -1) : i3;
    }
  }
  return e4;
}
function r3(t4, n5) {
  var _a;
  const e4 = String.fromCharCode.apply(null, t4.subarray(0, Math.min(300, t4.length))).split("\n"), r4 = Math.min(e4.length, 7), o3 = { contentDisposition: "inline" };
  let i3 = 0;
  for (let a4 = 0; a4 < r4; a4++) if (e4[a4].length < 4) i3 = i3 + e4[a4].length + 1;
  else if ("content" === e4[a4].slice(0, 7).toLowerCase()) {
    i3 = i3 + e4[a4].length + 1;
    const t5 = e4[a4].indexOf(":");
    if (-1 === t5) continue;
    const n6 = e4[a4].slice(0, t5).trim(), r5 = e4[a4].slice(t5 + 1).trim();
    switch (n6.toLowerCase()) {
      case "content-type":
        o3.contentType = r5;
        break;
      case "content-description":
        o3.contentDescription = r5;
        break;
      case "content-transfer-encoding":
        o3.contentTransferEncoding = r5;
        break;
      case "content-id":
        o3.contentID = r5;
        break;
      case "content-disposition":
        o3.contentDisposition = r5;
        break;
      case "content-location":
        o3.contentLocation = r5;
    }
  } else {
    if (o3.contentDisposition.toLowerCase().includes("inline") && e4[a4].length >= 4 && ((_a = o3.contentType) == null ? void 0 : _a.toLowerCase().indexOf("image")) > -1) {
      let n6 = true, e5 = t4.subarray(i3, t4.length);
      if (o3.contentType.toLowerCase().indexOf("tif") > 0) {
        if ("base64" === o3.contentTransferEncoding) {
          let t5 = "";
          const n7 = e5;
          for (let e6 = 0; e6 < n7.length; e6 += 65535) {
            const r6 = n7.subarray(e6, e6 + 65535 > n7.length - 1 ? n7.length - 1 : e6 + 65535);
            t5 += String.fromCharCode.apply(null, r6);
          }
          const r5 = atob(t5);
          e5 = new Uint8Array(r5.length);
          for (let o4 = 0; o4 < e5.length; o4++) e5[o4] = r5.charCodeAt(o4);
        }
        n6 = 73 === e5[0] && 73 === e5[1] || 77 === e5[0] && 77 === e5[1];
      }
      if (n6) {
        let n7 = e5.buffer;
        "base64" !== o3.contentTransferEncoding && (n7 = new ArrayBuffer(t4.length - i3), e5 = new Uint8Array(n7), e5.set(t4.subarray(i3, t4.length))), o3.contentData = n7, o3.isValidImage = true;
      }
      break;
    }
    if (("" === n5.start || o3.contentID === n5.start) && o3.contentType) {
      if (o3.contentType.includes("text") || o3.contentType.includes("xml")) {
        o3.contentData = String.fromCharCode.apply(null, t4.subarray(i3, t4.length));
        break;
      }
      o3.contentData = t4.subarray(i3, t4.length);
    }
  }
  return o3;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/WCSRaster.js
var g3 = ["nearest neighbor", "bilinear", "bicubic"];
var w4 = ["nearest", "linear", "cubic"];
var v3 = "response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode";
var y3 = "response is not a supported multipart mediaType with inline tiff";
var x2 = "response is base64 encoded which may impact layer display performance";
var I2 = "server returns an exception";
var C2 = /* @__PURE__ */ new Set(["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"]);
var b5 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "WCSServer", this.tileType = "Raster";
  }
  get rasterId() {
    return `${this.url}-${this.coverageId}-${this.version}`;
  }
  async fetchRawTile(e4, i3, n5, s2 = {}) {
    if (this.isBlockOutside(e4, i3, n5)) return null;
    const { nativePixelSize: o3, spatialReference: r4 } = this.rasterInfo, a4 = 2 ** e4, l5 = o3.x * a4, c2 = o3.y * a4, { blockWidth: d6, blockHeight: f5 } = this.getBlockWidthHeight(e4), { origin: p5 } = this.rasterInfo.storageInfo.tileInfo, u2 = this.getTileExtent({ x: l5, y: c2 }, i3, n5, p5, r4, [d6, f5]), h2 = this.rasterInfo.extent, g4 = u2.xmax > h2.xmax, w5 = u2.ymin < h2.ymin, v4 = g4 || w5;
    let y4 = u2, x3 = d6, I3 = f5;
    if (v4 && (y4 = u2.clone().intersection(h2), null != y4 && (g4 && (x3 = Math.floor((y4.xmax - y4.xmin) / l5), y4.xmax = y4.xmin + l5 * x3), w5 && (I3 = Math.floor((y4.ymax - y4.ymin) / c2), y4.ymin = y4.ymax - c2 * I3))), null == y4 || x3 <= 1 || I3 <= 1) return null;
    const C4 = await this._getCoverage(y4, x3, I3, a4, s2);
    if (!C4) return null;
    const { coverageDescription: b6 } = this.coverageInfo, { noDataValue: $2, multidimensionalInfo: S5 } = this.rasterInfo, { multidimensionalDefinition: j3 } = s2;
    let T2;
    if (null != S5 && null != j3 && j3.length) {
      const e5 = j3[0].variableName;
      if ("2.0" === b6.version) {
        const t4 = b6.rangeType[0].find((t5) => t5.name === e5);
        T2 = t4 == null ? void 0 : t4.nilValue;
      } else if ("1.1" === b6.version) {
        const t4 = b6.range.find((t5) => t5.identifier === e5);
        T2 = t4 == null ? void 0 : t4.nullValues;
      }
    }
    const L2 = T2 ?? $2, P6 = await this.decodePixelBlock(C4, { width: x3, height: I3, planes: null, pixelType: null, tiffNoDataValue: Array.isArray(L2) ? L2[0] : L2, matchAllNoData: true });
    if (null == P6) return null;
    if (P6 && (P6.width !== x3 || P6.height !== I3)) throw new s("wcsraster-fetch", `the response has unexpected dimension width: ${P6.width}, height: {pixelBlock.height}`);
    return v4 ? P3(P6, { x: 0, y: 0 }, { width: f5, height: f5 }) : P6;
  }
  async _open(e4) {
    const { customFetchParameters: i3 } = this.ioConfig, n5 = e4 == null ? void 0 : e4.signal, s2 = await i2(this.url, { version: (i3 == null ? void 0 : i3.version) ?? this.version, customParameters: i3, signal: n5 });
    if (this.capabilities = s2, !this.version) {
      let e5 = s2.version.slice(0, 3);
      "2.0" === e5 || "1.1" === e5 || "1.0" === e5 ? this.version = s2.version : (e5 = s2.supportedVersions.find((e6) => "2.0.1" === e6) || s2.supportedVersions.find((e6) => "2.0" === e6.slice(0, 3)) || s2.supportedVersions.find((e6) => "1.1" === e6.slice(0, 3)) || s2.supportedVersions.find((e6) => "1.0" === e6.slice(0, 3)) || "1.0.0", this.version = e5);
    }
    const { version: o3 } = this;
    if (!C2.has(o3)) throw new s("wcsraster-open", `unsupported WCS version ${o3}`);
    const { gridCoverages: r4 } = s2;
    if (!r4.length) throw new s("wcsraster-open", "cannot find rectified grid coverages");
    this.coverageId ?? (this.coverageId = r4[0].id);
    const { coverageId: c2 } = this, d6 = r4.find((e5) => e5.id === c2);
    if (null == d6) throw new s("wcsraster-open", `the coverageId ${c2} does not exist in capabilities`);
    const f5 = await n3(this.url, { coverageIds: [c2], version: o3, customParameters: i3, signal: n5 });
    if (this.coverageInfo = f5[0], "2.0" === o3.slice(0, 3)) {
      const { coverageInfo: e5 } = this;
      e5.lonLatEnvelope = d6.lonLatEnvelope, e5.supportedInterpolations = h(s2.supportedInterpolations), this._patchDimensionValues201(c2, n5);
    }
    this.datasetName = this.coverageInfo.title;
    const { rasterInfo: p5 } = this.coverageInfo;
    if (this.createRemoteDatasetStorageInfo(p5, 512, 512), this._set("rasterInfo", p5), null == p5.spatialReference) throw new s("wcsraster-open", `coverage without spatial reference is not supported: ${c2}`);
    const { pixelType: h2, bandCount: m3 } = await this._getPixelTypeAndBandCount(n5);
    p5.pixelType = h2, 1 === p5.bandCount && m3 > 1 && (p5.bandCount = m3), this.updateTileInfo();
  }
  async _patchDimensionValues201(e4, t4) {
    var _a, _b, _c, _d, _e;
    const { coverageInfo: i3 } = this, n5 = (_a = i3.rasterInfo.multidimensionalInfo) == null ? void 0 : _a.variables, s2 = C2.has("1.1.2") ? "1.1.2" : C2.has("1.1.1") ? "1.1.1" : C2.has("1.1.0") ? "1.1.0" : null, { customFetchParameters: o3 } = this.ioConfig;
    if (n5 && s2) try {
      const i4 = this.url.includes("/ImageServer/"), r4 = e4.length > 8 && e4.startsWith("Coverage") && i4 ? e4.slice(8) : e4, a4 = await n3(this.url, { coverageIds: [r4 ?? e4], version: s2, customParameters: o3, signal: t4 }).catch(() => {
        if (r4) return n3(this.url, { coverageIds: [e4], version: s2, customParameters: o3, signal: t4 });
      }), c2 = (_b = a4 == null ? void 0 : a4[0].rasterInfo.multidimensionalInfo) == null ? void 0 : _b.variables;
      if (c2) for (const e5 of n5) {
        const t5 = c2.find(({ name: t6 }) => t6 === e5.name);
        if ((_c = t5 == null ? void 0 : t5.dimensions) == null ? void 0 : _c.length) for (let n6 = e5.dimensions.length - 1; n6 >= 0; n6--) {
          const s3 = e5.dimensions[n6], o4 = t5.dimensions.find(({ name: e6 }) => e6 === s3.name);
          o4 ? o4.values && ((_d = o4.extent) == null ? void 0 : _d.join(",")) === ((_e = s3.extent) == null ? void 0 : _e.join(",")) && (e5.dimensions[n6] = { ...s3, values: o4.values }) : i4 && e5.dimensions.splice(n6, 1);
        }
      }
    } catch {
    }
  }
  async _getPixelTypeAndBandCount(e4) {
    var _a;
    const { pixelSize: n5, extent: s2, multidimensionalInfo: r4 } = this.rasterInfo, a4 = s2.center, l5 = new w({ xmin: a4.x - n5.x, xmax: a4.x + n5.x, ymin: a4.y - n5.y, ymax: a4.y + n5.y, spatialReference: s2.spatialReference });
    let d6 = [];
    if (null != r4) {
      const e5 = r4.variables[0];
      d6 = [], e5.dimensions.forEach((t4) => {
        var _a2, _b;
        d6.push(new p3({ variableName: e5.name, dimensionName: t4.name, values: t4.hasRegularIntervals ? (_a2 = t4.extent) == null ? void 0 : _a2[0] : (_b = t4.values) == null ? void 0 : _b[0], isSlice: true }));
      });
    }
    const { coverageDescription: f5 } = this.coverageInfo, p5 = { interpolation: "nearest", multidimensionalDefinition: d6, signal: e4 }, { version: u2 } = f5, { ioConfig: h2 } = this, m3 = "2.0" === u2 && null == h2.allowAnyMediaType || "1.1" === u2 && null == h2.use2GridOffsets;
    let g4;
    try {
      g4 = await this._getCoverage(l5, 2, 2, 1, p5, true);
    } catch (y4) {
      if (!m3) throw y4;
      if ("1.1" === u2) {
        if (!((_a = y4.details) == null ? void 0 : _a.isResolutionMismatch)) throw y4;
        h2.use2GridOffsets = true;
      }
    }
    if (!g4 && m3 && ("2.0" === u2 && (h2.allowAnyMediaType = true), g4 = await this._getCoverage(l5, 2, 2, 1, p5), g4 && n.getLogger(this).warn("wcsraster:getcoverage", v3)), !g4) throw new s("wcsraster-open", "unable to determine pixel type");
    const w5 = await this.decodePixelBlock(g4, { width: 2, height: 2, planes: null, pixelType: null });
    if (null == w5) throw new s("wcsraster-open", "unable to determine pixel type");
    return { pixelType: w5.pixelType, bandCount: w5.getPlaneCount() ?? 0 };
  }
  async _getCoverage(e4, n5, s2, o3, r4, a4 = false) {
    const { coverageDescription: l5 } = this.coverageInfo, { version: c2 } = l5, d6 = "2.0" === c2 ? this._getCoverage201Parameters(e4, n5, s2, o3, r4, l5) : "1.1" === c2 ? this._getCoverage110Parameters(e4, n5, s2, r4, l5) : this._getCoverage100Parameters(e4, n5, s2, r4), f5 = "2.0" === c2 ? await this.request(this._constructWCS201Url(d6), { signal: r4.signal, responseType: "array-buffer" }) : await this.request(this.url, { query: d6, signal: r4.signal, responseType: "array-buffer" });
    if ("1.0" === c2) return f5.data;
    if ("2.0" === c2 && false !== this.ioConfig.allowAnyMediaType) {
      if ("tiff" === P2(f5.data)) return a4 && (this.ioConfig.allowAnyMediaType = true, n.getLogger(this).warn("wcsraster:getcoverage", v3)), f5.data;
    }
    const u2 = t3(f5);
    if (u2.isMultipart && u2.data) {
      const e5 = u2.data.find((e6) => e6.isValidImage);
      return a4 && "base64" === (e5 == null ? void 0 : e5.contentTransferEncoding) && n.getLogger(this).warn("wcsraster:getcoverage", x2), e5 == null ? void 0 : e5.contentData;
    }
    const m3 = new Uint8Array(f5.data, 0, Math.min(f5.data.byteLength, 2e3)), g4 = String.fromCharCode.apply(null, m3).toLowerCase().includes("exception"), w5 = g4 && String.fromCharCode.apply(null, m3).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");
    if (g4) throw new s("wcsraster:getcoverage", I2, { isResolutionMismatch: w5 });
    throw new s("wcsraster:getcoverage", y3);
  }
  _getInterpolationIndex(e4) {
    var _a;
    return e4 && ((_a = this.coverageInfo.supportedInterpolations) == null ? void 0 : _a.includes(e4)) ? "nearest" === e4 ? 0 : "bilinear" === e4 ? 1 : "cubic" === e4 ? 2 : 0 : 0;
  }
  _getCoverage100Parameters(e4, t4, i3, n5) {
    const s2 = `${e4.xmin},${e4.ymin},${e4.xmax},${e4.ymax}`, o3 = e4.spatialReference.wkid, r4 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "GEOTIFF", { bandIds: a4, interpolation: l5 } = n5, c2 = this._getInterpolationIndex(l5), d6 = a4 ? a4.map((e5) => this.coverageInfo.bandNames[e5]) : null, f5 = g3[c2], { multidimensionalDefinition: p5 } = n5;
    let u2;
    if (null != p5 && null != this.rasterInfo.multidimensionalInfo) {
      const e5 = p5.find((e6) => "StdTime" === e6.dimensionName);
      let t5 = e5 == null ? void 0 : e5.values;
      t5 && t5.length > 0 && (Array.isArray(t5[0]) && (t5 = t5[0]), u2 = t5.map((e6) => $(e6)).join(","));
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, coverage: this.coverageId, format: r4, crs: `EPSG:${o3}`, bbox: s2, width: t4, height: i3, time: u2, interpolation: f5, band: d6 == null ? void 0 : d6.join(",") };
  }
  _getCoverage110Parameters(e4, t4, i3, n5, s2) {
    var _a, _b, _c;
    const { multidimensionalDefinition: o3, bandIds: a4, interpolation: l5 } = n5, c2 = e4.spatialReference.wkid, d6 = `urn:ogc:def:crs:EPSG::${c2}`, f5 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", p5 = this._getInterpolationIndex(l5), u2 = w4[p5], h2 = null == l5 || 0 === ((_a = this.coverageInfo.supportedInterpolations) == null ? void 0 : _a.indexOf(l5)), m3 = s2.domain.spatialDomain, g4 = m3.origin.x <= m3.envelope.xmin && m3.origin.y <= m3.envelope.ymin, v4 = e4.width / t4, y4 = e4.height / i3 * (g4 ? 1 : -1), x3 = g4 ? [e4.xmin, e4.ymin] : [e4.xmin, e4.ymax], I3 = m3.useEPSGAxis && o2(c2), C4 = I3 ? `${x3[1]},${x3[0]}` : `${x3[0]},${x3[1]}`, b6 = this.ioConfig.use2GridOffsets, S5 = I3 ? b6 ? `${y4},${v4}` : `${y4},0,0,${v4}` : b6 ? `${v4},${y4}` : `${v4},0,0,${y4}`, j3 = v4 / 2, T2 = e4.xmin + j3, L2 = e4.xmax - j3, P6 = Math.abs(y4) / 2, R2 = e4.ymin + P6, _ = e4.ymax - P6, D3 = I3 ? `${R2},${T2},${_},${L2},${d6}` : `${T2},${R2},${L2},${_},${d6}`, A3 = s2.range.find((e5) => e5.axis.some((e6) => e6.identifier.toLowerCase().includes("band")));
    let E2, G = A3 && u2 && a4 ? h2 ? `${A3.identifier}[${A3.axis[0].identifier}[${a4.join(",")}]]` : `${A3.identifier}:${u2}[${A3.axis[0].identifier}[${a4.join(",")}]]` : null;
    if (null != o3 && o3.length) for (let r4 = 0; r4 < o3.length; r4++) {
      let e5 = o3[r4].values;
      const t5 = (_b = o3[r4].dimensionName) == null ? void 0 : _b.toLowerCase(), i4 = (_c = o3[r4].variableName) == null ? void 0 : _c.toLowerCase(), n6 = s2.range.find((e6) => e6.identifier.toLowerCase() === i4);
      if (e5.length > 0) {
        if (Array.isArray(e5[0]) && (e5 = e5[0]), "stdtime" === t5) E2 = e5.map((e6) => $(e6)).join(",");
        else if (n6) {
          const i5 = n6.axis.find((e6) => e6.identifier.toLowerCase() === t5);
          i5 && (G = h2 ? n6.identifier + "[" + i5.identifier + "[" + e5.join(",") + "]]" : n6.identifier + ":" + u2 + "[" + i5.identifier + "[" + e5.join(",") + "]]");
        }
      }
      r4 === o3.length - 1 && n6 && !G && (G = h2 ? n6.identifier : n6.identifier + ":" + u2);
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, identifier: this.coverageId, format: f5, crs: `EPSG:${c2}`, boundingbox: D3, gridCS: "urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS", gridType: "urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs", gridOrigin: C4, gridOffsets: S5, gridBaseCRS: d6, timeSequence: E2, rangeSubset: G };
  }
  _getCoverage201Parameters(e4, t4, i3, n5, s2, o3) {
    var _a;
    const { multidimensionalDefinition: r4, interpolation: a4 } = s2, l5 = this._getInterpolationIndex(a4);
    let c2 = null;
    const { supportedInterpolations: d6 } = this.capabilities;
    if (d6 == null ? void 0 : d6.length) switch (l5) {
      case 0:
        c2 = d6.find((e5) => e5.toLowerCase().includes("nearest"));
        break;
      case 1:
        c2 = d6.find((e5) => e5.toLowerCase().includes("linear"));
        break;
      case 2:
        c2 = d6.find((e5) => e5.toLowerCase().includes("cubic") || e5.toLowerCase().includes("quadratic"));
    }
    const f5 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", { bandNames: p5 } = this.coverageInfo, { boundedBy: u2, domainSet: h2, rangeType: m3 } = o3, g4 = u2.isEastFirst ? 0 : 1, w5 = 1 - g4, { axisLabels: v4 } = u2, y4 = v4[g4], x3 = v4[w5], I3 = `http://www.opengis.net/def/crs/EPSG/0/${e4.spatialReference.wkid}`, C4 = I3, b6 = [];
    b6.push(`${y4}(${e4.xmin},${e4.xmax})`), b6.push(`${x3}(${e4.ymin},${e4.ymax})`);
    const S5 = [];
    if (v4.length > 2) for (let _ = 2; _ < v4.length; _++) {
      const e5 = h2.origin[_];
      if (v4[_].toLowerCase().includes("time")) {
        let t5 = e5.toString();
        ((_a = u2.uomLabels) == null ? void 0 : _a[_].toLowerCase().includes("ole")) && (S5.push(v4[_]), t5 = $(e5, true)), b6.push(v4[_] + ",http://www.opengis.net(" + t5 + ")");
      } else b6.push(v4[_] + ",http://www.opengis.net(" + e5 + ")");
    }
    let j3 = null;
    if (null != r4 && r4.length) {
      const e5 = [];
      m3.forEach((t6) => t6.forEach((t7) => e5.push(t7.name)));
      const t5 = [];
      for (let i4 = 0; i4 < r4.length; i4++) {
        const n6 = v4.find((e6) => e6 === r4[i4].dimensionName), s3 = e5.find((e6) => e6 === r4[i4].variableName);
        if (t5.includes(s3) || t5.push(s3), n6) {
          let e6 = r4[i4].values;
          if (e6.length > 0) {
            Array.isArray(e6[0]) && (e6 = e6[0]);
            let t6 = "";
            t6 = n6.toLowerCase().includes("time") ? e6.map((e7) => $(e7)).join(",") : e6.join(",");
            const i5 = b6.findIndex((e7) => 0 === e7.indexOf(n6 + ",http://www.opengis.net"));
            -1 === i5 && b6.push(n6 + ",http://www.opengis.net(" + t6 + ")"), -1 === i5 || b6[i5].includes("(" + t6 + ")") || b6.splice(i5, 1, n6 + ",http://www.opengis.net(" + t6 + ")");
          }
        }
      }
      t5.length && (j3 = t5.join(","));
    } else if ((p5 == null ? void 0 : p5.length) >= 2) {
      j3 = (s2.bandIds ? s2.bandIds.map((e5) => p5[e5]) : p5).join(",");
    }
    const T2 = b6.join("&subset="), L2 = !o3.domainSet.hasSameAxisLabelsAsBoundedBy && false !== this.ioConfig.allowScaleFactor, P6 = L2 ? null : `${y4}(${t4}),${x3}(${i3})`, R2 = L2 ? 1 / n5 : null;
    return { service: "WCS", request: "GetCoverage", version: this.version, coverageId: this.coverageId, rangesubset: j3, interpolation: c2, scaleSize: P6, scaleFactor: R2, subset: T2, format: f5, mediaType: this.ioConfig.allowAnyMediaType ? null : "multipart/related", outputcrs: I3, subsettingcrs: C4 };
  }
  _constructWCS201Url(e4) {
    const t4 = { ...this.ioConfig.customFetchParameters, ...e4 }, i3 = [];
    Object.keys(t4).forEach((e5) => {
      const n5 = t4[e5];
      null != n5 && ("subset" === e5 ? "string" == typeof n5 && n5.split("&subset=").forEach((e6) => {
        e6 && i3.push(`subset=${encodeURIComponent(e6)}`);
      }) : i3.push(`${e5}=${encodeURIComponent(n5)}`));
    });
    return `${encodeURI(this.url)}?${i3.join("&")}`;
  }
};
function $(e4, t4 = false) {
  return (t4 ? new Date(w2(e4)) : new Date(e4)).toISOString();
}
r([m({ type: String, json: { write: true } })], b5.prototype, "datasetFormat", void 0), r([m({ readOnly: true })], b5.prototype, "tileType", void 0), r([m({ type: String, json: { write: true } })], b5.prototype, "version", void 0), r([m({ type: String, json: { write: true } })], b5.prototype, "coverageId", void 0), r([m({ readOnly: true })], b5.prototype, "rasterId", null), b5 = r([a2("esri.layers.support.rasterDatasets.WCSRaster")], b5);
var S4 = b5;

// node_modules/@arcgis/core/layers/WCSLayer.js
var P5 = /* @__PURE__ */ new Set(["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "months", "years", "decades", "centuries"]);
var O2 = class extends p(t(b2(j2(e(K(l2(f2(S(a3.ClonableMixin(f)))))))))) {
  constructor(...e4) {
    super(...e4), this.coverageId = null, this.version = null, this.isReference = null, this.legendEnabled = true, this.noData = 0, this.operationalLayerType = "WCS", this.type = "wcs", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this._debouncedSaveOperations = k(async (e5, t4, r4) => {
      const { save: o3, saveAs: s2 } = await import("./imageryUtils-ACOGEUZB.js");
      switch (e5) {
        case A.SAVE:
          return o3(this, t4);
        case A.SAVE_AS:
          return s2(this, r4, t4);
      }
    });
  }
  normalizeCtorArgs(e4, t4) {
    return "string" == typeof e4 ? { url: e4, ...t4 } : e4;
  }
  load(e4) {
    const t4 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WCS"] }, e4).catch(a).then(() => this._openRaster(t4))), Promise.resolve(this);
  }
  get coverageInfo() {
    return this.raster.coverageInfo;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    return [o("Pixel Value")];
  }
  createPopupTemplate(e4) {
    return p2({ fields: this.rasterFields, title: this.title }, e4);
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, t4) {
    return this._debouncedSaveOperations(A.SAVE_AS, t4, e4);
  }
  async _openRaster(e4) {
    var _a, _b, _c, _d;
    const t4 = new S4({ url: this.url, version: this.version, coverageId: this.coverageId, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters } });
    if (await t4.open({ signal: e4 }), !t4.rasterInfo) throw t4.destroy(), new s("wcs-layer:load", "cannot load resources on " + this.url);
    const { rasterInfo: r4 } = t4;
    null == r4.noDataValue && (r4.noDataValue = this.noData), this._set("serviceRasterInfo", r4), this._set("spatialReference", r4.spatialReference), null == this.title && this.setAtOrigin("title", t4.datasetName, "service"), null == this.coverageId && this.setAtOrigin("coverageId", t4.coverageInfo.id, "service"), null == this.version && t4.version && this.setAtOrigin("version", t4.version, "service"), this.setAtOrigin("tileInfo", t4.rasterInfo.storageInfo.tileInfo, "service");
    const { multidimensionalInfo: s2 } = r4;
    if (null != s2) {
      const e5 = s2.variables[0].dimensions.find(({ name: e6 }) => "StdTime" === e6);
      if (e5) {
        let t5 = ((_a = e5.extent) == null ? void 0 : _a[0]) ?? e5.values[0];
        Array.isArray(t5) && (t5 = t5[0]);
        let r5 = ((_b = e5.extent) == null ? void 0 : _b[1]) ?? e5.values[e5.values.length - 1];
        Array.isArray(r5) && (r5 = r5[1]);
        const o3 = P5.has((_c = e5.intervalUnit) == null ? void 0 : _c.toLowerCase()) ? (_d = e5.intervalUnit) == null ? void 0 : _d.toLowerCase() : null;
        this.set("timeInfo", { startField: "StdTime", fullTimeExtent: { start: t5, end: r5 }, timeZone: null, interval: o3 ? { value: e5.interval, unit: o3 } : null });
      }
    }
    this.raster = t4, this._configDefaultSettings(), this.addHandles(d(() => this.customParameters, (e5) => this.raster.ioConfig.customFetchParameters = e5));
  }
};
r([m({ type: String, nonNullable: true, json: { name: "wcsInfo.coverageId", write: { isRequired: true, ignoreOrigin: true } } })], O2.prototype, "coverageId", void 0), r([m()], O2.prototype, "coverageInfo", null), r([m({ type: ["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"], nonNullable: true, json: { name: "wcsInfo.version", write: { isRequired: true, ignoreOrigin: true } } })], O2.prototype, "version", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], O2.prototype, "isReference", void 0), r([m({ json: { read: true, write: true } })], O2.prototype, "blendMode", void 0), r([m(d2)], O2.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], O2.prototype, "listMode", void 0), r([m()], O2.prototype, "noData", void 0), r([m({ type: ["WCS"] })], O2.prototype, "operationalLayerType", void 0), r([m()], O2.prototype, "raster", void 0), r([m({ readOnly: true })], O2.prototype, "type", void 0), r([m(l)], O2.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], O2.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], O2.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, type: [y] })], O2.prototype, "fields", void 0), r([m({ readOnly: true, type: [y] })], O2.prototype, "rasterFields", null), O2 = r([a2("esri.layers.WCSLayer")], O2);
var C3 = O2;
export {
  C3 as default
};
//# sourceMappingURL=WCSLayer-VIQQQ5DD.js.map
