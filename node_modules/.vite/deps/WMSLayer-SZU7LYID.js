import {
  a as a4
} from "./chunk-MMLJTKWA.js";
import {
  o as o3
} from "./chunk-IJ3INJ7A.js";
import {
  t as t2
} from "./chunk-YZNN4Y2U.js";
import {
  i
} from "./chunk-TKEIF3N7.js";
import {
  l
} from "./chunk-HKTC3ZVY.js";
import "./chunk-MQ3WYGQ2.js";
import {
  j
} from "./chunk-K5B7AETB.js";
import "./chunk-5APVNM2E.js";
import {
  f as f2
} from "./chunk-73NNNHMH.js";
import {
  b as b2
} from "./chunk-C6YDI6QX.js";
import {
  d as d2,
  y
} from "./chunk-DJ5HVIE7.js";
import {
  S,
  m as m2
} from "./chunk-KPY4ZIC2.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import {
  n as n2
} from "./chunk-FF3WJRKN.js";
import "./chunk-4GYBOMKF.js";
import "./chunk-GSNLF6RP.js";
import {
  p
} from "./chunk-SVWZAOD7.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import {
  t
} from "./chunk-MILRZFWI.js";
import "./chunk-RPPIM555.js";
import "./chunk-4FQDWSFN.js";
import "./chunk-JOQ2ZFQV.js";
import {
  f
} from "./chunk-3UBDE4PK.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b as b3
} from "./chunk-BLF64HON.js";
import {
  q
} from "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import {
  n
} from "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  C,
  d,
  v
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import {
  V
} from "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import {
  DateTime,
  FixedOffsetZone
} from "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import {
  w as w2
} from "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import {
  g as g2
} from "./chunk-4GOW35CM.js";
import {
  s as s4
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import {
  s as s3
} from "./chunk-LSOJIRW6.js";
import {
  o as o2
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import {
  o
} from "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2,
  b
} from "./chunk-BECTSF5P.js";
import {
  Et,
  I,
  P,
  x as x2
} from "./chunk-FX46DC27.js";
import {
  g
} from "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  a as a2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s as s2
} from "./chunk-OSHCNHH7.js";
import {
  w,
  x
} from "./chunk-7LCEUMDD.js";
import {
  a,
  s
} from "./chunk-6II7WQ2F.js";
import {
  G
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/layers/support/WMSSublayer.js
var h;
var c = 0;
var m3 = h = class extends n.IdentifiableMixin(m2) {
  constructor(e) {
    super(e), this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.legendUrl = null, this.legendEnabled = true, this.layer = null, this.maxScale = 0, this.minScale = 0, this.name = null, this.parent = null, this.popupEnabled = false, this.queryable = false, this.sublayers = null, this.spatialReferences = null, this.title = null, this.addHandles([v(() => this.sublayers, "after-add", ({ item: e2 }) => {
      e2.parent = this, e2.layer = this.layer;
    }, C), v(() => this.sublayers, "after-remove", ({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }, C), d(() => this.sublayers, (e2, t3) => {
      if (t3) for (const r3 of t3) r3.layer = r3.parent = null;
      if (e2) for (const r3 of e2) r3.parent = this, r3.layer = this.layer;
    }, C), d(() => this.layer, (e2) => {
      if (this.sublayers) for (const t3 of this.sublayers) t3.layer = e2;
    }, C)]);
  }
  get id() {
    const e = this._get("id");
    return e ?? c++;
  }
  set id(e) {
    this._set("id", e);
  }
  readLegendUrl(e, t3) {
    return t3.legendUrl ?? t3.legendURL ?? null;
  }
  get effectiveScaleRange() {
    const { minScale: e, maxScale: t3 } = this;
    return { minScale: e, maxScale: t3 };
  }
  castSublayers(e) {
    return w(V.ofType(h), e);
  }
  set visible(e) {
    this._setAndNotifyLayer("visible", e);
  }
  clone() {
    var _a, _b, _c;
    const e = new h();
    return this.hasOwnProperty("description") && (e.description = this.description), this.hasOwnProperty("fullExtent") && (e.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e.fullExtents = ((_a = this.fullExtents) == null ? void 0 : _a.map((e2) => e2.clone())) ?? null), this.hasOwnProperty("legendUrl") && (e.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e.layer = this.layer), this.hasOwnProperty("name") && (e.name = this.name), this.hasOwnProperty("parent") && (e.parent = this.parent), this.hasOwnProperty("queryable") && (e.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e.sublayers = (_b = this.sublayers) == null ? void 0 : _b.map((e2) => e2.clone())), this.hasOwnProperty("spatialReferences") && (e.spatialReferences = (_c = this.spatialReferences) == null ? void 0 : _c.map((e2) => e2)), this.hasOwnProperty("visible") && (e.visible = this.visible), this.hasOwnProperty("title") && (e.title = this.title), e;
  }
  _setAndNotifyLayer(e, t3) {
    const r3 = this.layer;
    this._get(e) !== t3 && (this._set(e, t3), r3 && r3.emit("wms-sublayer-update", { propertyName: e, id: this.id }));
  }
};
r([m()], m3.prototype, "description", void 0), r([m({ readOnly: true })], m3.prototype, "dimensions", void 0), r([m({ type: w2, json: { name: "extent" } })], m3.prototype, "fullExtent", void 0), r([m()], m3.prototype, "fullExtents", void 0), r([m({ type: Number, json: { write: { enabled: false, overridePolicy: () => ({ ignoreOrigin: true, enabled: true }) } } })], m3.prototype, "id", null), r([m({ type: String, json: { name: "legendUrl", write: { ignoreOrigin: true } } })], m3.prototype, "legendUrl", void 0), r([o2("legendUrl", ["legendUrl", "legendURL"])], m3.prototype, "readLegendUrl", null), r([m({ type: Boolean, json: { name: "showLegend", origins: { "web-map": { read: false, write: false }, "web-scene": { read: false, write: false } } } })], m3.prototype, "legendEnabled", void 0), r([m()], m3.prototype, "layer", void 0), r([m()], m3.prototype, "maxScale", void 0), r([m()], m3.prototype, "minScale", void 0), r([m({ readOnly: true })], m3.prototype, "effectiveScaleRange", null), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], m3.prototype, "name", void 0), r([m()], m3.prototype, "parent", void 0), r([m({ type: Boolean, json: { read: { source: "showPopup" }, write: { ignoreOrigin: true, target: "showPopup" } } })], m3.prototype, "popupEnabled", void 0), r([m({ type: Boolean, json: { write: { ignoreOrigin: true } } })], m3.prototype, "queryable", void 0), r([m()], m3.prototype, "sublayers", void 0), r([s3("sublayers")], m3.prototype, "castSublayers", null), r([m({ type: [Number], json: { read: { source: "spatialReferences" } } })], m3.prototype, "spatialReferences", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], m3.prototype, "title", void 0), r([m({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" } } })], m3.prototype, "visible", null), m3 = h = r([a3("esri.layers.support.WMSSublayer")], m3);
var f3 = m3;

// node_modules/@arcgis/core/layers/support/wmsUtils.js
var a5 = { 84: 4326, 83: 4269, 27: 4267 };
function u(n3) {
  if (!n3) return null;
  const r3 = { idCounter: -1 };
  if ("string" == typeof n3) {
    n3 = new DOMParser().parseFromString(n3, "text/xml");
  }
  const i2 = n3.documentElement;
  if ("ServiceExceptionReport" === i2.nodeName) {
    const e = Array.prototype.slice.call(i2.childNodes).map((e2) => e2.textContent).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", e);
  }
  const s5 = x3("Capability", i2), o4 = x3("Service", i2), l2 = s5 && x3("Request", s5);
  if (!s5 || !o4 || !l2) return null;
  const a6 = x3("Layer", s5);
  if (!a6) return null;
  const u2 = "WMS_Capabilities" === i2.nodeName || "WMT_MS_Capabilities" === i2.nodeName ? i2.getAttribute("version") : "1.3.0", c3 = N("Title", o4, "") || N("Name", o4, ""), d4 = N("AccessConstraints", o4, ""), p3 = /^none$/i.test(d4) ? "" : d4, h3 = N("Abstract", o4, ""), g4 = parseInt(N("MaxWidth", o4, "5000"), 10), A2 = parseInt(N("MaxHeight", o4, "5000"), 10), L2 = b4(l2, "GetMap"), C2 = y2(l2, "GetMap"), F2 = S2(a6, u2, r3);
  if (!F2) return null;
  let M, T2 = 0;
  const I3 = Array.prototype.slice.call(s5.childNodes), R2 = F2.sublayers ?? [], v3 = (e) => {
    null != e && R2.push(e);
  };
  I3.forEach((e) => {
    "Layer" === e.nodeName && (0 === T2 ? M = e : 1 === T2 ? (F2.name && (F2.name = "", v3(S2(M, u2, r3))), v3(S2(e, u2, r3))) : v3(S2(e, u2, r3)), T2++);
  });
  const U2 = F2.sublayers ?? [], V3 = F2.fullExtents ?? [];
  0 === U2.length && U2.push(F2), F2.extent ?? (F2.extent = U2[0].extent);
  const _2 = F2.spatialReferences.length > 0 ? F2.spatialReferences : m4(F2), O2 = y2(l2, "GetFeatureInfo"), B2 = O2 ? b4(l2, "GetFeatureInfo") : null, j3 = f4(U2), k2 = F2.minScale || 0, q3 = F2.maxScale || 0, X3 = F2.dimensions ?? [], D2 = j3.reduce((e, t3) => e.concat(t3.dimensions ?? []), []), G2 = X3.concat(D2).filter(w3);
  let $ = null;
  if (G2.length) {
    const t3 = G2.map((e) => {
      const { extent: t4 } = e;
      return E(t4) ? t4.map((e2) => e2.getTime()) : t4 == null ? void 0 : t4.map((e2) => [e2.min.getTime(), e2.max.getTime()]);
    }).flat(2).filter(G);
    $ = { startTimeField: null, endTimeField: null, trackIdField: void 0, timeExtent: [Math.min(...t3), Math.max(...t3)] };
  }
  return { copyright: p3, description: h3, dimensions: X3, extent: F2.extent, fullExtents: V3, featureInfoFormats: B2, featureInfoUrl: O2, mapUrl: C2, maxWidth: g4, maxHeight: A2, maxScale: q3, minScale: k2, layers: j3, spatialReferences: _2, supportedImageFormatTypes: L2, timeInfo: $, title: c3, version: u2 };
}
function c2(e) {
  const t3 = e.filter((e2) => e2.popupEnabled && e2.name && e2.queryable);
  return t3.length ? t3.map(({ name: e2 }) => e2).join() : null;
}
function m4(e) {
  if (e.spatialReferences.length > 0) return e.spatialReferences;
  if (e.sublayers) for (const t3 of e.sublayers) {
    const e2 = m4(t3);
    if (e2.length > 0) return e2;
  }
  return [];
}
function f4(e) {
  var _a;
  let t3 = [];
  for (const n3 of e) t3.push(n3), ((_a = n3.sublayers) == null ? void 0 : _a.length) && (t3 = t3.concat(f4(n3.sublayers)), delete n3.sublayers);
  return t3;
}
function d3(e, t3, n3) {
  return t3.getAttribute(e) ?? n3;
}
function p2(e, t3, n3, r3) {
  const i2 = x3(e, n3);
  return i2 ? d3(t3, i2, r3) : r3;
}
function x3(e, t3) {
  for (let n3 = 0; n3 < t3.childNodes.length; n3++) {
    const r3 = t3.childNodes[n3];
    if (L(r3) && r3.nodeName === e) return r3;
  }
  return null;
}
function h2(e, t3) {
  if (null == t3) return [];
  const n3 = [];
  for (let r3 = 0; r3 < t3.childNodes.length; r3++) {
    const i2 = t3.childNodes[r3];
    L(i2) && i2.nodeName === e && n3.push(i2);
  }
  return n3;
}
function N(e, t3, n3) {
  var _a;
  return ((_a = x3(e, t3)) == null ? void 0 : _a.textContent) ?? n3;
}
function g3(e, t3, n3) {
  if (!e) return null;
  const r3 = parseFloat(e.getAttribute("minx")), i2 = parseFloat(e.getAttribute("miny")), s5 = parseFloat(e.getAttribute("maxx")), o4 = parseFloat(e.getAttribute("maxy"));
  let l2, a6, u2, c3;
  return n3 ? (l2 = isNaN(i2) ? -Number.MAX_VALUE : i2, a6 = isNaN(r3) ? -Number.MAX_VALUE : r3, u2 = isNaN(o4) ? Number.MAX_VALUE : o4, c3 = isNaN(s5) ? Number.MAX_VALUE : s5) : (l2 = isNaN(r3) ? -Number.MAX_VALUE : r3, a6 = isNaN(i2) ? -Number.MAX_VALUE : i2, u2 = isNaN(s5) ? Number.MAX_VALUE : s5, c3 = isNaN(o4) ? Number.MAX_VALUE : o4), { xmin: l2, ymin: a6, xmax: u2, ymax: c3, spatialReference: { wkid: t3 } };
}
function y2(e, t3) {
  const n3 = x3(t3, e);
  if (n3) {
    const e2 = x3("DCPType", n3);
    if (e2) {
      const t4 = x3("HTTP", e2);
      if (t4) {
        const e3 = x3("Get", t4);
        if (e3) {
          let t5 = p2("OnlineResource", "xlink:href", e3, null);
          if (t5) {
            const e4 = t5.indexOf("&");
            return -1 !== e4 && e4 === t5.length - 1 && (t5 = t5.slice(0, -1)), T(t5, ["service", "request"]);
          }
        }
      }
    }
  }
  return null;
}
function b4(t3, n3) {
  const r3 = h2("Operation", t3);
  if (!r3.length) {
    return h2("Format", x3(n3, t3)).map(({ textContent: e }) => e).filter(G);
  }
  const i2 = [];
  for (const e of r3) if (e.getAttribute("name") === n3) {
    const t4 = h2("Format", e);
    for (const { textContent: e2 } of t4) null != e2 && i2.push(e2);
  }
  return i2;
}
function A(e, t3, n3) {
  const r3 = x3(t3, e);
  if (!r3) return n3;
  const { textContent: i2 } = r3;
  if (null == i2 || "" === i2) return n3;
  const s5 = Number(i2);
  return isNaN(s5) ? n3 : s5;
}
function S2(e, t3, n3) {
  var _a;
  if (!e) return null;
  const o4 = (_a = e.getAttribute("queryable")) == null ? void 0 : _a.toLowerCase(), l2 = "1" === o4 || "true" === o4, u2 = { id: n3.idCounter++, fullExtents: [], parentLayerId: null, queryable: l2, spatialReferences: [], sublayers: null }, c3 = x3("LatLonBoundingBox", e), m5 = x3("EX_GeographicBoundingBox", e);
  let f5 = null;
  c3 && (f5 = g3(c3, 4326)), m5 && (f5 = new w2(0, 0, 0, 0, new g2({ wkid: 4326 })), f5.xmin = parseFloat(N("westBoundLongitude", m5, "0")), f5.ymin = parseFloat(N("southBoundLatitude", m5, "0")), f5.xmax = parseFloat(N("eastBoundLongitude", m5, "0")), f5.ymax = parseFloat(N("northBoundLatitude", m5, "0"))), c3 || m5 || (f5 = new w2(-180, -90, 180, 90, new g2({ wkid: 4326 }))), u2.minScale = A(e, "MaxScaleDenominator", 0), u2.maxScale = A(e, "MinScaleDenominator", 0);
  const p3 = ["1.0.0", "1.1.0", "1.1.1"].includes(t3) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e.childNodes).forEach((e2) => {
    var _a2;
    if ("Name" === e2.nodeName) u2.name = e2.textContent || "";
    else if ("Title" === e2.nodeName) u2.title = e2.textContent || "";
    else if ("Abstract" === e2.nodeName) u2.description = e2.textContent || "";
    else if ("BoundingBox" === e2.nodeName) {
      const n4 = e2.getAttribute(p3);
      if (n4 && 0 === n4.indexOf("EPSG:")) {
        const r4 = parseInt(n4.slice(5), 10);
        0 === r4 || isNaN(r4) || f5 || (f5 = "1.3.0" === t3 ? g3(e2, r4, o3(r4)) : g3(e2, r4));
      }
      const r3 = n4 == null ? void 0 : n4.indexOf(":");
      if (r3 && r3 > -1) {
        let i2 = parseInt(n4.slice(r3 + 1), 10);
        0 === i2 || isNaN(i2) || (i2 = a5[i2] ?? i2);
        const o5 = "1.3.0" === t3 ? g3(e2, i2, o3(i2)) : g3(e2, i2);
        o5 && u2.fullExtents && u2.fullExtents.push(o5);
      }
    } else if (e2.nodeName === p3) {
      (((_a2 = e2.textContent) == null ? void 0 : _a2.split(" ")) ?? []).forEach((e3) => {
        let t4 = NaN;
        if (e3.includes(":")) {
          const [n4, r3] = e3.toUpperCase().split(":");
          "CRS" !== n4 && "EPSG" !== n4 || (t4 = parseInt(r3, 10));
        } else t4 = parseInt(e3, 10);
        if (0 !== t4 && !isNaN(t4)) {
          const e4 = a5[t4] ?? t4;
          u2.spatialReferences.includes(e4) || u2.spatialReferences.push(e4);
        }
      });
    } else if ("Style" !== e2.nodeName || u2.legendUrl) {
      if ("Layer" === e2.nodeName) {
        const r3 = S2(e2, t3, n3);
        r3 && (r3.parentLayerId = u2.id, u2.sublayers || (u2.sublayers = []), u2.sublayers.push(r3));
      }
    } else {
      const t4 = x3("LegendURL", e2);
      if (t4) {
        const e3 = x3("OnlineResource", t4);
        e3 && (u2.legendUrl = e3.getAttribute("xlink:href"));
      }
    }
  }), u2.extent = f5, u2.dimensions = h2("Dimension", e).filter((e2) => e2.getAttribute("name") && e2.getAttribute("units") && e2.textContent).map((e2) => {
    const t4 = e2.getAttribute("name"), n4 = e2.getAttribute("units"), r3 = e2.textContent, i2 = e2.getAttribute("unitSymbol") ?? void 0, s5 = e2.getAttribute("default") ?? void 0, o5 = "0" !== d3("default", e2, "0"), l3 = "0" !== d3("nearestValue", e2, "0"), a6 = "0" !== d3("current", e2, "0");
    if (w3({ name: t4, units: n4 })) {
      return { name: "time", units: "ISO8601", extent: v2(r3), default: v2(s5), multipleValues: o5, nearestValue: l3, current: a6 };
    }
    if (F({ name: t4, units: n4 })) {
      return { name: "elevation", units: n4, extent: I2(r3), unitSymbol: i2, default: I2(s5), multipleValues: o5, nearestValue: l3 };
    }
    return { name: t4, units: n4, extent: R(r3), unitSymbol: i2, default: R(s5), multipleValues: o5, nearestValue: l3 };
  }), u2;
}
function E(e) {
  return Array.isArray(e) && e.length > 0 && e[0] instanceof Date;
}
function L(e) {
  return e.nodeType === Node.ELEMENT_NODE;
}
function F(e) {
  return /^elevation$/i.test(e.name) && /^(epsg|crs):\d+$/i.test(e.units);
}
function w3(e) {
  return /^time$/i.test(e.name) && /^iso8601$/i.test(e.units);
}
function T(e, t3) {
  const r3 = [], i2 = I(e);
  for (const n3 in i2.query) i2.query.hasOwnProperty(n3) && (t3.includes(n3.toLowerCase()) || r3.push(n3 + "=" + i2.query[n3]));
  return i2.path + (r3.length ? "?" + r3.join("&") : "");
}
function I2(t3) {
  if (!t3) return;
  const n3 = t3.includes("/"), r3 = t3.split(",");
  return n3 ? r3.map((e) => {
    const t4 = e.split("/");
    if (t4.length < 2) return null;
    return { min: parseFloat(t4[0]), max: parseFloat(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? parseFloat(t4[2]) : void 0 };
  }).filter(G) : r3.map((e) => parseFloat(e));
}
function R(t3) {
  if (!t3) return;
  const n3 = t3.includes("/"), r3 = t3.split(",");
  return n3 ? r3.map((e) => {
    const t4 = e.split("/");
    if (t4.length < 2) return null;
    return { min: t4[0], max: t4[1], resolution: t4.length >= 3 && "0" !== t4[2] ? t4[2] : void 0 };
  }).filter(G) : r3;
}
function v2(t3) {
  if (!t3) return;
  const n3 = t3.includes("/"), r3 = t3.split(",");
  return n3 ? r3.map((e) => {
    const t4 = e.split("/");
    if (t4.length < 2) return null;
    return { min: U(t4[0]), max: U(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? V2(t4[2]) : void 0 };
  }).filter(G) : r3.map((e) => U(e));
}
function U(e) {
  return DateTime.fromISO(e, { zone: FixedOffsetZone.utcInstance }).toJSDate();
}
function V2(e) {
  const t3 = /(?:p(\d+y|\d+(?:\.|,)\d+y)?(\d+m|\d+(?:\.|,)\d+m)?(\d+d|\d+(?:\.|,)\d+d)?)?(?:t(\d+h|\d+(?:\.|,)\d+h)?(\d+m|\d+(?:\.|,)\d+m)?(\d+s|\d+(?:\.|,)\d+s)?)?/i, n3 = e.match(t3);
  if (!n3) return null;
  return { years: _(n3[1]), months: _(n3[2]), days: _(n3[3]), hours: _(n3[4]), minutes: _(n3[5]), seconds: _(n3[6]) };
}
function _(e) {
  if (!e) return 0;
  const t3 = /(?:\d+(?:\.|,)\d+|\d+)/, n3 = e.match(t3);
  if (!n3) return 0;
  const r3 = n3[0].replace(",", ".");
  return Number(r3);
}
function O(e) {
  return e.toISOString().replace(/\.[0-9]{3}/, "");
}
var B = "0000-01-01T00:00:00Z";
var j2 = "9999-12-31T23:59:59Z";
function k(e) {
  if (!e || e.isAllTime || e.isEmpty) return;
  const { start: t3, end: n3 } = e;
  if (t3 && n3 && t3.getTime() === n3.getTime()) return `${O(t3)}`;
  return `${t3 ? O(t3) : B}/${n3 ? O(n3) : j2}`;
}
var q2 = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var X = /* @__PURE__ */ new Set([3395, 54004]);
function D(e, t3) {
  let n3 = e.wkid;
  return null == t3 ? n3 : (null != n3 && t3.includes(n3) || !e.latestWkid || (n3 = e.latestWkid), null != n3 && q2.has(n3) ? t3.find((e2) => q2.has(e2)) || t3.find((e2) => X.has(e2)) || 102100 : n3);
}

// node_modules/@arcgis/core/layers/WMSLayer.js
var J = new o({ bmp: "image/bmp", gif: "image/gif", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml" }, { ignoreUnknown: false });
function z(e) {
  return "text/html" === e;
}
function Q(e) {
  return "text/plain" === e;
}
var K = class extends p(l(f2(t(b2(j(S(f))))))) {
  constructor(...e) {
    super(...e), this.allSublayers = new n2({ getCollections: () => [this.sublayers], getChildrenFunction: (e2) => e2.sublayers }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormats = null, this.featureInfoUrl = null, this.fetchFeatureInfoFunction = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.version = null, this.addHandles([v(() => this.sublayers, "after-add", ({ item: e2 }) => {
      e2.parent = e2.layer = this;
    }, C), v(() => this.sublayers, "after-remove", ({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }, C), d(() => this.sublayers, (e2, t3) => {
      if (t3) for (const r3 of t3) r3.layer = r3.parent = null;
      if (e2) for (const r3 of e2) r3.parent = r3.layer = this;
    }, C)]);
  }
  normalizeCtorArgs(e, t3) {
    return "string" == typeof e ? { url: e, ...t3 } : e;
  }
  destroy() {
    this.allSublayers.destroy();
  }
  load(e) {
    const t3 = null != e ? e.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMS"] }, e).catch(a2).then(() => this._fetchService(t3)).then(() => this._checkLayerValidity())), Promise.resolve(this);
  }
  readFullExtentFromItemOrMap(e, t3) {
    const r3 = t3.extent;
    return r3 ? new w2({ xmin: r3[0][0], ymin: r3[0][1], xmax: r3[1][0], ymax: r3[1][1] }) : null;
  }
  writeFullExtent(e, t3) {
    t3.extent = [[e.xmin, e.ymin], [e.xmax, e.ymax]];
  }
  get featureInfoFormat() {
    return null == this.featureInfoFormats ? null : this.featureInfoFormats.find(z) ?? this.featureInfoFormats.find(Q) ?? null;
  }
  set featureInfoFormat(e) {
    null == e ? (this.revert("featureInfoFormat", "service"), this._clearOverride("featureInfoFormat")) : (z(e) || Q(e)) && this._override("featureInfoFormat", e);
  }
  readImageFormat(e, t3) {
    const r3 = t3.supportedImageFormatTypes;
    return r3 && r3.includes("image/png") ? "image/png" : r3 && r3[0];
  }
  readSpatialReferenceFromItemOrDocument(e, t3) {
    return new g2(t3.spatialReferences[0]);
  }
  writeSpatialReferences(e, t3) {
    var _a;
    const r3 = (_a = this.spatialReference) == null ? void 0 : _a.wkid;
    e && r3 ? (t3.spatialReferences = e.filter((e2) => e2 !== r3), t3.spatialReferences.unshift(r3)) : t3.spatialReferences = e;
  }
  readSublayersFromItemOrMap(e, t3, r3) {
    return Y(t3.layers, r3, t3.visibleLayers);
  }
  readSublayers(e, t3, r3) {
    return Y(t3.layers, r3);
  }
  writeSublayers(e, t3, r3, o4) {
    var _a, _b;
    t3.layers = [];
    const s5 = /* @__PURE__ */ new Map(), i2 = e.flatten(({ sublayers: e2 }) => e2 ?? []);
    for (const a6 of i2) if ("number" == typeof ((_a = a6.parent) == null ? void 0 : _a.id)) {
      const e2 = s5.get(a6.parent.id);
      null != e2 ? e2.push(a6.id) : s5.set(a6.parent.id, [a6.id]);
    }
    for (const a6 of i2) {
      const e2 = { sublayer: a6, ...o4 }, r4 = a6.write({ parentLayerId: "number" == typeof ((_b = a6.parent) == null ? void 0 : _b.id) ? a6.parent.id : -1 }, e2);
      if (s5.has(a6.id) && (r4.sublayerIds = s5.get(a6.id)), !a6.sublayers && a6.name) {
        const r5 = a6.write({}, e2);
        delete r5.id, t3.layers.push(r5);
      }
    }
    t3.visibleLayers = i2.filter(({ visible: e2, sublayers: t4 }) => e2 && !t4).map(({ name: e2 }) => e2).toArray();
  }
  set url(e) {
    if (!e) return void this._set("url", e);
    const { path: t3, query: r3 } = I(e);
    for (const s5 in r3) /^(request|service)$/i.test(s5) && delete r3[s5];
    const o4 = Et(t3, r3 ?? {});
    this._set("url", o4);
  }
  createExportImageParameters(e, t3, r3, o4) {
    const s5 = (o4 == null ? void 0 : o4.pixelRatio) ?? 1, i2 = i({ extent: e, width: t3 }) * s5, a6 = new a4({ layer: this, scale: i2 }), { xmin: n3, ymin: l2, xmax: p3, ymax: m5, spatialReference: u2 } = e, c3 = D(u2, this.spatialReferences), y3 = "1.3.0" === this.version && o3(c3) ? `${l2},${n3},${m5},${p3}` : `${n3},${l2},${p3},${m5}`, f5 = a6.toJSON(), d4 = "1.3.0" === this.version ? "crs" : "srs";
    return { bbox: y3, [d4]: null == c3 || isNaN(c3) ? void 0 : "EPSG:" + c3, ...f5 };
  }
  async fetchImage(e, t3, r3, o4) {
    const i2 = this.mapUrl, a6 = this.createExportImageParameters(e, t3, r3, o4);
    if (!a6.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t3, e2.height = r3, e2;
    }
    const n3 = k(o4 == null ? void 0 : o4.timeExtent), l2 = { responseType: "image", query: this._mixCustomParameters({ width: t3, height: r3, ...a6, time: n3, ...this.refreshParameters }), signal: o4 == null ? void 0 : o4.signal };
    return P2(i2 ?? "", l2).then((e2) => e2.data);
  }
  async fetchImageBitmap(e, t3, r3, o4) {
    const i2 = this.mapUrl ?? "", a6 = this.createExportImageParameters(e, t3, r3, o4);
    if (!a6.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t3, e2.height = r3, e2;
    }
    const n3 = k(o4 == null ? void 0 : o4.timeExtent), l2 = { responseType: "blob", query: this._mixCustomParameters({ width: t3, height: r3, ...a6, time: n3, ...this.refreshParameters }), signal: o4 == null ? void 0 : o4.signal }, { data: p3 } = await P2(i2, l2);
    return t2(p3, i2, o4 == null ? void 0 : o4.signal);
  }
  fetchFeatureInfo(e, t3, r3, o4, s5) {
    const i2 = i({ extent: e, width: t3 }), a6 = new a4({ layer: this, scale: i2 }), n3 = c2(a6.visibleSublayers);
    if (null == this.featureInfoUrl || null == n3) return Promise.resolve([]);
    if (null == this.fetchFeatureInfoFunction && null == this.featureInfoFormat) return Promise.resolve([]);
    const l2 = "1.3.0" === this.version ? { I: o4, J: s5 } : { x: o4, y: s5 }, p3 = { query_layers: n3, request: "GetFeatureInfo", info_format: this.featureInfoFormat, feature_count: 25, width: t3, height: r3, ...l2 }, m5 = { ...this.createExportImageParameters(e, t3, r3), ...p3 }, u2 = this._mixCustomParameters(m5);
    return null != this.fetchFeatureInfoFunction ? this.fetchFeatureInfoFunction(u2) : this._defaultFetchFeatureInfoFunction(Et(this.featureInfoUrl, u2));
  }
  findSublayerById(e) {
    return this.allSublayers.find((t3) => t3.id === e);
  }
  findSublayerByName(e) {
    return this.allSublayers.find((t3) => t3.name === e);
  }
  serviceSupportsSpatialReference(e) {
    return b(this.url) || null != this.spatialReferences && this.spatialReferences.some((t3) => {
      const r3 = 900913 === t3 ? g2.WebMercator : new g2({ wkid: t3 });
      return s4(r3, e);
    });
  }
  _defaultFetchFeatureInfoFunction(e) {
    const t3 = document.createElement("iframe");
    t3.src = P(e), t3.style.border = "none", t3.style.margin = "0", t3.style.width = "100%", t3.setAttribute("sandbox", "");
    const s5 = new q({ title: this.title, content: t3 }), i2 = new b3({ sourceLayer: this, popupTemplate: s5 });
    return Promise.resolve([i2]);
  }
  async _fetchService(e) {
    var _a;
    if (!this.resourceInfo && ((_a = this.parsedUrl) == null ? void 0 : _a.path)) {
      const { path: t3, query: r3 } = this.parsedUrl, { data: o4 } = await P2(t3, { query: { SERVICE: "WMS", REQUEST: "GetCapabilities", ...r3, ...this.customParameters }, responseType: "xml", signal: e });
      this.resourceInfo = u(o4);
    }
    if (this.parsedUrl) {
      const e2 = new x2(this.parsedUrl.path), { httpsDomains: r3 } = s.request;
      "https" !== e2.scheme || e2.port && "443" !== e2.port || !e2.host || r3.includes(e2.host) || r3.push(e2.host);
    }
    this.read(this.resourceInfo, { origin: "service" });
  }
  _checkLayerValidity() {
    if (!this.allSublayers.length) throw new s2("wmslayer:empty-layer", "The layer doesn't have any sublayer");
  }
  _mixCustomParameters(e) {
    if (!this.customLayerParameters && !this.customParameters) return e;
    const t3 = { ...this.customParameters, ...this.customLayerParameters };
    for (const r3 in t3) e[r3.toLowerCase()] = t3[r3];
    return e;
  }
};
function X2(e, t3) {
  return e.some((e2) => {
    for (const r3 in e2) if (g(e2, r3, null, t3)) return true;
    return false;
  });
}
function Y(e, t3, r3) {
  e = e ?? [];
  const o4 = /* @__PURE__ */ new Map();
  e.every((e2) => null == e2.id) && (e = a(e)).forEach((e2, t4) => e2.id = t4);
  for (const i2 of e) {
    const e2 = new f3();
    e2.read(i2, t3), r3 && !r3.includes(e2.name) && (e2.visible = false), o4.set(e2.id, e2);
  }
  const s5 = [];
  for (const a6 of e) {
    const e2 = null != a6.id ? o4.get(a6.id) : null;
    if (e2) if (null != a6.parentLayerId && a6.parentLayerId >= 0) {
      const t4 = o4.get(a6.parentLayerId);
      if (!t4) continue;
      t4.sublayers || (t4.sublayers = new V()), t4.sublayers.push(e2);
    } else s5.push(e2);
  }
  return s5;
}
r([m({ readOnly: true })], K.prototype, "allSublayers", void 0), r([m({ json: { type: Object, write: true } })], K.prototype, "customParameters", void 0), r([m({ json: { type: Object, write: true } })], K.prototype, "customLayerParameters", void 0), r([m({ type: String, json: { write: true } })], K.prototype, "copyright", void 0), r([m()], K.prototype, "description", void 0), r([m({ readOnly: true })], K.prototype, "dimensions", void 0), r([m({ json: { type: [[Number]], read: { source: "extent" }, write: { target: "extent" }, origins: { "web-document": { write: { ignoreOrigin: true } }, "portal-item": { write: { ignoreOrigin: true } } } } })], K.prototype, "fullExtent", void 0), r([o2(["web-document", "portal-item"], "fullExtent", ["extent"])], K.prototype, "readFullExtentFromItemOrMap", null), r([r2(["web-document", "portal-item"], "fullExtent", { extent: { type: [[Number]] } })], K.prototype, "writeFullExtent", null), r([m({ type: [w2] })], K.prototype, "fullExtents", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], K.prototype, "featureInfoFormat", null), r([m({ type: [String], readOnly: true })], K.prototype, "featureInfoFormats", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], K.prototype, "featureInfoUrl", void 0), r([m()], K.prototype, "fetchFeatureInfoFunction", void 0), r([m({ type: String, json: { origins: { "web-document": { default: "image/png", type: J.jsonValues, read: { reader: J.read, source: "format" }, write: { writer: J.write, target: "format" } } } } })], K.prototype, "imageFormat", void 0), r([o2("imageFormat", ["supportedImageFormatTypes"])], K.prototype, "readImageFormat", null), r([m({ type: Number, json: { read: { source: "maxHeight" }, write: { target: "maxHeight" } } })], K.prototype, "imageMaxHeight", void 0), r([m({ type: Number, json: { read: { source: "maxWidth" }, write: { target: "maxWidth" } } })], K.prototype, "imageMaxWidth", void 0), r([m()], K.prototype, "imageTransparency", void 0), r([m(d2)], K.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide", "hide-children"] })], K.prototype, "listMode", void 0), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], K.prototype, "mapUrl", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], K.prototype, "isReference", void 0), r([m({ type: ["WMS"] })], K.prototype, "operationalLayerType", void 0), r([m()], K.prototype, "resourceInfo", void 0), r([m({ type: g2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, write: false } })], K.prototype, "spatialReference", void 0), r([o2(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], K.prototype, "readSpatialReferenceFromItemOrDocument", null), r([m({ type: [x], json: { read: false, origins: { service: { read: true }, "web-document": { read: false, write: { ignoreOrigin: true } }, "portal-item": { read: false, write: { ignoreOrigin: true } } } } })], K.prototype, "spatialReferences", void 0), r([r2(["web-document", "portal-item"], "spatialReferences")], K.prototype, "writeSpatialReferences", null), r([m({ type: V.ofType(f3), json: { write: { target: "layers", overridePolicy(e, t3, r3) {
  if (X2(this.allSublayers, r3)) return { ignoreOrigin: true };
} } } })], K.prototype, "sublayers", void 0), r([o2(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], K.prototype, "readSublayersFromItemOrMap", null), r([o2("service", "sublayers", ["layers"])], K.prototype, "readSublayers", null), r([r2("sublayers", { layers: { type: [f3] }, visibleLayers: { type: [String] } })], K.prototype, "writeSublayers", null), r([m({ json: { read: false }, readOnly: true, value: "wms" })], K.prototype, "type", void 0), r([m(y)], K.prototype, "url", null), r([m({ type: String, json: { write: { ignoreOrigin: true } } })], K.prototype, "version", void 0), K = r([a3("esri.layers.WMSLayer")], K);
var Z = K;
export {
  Z as default
};
//# sourceMappingURL=WMSLayer-SZU7LYID.js.map
