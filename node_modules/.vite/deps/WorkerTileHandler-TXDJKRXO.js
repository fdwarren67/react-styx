import {
  e as e4,
  s as s2
} from "./chunk-DGCCEGJE.js";
import {
  o as o2
} from "./chunk-J2QYVOHP.js";
import {
  O,
  U,
  l as l3,
  t as t3
} from "./chunk-PVSDTWLJ.js";
import {
  E,
  I
} from "./chunk-PQUUCIML.js";
import {
  a as a4,
  l as l2,
  m,
  n as n2,
  o as o3,
  p as p2,
  u
} from "./chunk-NBFYN6KG.js";
import "./chunk-23WGP47N.js";
import {
  a as a3,
  c as c2,
  i as i2
} from "./chunk-MVYDN2TM.js";
import {
  C
} from "./chunk-B7S3HUFO.js";
import {
  t as t2
} from "./chunk-6VF5U3IZ.js";
import {
  _,
  a as a2,
  d,
  e,
  e2,
  f,
  h,
  h2,
  i,
  o,
  p,
  r,
  s
} from "./chunk-E7IFPXEX.js";
import {
  e as e3
} from "./chunk-OK5AUMBT.js";
import "./chunk-OBVDE24U.js";
import {
  a
} from "./chunk-W5QWJI4E.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-QBRBJ5XN.js";
import "./chunk-PONPGREB.js";
import "./chunk-QNYMCEB7.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  t3 as t
} from "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  b,
  c2 as c,
  n
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  l2 as l
} from "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/ScriptUtils.js
function e5(e6) {
  return 746 === e6 || 747 === e6 || !(e6 < 4352) && (e6 >= 12704 && e6 <= 12735 || (e6 >= 12544 && e6 <= 12591 || (e6 >= 65072 && e6 <= 65103 && !(e6 >= 65097 && e6 <= 65103) || (e6 >= 63744 && e6 <= 64255 || (e6 >= 13056 && e6 <= 13311 || (e6 >= 11904 && e6 <= 12031 || (e6 >= 12736 && e6 <= 12783 || (e6 >= 12288 && e6 <= 12351 && !(e6 >= 12296 && e6 <= 12305 || e6 >= 12308 && e6 <= 12319 || 12336 === e6) || (e6 >= 13312 && e6 <= 19903 || (e6 >= 19968 && e6 <= 40959 || (e6 >= 12800 && e6 <= 13055 || (e6 >= 12592 && e6 <= 12687 || (e6 >= 43360 && e6 <= 43391 || (e6 >= 55216 && e6 <= 55295 || (e6 >= 4352 && e6 <= 4607 || (e6 >= 44032 && e6 <= 55215 || (e6 >= 12352 && e6 <= 12447 || (e6 >= 12272 && e6 <= 12287 || (e6 >= 12688 && e6 <= 12703 || (e6 >= 12032 && e6 <= 12255 || (e6 >= 12784 && e6 <= 12799 || (e6 >= 12448 && e6 <= 12543 && 12540 !== e6 || (e6 >= 65280 && e6 <= 65519 && !(65288 === e6 || 65289 === e6 || 65293 === e6 || e6 >= 65306 && e6 <= 65310 || 65339 === e6 || 65341 === e6 || 65343 === e6 || e6 >= 65371 && e6 <= 65503 || 65507 === e6 || e6 >= 65512 && e6 <= 65519) || (e6 >= 65104 && e6 <= 65135 && !(e6 >= 65112 && e6 <= 65118 || e6 >= 65123 && e6 <= 65126) || (e6 >= 5120 && e6 <= 5759 || (e6 >= 6320 && e6 <= 6399 || (e6 >= 65040 && e6 <= 65055 || (e6 >= 19904 && e6 <= 19967 || (e6 >= 40960 && e6 <= 42127 || e6 >= 42128 && e6 <= 42191)))))))))))))))))))))))))))));
}
function c3(e6) {
  return !(e6 < 11904) && (e6 >= 12704 && e6 <= 12735 || (e6 >= 12544 && e6 <= 12591 || (e6 >= 65072 && e6 <= 65103 || (e6 >= 63744 && e6 <= 64255 || (e6 >= 13056 && e6 <= 13311 || (e6 >= 11904 && e6 <= 12031 || (e6 >= 12736 && e6 <= 12783 || (e6 >= 12288 && e6 <= 12351 || (e6 >= 13312 && e6 <= 19903 || (e6 >= 19968 && e6 <= 40959 || (e6 >= 12800 && e6 <= 13055 || (e6 >= 65280 && e6 <= 65519 || (e6 >= 12352 && e6 <= 12447 || (e6 >= 12272 && e6 <= 12287 || (e6 >= 12032 && e6 <= 12255 || (e6 >= 12784 && e6 <= 12799 || (e6 >= 12448 && e6 <= 12543 || (e6 >= 65040 && e6 <= 65055 || (e6 >= 42128 && e6 <= 42191 || e6 >= 40960 && e6 <= 42127)))))))))))))))))));
}
function s3(e6) {
  switch (e6) {
    case 10:
    case 32:
    case 38:
    case 40:
    case 41:
    case 43:
    case 45:
    case 47:
    case 173:
    case 183:
    case 8203:
    case 8208:
    case 8211:
    case 8231:
      return true;
  }
  return false;
}
function a5(e6) {
  switch (e6) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
      return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TextShaping.js
var c4 = 24;
var h3 = 17;
var l4 = class {
  constructor(t5, e6, i5, o6, s6, c5, h5) {
    this._glyphItems = t5, this._maxWidth = e6, this._lineHeight = i5, this._letterSpacing = o6, this._hAnchor = s6, this._vAnchor = c5, this._justify = h5;
  }
  getShaping(s6, c5, h5) {
    const l6 = this._letterSpacing, n4 = this._lineHeight, a7 = this._justify, r6 = this._maxWidth, m2 = [];
    let f3 = 0, p4 = 0;
    for (const t5 of s6) {
      const e6 = t5.codePointAt(0);
      if (null == e6) continue;
      const i5 = h5 && e5(e6);
      let s7;
      for (const t6 of this._glyphItems) if (s7 = t6[e6], s7) break;
      m2.push({ codePoint: e6, x: f3, y: p4, vertical: i5, glyphMosaicItem: s7 }), s7 && (f3 += s7.metrics.advance + l6);
    }
    let g2 = f3;
    if (r6 > 0) {
      g2 = f3 / Math.max(1, Math.ceil(f3 / r6));
    }
    const y2 = s6.includes("â€‹"), d3 = [], x2 = m2.length;
    for (let e6 = 0; e6 < x2 - 1; e6++) {
      const o6 = m2[e6].codePoint, s7 = c3(o6);
      if (s3(o6) || s7) {
        let t5 = 0;
        if (10 === o6) t5 -= 1e4;
        else if (s7 && y2) t5 += 150;
        else {
          40 !== o6 && 65288 !== o6 || (t5 += 50);
          const i5 = m2[e6 + 1].codePoint;
          41 !== i5 && 65289 !== i5 || (t5 += 50);
        }
        d3.push(this._buildBreak(e6 + 1, m2[e6].x, g2, d3, t5, false));
      }
    }
    const u4 = this._optimalBreaks(this._buildBreak(x2, f3, g2, d3, 0, true));
    let M = 0;
    const _2 = c5 ? -n4 : n4;
    let I4 = 0;
    for (let t5 = 0; t5 < u4.length; t5++) {
      const i5 = u4[t5];
      let o6 = I4;
      for (; o6 < i5 && a5(m2[o6].codePoint); ) m2[o6].glyphMosaicItem = null, ++o6;
      let s7 = i5 - 1;
      for (; s7 > o6 && a5(m2[s7].codePoint); ) m2[s7].glyphMosaicItem = null, --s7;
      if (o6 <= s7) {
        const t6 = m2[o6].x;
        for (let i6 = o6; i6 <= s7; i6++) m2[i6].x -= t6, m2[i6].y = p4;
        let e6 = m2[s7].x;
        m2[s7].glyphMosaicItem && (e6 += m2[s7].glyphMosaicItem.metrics.advance), M = Math.max(e6, M), a7 && this._applyJustification(m2, o6, s7);
      }
      I4 = i5, p4 += _2;
    }
    if (m2.length > 0) {
      const t5 = u4.length - 1, e6 = (a7 - this._hAnchor) * M;
      let i5 = (-this._vAnchor * (t5 + 1) + 0.5) * n4;
      c5 && t5 && (i5 += t5 * n4);
      for (const o6 of m2) o6.x += e6, o6.y += i5;
    }
    return m2.filter((t5) => t5.glyphMosaicItem);
  }
  static getTextBox(t5, e6) {
    if (!t5.length) return null;
    let i5 = 1 / 0, o6 = 1 / 0, s6 = 0, c5 = 0;
    for (const l6 of t5) {
      const t6 = l6.glyphMosaicItem.metrics.advance, n4 = l6.x, a7 = l6.y - h3, r6 = n4 + t6, m2 = a7 + e6;
      i5 = Math.min(i5, n4), s6 = Math.max(s6, r6), o6 = Math.min(o6, a7), c5 = Math.max(c5, m2);
    }
    return { x: i5, y: o6, width: s6 - i5, height: c5 - o6 };
  }
  static getBox(t5) {
    if (!t5.length) return null;
    let e6 = 1 / 0, i5 = 1 / 0, o6 = 0, s6 = 0;
    for (const c5 of t5) {
      const { height: t6, left: h5, top: l6, width: n4 } = c5.glyphMosaicItem.metrics, a7 = c5.x, r6 = c5.y - (t6 - Math.abs(l6)), m2 = a7 + n4 + h5, f3 = r6 + t6;
      e6 = Math.min(e6, a7), o6 = Math.max(o6, m2), i5 = Math.min(i5, r6), s6 = Math.max(s6, f3);
    }
    return { x: e6, y: i5, width: o6 - e6, height: s6 - i5 };
  }
  static addDecoration(t5, e6) {
    const i5 = t5.length;
    if (0 === i5) return;
    const o6 = 3;
    let c5 = t5[0].x + t5[0].glyphMosaicItem.metrics.left, h5 = t5[0].y;
    for (let n4 = 1; n4 < i5; n4++) {
      const i6 = t5[n4];
      if (i6.y !== h5) {
        const l7 = t5[n4 - 1].x + t5[n4 - 1].glyphMosaicItem.metrics.left + t5[n4 - 1].glyphMosaicItem.metrics.width;
        t5.push({ codePoint: 0, x: c5, y: h5 + e6 - o6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: l7 - c5, height: 2 + 2 * o6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } }), h5 = i6.y, c5 = i6.x + i6.glyphMosaicItem.metrics.left;
      }
    }
    const l6 = t5[i5 - 1].x + t5[i5 - 1].glyphMosaicItem.metrics.left + t5[i5 - 1].glyphMosaicItem.metrics.width;
    t5.push({ codePoint: 0, x: c5, y: h5 + e6 - o6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: l6 - c5, height: 2 + 2 * o6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } });
  }
  _breakScore(t5, e6, i5, o6) {
    const s6 = (t5 - e6) * (t5 - e6);
    return o6 ? t5 < e6 ? s6 / 2 : 2 * s6 : s6 + Math.abs(i5) * i5;
  }
  _buildBreak(t5, e6, i5, o6, s6, c5) {
    let h5 = null, l6 = this._breakScore(e6, i5, s6, c5);
    for (const n4 of o6) {
      const t6 = e6 - n4.x, o7 = this._breakScore(t6, i5, s6, c5) + n4.score;
      o7 <= l6 && (h5 = n4, l6 = o7);
    }
    return { index: t5, x: e6, score: l6, previousBreak: h5 };
  }
  _optimalBreaks(t5) {
    return t5 ? this._optimalBreaks(t5.previousBreak).concat(t5.index) : [];
  }
  _applyJustification(t5, e6, i5) {
    const o6 = t5[i5], s6 = o6.vertical ? c4 : o6.glyphMosaicItem ? o6.glyphMosaicItem.metrics.advance : 0, h5 = (o6.x + s6) * this._justify;
    for (let c5 = e6; c5 <= i5; c5++) t5[c5].x -= h5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Placement.js
var x = 4096;
var d2 = 8;
var p3 = 0.5;
var w = 2;
var T = class {
  constructor(e6, t5, i5 = 0, n4 = -1, s6 = p3) {
    this.x = e6, this.y = t5, this.angle = i5, this.segment = n4, this.minzoom = s6;
  }
};
var y = class {
  constructor(e6, t5, i5, s6, o6, a7 = p3, l6 = r) {
    this.anchor = e6, this.labelAngle = t5, this.glyphAngle = i5, this.page = s6, this.alternateVerticalGlyph = o6, this.minzoom = a7, this.maxzoom = l6;
  }
};
var f2 = class {
  constructor(e6, t5, i5, n4, s6, o6, a7, l6, h5, r6, c5, g2) {
    this.tl = e6, this.tr = t5, this.bl = i5, this.br = n4, this.mosaicRect = s6, this.labelAngle = o6, this.minAngle = a7, this.maxAngle = l6, this.anchor = h5, this.minzoom = r6, this.maxzoom = c5, this.page = g2;
  }
};
var I2 = class {
  constructor(e6) {
    this.shapes = e6;
  }
};
var u2 = class {
  getIconPlacement(n4, s6, o6) {
    const a7 = new h(n4.x, n4.y), l6 = o6.rotationAlignment === l2.MAP, h5 = o6.keepUpright;
    let r6 = o6.rotate * s;
    l6 && (r6 += n4.angle);
    const m2 = new I2([]);
    return o6.allowOverlap && o6.ignorePlacement || !o2 || (m2.iconColliders = []), this._addIconPlacement(m2, a7, s6, o6, r6), l6 && h5 && this._addIconPlacement(m2, a7, s6, o6, r6 + o), m2;
  }
  _addIconPlacement(t5, i5, s6, o6, a7) {
    const l6 = s6.rasterizationScale, h5 = s6.width / l6, r6 = s6.height / l6, g2 = o6.offset;
    let x2 = g2[0], d3 = g2[1];
    switch (o6.anchor) {
      case m.CENTER:
        x2 -= h5 / 2, d3 -= r6 / 2;
        break;
      case m.LEFT:
        d3 -= r6 / 2;
        break;
      case m.RIGHT:
        x2 -= h5, d3 -= r6 / 2;
        break;
      case m.TOP:
        x2 -= h5 / 2;
        break;
      case m.BOTTOM:
        x2 -= h5 / 2, d3 -= r6;
        break;
      case m.TOP_LEFT:
        break;
      case m.BOTTOM_LEFT:
        d3 -= r6;
        break;
      case m.TOP_RIGHT:
        x2 -= h5;
        break;
      case m.BOTTOM_RIGHT:
        x2 -= h5, d3 -= r6;
    }
    const w2 = s6.rect, T2 = 2 / l6, y2 = x2 - T2, I4 = d3 - T2, u4 = y2 + w2.width / l6, b3 = I4 + w2.height / l6, P = new h(y2, I4), O2 = new h(u4, b3), _2 = new h(y2, b3), k = new h(u4, I4);
    if (0 !== a7) {
      const e6 = Math.cos(a7), t6 = Math.sin(a7);
      P.rotate(e6, t6), O2.rotate(e6, t6), _2.rotate(e6, t6), k.rotate(e6, t6);
    }
    const M = new f2(P, k, _2, O2, w2, a7, 0, 256, i5, p3, r, 0);
    if (t5.shapes.push(M), (!o6.allowOverlap || !o6.ignorePlacement) && o2) {
      const e6 = o6.size, s7 = o6.padding, l7 = { xTile: i5.x, yTile: i5.y, dxPixels: x2 * e6 - s7, dyPixels: d3 * e6 - s7, hard: !o6.optional, partIndex: 0, width: h5 * e6 + 2 * s7, height: r6 * e6 + 2 * s7, angle: a7, minLod: p3, maxLod: r };
      t5.iconColliders.push(l7);
    }
  }
  getTextPlacement(s6, o6, a7, c5) {
    const x2 = new h(s6.x, s6.y), T2 = c5.rotate * s, u4 = c5.rotationAlignment === l2.MAP, b3 = c5.keepUpright, P = c5.padding;
    let O2 = p3;
    const _2 = !u4 ? 0 : s6.angle, k = s6.segment >= 0 && u4, M = c5.allowOverlap && c5.ignorePlacement ? null : [], E2 = [], G = 4, N = !k;
    let A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
    const v = (k || u4) && b3, R = c5.size / c4;
    let B = false;
    for (const e6 of o6) if (e6.vertical) {
      B = true;
      break;
    }
    let H, V = 0, j = 0;
    if (!k && B) {
      const e6 = l4.getTextBox(o6, c5.lineHeight * c4);
      switch (c5.anchor) {
        case m.LEFT:
          V = e6.height / 2, j = -e6.width / 2;
          break;
        case m.RIGHT:
          V = -e6.height / 2, j = e6.width / 2;
          break;
        case m.TOP:
          V = e6.height / 2, j = e6.width / 2;
          break;
        case m.BOTTOM:
          V = -e6.height / 2, j = -e6.width / 2;
          break;
        case m.TOP_LEFT:
          V = e6.height;
          break;
        case m.BOTTOM_LEFT:
          j = -e6.width;
          break;
        case m.TOP_RIGHT:
          j = e6.width;
          break;
        case m.BOTTOM_RIGHT:
          V = -e6.height;
      }
    }
    V += c5.offset[0] * c4, j += c5.offset[1] * c4;
    for (const t5 of o6) {
      const o7 = t5.glyphMosaicItem;
      if (!o7 || o7.rect.isEmpty) continue;
      const l6 = o7.rect, h5 = o7.metrics, g2 = o7.page;
      if (M && N) {
        if (void 0 !== H && H !== t5.y) {
          let e6, t6, i5, o8;
          B ? (e6 = -F + V, t6 = A2 + j, i5 = F - z, o8 = L2 - A2) : (e6 = A2 + V, t6 = z + j, i5 = L2 - A2, o8 = F - z);
          const a8 = { xTile: s6.x, yTile: s6.y, dxPixels: e6 * R - P, dyPixels: t6 * R - P, hard: !c5.optional, partIndex: 1, width: i5 * R + 2 * P, height: o8 * R + 2 * P, angle: T2, minLod: p3, maxLod: r };
          M.push(a8), A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
        }
        H = t5.y;
      }
      const m2 = [];
      if (k) {
        const e6 = 0.5 * o7.metrics.width, i5 = (t5.x + h5.left - G + e6) * R * d2;
        if (O2 = this._placeGlyph(s6, O2, i5, a7, s6.segment, 1, t5.vertical, g2, m2), b3 && (O2 = this._placeGlyph(s6, O2, i5, a7, s6.segment, -1, t5.vertical, g2, m2)), O2 >= w) break;
      } else m2.push(new y(x2, _2, _2, g2, false)), u4 && b3 && m2.push(new y(x2, _2 + o, _2 + o, g2, false));
      const I4 = t5.x + h5.left, C3 = t5.y - h3 - h5.top, S = I4 + h5.width, Y = C3 + h5.height;
      let q, U2, D, J, K, Q, W, X;
      if (!k && B) if (t5.vertical) {
        const t6 = (I4 + S) / 2 - h5.height / 2, i5 = (C3 + Y) / 2 + h5.width / 2;
        q = new h(-i5 - G + V, t6 - G + j), U2 = new h(q.x + l6.width, q.y + l6.height), D = new h(q.x, U2.y), J = new h(U2.x, q.y);
      } else q = new h(-C3 + G + V, I4 - G + j), U2 = new h(q.x - l6.height, q.y + l6.width), D = new h(U2.x, q.y), J = new h(q.x, U2.y);
      else q = new h(I4 - G + V, C3 - G + j), U2 = new h(q.x + l6.width, q.y + l6.height), D = new h(q.x, U2.y), J = new h(U2.x, q.y);
      for (const i5 of m2) {
        let n4, o8, a8, r6;
        if (i5.alternateVerticalGlyph) {
          if (!K) {
            const t6 = (C3 + Y) / 2 + j;
            K = new h((I4 + S) / 2 + V - h5.height / 2 - G, t6 + h5.width / 2 + G), Q = new h(K.x + l6.height, K.y - l6.width), W = new h(Q.x, K.y), X = new h(K.x, Q.y);
          }
          n4 = K, o8 = W, a8 = X, r6 = Q;
        } else n4 = q, o8 = D, a8 = J, r6 = U2;
        const g3 = C3, m3 = Y, x3 = i5.glyphAngle + T2;
        if (0 !== x3) {
          const e6 = Math.cos(x3), t6 = Math.sin(x3);
          n4 = n4.clone(), o8 = o8 == null ? void 0 : o8.clone(), a8 = a8 == null ? void 0 : a8.clone(), r6 = r6 == null ? void 0 : r6.clone(), n4.rotate(e6, t6), r6 == null ? void 0 : r6.rotate(e6, t6), o8 == null ? void 0 : o8.rotate(e6, t6), a8 == null ? void 0 : a8.rotate(e6, t6);
        }
        let d3 = 0, p4 = 256;
        if (k && B ? t5.vertical ? i5.alternateVerticalGlyph ? (d3 = 32, p4 = 96) : (d3 = 224, p4 = 32) : (d3 = 224, p4 = 96) : (d3 = 192, p4 = 64), E2.push(new f2(n4, a8, o8, r6, l6, i5.labelAngle, d3, p4, i5.anchor, i5.minzoom, i5.maxzoom, i5.page)), M && (!v || this._legible(i5.labelAngle))) {
          if (N) I4 < A2 && (A2 = I4), g3 < z && (z = g3), S > L2 && (L2 = S), m3 > F && (F = m3);
          else if (i5.minzoom < w) {
            const e6 = { xTile: s6.x, yTile: s6.y, dxPixels: (I4 + V) * R - P, dyPixels: (g3 + V) * R - P, hard: !c5.optional, partIndex: 1, width: (S - I4) * R + 2 * P, height: (m3 - g3) * R + 2 * P, angle: x3, minLod: i5.minzoom, maxLod: i5.maxzoom };
            M.push(e6);
          }
        }
      }
    }
    if (O2 >= w) return null;
    if (M && N) {
      let e6, t5, i5, o7;
      B ? (e6 = -F + V, t5 = A2 + j, i5 = F - z, o7 = L2 - A2) : (e6 = A2 + V, t5 = z + j, i5 = L2 - A2, o7 = F - z);
      const a8 = { xTile: s6.x, yTile: s6.y, dxPixels: e6 * R - P, dyPixels: t5 * R - P, hard: !c5.optional, partIndex: 1, width: i5 * R + 2 * P, height: o7 * R + 2 * P, angle: T2, minLod: p3, maxLod: r };
      M.push(a8);
    }
    const C2 = new I2(E2);
    return M && M.length > 0 && (C2.textColliders = M), C2;
  }
  _legible(e6) {
    const t5 = f(e6);
    return t5 < 65 || t5 >= 193;
  }
  _placeGlyph(t5, s6, l6, h5, r6, c5, g2, m2, x2) {
    let d3 = c5;
    const p4 = d3 < 0 ? a2(t5.angle + o, e2) : t5.angle;
    let w2 = 0;
    l6 < 0 && (d3 *= -1, l6 *= -1, w2 = o), d3 > 0 && ++r6;
    let T2 = new h(t5.x, t5.y), f3 = h5[r6], I4 = r;
    if (h5.length <= r6) return I4;
    for (; ; ) {
      const e6 = f3.x - T2.x, t6 = f3.y - T2.y, i5 = Math.sqrt(e6 * e6 + t6 * t6), n4 = Math.max(l6 / i5, s6), c6 = e6 / i5, u4 = t6 / i5, b3 = a2(Math.atan2(u4, c6) + w2, e2);
      if (x2.push(new y(T2, p4, b3, m2, false, n4, I4)), g2 && x2.push(new y(T2, p4, b3, m2, true, n4, I4)), n4 <= s6) return n4;
      T2 = f3.clone();
      do {
        if (r6 += d3, h5.length <= r6 || r6 < 0) return n4;
        f3 = h5[r6];
      } while (T2.isEqual(f3));
      let P = f3.x - T2.x, O2 = f3.y - T2.y;
      const _2 = Math.sqrt(P * P + O2 * O2);
      P *= i5 / _2, O2 *= i5 / _2, T2.x -= P, T2.y -= O2, I4 = n4;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/IndexMemoryBuffer.js
var r2 = class extends t3 {
  constructor() {
    super(12);
  }
  add(s6, r6, t5) {
    const e6 = this.array;
    e6.push(s6), e6.push(r6), e6.push(t5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VertexMemoryBuffer.js
var o4 = class extends t3 {
  constructor(t5) {
    super(t5);
  }
  add(t5, o6, r6, u4, h5, a7, n4, d3, e6, p4, i5, c5) {
    const M = this.array;
    let l6 = t3.i1616to32(t5, o6);
    M.push(l6);
    const m2 = 31;
    l6 = t3.i8888to32(Math.round(m2 * r6), Math.round(m2 * u4), Math.round(m2 * h5), Math.round(m2 * a7)), M.push(l6), l6 = t3.i8888to32(Math.round(m2 * n4), Math.round(m2 * d3), Math.round(m2 * e6), Math.round(m2 * p4)), M.push(l6), l6 = t3.i1616to32(i5, 0), M.push(l6), c5 && M.push(...c5);
  }
};
var r3 = class extends t3 {
  constructor(t5) {
    super(t5);
  }
  add(t5, o6, r6) {
    const u4 = this.array;
    u4.push(t3.i1616to32(t5, o6)), r6 && u4.push(...r6);
  }
};
var u3 = class extends t3 {
  constructor(t5) {
    super(t5);
  }
  add(t5, o6, r6, u4, h5, a7, n4) {
    const d3 = this.array, e6 = this.index;
    let p4 = t3.i1616to32(t5, o6);
    d3.push(p4);
    const i5 = 15;
    return p4 = t3.i8888to32(Math.round(i5 * r6), Math.round(i5 * u4), h5, a7), d3.push(p4), n4 && d3.push(...n4), e6;
  }
};
var h4 = class extends t3 {
  constructor(t5) {
    super(t5);
  }
  add(o6, r6, u4, h5, a7, n4, d3, e6, p4, i5, c5, M) {
    const l6 = this.array;
    let m2 = t3.i1616to32(o6, r6);
    l6.push(m2), m2 = t3.i1616to32(Math.round(8 * u4), Math.round(8 * h5)), l6.push(m2), m2 = t3.i8888to32(a7 / 4, n4 / 4, e6, p4), l6.push(m2), m2 = t3.i8888to32(0, f(d3), 10 * i5, Math.min(10 * c5, 255)), l6.push(m2), M && l6.push(...M);
  }
};
var a6 = class extends t3 {
  constructor(t5) {
    super(t5);
  }
  add(t5, o6, r6, u4, h5) {
    const a7 = this.array, n4 = t3.i1616to32(2 * t5 + r6, 2 * o6 + u4);
    a7.push(n4), h5 && a7.push(...h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/BaseBucket.js
var t4 = class {
  constructor(t5, e6, s6) {
    this.layerExtent = 4096, this._features = [], this.layer = t5, this.zoom = e6, this._spriteInfo = s6, this._filter = t5.getFeatureFilter();
  }
  pushFeature(t5) {
    this._filter && !this._filter.filter(t5, this.zoom) || this._features.push(t5);
  }
  hasFeatures() {
    return this._features.length > 0;
  }
  getResources(t5, e6, s6) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/CircleBucket.js
var r4 = class extends t4 {
  constructor(t5, r6, i5, c5, s6) {
    super(t5, r6, i5), this.type = E.CIRCLE, this._circleVertexBuffer = c5, this._circleIndexBuffer = s6;
  }
  get circleIndexStart() {
    return this._circleIndexStart;
  }
  get circleIndexCount() {
    return this._circleIndexCount;
  }
  processFeatures(e6) {
    const t5 = this._circleVertexBuffer, r6 = this._circleIndexBuffer;
    this._circleIndexStart = 3 * r6.index, this._circleIndexCount = 0;
    const i5 = this.layer, c5 = this.zoom;
    e6 && e6.setExtent(this.layerExtent);
    for (const s6 of this._features) {
      const n4 = s6.getGeometry(e6);
      if (!n4) continue;
      const l6 = i5.circleMaterial.encodeAttributes(s6, c5, i5);
      for (const e7 of n4) if (e7) for (const i6 of e7) {
        const e8 = t5.index;
        t5.add(i6.x, i6.y, 0, 0, l6), t5.add(i6.x, i6.y, 0, 1, l6), t5.add(i6.x, i6.y, 1, 0, l6), t5.add(i6.x, i6.y, 1, 1, l6), r6.add(e8, e8 + 1, e8 + 2), r6.add(e8 + 1, e8 + 2, e8 + 3), this._circleIndexCount += 6;
      }
    }
  }
  serialize() {
    let e6 = 6;
    e6 += this.layerUIDs.length, e6 += this._circleVertexBuffer.array.length, e6 += this._circleIndexBuffer.array.length;
    const t5 = new Uint32Array(e6), r6 = new Int32Array(t5.buffer);
    let i5 = 0;
    t5[i5++] = this.type, t5[i5++] = this.layerUIDs.length;
    for (let c5 = 0; c5 < this.layerUIDs.length; c5++) t5[i5++] = this.layerUIDs[c5];
    t5[i5++] = this._circleIndexStart, t5[i5++] = this._circleIndexCount, t5[i5++] = this._circleVertexBuffer.array.length;
    for (let c5 = 0; c5 < this._circleVertexBuffer.array.length; c5++) r6[i5++] = this._circleVertexBuffer.array[c5];
    t5[i5++] = this._circleIndexBuffer.array.length;
    for (let c5 = 0; c5 < this._circleIndexBuffer.array.length; c5++) t5[i5++] = this._circleIndexBuffer.array[c5];
    return t5.buffer;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/FillBucket.js
var s4 = class _s extends t4 {
  constructor(t5, e6, i5, r6, n4, s6, o6) {
    super(t5, e6, i5), this.type = E.FILL, this._patternMap = /* @__PURE__ */ new Map(), this._fillVertexBuffer = r6, this._fillIndexBuffer = n4, this._outlineVertexBuffer = s6, this._outlineIndexBuffer = o6;
  }
  get fillIndexStart() {
    return this._fillIndexStart;
  }
  get fillIndexCount() {
    return this._fillIndexCount;
  }
  get outlineIndexStart() {
    return this._outlineIndexStart;
  }
  get outlineIndexCount() {
    return this._outlineIndexCount;
  }
  getResources(t5, e6, i5) {
    const r6 = this.layer, l6 = this.zoom, n4 = r6.getPaintProperty("fill-pattern");
    if (n4) if (n4.isDataDriven) for (const s6 of this._features) e6(n4.getValue(l6, s6), true);
    else e6(n4.getValue(l6), true);
  }
  processFeatures(t5) {
    this._fillIndexStart = 3 * this._fillIndexBuffer.index, this._fillIndexCount = 0, this._outlineIndexStart = 3 * this._outlineIndexBuffer.index, this._outlineIndexCount = 0;
    const e6 = this.layer, i5 = this.zoom, { fillMaterial: r6, outlineMaterial: l6, hasDataDrivenFill: n4, hasDataDrivenOutline: s6 } = e6;
    t5 && t5.setExtent(this.layerExtent);
    const o6 = e6.getPaintProperty("fill-pattern"), a7 = o6 == null ? void 0 : o6.isDataDriven;
    let f3 = !o6 && e6.getPaintValue("fill-antialias", i5);
    if (e6.outlineUsesFillColor) {
      if (f3 && !e6.hasDataDrivenOpacity) {
        const t6 = e6.getPaintValue("fill-opacity", i5), r7 = e6.getPaintValue("fill-opacity", i5 + 1);
        t6 < 1 && r7 < 1 && (f3 = false);
      }
      if (f3 && !e6.hasDataDrivenColor) {
        const t6 = e6.getPaintValue("fill-color", i5), r7 = e6.getPaintValue("fill-color", i5 + 1);
        t6[3] < 1 && r7[3] < 1 && (f3 = false);
      }
    }
    const u4 = this._features, d3 = t5 == null ? void 0 : t5.validateTessellation;
    if (a7) {
      const n5 = [];
      for (const a8 of u4) {
        const u5 = o6.getValue(i5, a8), h5 = this._spriteInfo[u5];
        if (!(h5 == null ? void 0 : h5.rect)) continue;
        const x2 = r6.encodeAttributes(a8, i5, e6, h5), c5 = f3 && s6 ? l6.encodeAttributes(a8, i5, e6) : [], _2 = a8.getGeometry(t5);
        n5.push({ ddFillAttributes: x2, ddOutlineAttributes: c5, page: h5.page, geometry: _2 }), n5.sort((t6, e7) => t6.page - e7.page);
        for (const { ddFillAttributes: t6, ddOutlineAttributes: i6, page: r7, geometry: l7 } of n5) this._processFeature(l7, f3, e6.outlineUsesFillColor, t6, i6, d3, r7);
      }
    } else for (const h5 of u4) {
      const o7 = n4 ? r6.encodeAttributes(h5, i5, e6) : null, a8 = f3 && s6 ? l6.encodeAttributes(h5, i5, e6) : null, u5 = h5.getGeometry(t5);
      this._processFeature(u5, f3, e6.outlineUsesFillColor, o7, a8, d3);
    }
  }
  serialize() {
    let t5 = 10;
    t5 += this.layerUIDs.length, t5 += this._fillVertexBuffer.array.length, t5 += this._fillIndexBuffer.array.length, t5 += this._outlineVertexBuffer.array.length, t5 += this._outlineIndexBuffer.array.length, t5 += 3 * this._patternMap.size + 1;
    const e6 = new Uint32Array(t5), i5 = new Int32Array(e6.buffer);
    let r6 = 0;
    e6[r6++] = this.type, e6[r6++] = this.layerUIDs.length;
    for (let s6 = 0; s6 < this.layerUIDs.length; s6++) e6[r6++] = this.layerUIDs[s6];
    e6[r6++] = this._fillIndexStart, e6[r6++] = this._fillIndexCount, e6[r6++] = this._outlineIndexStart, e6[r6++] = this._outlineIndexCount;
    const l6 = this._patternMap, n4 = l6.size;
    if (e6[r6++] = n4, n4 > 0) for (const [s6, [o6, a7]] of l6) e6[r6++] = s6, e6[r6++] = o6, e6[r6++] = a7;
    e6[r6++] = this._fillVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillVertexBuffer.array.length; s6++) i5[r6++] = this._fillVertexBuffer.array[s6];
    e6[r6++] = this._fillIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillIndexBuffer.array.length; s6++) e6[r6++] = this._fillIndexBuffer.array[s6];
    e6[r6++] = this._outlineVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineVertexBuffer.array.length; s6++) i5[r6++] = this._outlineVertexBuffer.array[s6];
    e6[r6++] = this._outlineIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineIndexBuffer.array.length; s6++) e6[r6++] = this._outlineIndexBuffer.array[s6];
    return e6.buffer;
  }
  _processFeature(t5, e6, i5, r6, l6, n4, o6) {
    if (!t5) return;
    const a7 = t5.length, f3 = !l6 || 0 === l6.length;
    if (e6 && (!i5 || f3)) for (let s6 = 0; s6 < a7; s6++) this._processOutline(t5[s6], l6);
    const u4 = 32;
    let d3;
    for (let h5 = 0; h5 < a7; h5++) {
      const e7 = _s._area(t5[h5]);
      e7 > u4 ? (void 0 !== d3 && this._processFill(t5, d3, r6, n4, o6), d3 = [h5]) : e7 < -32 && void 0 !== d3 && d3.push(h5);
    }
    void 0 !== d3 && this._processFill(t5, d3, r6, n4, o6);
  }
  _processOutline(t5, e6) {
    const i5 = this._outlineVertexBuffer, l6 = this._outlineIndexBuffer, n4 = l6.index;
    let s6, o6, a7;
    const f3 = new h(0, 0), u4 = new h(0, 0), d3 = new h(0, 0);
    let h5 = -1, x2 = -1, c5 = -1, _2 = -1, y2 = -1, g2 = false;
    const p4 = 0;
    let I4 = t5.length;
    if (I4 < 2) return;
    const B = t5[p4];
    let m2 = t5[I4 - 1];
    for (; I4 && m2.isEqual(B); ) --I4, m2 = t5[I4 - 1];
    if (!(I4 - p4 < 2)) {
      for (let r6 = p4; r6 < I4; ++r6) {
        r6 === p4 ? (s6 = t5[I4 - 1], o6 = t5[p4], a7 = t5[p4 + 1], f3.assignSub(o6, s6), f3.normalize(), f3.rightPerpendicular()) : (s6 = o6, o6 = a7, a7 = r6 !== I4 - 1 ? t5[r6 + 1] : t5[p4], f3.assign(u4));
        const n5 = this._isClipEdge(s6, o6);
        -1 === _2 && (g2 = n5), u4.assignSub(a7, o6), u4.normalize(), u4.rightPerpendicular();
        const B2 = f3.x * u4.y - f3.y * u4.x;
        d3.assignAdd(f3, u4), d3.normalize();
        const m3 = -d3.x * -f3.x + -d3.y * -f3.y;
        let V = Math.abs(0 !== m3 ? 1 / m3 : 1);
        V > 8 && (V = 8), B2 >= 0 ? (c5 = i5.add(o6.x, o6.y, f3.x, f3.y, 0, 1, e6), -1 === _2 && (_2 = c5), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), x2 = i5.add(o6.x, o6.y, V * -d3.x, V * -d3.y, 0, -1, e6), -1 === y2 && (y2 = x2), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), h5 = x2, x2 = c5, c5 = i5.add(o6.x, o6.y, d3.x, d3.y, 0, 1, e6), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), x2 = i5.add(o6.x, o6.y, u4.x, u4.y, 0, 1, e6), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5)) : (c5 = i5.add(o6.x, o6.y, V * d3.x, V * d3.y, 0, 1, e6), -1 === _2 && (_2 = c5), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), x2 = i5.add(o6.x, o6.y, -f3.x, -f3.y, 0, -1, e6), -1 === y2 && (y2 = x2), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), h5 = x2, x2 = c5, c5 = i5.add(o6.x, o6.y, -d3.x, -d3.y, 0, -1, e6), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5), h5 = i5.add(o6.x, o6.y, -u4.x, -u4.y, 0, -1, e6), h5 >= 0 && x2 >= 0 && c5 >= 0 && !n5 && l6.add(h5, x2, c5));
      }
      h5 >= 0 && x2 >= 0 && _2 >= 0 && !g2 && l6.add(h5, x2, _2), h5 >= 0 && _2 >= 0 && y2 >= 0 && !g2 && l6.add(h5, y2, _2), this._outlineIndexCount += 3 * (l6.index - n4);
    }
  }
  _processFill(r6, l6, n4, s6, o6) {
    s6 = true;
    let a7;
    l6.length > 1 && (a7 = []);
    let f3 = 0;
    for (const t5 of l6) 0 !== f3 && a7.push(f3), f3 += r6[t5].length;
    const u4 = 2 * f3, d3 = t.acquire();
    for (const t5 of l6) {
      const e6 = r6[t5], i5 = e6.length;
      for (let t6 = 0; t6 < i5; ++t6) d3.push(e6[t6].x, e6[t6].y);
    }
    const h5 = e3(d3, a7, 2);
    if (s6 && e3.deviation(d3, a7, 2, h5) > 0) {
      const t5 = l6.map((t6) => r6[t6].length), { buffer: e6, vertexCount: s7 } = a3(d3, t5);
      if (s7 > 0) {
        const t6 = this._fillVertexBuffer.index;
        for (let i5 = 0; i5 < s7; i5++) this._fillVertexBuffer.add(e6[2 * i5], e6[2 * i5 + 1], n4);
        for (let e7 = 0; e7 < s7; e7 += 3) {
          const i5 = t6 + e7;
          this._fillIndexBuffer.add(i5, i5 + 1, i5 + 2);
        }
        if (void 0 !== o6) {
          const t7 = this._patternMap, e7 = t7.get(o6);
          e7 ? e7[1] += s7 : t7.set(o6, [this._fillIndexStart + this._fillIndexCount, s7]);
        }
        this._fillIndexCount += s7;
      }
    } else {
      const t5 = h5.length;
      if (t5 > 0) {
        const e6 = this._fillVertexBuffer.index;
        let i5 = 0;
        for (; i5 < u4; ) this._fillVertexBuffer.add(d3[i5++], d3[i5++], n4);
        let r7 = 0;
        for (; r7 < t5; ) this._fillIndexBuffer.add(e6 + h5[r7++], e6 + h5[r7++], e6 + h5[r7++]);
        if (void 0 !== o6) {
          const e7 = this._patternMap, i6 = e7.get(o6);
          i6 ? i6[1] += t5 : e7.set(o6, [this._fillIndexStart + this._fillIndexCount, t5]);
        }
        this._fillIndexCount += t5;
      }
    }
    t.release(d3);
  }
  _isClipEdge(t5, e6) {
    return t5.x === e6.x ? t5.x <= -64 || t5.x >= 4160 : t5.y === e6.y && (t5.y <= -64 || t5.y >= 4160);
  }
  static _area(t5) {
    let e6 = 0;
    const i5 = t5.length - 1;
    for (let r6 = 0; r6 < i5; r6++) e6 += (t5[r6].x - t5[r6 + 1].x) * (t5[r6].y + t5[r6 + 1].y);
    return e6 += (t5[i5].x - t5[0].x) * (t5[i5].y + t5[0].y), 0.5 * e6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/LineBucket.js
var s5 = 65535;
var n3 = class extends t4 {
  constructor(t5, s6, n4, a7, o6) {
    super(t5, s6, n4), this.type = E.LINE, this._tessellationOptions = { pixelCoordRatio: 8, halfWidth: 0, offset: 0 }, this._patternMap = /* @__PURE__ */ new Map(), this.tessellationProperties = { _lineVertexBuffer: null, _lineIndexBuffer: null, _ddValues: null }, this.tessellationProperties._lineVertexBuffer = a7, this.tessellationProperties._lineIndexBuffer = o6, this._lineTessellator = new c2(r5(this.tessellationProperties), l5(this.tessellationProperties), t5.canUseThinTessellation);
  }
  get lineIndexStart() {
    return this._lineIndexStart;
  }
  get lineIndexCount() {
    return this._lineIndexCount;
  }
  getResources(e6, t5, i5) {
    const s6 = this.layer, n4 = this.zoom, r6 = s6.getPaintProperty("line-pattern"), l6 = s6.getPaintProperty("line-dasharray"), a7 = s6.getLayoutProperty("line-cap");
    if (!r6 && !l6) return;
    const o6 = (a7 == null ? void 0 : a7.getValue(n4)) || 0, u4 = a7 == null ? void 0 : a7.isDataDriven, f3 = r6 == null ? void 0 : r6.isDataDriven, h5 = l6 == null ? void 0 : l6.isDataDriven;
    if (f3 || h5) for (const p4 of this._features) t5(f3 ? r6.getValue(n4, p4) : this._getDashArrayKey(p4, n4, s6, l6, u4, a7, o6));
    else if (r6) t5(r6.getValue(n4));
    else if (l6) {
      const e7 = l6.getValue(n4);
      t5(s6.getDashKey(e7, o6));
    }
  }
  processFeatures(e6) {
    this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index, this._lineIndexCount = 0;
    const t5 = this.layer, i5 = this.zoom, s6 = this._features, n4 = this._tessellationOptions, { hasDataDrivenLine: r6, lineMaterial: l6 } = t5;
    e6 && e6.setExtent(this.layerExtent);
    const a7 = t5.getPaintProperty("line-pattern"), o6 = t5.getPaintProperty("line-dasharray"), u4 = a7 == null ? void 0 : a7.isDataDriven, f3 = o6 == null ? void 0 : o6.isDataDriven;
    let h5;
    h5 = t5.getLayoutProperty("line-cap");
    const p4 = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, g2 = p4 ? null : t5.getLayoutValue("line-cap", i5), y2 = g2 || 0, d3 = !!p4;
    h5 = t5.getLayoutProperty("line-join");
    const c5 = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, _2 = c5 ? null : t5.getLayoutValue("line-join", i5);
    h5 = t5.getLayoutProperty("line-miter-limit");
    const x2 = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, V = x2 ? null : t5.getLayoutValue("line-miter-limit", i5);
    h5 = t5.getLayoutProperty("line-round-limit");
    const m2 = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, D = m2 ? null : t5.getLayoutValue("line-round-limit", i5);
    h5 = t5.getPaintProperty("line-width");
    const P = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, I4 = P ? null : t5.getPaintValue("line-width", i5);
    h5 = t5.getPaintProperty("line-offset");
    const L2 = (h5 == null ? void 0 : h5.isDataDriven) ? h5 : null, B = L2 ? null : t5.getPaintValue("line-offset", i5);
    if (u4 || f3) {
      const r7 = [];
      for (const n5 of s6) {
        const s7 = u4 ? a7.getValue(i5, n5) : this._getDashArrayKey(n5, i5, t5, o6, d3, p4, y2), f4 = this._spriteInfo[s7];
        if (!(f4 == null ? void 0 : f4.rect)) continue;
        const h6 = l6.encodeAttributes(n5, i5, t5, f4), v = n5.getGeometry(e6);
        r7.push({ ddAttributes: h6, page: f4.page, cap: p4 ? p4.getValue(i5, n5) : g2, join: c5 ? c5.getValue(i5, n5) : _2, miterLimit: x2 ? x2.getValue(i5, n5) : V, roundLimit: m2 ? m2.getValue(i5, n5) : D, halfWidth: 0.5 * (P ? P.getValue(i5, n5) : I4), offset: L2 ? L2.getValue(i5, n5) : B, geometry: v });
      }
      r7.sort((e7, t6) => e7.page - t6.page), n4.textured = true;
      for (const { ddAttributes: e7, page: t6, cap: i6, join: s7, miterLimit: l7, roundLimit: a8, halfWidth: o7, offset: u5, geometry: f4 } of r7) n4.capType = i6, n4.joinType = s7, n4.miterLimit = l7, n4.roundLimit = a8, n4.halfWidth = o7, n4.offset = u5, this._processFeature(f4, e7, t6);
    } else {
      if (a7) {
        const e7 = a7.getValue(i5), t6 = this._spriteInfo[e7];
        if (!(t6 == null ? void 0 : t6.rect)) return;
      }
      n4.textured = !(!a7 && !o6), n4.capType = g2, n4.joinType = _2, n4.miterLimit = V, n4.roundLimit = D, n4.halfWidth = 0.5 * I4, n4.offset = B;
      for (const a8 of s6) {
        const s7 = r6 ? l6.encodeAttributes(a8, i5, t5) : null;
        p4 && (n4.capType = p4.getValue(i5, a8)), c5 && (n4.joinType = c5.getValue(i5, a8)), x2 && (n4.miterLimit = x2.getValue(i5, a8)), m2 && (n4.roundLimit = m2.getValue(i5, a8)), P && (n4.halfWidth = 0.5 * P.getValue(i5, a8)), L2 && (n4.offset = L2.getValue(i5, a8));
        const o7 = a8.getGeometry(e6);
        this._processFeature(o7, s7);
      }
    }
  }
  serialize() {
    let e6 = 6;
    e6 += this.layerUIDs.length, e6 += this.tessellationProperties._lineVertexBuffer.array.length, e6 += this.tessellationProperties._lineIndexBuffer.array.length, e6 += 3 * this._patternMap.size + 1;
    const t5 = new Uint32Array(e6), i5 = new Int32Array(t5.buffer);
    let s6 = 0;
    t5[s6++] = this.type, t5[s6++] = this.layerUIDs.length;
    for (let l6 = 0; l6 < this.layerUIDs.length; l6++) t5[s6++] = this.layerUIDs[l6];
    t5[s6++] = this._lineIndexStart, t5[s6++] = this._lineIndexCount;
    const n4 = this._patternMap, r6 = n4.size;
    if (t5[s6++] = r6, r6 > 0) for (const [l6, [a7, o6]] of n4) t5[s6++] = l6, t5[s6++] = a7, t5[s6++] = o6;
    t5[s6++] = this.tessellationProperties._lineVertexBuffer.array.length;
    for (let l6 = 0; l6 < this.tessellationProperties._lineVertexBuffer.array.length; l6++) i5[s6++] = this.tessellationProperties._lineVertexBuffer.array[l6];
    t5[s6++] = this.tessellationProperties._lineIndexBuffer.array.length;
    for (let l6 = 0; l6 < this.tessellationProperties._lineIndexBuffer.array.length; l6++) t5[s6++] = this.tessellationProperties._lineIndexBuffer.array[l6];
    return t5.buffer;
  }
  _processFeature(e6, t5, i5) {
    if (!e6) return;
    const s6 = e6.length;
    for (let n4 = 0; n4 < s6; n4++) this._processGeometry(e6[n4], t5, i5);
  }
  _processGeometry(e6, t5, i5) {
    if (e6.length < 2) return;
    const n4 = 1e-3;
    let r6, l6, a7 = e6[0], o6 = 1;
    for (; o6 < e6.length; ) r6 = e6[o6].x - a7.x, l6 = e6[o6].y - a7.y, r6 * r6 + l6 * l6 < n4 * n4 ? e6.splice(o6, 1) : (a7 = e6[o6], ++o6);
    if (e6.length < 2) return;
    const u4 = this.tessellationProperties._lineIndexBuffer, f3 = 3 * u4.index;
    this._tessellationOptions.initialDistance = 0, this._tessellationOptions.wrapDistance = s5, this.tessellationProperties._ddValues = t5, this._lineTessellator.tessellate(e6, this._tessellationOptions);
    const h5 = 3 * u4.index - f3;
    if (void 0 !== i5) {
      const e7 = this._patternMap, t6 = e7.get(i5);
      t6 ? t6[1] += h5 : e7.set(i5, [f3 + this._lineIndexCount, h5]);
    }
    this._lineIndexCount += h5;
  }
  _getDashArrayKey(e6, t5, i5, s6, n4, r6, l6) {
    const a7 = n4 ? r6.getValue(t5, e6) : l6, o6 = s6.getValue(t5, e6);
    return i5.getDashKey(o6, a7);
  }
};
var r5 = (e6) => (t5, i5, s6, n4, r6, l6, a7, o6, u4, f3, h5) => (e6._lineVertexBuffer.add(t5, i5, a7, o6, s6, n4, r6, l6, u4, f3, h5, e6._ddValues), e6._lineVertexBuffer.index - 1);
var l5 = (e6) => (t5, i5, s6) => {
  e6._lineIndexBuffer.add(t5, i5, s6);
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/SymbolBucket.js
var b2 = 10;
function A(e6, t5) {
  return e6.iconMosaicItem && t5.iconMosaicItem ? e6.iconMosaicItem.page === t5.iconMosaicItem.page ? 0 : e6.iconMosaicItem.page - t5.iconMosaicItem.page : e6.iconMosaicItem && !t5.iconMosaicItem ? 1 : !e6.iconMosaicItem && t5.iconMosaicItem ? -1 : 0;
}
var L = class _L extends t4 {
  constructor(e6, t5, n4, i5, s6, o6, r6, l6, h5) {
    super(t5, n4, h5.getSpriteItems()), this.type = E.SYMBOL, this._markerMap = /* @__PURE__ */ new Map(), this._glyphMap = /* @__PURE__ */ new Map(), this._glyphBufferDataStorage = /* @__PURE__ */ new Map(), this._isIconSDF = false, this._sourceTileKey = e6, this._iconVertexBuffer = i5, this._iconIndexBuffer = s6, this._textVertexBuffer = o6, this._textIndexBuffer = r6, this._placementEngine = l6, this._workerTileHandler = h5;
  }
  get markerPageMap() {
    return this._markerMap;
  }
  get glyphsPageMap() {
    return this._glyphMap;
  }
  get symbolInstances() {
    return this._symbolInstances;
  }
  getResources(e6, t5, i5) {
    const s6 = this.layer, a7 = this.zoom;
    e6 && e6.setExtent(this.layerExtent);
    const o6 = s6.getLayoutProperty("icon-image"), r6 = s6.getLayoutProperty("text-field");
    let l6 = s6.getLayoutProperty("text-transform"), h5 = s6.getLayoutProperty("text-font");
    const x2 = [];
    let c5, d3, f3, g2;
    o6 && !o6.isDataDriven && (c5 = o6.getValue(a7)), r6 && !r6.isDataDriven && (d3 = r6.getValue(a7)), l6 && l6.isDataDriven || (f3 = s6.getLayoutValue("text-transform", a7), l6 = null), h5 && h5.isDataDriven || (g2 = s6.getLayoutValue("text-font", a7), h5 = null);
    for (const m2 of this._features) {
      const u4 = m2.getGeometry(e6);
      if (!u4 || 0 === u4.length) continue;
      let p4, _2;
      o6 && (p4 = o6.isDataDriven ? o6.getValue(a7, m2) : this._replaceKeys(c5, m2.values), p4 && t5(p4));
      let M = false;
      if (r6 && (_2 = r6.isDataDriven ? r6.getValue(a7, m2) : this._replaceKeys(d3, m2.values), _2)) {
        switch (_2 = _2.replaceAll("\\n", "\n"), l6 && (f3 = l6.getValue(a7, m2)), f3) {
          case o3.LOWERCASE:
            _2 = _2.toLowerCase();
            break;
          case o3.UPPERCASE:
            _2 = _2.toUpperCase();
        }
        if (_L._bidiEngine.hasBidiChar(_2)) {
          let e7;
          e7 = "rtl" === _L._bidiEngine.checkContextual(_2) ? "IDNNN" : "ICNNN", _2 = _L._bidiEngine.bidiTransform(_2, e7, "VLYSN"), M = true;
        }
        if (_2.length > 0) {
          h5 && (g2 = h5.getValue(a7, m2));
          for (const e7 of g2) {
            let t6 = i5[e7];
            t6 || (t6 = i5[e7] = /* @__PURE__ */ new Set());
            for (const e8 of _2) {
              const n4 = e8.codePointAt(0);
              null != n4 && t6.add(n4);
            }
          }
        }
      }
      if (!p4 && !_2) continue;
      const P = s6.getLayoutValue("symbol-sort-key", a7, m2), I4 = { feature: m2, sprite: p4, label: _2, rtl: M, geometry: u4, hash: (_2 ? l(_2) : 0) ^ (p4 ? l(p4) : 0), priority: P, textFont: g2 };
      x2.push(I4);
    }
    this._symbolFeatures = x2;
  }
  processFeatures(e6) {
    e6 && e6.setExtent(this.layerExtent);
    const n4 = this.layer, s6 = this.zoom, a7 = n4.getLayoutValue("symbol-placement", s6), r6 = a7 !== n2.POINT, l6 = n4.getLayoutValue("symbol-spacing", s6) * d2, g2 = n4.getLayoutProperty("icon-image"), y2 = n4.getLayoutProperty("text-field"), b3 = g2 ? new U(n4, s6, r6) : null, T2 = y2 ? new O(n4, s6, r6) : null, V = this._workerTileHandler;
    let w2;
    g2 && (w2 = V.getSpriteItems()), this._iconIndexStart = 3 * this._iconIndexBuffer.index, this._textIndexStart = 3 * this._textIndexBuffer.index, this._iconIndexCount = 0, this._textIndexCount = 0, this._markerMap.clear(), this._glyphMap.clear();
    const B = [];
    let C2 = 1;
    (T2 == null ? void 0 : T2.size) && (C2 = T2.size / c4);
    const R = T2 ? T2.maxAngle * s : 0, D = T2 ? T2.size * d2 : 0;
    for (const o6 of this._symbolFeatures) {
      let e7;
      b3 && w2 && o6.sprite && (e7 = w2[o6.sprite], e7 && e7.sdf && (this._isIconSDF = true));
      let n5;
      !!e7 && b3.update(s6, o6.feature);
      let g3 = 0;
      const y3 = o6.label;
      if (y3) {
        n(T2), T2.update(s6, o6.feature);
        const e8 = r6 && T2.rotationAlignment === l2.MAP ? T2.keepUpright : T2.writingMode && T2.writingMode.includes(p2.VERTICAL);
        let i5 = 0.5;
        switch (T2.anchor) {
          case m.TOP_LEFT:
          case m.LEFT:
          case m.BOTTOM_LEFT:
            i5 = 0;
            break;
          case m.TOP_RIGHT:
          case m.RIGHT:
          case m.BOTTOM_RIGHT:
            i5 = 1;
        }
        let a8 = 0.5;
        switch (T2.anchor) {
          case m.TOP_LEFT:
          case m.TOP:
          case m.TOP_RIGHT:
            a8 = 0;
            break;
          case m.BOTTOM_LEFT:
          case m.BOTTOM:
          case m.BOTTOM_RIGHT:
            a8 = 1;
        }
        let l7 = 0.5;
        switch (T2.justify) {
          case u.AUTO:
            l7 = i5;
            break;
          case u.LEFT:
            l7 = 0;
            break;
          case u.RIGHT:
            l7 = 1;
        }
        const x2 = T2.letterSpacing * c4, c5 = r6 ? 0 : T2.maxWidth * c4, m2 = T2.lineHeight * c4, P = o6.textFont.map((e9) => V.getGlyphItems(e9));
        if (n5 = new l4(P, c5, m2, x2, i5, a8, l7).getShaping(y3, o6.rtl, e8), n5 && n5.length > 0) {
          let e9 = 1e30, t5 = -1e30;
          for (const i6 of n5) e9 = Math.min(e9, i6.x), t5 = Math.max(t5, i6.x);
          g3 = (t5 - e9 + 2 * c4) * C2 * d2;
        }
      }
      for (let t5 of o6.geometry) {
        const s7 = [];
        if (a7 === n2.LINE) {
          if ((n5 == null ? void 0 : n5.length) && (T2 == null ? void 0 : T2.size)) {
            const e8 = T2.size * d2 * (2 + Math.min(2, 4 * Math.abs(T2.offset[1])));
            t5 = _L._smoothVertices(t5, e8);
          }
          _L._pushAnchors(s7, t5, l6, g3);
        } else a7 === n2.LINE_CENTER ? _L._pushCenterAnchor(s7, t5) : o6.feature.type === i.Polygon ? _L._pushCentroid(s7, t5) : s7.push(new T(t5[0].x, t5[0].y));
        for (const i5 of s7) {
          if (i5.x < 0 || i5.x > x || i5.y < 0 || i5.y > x) continue;
          if (r6 && g3 > 0 && (T2 == null ? void 0 : T2.rotationAlignment) === l2.MAP && !_L._honorsTextMaxAngle(t5, i5, g3, R, D)) continue;
          const s8 = { shaping: n5, line: t5, iconMosaicItem: e7, anchor: i5, symbolFeature: o6, textColliders: [], iconColliders: [], textVertexRanges: [], iconVertexRanges: [] };
          B.push(s8), this._processFeature(s8, b3, T2);
        }
      }
    }
    B.sort(A), this._addPlacedGlyphs(), this._symbolInstances = B;
  }
  serialize() {
    let e6 = 14;
    e6 += this.layerUIDs.length, e6 += 3 * this.markerPageMap.size, e6 += 3 * this.glyphsPageMap.size, e6 += _L._symbolsSerializationLength(this._symbolInstances), e6 += this._iconVertexBuffer.array.length, e6 += this._iconIndexBuffer.array.length, e6 += this._textVertexBuffer.array.length, e6 += this._textIndexBuffer.array.length;
    const t5 = new Uint32Array(e6), n4 = new Int32Array(t5.buffer), i5 = new Float32Array(t5.buffer), [s6, a7, o6] = this._sourceTileKey.split("/");
    let r6 = 0;
    t5[r6++] = this.type, t5[r6++] = this.layerUIDs.length;
    for (let l6 = 0; l6 < this.layerUIDs.length; l6++) t5[r6++] = this.layerUIDs[l6];
    t5[r6++] = this._isIconSDF ? 1 : 0, t5[r6++] = parseFloat(s6), t5[r6++] = parseFloat(a7), t5[r6++] = parseFloat(o6), t5[r6++] = this.markerPageMap.size;
    for (const [l6, [h5, x2]] of this.markerPageMap) t5[r6++] = l6, t5[r6++] = h5, t5[r6++] = x2;
    t5[r6++] = this.glyphsPageMap.size;
    for (const [l6, [h5, x2]] of this.glyphsPageMap) t5[r6++] = l6, t5[r6++] = h5, t5[r6++] = x2;
    t5[r6++] = this._iconVertexBuffer.index / 4, t5[r6++] = this._textVertexBuffer.index / 4, r6 = _L.serializeSymbols(t5, n4, i5, r6, this._symbolInstances), t5[r6++] = this._iconVertexBuffer.array.length;
    for (let l6 = 0; l6 < this._iconVertexBuffer.array.length; l6++) n4[r6++] = this._iconVertexBuffer.array[l6];
    t5[r6++] = this._iconIndexBuffer.array.length;
    for (let l6 = 0; l6 < this._iconIndexBuffer.array.length; l6++) t5[r6++] = this._iconIndexBuffer.array[l6];
    t5[r6++] = this._textVertexBuffer.array.length;
    for (let l6 = 0; l6 < this._textVertexBuffer.array.length; l6++) n4[r6++] = this._textVertexBuffer.array[l6];
    t5[r6++] = this._textIndexBuffer.array.length;
    for (let l6 = 0; l6 < this._textIndexBuffer.array.length; l6++) t5[r6++] = this._textIndexBuffer.array[l6];
    return t5.buffer;
  }
  static _symbolsSerializationLength(e6) {
    let t5 = 0;
    t5 += 1;
    for (const n4 of e6 || []) {
      t5 += 5, t5 += 1;
      for (const e7 of n4.textColliders) t5 += b2;
      for (const e7 of n4.iconColliders) t5 += b2;
      t5 += 1, t5 += 2 * n4.textVertexRanges.length, t5 += 1, t5 += 2 * n4.iconVertexRanges.length;
    }
    return t5;
  }
  static serializeSymbols(e6, t5, n4, i5, s6) {
    s6 = s6 || [], t5[i5++] = s6.length;
    for (const a7 of s6) {
      t5[i5++] = a7.anchor.x, t5[i5++] = a7.anchor.y, t5[i5++] = a7.symbolFeature.hash, t5[i5++] = a7.symbolFeature.priority, t5[i5++] = a7.symbolFeature.feature.featureIndex, t5[i5++] = a7.textColliders.length + a7.iconColliders.length;
      for (const e7 of a7.textColliders) t5[i5++] = e7.xTile, t5[i5++] = e7.yTile, t5[i5++] = e7.dxPixels, t5[i5++] = e7.dyPixels, t5[i5++] = e7.hard ? 1 : 0, t5[i5++] = e7.partIndex, n4[i5++] = e7.minLod, n4[i5++] = e7.maxLod, t5[i5++] = e7.width, t5[i5++] = e7.height;
      for (const e7 of a7.iconColliders) t5[i5++] = e7.xTile, t5[i5++] = e7.yTile, t5[i5++] = e7.dxPixels, t5[i5++] = e7.dyPixels, t5[i5++] = e7.hard ? 1 : 0, t5[i5++] = e7.partIndex, n4[i5++] = e7.minLod, n4[i5++] = e7.maxLod, t5[i5++] = e7.width, t5[i5++] = e7.height;
      t5[i5++] = a7.textVertexRanges.length;
      for (const [e7, n5] of a7.textVertexRanges) t5[i5++] = e7, t5[i5++] = n5;
      t5[i5++] = a7.iconVertexRanges.length;
      for (const [e7, n5] of a7.iconVertexRanges) t5[i5++] = e7, t5[i5++] = n5;
    }
    return i5;
  }
  _replaceKeys(e6, t5) {
    return e6.replaceAll(/{([^{}]+)}/g, (e7, n4) => n4 in t5 ? t5[n4] : "");
  }
  _processFeature(e6, t5, n4) {
    const { line: i5, iconMosaicItem: s6, shaping: a7, anchor: o6 } = e6, l6 = this.zoom, h5 = this.layer, x2 = !!s6;
    let c5 = true;
    x2 && (c5 = (t5 == null ? void 0 : t5.optional) || !s6);
    const d3 = a7 && a7.length > 0, f3 = !d3 || (n4 == null ? void 0 : n4.optional);
    let g2, y2;
    if (x2 && (g2 = this._placementEngine.getIconPlacement(o6, s6, t5)), (g2 || c5) && (d3 && (y2 = this._placementEngine.getTextPlacement(o6, a7, i5, n4)), y2 || f3)) {
      if (g2 && y2 || (f3 || c5 ? f3 || y2 ? c5 || g2 || (y2 = null) : g2 = null : (g2 = null, y2 = null)), y2) {
        const t6 = h5.hasDataDrivenText ? h5.textMaterial.encodeAttributes(e6.symbolFeature.feature, l6, h5) : null;
        if (this._storePlacedGlyphs(e6, y2.shapes, l6, n4.rotationAlignment, t6), y2.textColliders) {
          e6.textColliders = y2.textColliders;
          for (const e7 of y2.textColliders) {
            e7.minLod = Math.max(l6 + h2(e7.minLod), 0), e7.maxLod = Math.min(l6 + h2(e7.maxLod), 25);
            const t7 = e7.angle;
            if (t7) {
              const n5 = Math.cos(t7), i6 = Math.sin(t7), s7 = e7.dxPixels * n5 - e7.dyPixels * i6, a8 = e7.dxPixels * i6 + e7.dyPixels * n5, o7 = (e7.dxPixels + e7.width) * n5 - e7.dyPixels * i6, r6 = (e7.dxPixels + e7.width) * i6 + e7.dyPixels * n5, l7 = e7.dxPixels * n5 - (e7.dyPixels + e7.height) * i6, h6 = e7.dxPixels * i6 + (e7.dyPixels + e7.height) * n5, x3 = (e7.dxPixels + e7.width) * n5 - (e7.dyPixels + e7.height) * i6, c6 = (e7.dxPixels + e7.width) * i6 + (e7.dyPixels + e7.height) * n5, d4 = Math.min(s7, o7, l7, x3), f4 = Math.max(s7, o7, l7, x3), g3 = Math.min(a8, r6, h6, c6), y3 = Math.max(a8, r6, h6, c6);
              e7.dxPixels = d4, e7.dyPixels = g3, e7.width = f4 - d4, e7.height = y3 - g3;
            }
          }
        }
      }
      if (g2) {
        const n5 = h5.hasDataDrivenIcon ? h5.iconMaterial.encodeAttributes(e6.symbolFeature.feature, l6, h5) : null;
        if (this._addPlacedIcons(e6, g2.shapes, l6, s6.page, t5.rotationAlignment === l2.VIEWPORT, n5), g2.iconColliders) {
          e6.iconColliders = g2.iconColliders;
          for (const e7 of g2.iconColliders) {
            e7.minLod = Math.max(l6 + h2(e7.minLod), 0), e7.maxLod = Math.min(l6 + h2(e7.maxLod), 25);
            const t6 = e7.angle;
            if (t6) {
              const n6 = Math.cos(t6), i6 = Math.sin(t6), s7 = e7.dxPixels * n6 - e7.dyPixels * i6, a8 = e7.dxPixels * i6 + e7.dyPixels * n6, o7 = (e7.dxPixels + e7.width) * n6 - e7.dyPixels * i6, r6 = (e7.dxPixels + e7.width) * i6 + e7.dyPixels * n6, l7 = e7.dxPixels * n6 - (e7.dyPixels + e7.height) * i6, h6 = e7.dxPixels * i6 + (e7.dyPixels + e7.height) * n6, x3 = (e7.dxPixels + e7.width) * n6 - (e7.dyPixels + e7.height) * i6, c6 = (e7.dxPixels + e7.width) * i6 + (e7.dyPixels + e7.height) * n6, d4 = Math.min(s7, o7, l7, x3), f4 = Math.max(s7, o7, l7, x3), g3 = Math.min(a8, r6, h6, c6), y3 = Math.max(a8, r6, h6, c6);
              e7.dxPixels = d4, e7.dyPixels = g3, e7.width = f4 - d4, e7.height = y3 - g3;
            }
          }
        }
      }
    }
  }
  _addPlacedIcons(e6, t5, n4, i5, s6, a7) {
    const o6 = Math.max(n4 - 1, 0), l6 = this._iconVertexBuffer, h5 = this._iconIndexBuffer, x2 = this._markerMap;
    for (const c5 of t5) {
      const t6 = s6 ? 0 : Math.max(n4 + h2(c5.minzoom), o6), d3 = s6 ? 25 : Math.min(n4 + h2(c5.maxzoom), 25);
      if (d3 <= t6) continue;
      const f3 = c5.tl, g2 = c5.tr, y2 = c5.bl, m2 = c5.br, u4 = c5.mosaicRect, p4 = c5.labelAngle, _2 = c5.minAngle, M = c5.maxAngle, P = c5.anchor, I4 = l6.index, b3 = u4.x, A2 = u4.y, L2 = b3 + u4.width, T2 = A2 + u4.height, V = l6.index;
      l6.add(P.x, P.y, f3.x, f3.y, b3, A2, p4, _2, M, t6, d3, a7), l6.add(P.x, P.y, g2.x, g2.y, L2, A2, p4, _2, M, t6, d3, a7), l6.add(P.x, P.y, y2.x, y2.y, b3, T2, p4, _2, M, t6, d3, a7), l6.add(P.x, P.y, m2.x, m2.y, L2, T2, p4, _2, M, t6, d3, a7), e6.iconVertexRanges.length > 0 && e6.iconVertexRanges[0][0] + e6.iconVertexRanges[0][1] === V ? e6.iconVertexRanges[0][1] += 4 : e6.iconVertexRanges.push([V, 4]), h5.add(I4, I4 + 1, I4 + 2), h5.add(I4 + 1, I4 + 2, I4 + 3), x2.has(i5) ? x2.get(i5)[1] += 6 : x2.set(i5, [this._iconIndexStart + this._iconIndexCount, 6]), this._iconIndexCount += 6;
    }
  }
  _addPlacedGlyphs() {
    const e6 = this._textVertexBuffer, t5 = this._textIndexBuffer, n4 = this._glyphMap;
    for (const [i5, s6] of this._glyphBufferDataStorage) for (const a7 of s6) {
      const s7 = e6.index, o6 = a7.symbolInstance, r6 = a7.ddAttributes, l6 = e6.index;
      e6.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.tl[0], a7.tl[1], a7.xmin, a7.ymin, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r6), e6.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.tr[0], a7.tr[1], a7.xmax, a7.ymin, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r6), e6.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.bl[0], a7.bl[1], a7.xmin, a7.ymax, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r6), e6.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.br[0], a7.br[1], a7.xmax, a7.ymax, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r6), o6.textVertexRanges.length > 0 && o6.textVertexRanges[0][0] + o6.textVertexRanges[0][1] === l6 ? o6.textVertexRanges[0][1] += 4 : o6.textVertexRanges.push([l6, 4]), t5.add(s7, s7 + 1, s7 + 2), t5.add(s7 + 1, s7 + 2, s7 + 3), n4.has(i5) ? n4.get(i5)[1] += 6 : n4.set(i5, [this._textIndexStart + this._textIndexCount, 6]), this._textIndexCount += 6;
    }
    this._glyphBufferDataStorage.clear();
  }
  _storePlacedGlyphs(e6, t5, n4, i5, s6) {
    const a7 = Math.max(n4 - 1, 0), o6 = i5 === l2.VIEWPORT;
    let l6, h5, x2, c5, d3, f3, g2, y2, m2, p4, _2;
    for (const u4 of t5) {
      if (l6 = o6 ? 0 : Math.max(n4 + h2(u4.minzoom), a7), h5 = o6 ? 25 : Math.min(n4 + h2(u4.maxzoom), 25), h5 <= l6) continue;
      x2 = u4.tl, c5 = u4.tr, d3 = u4.bl, f3 = u4.br, g2 = u4.labelAngle, y2 = u4.minAngle, m2 = u4.maxAngle, p4 = u4.anchor, _2 = u4.mosaicRect, this._glyphBufferDataStorage.has(u4.page) || this._glyphBufferDataStorage.set(u4.page, []);
      this._glyphBufferDataStorage.get(u4.page).push({ glyphAnchor: [p4.x, p4.y], tl: [x2.x, x2.y], tr: [c5.x, c5.y], bl: [d3.x, d3.y], br: [f3.x, f3.y], xmin: _2.x, ymin: _2.y, xmax: _2.x + _2.width, ymax: _2.y + _2.height, labelAngle: g2, minAngle: y2, maxAngle: m2, minLod: l6, maxLod: h5, placementLod: a7, symbolInstance: e6, ddAttributes: s6 });
    }
  }
  static _pushAnchors(e6, t5, n4, i5) {
    n4 += i5;
    let a7 = 0;
    const o6 = t5.length - 1;
    for (let l6 = 0; l6 < o6; l6++) a7 += h.distance(t5[l6], t5[l6 + 1]);
    let r6 = i5 || n4;
    if (r6 *= 0.5, a7 <= r6) return;
    const h5 = r6 / a7;
    let c5 = 0, d3 = -(n4 = a7 / Math.max(Math.round(a7 / n4), 1)) / 2;
    const f3 = t5.length - 1;
    for (let s6 = 0; s6 < f3; s6++) {
      const i6 = t5[s6], a8 = t5[s6 + 1], o7 = a8.x - i6.x, r7 = a8.y - i6.y, f4 = Math.sqrt(o7 * o7 + r7 * r7);
      let g2;
      for (; d3 + n4 < c5 + f4; ) {
        d3 += n4;
        const t6 = (d3 - c5) / f4, y2 = p(i6.x, a8.x, t6), m2 = p(i6.y, a8.y, t6);
        void 0 === g2 && (g2 = Math.atan2(r7, o7)), e6.push(new T(y2, m2, g2, s6, h5));
      }
      c5 += f4;
    }
  }
  static _pushCenterAnchor(e6, t5) {
    let n4 = 0;
    const i5 = t5.length - 1;
    for (let l6 = 0; l6 < i5; l6++) n4 += h.distance(t5[l6], t5[l6 + 1]);
    const a7 = n4 / 2;
    let o6 = 0;
    const r6 = t5.length - 1;
    for (let s6 = 0; s6 < r6; s6++) {
      const n5 = t5[s6], i6 = t5[s6 + 1], r7 = i6.x - n5.x, h5 = i6.y - n5.y, c5 = Math.sqrt(r7 * r7 + h5 * h5);
      if (a7 < o6 + c5) {
        const t6 = (a7 - o6) / c5, d3 = p(n5.x, i6.x, t6), f3 = p(n5.y, i6.y, t6), g2 = Math.atan2(h5, r7);
        return void e6.push(new T(d3, f3, g2, s6, 0));
      }
      o6 += c5;
    }
  }
  static _deviation(e6, t5, n4) {
    const i5 = (t5.x - e6.x) * (n4.x - t5.x) + (t5.y - e6.y) * (n4.y - t5.y), s6 = (t5.x - e6.x) * (n4.y - t5.y) - (t5.y - e6.y) * (n4.x - t5.x);
    return Math.atan2(s6, i5);
  }
  static _honorsTextMaxAngle(e6, t5, n4, i5, a7) {
    let o6 = 0;
    const r6 = n4 / 2;
    let l6 = new h(t5.x, t5.y), h5 = t5.segment + 1;
    for (; o6 > -r6; ) {
      if (--h5, h5 < 0) return false;
      o6 -= h.distance(e6[h5], l6), l6 = e6[h5];
    }
    o6 += h.distance(e6[h5], e6[h5 + 1]);
    const x2 = [];
    let c5 = 0;
    const d3 = e6.length;
    for (; o6 < r6; ) {
      const t6 = e6[h5];
      let n5, r7 = h5;
      do {
        if (++r7, r7 === d3) return false;
        n5 = e6[r7];
      } while (n5.isEqual(t6));
      let l7, f3 = r7;
      do {
        if (++f3, f3 === d3) return false;
        l7 = e6[f3];
      } while (l7.isEqual(n5));
      const g2 = this._deviation(t6, n5, l7);
      for (x2.push({ deviation: g2, distToAnchor: o6 }), c5 += g2; o6 - x2[0].distToAnchor > a7; ) c5 -= x2.shift().deviation;
      if (Math.abs(c5) > i5) return false;
      o6 += h.distance(n5, l7), h5 = r7;
    }
    return true;
  }
  static _smoothVertices(e6, t5) {
    if (t5 <= 0) return e6;
    let n4 = e6.length;
    if (n4 < 3) return e6;
    const i5 = [];
    let a7 = 0, o6 = 0;
    i5.push(0);
    for (let y2 = 1; y2 < n4; y2++) {
      const t6 = h.distance(e6[y2], e6[y2 - 1]);
      t6 > 0 && (a7 += t6, i5.push(a7), o6++, o6 !== y2 && (e6[o6] = e6[y2]));
    }
    if (n4 = o6 + 1, n4 < 3) return e6;
    t5 = Math.min(t5, 0.2 * a7);
    const r6 = e6[0].x, l6 = e6[0].y, h5 = e6[n4 - 1].x, x2 = e6[n4 - 1].y, c5 = h.sub(e6[0], e6[1]);
    c5.normalize(), e6[0].x += t5 * c5.x, e6[0].y += t5 * c5.y, c5.assignSub(e6[n4 - 1], e6[n4 - 2]), c5.normalize(), e6[n4 - 1].x += t5 * c5.x, e6[n4 - 1].y += t5 * c5.y, i5[0] -= t5, i5[n4 - 1] += t5;
    const d3 = [];
    d3.push(new h(r6, l6));
    const f3 = 1e-6, g2 = 0.5 * t5;
    for (let y2 = 1; y2 < n4 - 1; y2++) {
      let a8 = 0, o7 = 0, r7 = 0;
      for (let n5 = y2 - 1; n5 >= 0; n5--) {
        const s6 = g2 + i5[n5 + 1] - i5[y2];
        if (s6 < 0) break;
        const l7 = i5[n5 + 1] - i5[n5], h6 = i5[y2] - i5[n5] < g2 ? 1 : s6 / l7;
        if (h6 < f3) break;
        const x3 = h6 * h6, c6 = h6 * s6 - 0.5 * x3 * l7, d4 = h6 * l7 / t5, m2 = e6[n5 + 1], u4 = e6[n5].x - m2.x, p4 = e6[n5].y - m2.y;
        a8 += d4 / c6 * (m2.x * h6 * s6 + 0.5 * x3 * (s6 * u4 - l7 * m2.x) - x3 * h6 * l7 * u4 / 3), o7 += d4 / c6 * (m2.y * h6 * s6 + 0.5 * x3 * (s6 * p4 - l7 * m2.y) - x3 * h6 * l7 * p4 / 3), r7 += d4;
      }
      for (let s6 = y2 + 1; s6 < n4; s6++) {
        const n5 = g2 - i5[s6 - 1] + i5[y2];
        if (n5 < 0) break;
        const l7 = i5[s6] - i5[s6 - 1], h6 = i5[s6] - i5[y2] < g2 ? 1 : n5 / l7;
        if (h6 < f3) break;
        const x3 = h6 * h6, c6 = h6 * n5 - 0.5 * x3 * l7, d4 = h6 * l7 / t5, m2 = e6[s6 - 1], u4 = e6[s6].x - m2.x, p4 = e6[s6].y - m2.y;
        a8 += d4 / c6 * (m2.x * h6 * n5 + 0.5 * x3 * (n5 * u4 - l7 * m2.x) - x3 * h6 * l7 * u4 / 3), o7 += d4 / c6 * (m2.y * h6 * n5 + 0.5 * x3 * (n5 * p4 - l7 * m2.y) - x3 * h6 * l7 * p4 / 3), r7 += d4;
      }
      d3.push(new h(a8 / r7, o7 / r7));
    }
    return d3.push(new h(h5, x2)), e6[0].x = r6, e6[0].y = l6, e6[n4 - 1].x = h5, e6[n4 - 1].y = x2, d3;
  }
  static _pushCentroid(e6, t5) {
    const n4 = 0, i5 = 0, s6 = 4096, a7 = 4096, o6 = t5.length - 1;
    let r6 = 0, l6 = 0, h5 = 0, c5 = t5[0].x, d3 = t5[0].y;
    c5 > s6 && (c5 = s6), c5 < n4 && (c5 = n4), d3 > a7 && (d3 = a7), d3 < i5 && (d3 = i5);
    for (let x2 = 1; x2 < o6; x2++) {
      let e7 = t5[x2].x, o7 = t5[x2].y, f3 = t5[x2 + 1].x, g2 = t5[x2 + 1].y;
      e7 > s6 && (e7 = s6), e7 < n4 && (e7 = n4), o7 > a7 && (o7 = a7), o7 < i5 && (o7 = i5), f3 > s6 && (f3 = s6), f3 < n4 && (f3 = n4), g2 > a7 && (g2 = a7), g2 < i5 && (g2 = i5);
      const y2 = (e7 - c5) * (g2 - d3) - (f3 - c5) * (o7 - d3);
      r6 += y2 * (c5 + e7 + f3), l6 += y2 * (d3 + o7 + g2), h5 += y2;
    }
    r6 /= 3 * h5, l6 /= 3 * h5, isNaN(r6) || isNaN(l6) || e6.push(new T(r6, l6));
  }
};
L._bidiEngine = new C();

// node_modules/@arcgis/core/views/2d/tiling/enums.js
var I3;
!function(I4) {
  I4[I4.INITIALIZED = 0] = "INITIALIZED", I4[I4.NO_DATA = 1] = "NO_DATA", I4[I4.READY = 2] = "READY", I4[I4.MODIFIED = 3] = "MODIFIED", I4[I4.INVALID = 4] = "INVALID";
}(I3 || (I3 = {}));

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileParser.js
var g = class {
  constructor(t5, r6, o6, n4, l6, a7) {
    var _a;
    if (this._pbfTiles = {}, this._tileClippers = {}, this._client = o6, this._tile = r6, this._sourceDataMaxLOD = n4, a7) {
      this._styleLayerUIDs = /* @__PURE__ */ new Set();
      for (const e6 of a7) this._styleLayerUIDs.add(e6);
    }
    this._styleRepository = l6, this._layers = ((_a = this._styleRepository) == null ? void 0 : _a.layers) ?? [];
    const [u4, f3, p4] = r6.tileKey.split("/").map(parseFloat);
    this._level = u4;
    const h5 = d(this._level);
    for (const c5 of Object.keys(t5)) {
      const r7 = t5[c5];
      this._pbfTiles[c5] = new a(new Uint8Array(r7.protobuff), new DataView(r7.protobuff));
      if (r7.refKey) {
        const [e6] = r7.refKey.split("/").map(parseFloat), t6 = u4 - e6;
        if (t6 > 0) {
          const e7 = (1 << t6) - 1, r8 = f3 & e7, i5 = p4 & e7;
          this._tileClippers[c5] = new e(t6, r8, i5, 8, h5);
        }
      }
      this._tileClippers[c5] || (this._tileClippers[c5] = new _());
    }
  }
  _canParseStyleLayer(e6) {
    return !this._styleLayerUIDs || this._styleLayerUIDs.has(e6);
  }
  async parse(e6) {
    const t5 = i2(), s6 = this._initialize(e6), { returnedBuckets: i5 } = s6;
    this._processLayers(s6), this._linkReferences(s6), this._filterFeatures(s6);
    const o6 = [], c5 = /* @__PURE__ */ new Set(), n4 = (e7, t6) => {
      c5.has(e7) || (o6.push({ name: e7, repeat: t6 }), c5.add(e7));
    }, l6 = {};
    for (const r6 of i5) r6.getResources(r6.tileClipper, n4, l6);
    if (this._tile.status === I3.INVALID) return [];
    const a7 = this._fetchResources(o6, l6, e6);
    return Promise.all([...a7, t5]).then(() => this._processFeatures(s6.returnedBuckets));
  }
  _initialize(e6) {
    const t5 = e6 == null ? void 0 : e6.signal;
    return { signal: t5, sourceNameToTileData: this._parseTileData(this._pbfTiles), layers: this._layers, zoom: this._level, sourceNameToTileClipper: this._tileClippers, sourceNameToUniqueSourceLayerBuckets: {}, sourceNameToUniqueSourceLayers: {}, returnedBuckets: [], layerIdToBucket: {}, referencerUIDToReferencedId: /* @__PURE__ */ new Map() };
  }
  _processLayers(e6) {
    const { sourceNameToTileData: t5, zoom: r6, layers: s6, sourceNameToTileClipper: i5, sourceNameToUniqueSourceLayerBuckets: o6, sourceNameToUniqueSourceLayers: c5, returnedBuckets: n4, layerIdToBucket: l6, referencerUIDToReferencedId: a7 } = e6, u4 = this._sourceDataMaxLOD;
    for (let f3 = s6.length - 1; f3 >= 0; f3--) {
      const e7 = s6[f3];
      if (r6 < u4) {
        if (e7.minzoom && r6 < Math.floor(e7.minzoom) || e7.maxzoom && r6 >= e7.maxzoom) continue;
      } else if (e7.maxzoom && r6 >= e7.maxzoom) continue;
      if (e7.type === a4.BACKGROUND || !this._canParseStyleLayer(e7.uid) || !t5[e7.source] || !i5[e7.source]) continue;
      const p4 = t5[e7.source], h5 = i5[e7.source], m2 = e7.sourceLayer, _2 = p4[m2];
      if (_2) {
        let t6 = c5[e7.source];
        if (t6 || (t6 = c5[e7.source] = /* @__PURE__ */ new Set()), t6.add(e7.sourceLayer), e7.refLayerId) a7.set(e7.uid, e7.refLayerId);
        else {
          const t7 = this._createBucket(e7);
          if (t7) {
            t7.layerUIDs = [e7.uid], t7.layerExtent = _2.extent, t7.tileClipper = h5;
            let r7 = o6[e7.source];
            r7 || (r7 = o6[e7.source] = {});
            let s7 = r7[m2];
            s7 || (s7 = r7[m2] = []), s7.push(t7), n4.push(t7), l6[e7.id] = t7;
          }
        }
      }
    }
  }
  _linkReferences(e6) {
    const { layerIdToBucket: t5, referencerUIDToReferencedId: r6 } = e6;
    r6.forEach((e7, r7) => {
      t5[e7] && t5[e7].layerUIDs.push(r7);
    });
  }
  _filterFeatures(e6) {
    const { signal: r6, sourceNameToTileData: s6, sourceNameToUniqueSourceLayerBuckets: i5, sourceNameToUniqueSourceLayers: c5 } = e6, n4 = 10 * this._level, l6 = 10 * (this._level + 1), a7 = [], u4 = [];
    for (const t5 of Object.keys(c5)) {
      c5[t5].forEach((e7) => {
        a7.push(e7), u4.push(t5);
      });
    }
    for (let f3 = 0; f3 < a7.length; f3++) {
      const e7 = u4[f3], c6 = a7[f3];
      if (!s6[e7] || !i5[e7]) continue;
      const p4 = s6[e7][c6], h5 = i5[e7][c6];
      if (!h5 || 0 === h5.length) continue;
      if (c(r6)) return;
      let m2 = 0;
      const _2 = p4.getData();
      for (; _2.nextTag(2); ) {
        const e8 = _2.getMessage(), t5 = new s2(e8, p4, m2++);
        e8.release();
        const r7 = t5.values;
        if (r7) {
          const e9 = r7._minzoom;
          if (e9 && e9 >= l6) continue;
          const t6 = r7._maxzoom;
          if (t6 && t6 <= n4) continue;
        }
        for (const s7 of h5) s7.pushFeature(t5);
      }
    }
  }
  _fetchResources(e6, t5, r6) {
    const s6 = [], i5 = this._tile.getWorkerTileHandler();
    let o6, c5;
    e6.length > 0 && (o6 = i5.fetchSprites(e6, this._client, r6), s6.push(o6));
    for (const n4 in t5) {
      const e7 = t5[n4];
      e7.size > 0 && (c5 = i5.fetchGlyphs(this._tile.tileKey, n4, e7, this._client, r6), s6.push(c5));
    }
    return s6;
  }
  _processFeatures(e6) {
    const t5 = e6.filter((e7) => e7.hasFeatures() || this._canParseStyleLayer(e7.layer.uid));
    for (const r6 of t5) r6.processFeatures(r6.tileClipper);
    return t5;
  }
  _parseTileData(e6) {
    const t5 = {};
    for (const r6 of Object.keys(e6)) {
      const s6 = e6[r6], i5 = {};
      for (; s6.next(); ) switch (s6.tag()) {
        case 3: {
          const e7 = s6.getMessage(), t6 = new e4(e7);
          e7.release(), i5[t6.name] = t6;
          break;
        }
        default:
          s6.skip();
      }
      t5[r6] = i5;
    }
    return t5;
  }
  _createBucket(e6) {
    switch (e6.type) {
      case a4.BACKGROUND:
        return null;
      case a4.FILL:
        return this._createFillBucket(e6);
      case a4.LINE:
        return this._createLineBucket(e6);
      case a4.CIRCLE:
        return this._createCircleBucket(e6);
      case a4.SYMBOL:
        return this._createSymbolBucket(e6);
    }
  }
  _createFillBucket(e6) {
    return new s4(e6, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new r3(e6.fillMaterial.getStride()), new r2(), new u3(e6.outlineMaterial.getStride()), new r2());
  }
  _createLineBucket(e6) {
    return new n3(e6, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new o4(e6.lineMaterial.getStride()), new r2());
  }
  _createCircleBucket(e6) {
    return new r4(e6, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new a6(e6.circleMaterial.getStride()), new r2());
  }
  _createSymbolBucket(e6) {
    const t5 = this._tile;
    return new L(t5.tileKey, e6, this._level, new h4(e6.iconMaterial.getStride()), new r2(), new h4(e6.textMaterial.getStride()), new r2(), t5.placementEngine, t5.getWorkerTileHandler());
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTile.js
var i3 = class {
  constructor(t5, s6, i5, a7) {
    this.status = I3.INITIALIZED, this.placementEngine = new u2(), this.tileKey = t5, this.refKeys = s6, this._workerTileHandler = i5, this._styleRepository = a7;
  }
  release() {
    this.tileKey = "", this.refKeys = null, this.status = I3.INITIALIZED, this._workerTileHandler = null;
  }
  async parse(e6, s6) {
    const i5 = s6 == null ? void 0 : s6.signal;
    if (null != i5) {
      const t5 = () => {
        i5.removeEventListener("abort", t5), this.status = I3.INVALID;
      };
      i5.addEventListener("abort", t5);
    }
    let a7;
    const n4 = { bucketsWithData: [], emptyBuckets: null };
    try {
      a7 = await this._parse(e6, s6);
    } catch (c5) {
      if (b(c5)) throw c5;
      return { result: n4, transferList: [] };
    }
    this.status = I3.READY;
    const l6 = n4.bucketsWithData, o6 = [];
    for (const t5 of a7) if (t5.hasFeatures()) {
      const e7 = t5.serialize();
      l6.push(e7);
    } else o6.push(t5.layer.uid);
    const u4 = [...l6];
    let h5 = null;
    return o6.length > 0 && (h5 = Uint32Array.from(o6), u4.push(h5.buffer)), n4.emptyBuckets = h5, { result: n4, transferList: u4 };
  }
  setObsolete() {
    this.status = I3.INVALID;
  }
  getLayers() {
    return this._workerTileHandler.getLayers();
  }
  getWorkerTileHandler() {
    return this._workerTileHandler;
  }
  async _parse(t5, e6) {
    const i5 = t5.sourceName2DataAndRefKey;
    if (0 === Object.keys(i5).length) return [];
    this.status = I3.MODIFIED;
    return new g(i5, this, e6.client, t5.sourceDataMaxLOD, this._styleRepository, t5.styleLayerUIDs).parse(e6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTileHandler.js
var o5 = 25;
var i4 = class {
  constructor() {
    this._spriteInfo = {}, this._glyphInfo = {}, this._sourceDataMaxLOD = o5;
  }
  reset() {
    return this._spriteInfo = {}, this._glyphInfo = {}, Promise.resolve();
  }
  getLayers() {
    var _a;
    return ((_a = this._styleRepository) == null ? void 0 : _a.layers) ?? [];
  }
  async createTileAndParse(t5, r6) {
    const { key: o6 } = t5, i5 = {};
    for (const e6 of Object.keys(t5.sourceName2DataAndRefKey)) {
      const s6 = t5.sourceName2DataAndRefKey[e6];
      i5[e6] = s6.refKey;
    }
    const a7 = new i3(o6, i5, this, this._styleRepository);
    try {
      return await a7.parse({ ...t5, sourceDataMaxLOD: this._sourceDataMaxLOD }, r6);
    } catch (n4) {
      if (a7.setObsolete(), a7.release(), !b(n4)) throw n4;
      return null;
    }
  }
  updateStyle(e6) {
    if (!e6 || 0 === e6.length || !this._styleRepository) return;
    const s6 = this._styleRepository;
    for (const r6 of e6) {
      const e7 = r6.type, o6 = r6.data;
      switch (e7) {
        case I.PAINTER_CHANGED:
          s6.setPaintProperties(o6.layer, o6.paint);
          break;
        case I.LAYOUT_CHANGED:
          s6.setLayoutProperties(o6.layer, o6.layout);
          break;
        case I.LAYER_REMOVED:
          s6.deleteStyleLayer(o6.layer);
          break;
        case I.LAYER_CHANGED:
          s6.setStyleLayer(o6.layer, o6.index);
          break;
        case I.SPRITES_CHANGED:
          this._spriteInfo = {};
      }
    }
  }
  setStyle(e6) {
    const { style: t5, sourceDataMaxLOD: s6 } = e6;
    this._styleRepository = new l3(t5), this._sourceDataMaxLOD = s6, this._spriteInfo = {}, this._glyphInfo = {};
  }
  fetchSprites(e6, t5, s6) {
    const r6 = [], o6 = this._spriteInfo;
    for (const i5 of e6) {
      void 0 === o6[i5.name] && r6.push(i5);
    }
    return 0 === r6.length ? Promise.resolve() : t5.invoke("getSprites", r6, { signal: s6 == null ? void 0 : s6.signal }).then((e7) => {
      for (const t6 in e7) {
        const s7 = e7[t6];
        o6[t6] = s7;
      }
    });
  }
  getSpriteItems() {
    return this._spriteInfo;
  }
  fetchGlyphs(e6, t5, s6, r6, o6) {
    const i5 = [];
    let a7 = this._glyphInfo[t5];
    return a7 ? s6.forEach((e7) => {
      a7[e7] || i5.push(e7);
    }) : (a7 = this._glyphInfo[t5] = [], s6.forEach((e7) => i5.push(e7))), 0 === i5.length ? Promise.resolve() : r6.invoke("getGlyphs", { tileID: e6, font: t5, codePoints: i5 }, o6).then((e7) => {
      for (let t6 = 0; t6 < e7.length; t6++) e7[t6] && (a7[t6] = e7[t6]);
    });
  }
  getGlyphItems(e6) {
    return this._glyphInfo[e6];
  }
};
export {
  i4 as default
};
//# sourceMappingURL=WorkerTileHandler-TXDJKRXO.js.map
