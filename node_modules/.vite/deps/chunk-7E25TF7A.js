import {
  s
} from "./chunk-FQILN67Z.js";
import {
  G as G2,
  _,
  r
} from "./chunk-6K2FAOQG.js";
import {
  G
} from "./chunk-L7QO6TDW.js";

// node_modules/@arcgis/core/geometry/operators/gx/operatorProject.js
var o;
function u() {
  return !!o && r();
}
async function i() {
  if (!u()) {
    const [n, e] = await Promise.all([import("./ProjectionTransformation-5RU2C5GV.js").then((n2) => n2.aH), import("./ProjectionTransformation-5RU2C5GV.js").then((n2) => n2.aG).then(({ injectPe: n2 }) => n2), _()]);
    o = new n.OperatorProject(), e(G2);
  }
}
function a(n, r2) {
  return o.execute(n, r2, null);
}
function s2(r2, t) {
  const e = o.executeMany(new s(r2), t, null);
  return Array.from(e);
}
function p() {
  return o.supportsCurves();
}

// node_modules/@arcgis/core/geometry/operators/projectOperator.js
var s3;
var i2;
var c;
var m;
var f;
var p2;
var u2;
var l;
var h;
var j;
var x;
var T;
function g() {
  return !!i2 && u();
}
async function E() {
  if (!g()) {
    const [e, o2, a2, n] = await Promise.all([import("./apiConverter-GCJB7PQV.js"), import("./ProjectionTransformation-5RU2C5GV.js").then((e2) => e2.aI).then(({ CompositeGeographicTransformation: e2 }) => e2), import("./ProjectionTransformation-5RU2C5GV.js").then((e2) => e2.aJ).then(({ create: e2, createFromWKT: r2 }) => ({ create: e2, createFromWKT: r2 })), import("./ProjectionTransformation-5RU2C5GV.js").then((e2) => e2.aK).then(({ create: e2, createEx: r2, createFromAoi: t }) => ({ create: e2, createEx: r2, createFromAoi: t })), i()]);
    s3 = e.fromExtent, i2 = e.fromGeometry, c = e.fromSpatialReference, m = e.getSpatialReference, f = e.toGeometry, p2 = o2, u2 = a2.create, l = a2.createFromWKT, h = n.createEx, j = n.createFromAoi, x = n.create, T = p();
  }
}
function k(e, r2, t = {}) {
  const a2 = d(m(e), r2, t);
  return f(a(i2(e), a2), r2);
}
function F(r2, t, o2 = {}) {
  const n = r2.map(i2), s4 = d(m(r2), t, o2);
  return s2(n, s4).map((e) => f(e, t)).filter(G);
}
function d(e, r2, t = {}) {
  let o2;
  const a2 = c(e), n = c(r2);
  if (t == null ? void 0 : t.geographicTransformation) {
    const e2 = t.geographicTransformation.steps.map((e3) => e3.wkid ? u2(e3.wkid, e3.isInverse) : l(e3.wkt, e3.isInverse));
    o2 = new p2(e2, null, a2, n);
  } else if (t == null ? void 0 : t.areaOfInterestExtent) return j(a2, n, s3(t.areaOfInterestExtent).asEnvelope2D());
  return o2 ? h(a2, n, o2) : x(a2, n);
}

export {
  T,
  g,
  E,
  k,
  F
};
//# sourceMappingURL=chunk-7E25TF7A.js.map
