import {
  n2 as n
} from "./chunk-6II7WQ2F.js";

// node_modules/@arcgis/core/core/MapUtils.js
function n2(n3, t3) {
  for (const r3 of n3.values()) if (t3(r3)) return true;
  return false;
}
function t(n3, t3) {
  for (const r3 of n3.values()) if (t3(r3)) return r3;
  return null;
}
function r(n3, t3, r3) {
  const e2 = n3.get(t3);
  if (void 0 !== e2) return e2;
  const o2 = r3();
  return n3.set(t3, o2), o2;
}
function e(n3) {
  const t3 = /* @__PURE__ */ new Map();
  return (r3) => (t3.has(r3) || t3.set(r3, n3(r3)), t3.get(r3));
}

// node_modules/@arcgis/core/core/accessorSupport/ensureType.js
var r2 = () => n.getLogger("esri.core.accessorSupport.ensureTypes");
function t2(e2) {
  return null == e2 ? e2 : new Date(e2);
}
function o(e2) {
  return null == e2 ? e2 : !!e2;
}
function u(e2) {
  return null == e2 ? e2 : e2.toString();
}
function a(e2, n3 = 0) {
  return null == e2 ? e2 : (e2 = parseFloat(e2), isNaN(e2) ? n3 : e2);
}
function s(e2) {
  return null == e2 ? e2 : Math.round(parseFloat(e2));
}
function l(e2) {
  return null;
}
function i(e2, n3) {
  return (r3) => {
    let t3 = e2(r3);
    return null != n3.step && (t3 = Math.round(t3 / n3.step) * n3.step), null != n3.min && (t3 = Math.max(n3.min, t3)), null != n3.max && (t3 = Math.min(n3.max, t3)), t3;
  };
}
function c(e2) {
  return (e2 == null ? void 0 : e2.constructor) && void 0 !== e2.constructor.__accessorMetadata__;
}
function f(e2, n3) {
  return null != n3 && e2 && !(n3 instanceof e2);
}
function p(e2) {
  return e2 && "isCollection" in e2;
}
function y(e2) {
  return (e2 == null ? void 0 : e2.Type) ? "function" == typeof e2.Type ? e2.Type : e2.Type.base : null;
}
function v(e2, n3) {
  if (!(n3 == null ? void 0 : n3.constructor) || !p(n3.constructor)) return g(e2, n3) ? n3 : new e2(n3);
  const r3 = y(e2.prototype.itemType), t3 = y(n3.constructor.prototype.itemType);
  return r3 ? t3 ? r3 === t3 ? n3 : r3.prototype.isPrototypeOf(t3.prototype) ? new e2(n3) : (g(e2, n3), n3) : new e2(n3) : n3;
}
function g(e2, n3) {
  return !!c(n3) && (r2().error("Accessor#set", "Assigning an instance of '" + (n3.declaredClass || "unknown") + "' which is not a subclass of '" + m(e2) + "'"), true);
}
function h(e2, n3) {
  return null == n3 ? n3 : p(e2) ? v(e2, n3) : f(e2, n3) ? g(e2, n3) ? n3 : new e2(n3) : n3;
}
function m(e2) {
  var _a;
  return ((_a = e2 == null ? void 0 : e2.prototype) == null ? void 0 : _a.declaredClass) || "unknown";
}
var d = /* @__PURE__ */ new WeakMap();
function b(e2) {
  switch (e2) {
    case Number:
      return (e3) => a(e3);
    case x:
      return s;
    case Boolean:
      return o;
    case String:
      return u;
    case Date:
      return t2;
    case _:
      return l;
    default:
      return r(d, e2, () => h.bind(null, e2));
  }
}
function w(e2, n3) {
  const r3 = b(e2);
  return 1 === arguments.length ? r3 : r3(n3);
}
function A(e2, n3, r3) {
  return 1 === arguments.length ? A.bind(null, e2) : n3 ? Array.isArray(n3) ? n3.map((n4) => e2(n4, r3)) : [e2(n3, r3)] : n3;
}
function $(e2, n3) {
  return 1 === arguments.length ? A((n4) => w(e2, n4)) : A((n4) => w(e2, n4), n3);
}
function j(e2, n3, r3) {
  return 0 !== n3 && Array.isArray(r3) ? r3.map((r4) => j(e2, n3 - 1, r4)) : e2(r3);
}
function M(e2, n3, r3) {
  if (2 === arguments.length) return (r4) => M(e2, n3, r4);
  if (!r3) return r3;
  r3 = j(e2, n3, r3);
  let t3 = n3, o2 = r3;
  for (; t3 > 0 && Array.isArray(o2); ) t3--, o2 = o2[0];
  if (void 0 !== o2) for (let u2 = 0; u2 < t3; u2++) r3 = [r3];
  return r3;
}
function k(e2, n3, r3) {
  return 2 === arguments.length ? M((n4) => w(e2, n4), n3) : M((n4) => w(e2, n4), n3, r3);
}
function S(e2) {
  return !!Array.isArray(e2) && !e2.some((n3) => {
    const r3 = typeof n3;
    return !("string" === r3 || "number" === r3 || "function" === r3 && e2.length > 1);
  });
}
function T(e2, n3) {
  if (2 === arguments.length) return T(e2).call(null, n3);
  const t3 = /* @__PURE__ */ new Set(), o2 = e2.filter((e3) => "function" != typeof e3), u2 = e2.filter((e3) => "function" == typeof e3);
  for (const r3 of e2) "string" != typeof r3 && "number" != typeof r3 || t3.add(r3);
  let a2 = null, s2 = null;
  return (e3, n4) => {
    if (null == e3) return e3;
    const l2 = typeof e3, i2 = "string" === l2 || "number" === l2;
    return i2 && (t3.has(e3) || u2.some((e4) => "string" === l2 && e4 === String || "number" === l2 && e4 === Number)) || "object" === l2 && u2.some((n5) => !f(e3, n5)) ? e3 : (i2 && o2.length ? (a2 || (a2 = o2.map((e4) => "string" == typeof e4 ? `'${e4}'` : `${e4}`).join(", ")), r2().error("Accessor#set", `'${e3}' is not a valid value for this property, only the following values are valid: ${a2}`)) : "object" == typeof e3 && u2.length ? (s2 || (s2 = u2.map((e4) => m(e4)).join(", ")), r2().error("Accessor#set", `'${e3}' is not a valid value for this property, value must be one of ${s2}`)) : r2().error("Accessor#set", `'${e3}' is not a valid value for this property`), n4 && (n4.valid = false), null);
  };
}
function N(e2, n3) {
  if (2 === arguments.length) return N(e2).call(null, n3);
  const t3 = {}, o2 = [], u2 = [];
  for (const r3 in e2.typeMap) {
    const n4 = e2.typeMap[r3];
    t3[r3] = w(n4), o2.push(m(n4)), u2.push(r3);
  }
  const a2 = () => `'${o2.join("', '")}'`, s2 = () => `'${u2.join("', '")}'`, l2 = "string" == typeof e2.key ? (n4) => n4[e2.key] : e2.key;
  return (n4) => {
    if (e2.base && !f(e2.base, n4)) return n4;
    if (null == n4) return n4;
    const o3 = l2(n4) || e2.defaultKeyValue, u3 = t3[o3];
    if (!u3) return r2().error("Accessor#set", `Invalid property value, value needs to be one of ${a2()}, or a plain object that can autocast (having .type = ${s2()})`), null;
    if (!f(e2.typeMap[o3], n4)) return n4;
    if ("string" == typeof e2.key && !c(n4)) {
      const r3 = {};
      for (const t4 in n4) t4 !== e2.key && (r3[t4] = n4[t4]);
      return u3(r3);
    }
    return u3(n4);
  };
}
var x = class {
};
var _ = class {
};
var B = { native: (e2) => ({ type: "native", value: e2 }), array: (e2) => ({ type: "array", value: e2 }), oneOf: (e2) => ({ type: "one-of", values: e2 }) };
function C(e2) {
  if (!e2 || !("type" in e2)) return false;
  switch (e2.type) {
    case "native":
    case "array":
    case "one-of":
      return true;
  }
  return false;
}
function D(e2) {
  switch (e2.type) {
    case "native":
      return w(e2.value);
    case "array":
      return A(D(e2.value));
    case "one-of":
      return F(e2);
    default:
      return null;
  }
}
function F(e2) {
  let n3 = null;
  return (t3, o2) => L(t3, e2) ? t3 : (null == n3 && (n3 = I(e2)), r2().error("Accessor#set", `Invalid property value, value needs to be of type ${n3}`), o2 && (o2.valid = false), null);
}
function I(e2) {
  switch (e2.type) {
    case "native":
      switch (e2.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case x:
          return "integer";
        case Date:
          return "date";
        case _:
          return "null";
        default:
          return m(e2.value);
      }
    case "array":
      return `array of ${I(e2.value)}`;
    case "one-of": {
      const n3 = e2.values.map((e3) => I(e3));
      return `one of ${n3.slice(0, -1)} or ${n3[n3.length - 1]}`;
    }
  }
  return "unknown";
}
function L(e2, n3) {
  if (null == e2) return true;
  switch (n3.type) {
    case "native":
      switch (n3.value) {
        case Number:
        case x:
          return "number" == typeof e2;
        case Boolean:
          return "boolean" == typeof e2;
        case String:
          return "string" == typeof e2;
        case _:
          return null === e2;
      }
      return e2 instanceof n3.value;
    case "array":
      return !!Array.isArray(e2) && !e2.some((e3) => !L(e3, n3.value));
    case "one-of":
      return n3.values.some((n4) => L(e2, n4));
  }
}

export {
  n2 as n,
  t,
  r,
  e,
  u,
  a,
  s,
  i,
  h,
  w,
  A,
  $,
  M,
  k,
  S,
  T,
  N,
  x,
  _,
  B,
  C,
  D
};
//# sourceMappingURL=chunk-7LCEUMDD.js.map
