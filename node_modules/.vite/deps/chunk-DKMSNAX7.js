import {
  M,
  c2 as c,
  f2,
  h,
  i,
  i2 as i3
} from "./chunk-IVUJZZWI.js";
import {
  p as p2,
  t as t3,
  u as u2,
  v
} from "./chunk-KLCCKTMY.js";
import {
  m2,
  x
} from "./chunk-O3RCWUGN.js";
import {
  m,
  n2 as n3,
  n3 as n4,
  o3 as o5,
  t2 as t4
} from "./chunk-R33GG7W2.js";
import {
  e as e3
} from "./chunk-BXGUHXQX.js";
import {
  n as n2,
  o,
  o2
} from "./chunk-CS6KRDFU.js";
import {
  o as o3,
  p as p3
} from "./chunk-VGAGCEX3.js";
import {
  s2 as s
} from "./chunk-MSPEL4X6.js";
import {
  l
} from "./chunk-DLHCJHCP.js";
import {
  d as d2
} from "./chunk-Y6THB4GE.js";
import {
  o as o4
} from "./chunk-W2OFQBYT.js";
import {
  p
} from "./chunk-3LQTECQ4.js";
import {
  d,
  f
} from "./chunk-LTEACZYT.js";
import {
  e as e4
} from "./chunk-C2LO2UDO.js";
import {
  s as s2
} from "./chunk-6WRMI32T.js";
import {
  s as s3
} from "./chunk-7FXRLNEH.js";
import {
  i as i2
} from "./chunk-CXHZI2CJ.js";
import {
  t as t2
} from "./chunk-MD2QBQPV.js";
import {
  u
} from "./chunk-457CK7GN.js";
import {
  e as e2
} from "./chunk-EQ5WRTBD.js";
import {
  n,
  t
} from "./chunk-55SEMSMA.js";
import {
  e
} from "./chunk-HYT6FDCG.js";

// node_modules/@arcgis/core/chunks/RealisticTree.glsl.js
function _(_2) {
  const z2 = new i2(), { vertex: k, fragment: G, varyings: U } = z2, { output: W, offsetBackfaces: H, instancedColor: q, pbrMode: J, snowCover: K, spherical: Q } = _2, X = J === n3.Normal || J === n3.Schematic;
  if (f(k, _2), z2.include(o), U.add("vpos", "vec3"), z2.include(l, _2), z2.include(M, _2), z2.include(s, _2), z2.include(d2, _2), u(W) && (d(z2.vertex, _2), z2.include(t2, _2), z2.include(o2, _2), H && z2.include(c), q && z2.attributes.add(e.INSTANCECOLOR, "vec4"), U.add("vNormalWorld", "vec3"), U.add("localvpos", "vec3"), z2.include(o3, _2), z2.include(n2, _2), z2.include(i, _2), z2.include(e3, _2), k.uniforms.add(new e4("externalColor", (e5) => e5.externalColor)), U.add("vcolorExt", "vec4"), k.main.add(n`
      forwardNormalizedVertexColor();
      vcolorExt = externalColor;
      ${t(q, "vcolorExt *= instanceColor * 0.003921568627451;")}
      vcolorExt *= vvColor();
      vcolorExt *= getSymbolColor();
      forwardColorMixMode();

      bool alphaCut = vcolorExt.a < ${n.float(o4)};
      vpos = getVertexInLocalOriginSpace();
      localvpos = vpos - view[3].xyz;
      vpos = subtractOrigin(vpos);
      vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
      vpos = addVerticalOffset(vpos, localOrigin);
      vec4 basePosition = transformPosition(proj, view, vpos);

      forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
      forwardLinearDepth();
      forwardTextureCoordinates();

      gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
      ${t(H, "offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);", "basePosition;")}
    `)), u(W)) {
    const { hasColorTexture: e5, hasColorTextureTransform: r, receiveShadows: o6 } = _2;
    z2.include(v, _2), z2.include(t3, _2), z2.include(f2, _2), z2.include(_2.instancedDoublePrecision ? m2 : x, _2), z2.fragment.include(p, _2), z2.include(p3, _2), d(z2.fragment, _2), t4(G), u2(G), p2(G), G.uniforms.add(k.uniforms.get("localOrigin"), k.uniforms.get("view"), new e2("ambient", (e6) => e6.ambient), new e2("diffuse", (e6) => e6.diffuse), new s2("opacity", (e6) => e6.opacity), new s2("layerOpacity", (e6) => e6.layerOpacity)), e5 && G.uniforms.add(new s3("tex", (e6) => e6.texture)), z2.include(m, _2), z2.include(n4, _2), G.include(i3), o5(G), G.main.add(n`
      discardBySlice(vpos);
      discardByTerrainDepth();
      vec4 texColor = ${e5 ? `texture(tex, ${r ? "colorUV" : "vuv0"})` : " vec4(1.0)"};
      ${t(e5, `${t(_2.textureAlphaPremultiplied, "texColor.rgb /= texColor.a;")}
        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = ${o6 ? "max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))" : Q ? "lightingGlobalFactor * (1.0 - additionalAmbientScale)" : "0.0"};
      vec3 matColor = max(ambient, diffuse);
      ${_2.hasVertexColors ? n`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));` : n`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
      ${t(K, "albedo = mix(albedo, vec3(1), 0.9);")}
      ${n`vec3 shadingNormal = normalize(vNormalWorld);
             albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}
      ${t(X, `vec3 normalGround = ${Q ? "normalize(vpos + localOrigin)" : "vec3(0.0, 0.0, 1.0)"};`)}
      ${X ? n`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
                 ${t(K, n`mrr = vec3(0.0, 1.0, 0.04);`)}
            vec4 emission = ${K ? "vec4(0.0)" : "getEmissions()"};
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);` : n`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos);`);
  }
  return z2.include(h, _2), z2;
}
var z = Object.freeze(Object.defineProperty({ __proto__: null, build: _ }, Symbol.toStringTag, { value: "Module" }));

export {
  _,
  z
};
//# sourceMappingURL=chunk-DKMSNAX7.js.map
