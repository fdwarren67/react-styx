import {
  $,
  A,
  A2,
  At,
  B,
  B2,
  Bs,
  Bt,
  C,
  Cs,
  Ct,
  D,
  D2,
  Dt,
  Es,
  Et,
  F,
  Fs,
  Ft,
  G,
  G2,
  Gs,
  Gt,
  H,
  Hs,
  I,
  I2,
  Is,
  It,
  Kt,
  L,
  L2,
  Ls,
  Lt,
  Ms,
  Mt,
  N,
  O,
  Os,
  Ot,
  P,
  P2,
  Ps,
  Pt,
  Q,
  Qs,
  Qt,
  R,
  R2,
  Rs,
  Rt,
  S,
  Ss,
  St,
  T,
  Ts,
  Tt,
  U,
  U2,
  Ut,
  V,
  Vs,
  Vt,
  W,
  Ws,
  X,
  Xs,
  Y,
  Ys,
  Yt,
  Zt,
  _t,
  a,
  as,
  b,
  ct,
  ei,
  f,
  ft,
  g,
  gs,
  h,
  hs,
  ii,
  j,
  j2,
  js,
  jt,
  k,
  k2,
  ks,
  kt,
  l,
  ls,
  m,
  ms,
  n as n2,
  n2 as n3,
  os,
  p,
  p2,
  pt,
  qs,
  qt,
  rs,
  si,
  st,
  ti,
  us,
  v,
  vt,
  w,
  w2,
  ws,
  wt,
  x,
  x2,
  x3,
  y,
  yt,
  z,
  z2,
  zt
} from "./chunk-JGZNT3KT.js";
import {
  s as s2,
  t
} from "./chunk-FQILN67Z.js";
import {
  n,
  s
} from "./chunk-SCZRL2WP.js";

// node_modules/@arcgis/core/chunks/Envelope2D.js
var n4 = class _n3 {
  static construct(i2, t2, s4, m2) {
    return new _n3(i2, t2, s4, m2);
  }
  constructor(i2, t2, s4, m2) {
    this.m_EnvelopeType = 2, void 0 === i2 ? (this.xmin = Number.NaN, this.ymin = Number.NaN, this.xmax = Number.NaN, this.ymax = Number.NaN) : "number" == typeof i2 ? (this.xmin = i2, this.ymin = t2, this.xmax = s4, this.ymax = m2) : (this.xmin = i2.xmin, this.ymin = i2.ymin, this.xmax = i2.xmax, this.ymax = i2.ymax), this.normalize();
  }
  static constructEmpty() {
    return new _n3(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
  }
  clone() {
    return new _n3(this);
  }
  assign(i2) {
    return this.xmin = i2.xmin, this.xmax = i2.xmax, this.ymin = i2.ymin, this.ymax = i2.ymax, this;
  }
  width() {
    return this.xmax - this.xmin;
  }
  height() {
    return this.ymax - this.ymin;
  }
  maxDimension() {
    return Math.max(this.width(), this.height());
  }
  minDimension() {
    return Math.min(this.width(), this.height());
  }
  sqrDiagonal() {
    const i2 = this.width(), t2 = this.height();
    return i2 * i2 + t2 * t2;
  }
  diagonal() {
    return Math.sqrt(this.sqrDiagonal());
  }
  getCenterX() {
    return 0.5 * (this.xmin + this.xmax);
  }
  getCenterY() {
    return 0.5 * (this.ymin + this.ymax);
  }
  getCenter() {
    return ei.construct(this.getCenterX(), this.getCenterY());
  }
  queryCenter(i2) {
    i2.x = 0.5 * (this.xmin + this.xmax), i2.y = 0.5 * (this.ymin + this.ymax);
  }
  setEmpty() {
    this.xmin = Number.NaN, this.ymin = Number.NaN, this.xmax = Number.NaN, this.ymax = Number.NaN;
  }
  setInfinite() {
    this.xmin = Number.NEGATIVE_INFINITY, this.xmax = Number.POSITIVE_INFINITY, this.ymin = Number.NEGATIVE_INFINITY, this.ymax = Number.POSITIVE_INFINITY;
  }
  isDegenerate(i2) {
    return !this.isEmpty() && (this.width() <= i2 || this.height() <= i2);
  }
  isZero() {
    return !(this.isEmpty() || this.width() && this.height());
  }
  isEmpty() {
    return Number.isNaN(this.xmin) || Number.isNaN(this.ymin) || Number.isNaN(this.xmax) || Number.isNaN(this.ymax);
  }
  mergeNeCoords(i2, t2) {
    this.xmin > i2 ? this.xmin = i2 : this.xmax < i2 && (this.xmax = i2), this.ymin > t2 ? this.ymin = t2 : this.ymax < t2 && (this.ymax = t2);
  }
  mergeNe(i2) {
    this.mergeNeCoords(i2.x, i2.y);
  }
  mergeCoords(i2, t2) {
    this.isEmpty() ? (this.xmin = i2, this.ymin = t2, this.xmax = i2, this.ymax = t2) : (this.xmin > i2 ? this.xmin = i2 : this.xmax < i2 && (this.xmax = i2), this.ymin > t2 ? this.ymin = t2 : this.ymax < t2 && (this.ymax = t2));
  }
  merge(i2) {
    this.mergeCoords(i2.x, i2.y);
  }
  mergeEnvelope2D(i2) {
    i2.isEmpty() || (this.mergeCoords(i2.xmin, i2.ymin), this.mergeNeCoords(i2.xmax, i2.ymax));
  }
  mergePoints(i2, t2) {
    for (let s4 = 0; s4 < t2; ) {
      if (!this.isEmpty()) {
        for (let m2 = s4; m2 < t2; m2++) this.mergeNe(i2[m2]);
        break;
      }
      this.setCoords(i2[s4]), s4++;
    }
  }
  mergePointsInterleaved(i2, t2, s4) {
    for (let m2 = 2 * t2, h2 = m2 + 2 * s4; m2 < h2; m2 += 2) this.mergeCoords(i2.read(m2), i2.read(m2 + 1));
  }
  inflateCoords(i2, t2) {
    this.isEmpty() || (this.xmin -= i2, this.xmax += i2, this.ymin -= t2, this.ymax += t2, (this.xmin > this.xmax || this.ymin > this.ymax) && this.setEmpty());
  }
  getInflatedCoords(i2, t2) {
    const s4 = this.clone();
    return s4.inflateCoords(i2, t2), s4;
  }
  inflate(i2) {
    this.inflateCoords(i2, i2);
  }
  getInflated(i2) {
    const t2 = this.clone();
    return t2.inflateCoords(i2, i2), t2;
  }
  zoom(i2, t2) {
    this.isEmpty() || this.setCoords({ center: this.getCenter(), width: i2 * this.width(), height: t2 * this.height() });
  }
  scale(i2) {
    i2 < 0 && this.setEmpty(), this.xmin *= i2, this.xmax *= i2, this.ymin *= i2, this.ymax *= i2;
  }
  equals(i2, t2) {
    return !(!this.isEmpty() || !i2.isEmpty()) || (t2 ? Math.abs(this.xmin - i2.xmin) <= t2 && Math.abs(this.ymin - i2.ymin) <= t2 && Math.abs(this.xmax - i2.xmax) <= t2 && Math.abs(this.ymax - i2.ymax) <= t2 : this.xmin === i2.xmin && this.ymin === i2.ymin && this.xmax === i2.xmax && this.ymax === i2.ymax);
  }
  setCoords(t2) {
    void 0 !== t2.xmin ? (this.xmin = t2.xmin, this.xmax = t2.xmax, this.ymin = t2.ymin, this.ymax = t2.ymax) : void 0 !== t2.x ? (this.xmin = t2.x, this.xmax = t2.x, this.ymin = t2.y, this.ymax = t2.y) : void 0 !== t2.pt1 ? (this.xmin = t2.pt1.x, this.ymin = t2.pt1.y, this.xmax = t2.pt2.x, this.ymax = t2.pt2.y, this.normalize()) : void 0 !== t2.env2D ? (this.xmin = t2.env2D.xmin, this.xmax = t2.env2D.xmax, this.ymin = t2.env2D.ymin, this.ymax = t2.env2D.ymax, this.normalize()) : void 0 !== t2.pt ? (this.xmin = t2.pt.x, this.xmax = t2.pt.x, this.ymin = t2.pt.y, this.ymax = t2.pt.y) : void 0 !== t2.center ? (this.xmin = t2.center.x - 0.5 * t2.width, this.xmax = this.xmin + t2.width, this.ymin = t2.center.y - 0.5 * t2.height, this.ymax = this.ymin + t2.height, this.normalize()) : z("unrecognized input type for setCoords"), this.normalize();
  }
  queryIntervalX(i2) {
    this.isEmpty() ? i2.setEmpty() : i2.setCoords(this.xmin, this.xmax);
  }
  queryIntervalY(i2) {
    this.isEmpty() ? i2.setEmpty() : i2.setCoords(this.ymin, this.ymax);
  }
  setFromPoints(i2, t2) {
    if (0 === t2) return void this.setEmpty();
    if (Array.isArray(i2)) {
      const s5 = i2;
      this.setCoords(s5[0]);
      for (let i3 = 1; i3 < t2; ) {
        if (!this.isEmpty()) {
          for (let m2 = i3; m2 < t2; m2++) this.mergeNe(s5[m2]);
          return;
        }
        this.setCoords(s5[i3]), i3++;
      }
      return;
    }
    const s4 = i2;
    this.setCoords({ x: s4[0], y: s4[1] });
    for (let m2 = 1, h2 = 2 * t2; m2 < h2; m2 += 2) {
      if (!this.isEmpty()) {
        for (let i3 = m2, h3 = 2 * t2; i3 < h3; i3 += 2) this.mergeNeCoords(s4[i3], s4[i3 + 1]);
        return;
      }
      this.setCoords({ x: s4[m2], y: s4[m2 + 1] }), m2 += 2;
    }
  }
  normalize() {
    let i2 = false;
    this.xmin <= this.xmax || ([this.xmin, this.xmax] = [this.xmax, this.xmin], i2 = true), this.ymin <= this.ymax || ([this.ymin, this.ymax] = [this.ymax, this.ymin], i2 = true), !i2 || this.xmin <= this.xmax && this.ymin <= this.ymax || this.setEmpty();
  }
  isValid() {
    return this.isEmpty() || this.xmin <= this.xmax && this.ymin <= this.ymax;
  }
  getLowerLeft() {
    return new ei(this.xmin, this.ymin);
  }
  getLowerRight() {
    return new ei(this.xmax, this.ymin);
  }
  getUpperLeft() {
    return new ei(this.xmin, this.ymax);
  }
  getUpperRight() {
    return new ei(this.xmax, this.ymax);
  }
  move(i2, t2) {
    this.isEmpty() || (this.xmin += i2, this.ymin += t2, this.xmax += i2, this.ymax += t2);
  }
  centerAtCoords(i2, t2) {
    this.move(i2 - this.getCenterX(), t2 - this.getCenterY());
  }
  centerAt(i2) {
    this.centerAtCoords(i2.x, i2.y);
  }
  containsCoords(i2, t2) {
    return i2 >= this.xmin && i2 <= this.xmax && t2 >= this.ymin && t2 <= this.ymax;
  }
  contains(i2) {
    return this.containsCoords(i2.x, i2.y);
  }
  containsEnvelope(i2) {
    return i2.xmin >= this.xmin && i2.xmax <= this.xmax && i2.ymin >= this.ymin && i2.ymax <= this.ymax;
  }
  containsExclusiveCoords(i2, t2) {
    return i2 > this.xmin && i2 < this.xmax && t2 > this.ymin && t2 < this.ymax;
  }
  containsExclusive(i2) {
    return this.containsExclusiveCoords(i2.x, i2.y);
  }
  containsExclusiveEnvelope(i2) {
    return i2.xmin > this.xmin && i2.xmax < this.xmax && i2.ymin > this.ymin && i2.ymax < this.ymax;
  }
  isIntersecting(i2) {
    return (this.xmin <= i2.xmin ? this.xmax >= i2.xmin : i2.xmax >= this.xmin) && (this.ymin <= i2.ymin ? this.ymax >= i2.ymin : i2.ymax >= this.ymin);
  }
  isIntersectingNe(i2) {
    return (this.xmin <= i2.xmin ? this.xmax >= i2.xmin : i2.xmax >= this.xmin) && (this.ymin <= i2.ymin ? this.ymax >= i2.ymin : i2.ymax >= this.ymin);
  }
  intersect(i2) {
    if (this.isEmpty()) return false;
    if (i2.isEmpty()) return this.setEmpty(), false;
    i2.xmin > this.xmin && (this.xmin = i2.xmin), i2.xmax < this.xmax && (this.xmax = i2.xmax), i2.ymin > this.ymin && (this.ymin = i2.ymin), i2.ymax < this.ymax && (this.ymax = i2.ymax);
    const t2 = this.xmin <= this.xmax && this.ymin <= this.ymax;
    return t2 || this.setEmpty(), t2;
  }
  queryCorner(i2) {
    switch (3 & i2) {
      case 0:
        return new ei(this.xmin, this.ymin);
      case 1:
        return new ei(this.xmin, this.ymax);
      case 2:
        return new ei(this.xmax, this.ymax);
      default:
        return new ei(this.xmax, this.ymin);
    }
  }
  queryCorners(i2) {
    i2[0].setCoords(this.xmin, this.ymin), i2[1].setCoords(this.xmin, this.ymax), i2[2].setCoords(this.xmax, this.ymax), i2[3].setCoords(this.xmax, this.ymin);
  }
  queryCornersReversed(i2) {
    i2[0].setCoords(this.xmin, this.ymin), i2[1].setCoords(this.xmax, this.ymin), i2[2].setCoords(this.xmax, this.ymax), i2[3].setCoords(this.xmin, this.ymax);
  }
  reaspect(i2, t2) {
    if (this.isEmpty()) return;
    const s4 = i2 / t2, m2 = 0.5 * this.width(), h2 = 0.5 * this.height() * s4;
    if (m2 <= h2) {
      const i3 = this.getCenterX();
      this.xmin = i3 - h2, this.xmax = i3 + h2;
    } else {
      const i3 = m2 / s4, t3 = this.getCenterY();
      this.ymin = t3 - i3, this.ymax = t3 + i3;
    }
    this.normalize();
  }
  getArea() {
    return this.isEmpty() ? 0 : this.width() * this.height();
  }
  getLength() {
    return this.isEmpty() ? 0 : 2 * (this.width() + this.height());
  }
  clipCode(i2) {
    return (i2.x < this.xmin ? 1 : 0) | (i2.x > this.xmax ? 1 : 0) << 1 | (i2.y < this.ymin ? 1 : 0) << 2 | (i2.y > this.ymax ? 1 : 0) << 3;
  }
  clipLine(i2, t2) {
    let s4 = this.clipCode(i2), m2 = this.clipCode(t2);
    if (s4 & m2) return 0;
    if (!(s4 | m2)) return 4;
    const h2 = (s4 ? 1 : 0) | (m2 ? 2 : 0);
    do {
      const h3 = t2.x - i2.x, x4 = t2.y - i2.y;
      if (Math.abs(h3) > Math.abs(x4) ? s4 & _n3.XMASK ? (s4 & _n3.XLESSXMIN ? (i2.y += x4 * (this.xmin - i2.x) / h3, i2.x = this.xmin) : (i2.y += x4 * (this.xmax - i2.x) / h3, i2.x = this.xmax), s4 = this.clipCode(i2)) : m2 & _n3.XMASK ? (m2 & _n3.XLESSXMIN ? (t2.y += x4 * (this.xmin - t2.x) / h3, t2.x = this.xmin) : (t2.y += x4 * (this.xmax - t2.x) / h3, t2.x = this.xmax), m2 = this.clipCode(t2)) : s4 ? (s4 & _n3.YLESSYMIN ? (i2.x += h3 * (this.ymin - i2.y) / x4, i2.y = this.ymin) : (i2.x += h3 * (this.ymax - i2.y) / x4, i2.y = this.ymax), s4 = this.clipCode(i2)) : (m2 & _n3.YLESSYMIN ? (t2.x += h3 * (this.ymin - t2.y) / x4, t2.y = this.ymin) : (t2.x += h3 * (this.ymax - t2.y) / x4, t2.y = this.ymax), m2 = this.clipCode(t2)) : s4 & _n3.YMASK ? (s4 & _n3.YLESSYMIN ? (i2.x += h3 * (this.ymin - i2.y) / x4, i2.y = this.ymin) : (i2.x += h3 * (this.ymax - i2.y) / x4, i2.y = this.ymax), s4 = this.clipCode(i2)) : m2 & _n3.YMASK ? (m2 & _n3.YLESSYMIN ? (t2.x += h3 * (this.ymin - t2.y) / x4, t2.y = this.ymin) : (t2.x += h3 * (this.ymax - t2.y) / x4, t2.y = this.ymax), m2 = this.clipCode(t2)) : s4 ? (s4 & _n3.XLESSXMIN ? (i2.y += x4 * (this.xmin - i2.x) / h3, i2.x = this.xmin) : (i2.y += x4 * (this.xmax - i2.x) / h3, i2.x = this.xmax), s4 = this.clipCode(i2)) : (m2 & _n3.XLESSXMIN ? (t2.y += x4 * (this.xmin - t2.x) / h3, t2.x = this.xmin) : (t2.y += x4 * (this.xmax - t2.x) / h3, t2.x = this.xmax), m2 = this.clipCode(t2)), s4 & m2) return 0;
    } while (s4 | m2);
    return h2;
  }
  distanceFromEnvelope(i2) {
    return Math.sqrt(this.sqrDistanceEnvelope(i2, null, null));
  }
  distance(i2) {
    return Math.sqrt(this.sqrDistance(i2));
  }
  sqrDistanceEnvelope(i2, t2, s4) {
    if (!t2 && !s4) {
      if (this.isEmpty() || i2.isEmpty()) return Number.NaN;
      let t3, s5 = 0, m3 = 0;
      return t3 = this.xmin - i2.xmax, t3 > s5 && (s5 = t3), t3 = this.ymin - i2.ymax, t3 > m3 && (m3 = t3), t3 = i2.xmin - this.xmax, t3 > s5 && (s5 = t3), t3 = i2.ymin - this.ymax, t3 > m3 && (m3 = t3), s5 * s5 + m3 * m3;
    }
    if (this.isEmpty() || i2.isEmpty()) return t2 && t2.setNAN(), s4 && s4.setNAN(), Number.NaN;
    let m2, h2 = 0, x4 = 0;
    const n6 = Math.max(this.xmin, i2.xmin), e5 = Math.max(this.ymin, i2.ymin);
    return t2 && t2.setCoords(n6, e5), s4 && s4.setCoords(n6, e5), m2 = this.xmin - i2.xmax, m2 > h2 && (h2 = m2, t2 && (t2.x = this.xmin), s4 && (s4.x = i2.xmax)), m2 = this.ymin - i2.ymax, m2 > x4 && (x4 = m2, t2 && (t2.y = this.ymin), s4 && (s4.y = i2.ymax)), m2 = i2.xmin - this.xmax, m2 > h2 && (h2 = m2, t2 && (t2.x = this.xmax), s4 && (s4.x = i2.xmin)), m2 = i2.ymin - this.ymax, m2 > x4 && (x4 = m2, t2 && (t2.y = this.ymax), s4 && (s4.y = i2.ymin)), h2 * h2 + x4 * x4;
  }
  sqrDistance(i2, t2) {
    if (void 0 === t2) {
      if (this.isEmpty() || i2.isNAN()) return Number.NaN;
      let t3, s5 = 0, m3 = 0;
      return t3 = this.xmin - i2.x, t3 > s5 && (s5 = t3), t3 = this.ymin - i2.y, t3 > m3 && (m3 = t3), t3 = i2.x - this.xmax, t3 > s5 && (s5 = t3), t3 = i2.y - this.ymax, t3 > m3 && (m3 = t3), s5 * s5 + m3 * m3;
    }
    if (this.isEmpty() || i2.isNAN()) return t2.setNAN(), Number.NaN;
    t2.assign(i2);
    let s4, m2 = 0, h2 = 0;
    return s4 = this.xmin - i2.x, s4 > m2 && (m2 = s4, t2.x = this.xmin), s4 = this.ymin - i2.y, s4 > h2 && (h2 = s4, t2.y = this.ymin), s4 = i2.x - this.xmax, s4 > m2 && (m2 = s4, t2.x = this.xmax), s4 = i2.y - this.ymax, s4 > h2 && (h2 = s4, t2.y = this.ymax), m2 * m2 + h2 * h2;
  }
  sqrMaxMinDistanceEnvelope(i2) {
    if (this.isEmpty() || i2.isEmpty()) return Number.NaN;
    let t2 = Number.MAX_VALUE;
    {
      const m2 = ei.sqrDistanceCoords(this.xmin, this.ymin, i2.xmax, i2.ymin), h2 = ei.sqrDistanceCoords(this.xmin, this.ymin, i2.xmax, i2.ymax), x4 = ei.sqrDistanceCoords(this.xmin, this.ymax, i2.xmax, i2.ymin), n6 = ei.sqrDistanceCoords(this.xmin, this.ymax, i2.xmax, i2.ymax), e5 = Math.max(m2, h2), a2 = Math.max(x4, n6), r = Math.max(e5, a2);
      t2 = Math.min(r, t2);
    }
    {
      const m2 = ei.sqrDistanceCoords(this.xmin, this.ymin, i2.xmin, i2.ymax), h2 = ei.sqrDistanceCoords(this.xmin, this.ymin, i2.xmax, i2.ymax), x4 = ei.sqrDistanceCoords(this.xmax, this.ymin, i2.xmin, i2.ymax), n6 = ei.sqrDistanceCoords(this.xmax, this.ymin, i2.xmax, i2.ymax), e5 = Math.max(m2, h2), a2 = Math.max(x4, n6), r = Math.max(e5, a2);
      t2 = Math.min(r, t2);
    }
    {
      const m2 = ei.sqrDistanceCoords(this.xmax, this.ymin, i2.xmin, i2.ymin), h2 = ei.sqrDistanceCoords(this.xmax, this.ymin, i2.xmin, i2.ymax), x4 = ei.sqrDistanceCoords(this.xmax, this.ymax, i2.xmin, i2.ymin), n6 = ei.sqrDistanceCoords(this.xmax, this.ymax, i2.xmin, i2.ymax), e5 = Math.max(m2, h2), a2 = Math.max(x4, n6), r = Math.max(e5, a2);
      t2 = Math.min(r, t2);
    }
    {
      const m2 = ei.sqrDistanceCoords(this.xmin, this.ymax, i2.xmin, i2.ymin), h2 = ei.sqrDistanceCoords(this.xmin, this.ymax, i2.xmax, i2.ymin), x4 = ei.sqrDistanceCoords(this.xmax, this.ymax, i2.xmin, i2.ymin), n6 = ei.sqrDistanceCoords(this.xmax, this.ymax, i2.xmax, i2.ymin), e5 = Math.max(m2, h2), a2 = Math.max(x4, n6), r = Math.max(e5, a2);
      t2 = Math.min(r, t2);
    }
    return t2;
  }
  sqrMaxDistanceEnvelope(i2) {
    if (this.isEmpty() || i2.isEmpty()) return Number.NaN;
    let t2 = 0;
    const h2 = Rt(ei, 4);
    this.queryCorners(h2);
    const x4 = Rt(ei, 4);
    i2.queryCorners(x4);
    for (let m2 = 0; m2 < 4; m2++) for (let i3 = 0; i3 < 4; i3++) {
      const n6 = ei.sqrDistance(h2[m2], x4[i3]);
      n6 > t2 && (t2 = n6);
    }
    return t2;
  }
  sqrMaxMinDistance(i2) {
    const t2 = ei.sqrDistance(i2, this.getLowerLeft()), m2 = ei.sqrDistance(i2, this.getUpperLeft()), h2 = ei.sqrDistance(i2, this.getLowerRight()), x4 = ei.sqrDistance(i2, this.getUpperRight());
    let n6, e5 = Math.max(t2, m2);
    return n6 = Math.max(t2, h2), e5 > n6 && (e5 = n6), n6 = Math.max(m2, x4), e5 > n6 && (e5 = n6), n6 = Math.max(h2, x4), e5 > n6 && (e5 = n6), e5;
  }
  sqrMinDistance(i2) {
    if (this.contains(i2)) return 0;
    return this.sqrDistance(i2);
  }
  sqrMaxDistance(i2) {
    let t2 = ei.sqrDistance(i2, this.getLowerLeft());
    return t2 = Math.max(ei.sqrDistance(i2, this.getUpperLeft()), t2), t2 = Math.max(ei.sqrDistance(i2, this.getUpperRight()), t2), t2 = Math.max(ei.sqrDistance(i2, this.getLowerRight()), t2), t2;
  }
  snapToBoundary(i2) {
    if (i2.isNAN()) return false;
    if (this.isEmpty()) return i2.setNAN(), true;
    let t2 = true;
    if (i2.x < this.xmin ? i2.x = this.xmin : i2.x > this.xmax ? i2.x = this.xmax : t2 = false, i2.y < this.ymin ? i2.y = this.ymin : i2.y > this.ymax ? i2.y = this.ymax : t2 = false, t2) return true;
    if (i2.x === this.xmin || i2.x === this.xmax || i2.y === this.ymin || i2.y === this.ymax) return false;
    const s4 = this.xmax - i2.x, m2 = i2.x - this.xmin, h2 = this.ymax - i2.y, x4 = i2.y - this.ymin;
    return Math.max(s4, m2) > Math.max(h2, x4) ? i2.y = x4 < h2 ? this.ymin : this.ymax : i2.x = m2 < s4 ? this.xmin : this.xmax, true;
  }
  snapClip(i2) {
    const t2 = ks(i2.x, this.xmin, this.xmax), m2 = ks(i2.y, this.ymin, this.ymax);
    return ei.construct(t2, m2);
  }
  boundaryDistance(i2) {
    if (this.isEmpty() || i2.isNAN()) return Number.NaN;
    if (i2.x === this.xmin) return i2.y - this.ymin;
    const t2 = this.ymax - this.ymin, m2 = this.xmax - this.xmin;
    if (i2.y === this.ymax) return t2 + i2.x - this.xmin;
    if (i2.x === this.xmax) return t2 + m2 + this.ymax - i2.y;
    if (i2.y === this.ymin) return 2 * t2 + m2 + this.xmax - i2.x;
    const h2 = new ei();
    return h2.setCoordsPoint2D(i2), this.snapToBoundary(h2), this.boundaryDistance(h2);
  }
  envelopeSide(i2) {
    if (this.isEmpty()) return -1;
    let t2 = this.boundaryDistance(i2);
    const s4 = this.ymax - this.ymin, m2 = this.xmax - this.xmin;
    return t2 < s4 ? 0 : (t2 -= s4) < m2 ? 1 : t2 - m2 < s4 ? 2 : 3;
  }
  querySide(i2, s4) {
    switch (i2) {
      case 0:
        s4.constructFromCoords(this.xmin, this.ymin, this.xmin, this.ymax);
        break;
      case 1:
        s4.constructFromCoords(this.xmin, this.ymax, this.xmax, this.ymax);
        break;
      case 2:
        s4.constructFromCoords(this.xmax, this.ymax, this.xmax, this.ymin);
        break;
      case 3:
        s4.constructFromCoords(this.xmax, this.ymin, this.xmin, this.ymin);
        break;
      default:
        P("query_side");
    }
    return s4;
  }
  isPointOnBoundary(i2, t2) {
    return Math.abs(i2.x - this.xmin) <= t2 || Math.abs(i2.x - this.xmax) <= t2 || Math.abs(i2.y - this.ymin) <= t2 || Math.abs(i2.y - this.ymax) <= t2;
  }
  calculateToleranceFromEnvelope() {
    if (this.isEmpty()) return Cs();
    return (Math.abs(this.xmin) + Math.abs(this.xmax) + Math.abs(this.ymin) + Math.abs(this.ymax) + 1) * Cs();
  }
  toString() {
    return `[${this.xmin}, ${this.ymin}, ${this.xmax}, ${this.ymax}]`;
  }
};
n4.XLESSXMIN = 1, n4.YLESSYMIN = 4, n4.XMASK = 3, n4.YMASK = 12;

// node_modules/@arcgis/core/chunks/Envelope.js
var I3 = [0, 0, Number.NaN, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0];
var T2 = [2, 1, 1, 1, 3, 1, 2, 3, 2, 4, 1, 1, 2, 1];
var R3 = [1, 1, 1, 0, 2, 1, 1, 1, 0, 0, 0, 0, 0, 1];
var w3 = [1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 4, 2, 2, 1];
var A3 = [4, 8, 4, 8, 1];
var q = 25;
function z3() {
  return Lt(q, Number.NaN);
}
var B3 = class s3 {
  getAttributeCount() {
    return this.m_attributeCount;
  }
  getSemantics(t2) {
    return this.m_indexToSemantics[t2];
  }
  getSemanticsBitArray() {
    return this.m_semanticsBitArray;
  }
  getAttributeIndex(t2) {
    return this.m_semanticsToIndexMap[t2];
  }
  static getInterpolation(t2) {
    return R3[t2];
  }
  static getPersistence(t2) {
    return w3[t2];
  }
  static getPersistenceSize(t2) {
    return A3[t2];
  }
  static getPersistenceSizeFromSemantics(t2) {
    return s3.getPersistenceSize(s3.getPersistence(t2)) * s3.getComponentCount(t2);
  }
  static getComponentCount(t2) {
    return T2[t2];
  }
  static maxComponentCount() {
    return 4;
  }
  static isInteger(t2) {
    return 2 === t2 || 3 === t2 || 4 === t2;
  }
  static isIntegerSemantics(t2) {
    return s3.isInteger(s3.getPersistence(t2));
  }
  static isTexture(t2) {
    return 5 === t2 || 6 === t2 || 7 === t2;
  }
  hasAttribute(t2) {
    return !!(this.m_semanticsBitArray & 1 << t2);
  }
  hasAttributesFrom(t2) {
    return (this.m_semanticsBitArray & t2.m_semanticsBitArray) === t2.m_semanticsBitArray;
  }
  hasZ() {
    return this.hasAttribute(1);
  }
  hasM() {
    return this.hasAttribute(2);
  }
  hasID() {
    return this.hasAttribute(3);
  }
  getTotalComponentCount() {
    return this.m_totalComponentCount;
  }
  static getDefaultValue(t2) {
    return I3[t2];
  }
  static isDefaultValue(t2, s4) {
    return rs(I3[t2], s4);
  }
  equals(t2) {
    return this === t2;
  }
  getDefaultPointAttributes() {
    return this.m_defaultPointAttributes;
  }
  getPointAttributeOffset(t2) {
    return this.m_pointAttributeOffsets[t2];
  }
  constructor(e5) {
    this.m_semanticsBitArray = e5, this.m_attributeCount = 0, this.m_totalComponentCount = 0, this.m_semanticsToIndexMap = new Int32Array(14), this.m_indexToSemantics = new Int32Array(14), this.m_pointAttributeOffsets = new Int32Array(14), this.m_defaultPointAttributes = Lt(q, Number.NaN), this.m_semanticsToIndexMap.fill(-1), this.m_indexToSemantics.fill(-1);
    let i2 = 0, n6 = 1, r = 14;
    for (; i2 < r; i2++) e5 & n6 && (this.m_semanticsToIndexMap[i2] = this.m_attributeCount, this.m_indexToSemantics[this.m_attributeCount] = i2, this.m_attributeCount++, this.m_totalComponentCount += s3.getComponentCount(i2)), n6 <<= 1;
    let o2 = 0;
    for (i2 = 0, r = this.getAttributeCount(); i2 < r; i2++) {
      const t2 = this.getSemantics(i2), e6 = s3.getComponentCount(t2), n7 = s3.getDefaultValue(t2);
      this.m_pointAttributeOffsets[i2] = o2;
      for (let s4 = 0; s4 < e6; s4++) this.m_defaultPointAttributes[o2] = n7, o2++;
    }
  }
};
var S2 = B3;
function L3() {
  return Lt(14, 0);
}
var P3 = class _P {
  static getInstance() {
    return _P.s_thisInstance;
  }
  constructor() {
    this.m_map = /* @__PURE__ */ new Map(), this.m_vd2D = new S2(1), this.m_map.set(1, this.m_vd2D), this.m_vd3D = new S2(3), this.m_map.set(3, this.m_vd2D);
  }
  GetVD2D() {
    return this.m_vd2D;
  }
  GetVD3D() {
    return this.m_vd3D;
  }
  FindOrAdd(t2) {
    if (1 === t2) return this.GetVD2D();
    if (3 === t2) return this.GetVD3D();
    const e5 = this.m_map.get(t2);
    if (e5) return e5;
    const s4 = new S2(t2);
    return this.m_map.set(t2, s4), s4;
  }
};
function F2(t2) {
  return P3.getInstance().FindOrAdd(t2);
}
function H2(t2, e5) {
  if (!t2 || !e5) return e5 || t2;
  const s4 = t2.getSemanticsBitArray() | e5.getSemanticsBitArray();
  return (s4 & t2.getSemanticsBitArray()) === s4 ? t2 : (s4 & e5.getSemanticsBitArray()) === s4 ? e5 : F2(s4);
}
function k3(t2, e5) {
  const s4 = t2.getSemanticsBitArray() | 1 << e5;
  return (s4 & t2.getSemanticsBitArray()) === s4 ? t2 : F2(s4);
}
function V2(t2, e5) {
  const s4 = (t2.getSemanticsBitArray() | 1 << e5) - (1 << e5);
  return s4 === t2.getSemanticsBitArray() ? t2 : F2(s4);
}
function M() {
  return P3.getInstance().GetVD2D();
}
function O2() {
  return P3.getInstance().GetVD3D();
}
function Y2(t2, e5, s4) {
  if (s4.fill(-1), null !== t2 && null !== e5) for (let i2 = 0, n6 = t2.getAttributeCount(); i2 < n6; i2++) s4[i2] = e5.getAttributeIndex(t2.getSemantics(i2));
}
P3.s_thisInstance = new P3();
var X2 = class _X {
  static construct(t2, e5, s4) {
    return new _X(t2, e5, s4);
  }
  constructor(t2, e5, s4) {
    void 0 !== t2 ? (this.x = t2, this.y = e5, this.z = s4) : this.x = this.y = this.z = Number.NaN;
  }
  get 0() {
    return this.x;
  }
  get 1() {
    return this.y;
  }
  get 2() {
    return this.z;
  }
  set 0(t2) {
    this.x = t2;
  }
  set 1(t2) {
    this.y = t2;
  }
  set 2(t2) {
    this.z = t2;
  }
  clone() {
    return new _X(this.x, this.y, this.z);
  }
  assign(t2) {
    return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
  }
  setCoords(t2, e5, s4) {
    return this.x = t2, this.y = e5, this.z = s4, this;
  }
  setCoordsPoint2DZ(t2, e5) {
    return this.setCoords(t2.x, t2.y, e5);
  }
  setCoordsPoint3D(t2) {
    this.x = t2.x, this.y = t2.y, this.z = t2.z;
  }
  setZero() {
    this.x = 0, this.y = 0, this.z = 0;
  }
  setNormalized(t2) {
    this.assign(t2), this.normalizeThis();
  }
  normalizeThis() {
    const t2 = this.length();
    return t2 ? (this.x /= t2, this.y /= t2, this.z /= t2) : (this.x = 1, this.y = 0, this.z = 0), this;
  }
  getUnitVector() {
    const t2 = new _X();
    return t2.setNormalized(this), t2;
  }
  sqrLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthXY() {
    return n2(0), 0;
  }
  static sqrDistance(t2, e5) {
    return $(t2.x - e5.x) + $(t2.y - e5.y) + $(t2.z - e5.z);
  }
  static sqrDistanceCoords(t2, e5, i2, n6, r, o2) {
    return $(t2 - n6) + $(e5 - r) + $(i2 - o2);
  }
  static distance(t2, e5) {
    return Math.sqrt(_X.sqrDistance(t2, e5));
  }
  isEqual(t2, e5) {
    return void 0 === e5 && (e5 = 0), Math.abs(this.x - t2.x) <= e5 && Math.abs(this.y - t2.y) <= e5 && us(this.z, t2.z, e5);
  }
  static compareByLength(t2, e5, s4, i2) {
    return n2(0), 0;
  }
  isEqualCoords(t2, e5, s4, i2) {
    return n2(0), this.x === t2 && this.y === e5 && this.z === s4;
  }
  isEqualsTols(t2, e5, s4) {
    return n2(0), false;
  }
  isEqualCoordsTols(t2, e5, s4, i2, n6) {
    return n2(0), false;
  }
  static st_isEqual(t2, e5, s4, i2) {
    return n2(0), false;
  }
  equals(t2, e5) {
    return this.isEqual(t2, e5);
  }
  equalsTols(t2, e5, s4) {
    return n2(0), false;
  }
  divThis(t2) {
    return this.x /= t2, this.y /= t2, this.z /= t2, this;
  }
  subThis(t2) {
    return this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this;
  }
  setSub(t2, e5) {
    return this.x = t2.x - e5.x, this.y = t2.y - e5.y, this.z = t2.z - e5.z, this;
  }
  sub(t2) {
    return _X.construct(this.x - t2.x, this.y - t2.y, this.z - t2.z);
  }
  addThis(t2) {
    return this.x += t2.x, this.y += t2.y, this.z += t2.z, this;
  }
  add(t2) {
    return this.clone().addThis(t2);
  }
  setAdd(t2, e5) {
    return this.x = t2.x + e5.x, this.y = t2.y + e5.y, this.z = t2.z + e5.z, this;
  }
  mul(t2) {
    return _X.construct(this.x * t2, this.y * t2, this.z * t2);
  }
  dotProduct(t2) {
    return this.x * t2.x + this.y * t2.y + this.z * t2.z;
  }
  crossProductVector(t2) {
    const e5 = this.y * t2.z - t2.y * this.z, s4 = t2.x * this.z - this.x * t2.z, i2 = this.x * t2.y - t2.x * this.y;
    return new _X(e5, s4, i2);
  }
  setCrossProductVector(t2, e5) {
    const s4 = t2.y * e5.z - e5.y * t2.z, i2 = e5.x * t2.z - t2.x * e5.z, n6 = t2.x * e5.y - e5.x * t2.y;
    return this.x = s4, this.y = i2, this.z = n6, this;
  }
  setScaled(t2, e5) {
    return this.x = t2 * e5.x, this.y = t2 * e5.y, this.z = t2 * e5.z, this;
  }
  scaleThis(t2) {
    return this.x *= t2, this.y *= t2, this.z *= t2, this;
  }
  scaleZThis(t2) {
    return this.z *= t2, this;
  }
  setNAN() {
    return n2(0), this;
  }
  isNAN() {
    return Number.isNaN(this.x) || Number.isNaN(this.y) || Number.isNaN(this.z);
  }
  static getNAN() {
    return _X.construct(Number.NaN, Number.NaN, Number.NaN);
  }
  isFinite() {
    return n2(0), false;
  }
  isZero() {
    return 0 === this.x && 0 === this.y && 0 === this.z;
  }
  norm(t2) {
    return n2(0), 0;
  }
  sqrDistanceFromCenterToSpheroidSurface(t2, e5) {
    return n2(0), 0;
  }
  distanceFromCenterToSpheroidSurface(t2, e5) {
    return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(t2, e5));
  }
  static getClosestCoordinate(t2, e5, s4, i2 = false) {
    return n2(0), 0;
  }
  compare(t2) {
    return this.y < t2.y ? -1 : this.y > t2.y ? 1 : this.x < t2.x ? -1 : this.x > t2.x ? 1 : this.z < t2.z ? -1 : this.z > t2.z ? 1 : 0;
  }
  compareXYZ(t2) {
    return n2(0), 0;
  }
  negateThis() {
    this.x = -this.x, this.y = -this.y, this.z = -this.z;
  }
  static averageFast(t2, e5) {
    return n2(0), {};
  }
  static average(t2, e5) {
    return n2(0), {};
  }
  static size() {
    return _X.dimensions;
  }
  static lerp(t2, e5, s4) {
    const i2 = new _X();
    return j2(t2, e5, s4, i2), i2;
  }
  static slerp(t2, e5, s4) {
    return n2(0), {};
  }
  static compareVectors(t2, e5) {
    return n2(0), 0;
  }
  static selectRightHandedBasisFromNormal(t2, e5, s4) {
    const i2 = t2.getUnitVector(), n6 = i2.createAPerpendicular(), r = new _X();
    r.setCrossProductVector(i2, n6), r.normalizeThis(), e5.setCoordsPoint3D(n6), s4.setCoordsPoint3D(r);
  }
  createAPerpendicular() {
    const t2 = [this.crossProductVector(new _X(0, 0, 1)), this.crossProductVector(new _X(1, 0, 0)), this.crossProductVector(new _X(0, 1, 0))], e5 = [t2[0].sqrLength(), t2[1].sqrLength(), t2[2].sqrLength()], s4 = t2[e5.reduce((t3, s5, i2) => e5[t3] > e5[i2] ? t3 : i2, 0)];
    return s4.normalizeThis(), s4;
  }
  calculateAngle(t2) {
    return n2(0), 0;
  }
  static crossDotSign(t2, e5, s4) {
    return n2(0), 0;
  }
  static isBisectorRobust(t2, e5, s4) {
    return n2(0), 0;
  }
  static compareZOrder(t2, e5) {
    return n2(0), false;
  }
};
X2.dimensions = 3;
var U3 = class _U {
  static constructEmpty() {
    return new _U(Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN);
  }
  constructor(t2, e5, s4, i2, n6, r) {
    this.m_EnvelopeType = 3, this.xmin = t2, this.ymin = e5, this.zmin = s4, this.xmax = i2, this.ymax = n6, this.zmax = r, this.normalize();
  }
  inflate(t2) {
    this.inflateCoords(t2, t2, t2);
  }
  inflateCoords(t2, e5, s4) {
    n2(0);
  }
  getEnvelope2D() {
    return new n4(this.xmin, this.ymin, this.xmax, this.ymax);
  }
  getEnvelopeZs() {
    return new x2(this.zmin, this.zmax);
  }
  setEmptyZ() {
    this.zmin = Number.NaN, this.zmax = Number.NaN;
  }
  normalize() {
    let t2 = false;
    this.xmin <= this.xmax || (this.xmax = Mt(this.xmin, this.xmin = this.xmax), t2 = true), this.ymin <= this.ymax || (this.ymax = Mt(this.ymin, this.ymin = this.ymax), t2 = true), !t2 || this.xmin <= this.xmax && this.ymin <= this.ymax ? this.zmin <= this.zmax || (this.zmax = Mt(this.zmin, this.zmin = this.zmax), this.zmin <= this.zmax || this.setEmptyZ()) : this.setEmpty();
  }
  isEmpty() {
    return Number.isNaN(this.xmin) || Number.isNaN(this.ymin) || Number.isNaN(this.xmax) || Number.isNaN(this.ymax);
  }
  isEmptyZ() {
    return Number.isNaN(this.zmin) || Number.isNaN(this.zmax);
  }
  setEmpty() {
    this.xmin = Number.NaN, this.ymin = Number.NaN, this.zmin = Number.NaN, this.xmax = Number.NaN, this.ymax = Number.NaN, this.zmax = Number.NaN;
  }
  mergeEnv3D(t2) {
    t2.isEmpty() || (this.mergeCoords(t2.xmin, t2.ymin, t2.zmin), this.mergeCoords(t2.xmax, t2.ymax, t2.zmax));
  }
  mergeNe(t2) {
    this.mergeNeCoords(t2.x, t2.y, t2.z);
  }
  mergeNeCoords(t2, e5, s4) {
    this.xmin > t2 ? this.xmin = t2 : this.xmax < t2 && (this.xmax = t2), this.ymin > e5 ? this.ymin = e5 : this.ymax < e5 && (this.ymax = e5), this.zmin > s4 ? this.zmin = s4 : this.zmax < s4 && (this.zmax = s4);
  }
  mergeCoords(t2, e5, s4) {
    this.isEmpty() ? (this.xmin = t2, this.xmax = t2, this.ymin = e5, this.ymax = e5, this.zmin = s4, this.zmax = s4) : (this.isEmptyZ() && (this.zmin = s4, this.zmax = s4), this.mergeNeCoords(t2, e5, s4));
  }
  setCoords(t2, e5, s4, i2, n6, r) {
    this.xmin = t2, this.ymin = e5, this.zmin = s4, this.xmax = i2, this.ymax = n6, this.zmax = r, this.normalize();
  }
  sqrDistanceEnvelope3DAndPoints(t2, e5, s4, i2 = 1) {
    return n2(0), 0;
  }
  sqrMaxDistance(t2, e5 = 1) {
    return n2(0), 0;
  }
};
var G3 = -559038737;
var Z = B3;
function Q2(t2, e5, s4) {
  switch (t2) {
    case 0:
      return new it(e5, s4);
    case 1:
      return new nt(e5, s4);
    case 2:
      return new st2(e5, s4);
    case 3:
      throw new Error("64 bit int attribute stream not implemented");
    case 4:
      return new et(e5, s4);
    default:
      P("");
  }
}
function j3(t2, e5) {
  const s4 = Z.getComponentCount(t2);
  return Q2(Z.getPersistence(t2), e5 * s4, Z.getDefaultValue(t2));
}
function W2(t2, e5) {
  const s4 = Z.getComponentCount(t2);
  return Q2(Z.getPersistence(t2), e5 * s4);
}
function J(t2, e5) {
  return new st2(t2, e5);
}
function K(t2, e5) {
  return new et(t2, e5);
}
function $2(t2, e5) {
  return new nt(t2, e5);
}
var tt = class _tt {
  size() {
    return this.m_size;
  }
  checkResize(t2, e5) {
    t2 > this.m_size && this.resize(t2, e5);
  }
  resize(t2, e5) {
    if ((t2 = Math.trunc(t2)) === this.m_size) return;
    const s4 = !!e5 || Number.isNaN(e5);
    if (t2 < this.m_a.length) this.m_a.length > _tt.s_resizeMin && 1.25 * t2 < this.m_a.length && (this.m_a = this.m_a.slice(0, t2)), s4 && t2 > this.m_size && this.m_a.fill(e5, this.m_size, t2);
    else if (t2 >= this.m_a.length) {
      const i2 = 1.25 * t2, n6 = new this.m_a.constructor(i2);
      n6.set(this.m_a), this.m_a = n6, s4 && this.m_a.fill(e5, this.m_size, t2);
    }
    this.m_size = t2;
  }
  resizeRounded(t2, e5) {
    return this.resize(t2, e5);
  }
  reserve(t2) {
  }
  read(t2) {
    return this.m_a[t2];
  }
  readAsDbl(t2) {
    return this.read(t2);
  }
  write(t2, e5) {
    this.m_a[t2] = e5;
  }
  writeAsDbl(t2, e5) {
    this.write(t2, e5);
  }
  setRange(t2, e5, s4) {
    (e5 < 0 || s4 < 0 || s4 + e5 > this.size()) && P(), this.m_a.fill(t2, e5, e5 + s4);
  }
  add(t2) {
    this.resize(this.m_size + 1), this.m_a[this.m_size - 1] = t2;
  }
  addArray(t2, e5) {
    const s4 = this.m_size;
    void 0 === e5 ? (this.resize(this.m_size + t2.length), this.m_a.set(t2, s4)) : (this.resize(this.m_size + e5), this.m_a.set(t2.slice(0, e5), s4));
  }
  equals(t2, e5, s4, i2) {
    if (this.getPersistence() !== t2.getPersistence()) return false;
    return rt(this, t2, e5, s4, i2);
  }
  insertRange(t2, e5, s4, i2) {
    const n6 = this.m_size;
    this.checkResize(Math.max(0, i2) + s4), this.m_a.copyWithin(t2 + s4, t2, i2 >= 0 ? i2 : n6), this.m_a.fill(e5, t2, t2 + s4);
  }
  readRange(t2, e5) {
    return this.m_a.slice(t2, t2 + e5);
  }
  insertRangeFromStream(t2, e5, s4, i2, n6, r, o2) {
    n2(this.getPersistence() === e5.getPersistence());
    const h2 = e5, a2 = this.m_size;
    i2 && this.checkResize(Math.max(0, o2) + i2), this.m_a.copyWithin(t2 + i2, t2, o2 >= 0 ? o2 : a2), this.m_a.set(h2.readRange(s4, i2), t2), n6 || this.reverseRange(t2, i2, r);
  }
  writeRange(t2, e5, s4, i2, n6, r) {
    n2(this.getPersistence() === s4.getPersistence());
    const o2 = s4;
    if ((t2 < 0 || e5 < 0 || i2 < 0) && P(), o2.size() < i2 + e5 && P(), 0 === e5) return;
    this.size() < e5 + t2 && this.resize(e5 + t2);
    const h2 = o2.m_a.subarray(i2, i2 + e5);
    ot(this.m_a, t2, e5, h2);
  }
  insertAttributes(t2, e5, s4, i2) {
    const n6 = Z.getComponentCount(s4);
    this.m_a.copyWithin(t2 + n6, t2, i2 >= 0 ? i2 : this.m_size);
    for (let r = 0; r < n6; r++) this.m_a[t2 + r] = e5.getAttributeAsDbl(s4, r);
  }
  insertAttributesFromPoints(t2, e5, s4, i2, n6) {
    n2(Z.getPersistence(i2) === this.getPersistence());
    const r = Z.getComponentCount(i2), o2 = this.m_size;
    if (this.checkResize(Math.max(0, n6) + r * s4), this.m_a.copyWithin(t2 + r * s4, t2, n6 >= 0 ? n6 : o2), 0 === i2) {
      const i3 = new ei();
      for (let n7 = t2, r2 = 0; r2 < s4; r2++, n7 += 2) e5[r2].queryXY(i3), this.m_a[n7] = i3.x, this.m_a[n7 + 1] = i3.y;
    } else if (1 === r) for (let h2 = t2, a2 = 0; a2 < s4; a2++, h2++) this.m_a[h2] = e5[a2].getAttributeAsDbl(i2, 0);
    else for (let h2 = t2, a2 = 0; a2 < s4; a2++, h2 += r) for (let t3 = 0; t3 < r; t3++) this.m_a[h2 + t3] = e5[a2].getAttributeAsDbl(i2, t3);
  }
  eraseRange(t2, e5, s4) {
    this.m_size < t2 + e5 && P(), this.m_a.copyWithin(t2, t2 + e5), this.m_size -= e5;
  }
  reverseRange(t2, e5, s4) {
    if ((s4 < 1 || e5 % s4 != 0) && P(), this.m_a.subarray(t2, t2 + e5).reverse(), s4 > 1) for (let i2 = t2, n6 = t2 + e5; i2 < n6; i2 += s4) {
      let t3 = i2, e6 = i2 + s4 - 1;
      for (; t3 < e6; ) {
        const s5 = this.m_a[t3];
        this.m_a[t3] = this.m_a[e6], this.m_a[e6] = s5, t3++, e6--;
      }
    }
  }
  rotate(t2, e5, s4) {
    (e5 < t2 || e5 > s4 || t2 > s4) && A("rotate"), e5 !== t2 && e5 !== s4 && (this.reverseRange(t2, e5 - t2, 1), this.reverseRange(e5, s4 - e5, 1), this.reverseRange(t2, s4 - t2, 1));
  }
  sort(t2, e5, s4) {
    this.m_a.subarray(t2, e5).sort(s4);
  }
  constructor(t2) {
    if (t2.move) this.m_a = t2.move.m_a, this.m_size = t2.move.m_size, t2.move.m_a = t2.move.m_a.slice(0, 0), t2.move.m_size = 0;
    else if (t2.copy) this.m_size = t2.copy.m_size, t2.maxSize && (this.m_size = Math.min(t2.maxSize, this.m_size)), this.m_a = t2.copy.m_a.slice(0, this.m_size);
    else {
      const e5 = Math.max(t2.size, _tt.s_constructMin);
      this.m_a = new t2.ctor(e5), (t2.defaultValue || Number.isNaN(t2.defaultValue)) && this.m_a.fill(t2.defaultValue), this.m_size = t2.size;
    }
  }
};
tt.s_constructMin = 2, tt.s_resizeMin = 30;
var et = class _et extends tt {
  setBits(t2, e5) {
    this.m_a[t2] |= e5;
  }
  clearBits(t2, e5) {
    this.m_a[t2] &= ~e5;
  }
  getPersistence() {
    return 4;
  }
  clone() {
    return new _et({ ctor: Int8Array, copy: this });
  }
  restrictedClone(t2) {
    return new _et({ ctor: Int8Array, copy: this, maxSize: t2 });
  }
  constructor(t2, e5) {
    super("number" == typeof t2 ? { ctor: Int8Array, size: t2, defaultValue: e5 } : t2);
  }
};
var st2 = class _st extends tt {
  getPersistence() {
    return 2;
  }
  clone() {
    return new _st({ ctor: Int32Array, copy: this });
  }
  restrictedClone(t2) {
    return new _st({ ctor: Int32Array, copy: this, maxSize: t2 });
  }
  write(t2, e5) {
    n2(e5 <= ls()), super.write(t2, e5);
  }
  constructor(t2, e5) {
    super("number" == typeof t2 ? { ctor: Int32Array, size: t2, defaultValue: e5 } : t2);
  }
};
var it = class _it extends tt {
  getPersistence() {
    return 0;
  }
  clone() {
    return new _it({ ctor: Float32Array, copy: this });
  }
  restrictedClone(t2) {
    return new _it({ ctor: Float32Array, copy: this, maxSize: t2 });
  }
  constructor(t2, e5) {
    super("number" == typeof t2 ? { ctor: Float32Array, size: t2, defaultValue: e5 } : t2);
  }
};
var nt = class _nt extends tt {
  getPersistence() {
    return 1;
  }
  getArray() {
    return this.m_a;
  }
  applyTransformation(t2, e5, s4) {
    (1 & e5 || e5 + 2 * s4 > this.size()) && P();
    const i2 = 0 === e5 ? this.m_a : this.m_a.subarray(e5);
    t2.transformInterleavedPoints(i2, s4, i2);
  }
  readPoint2D(t2) {
    const e5 = this.m_a[t2], s4 = this.m_a[t2 + 1];
    return new ei(e5, s4);
  }
  queryPoint2D(t2, e5) {
    return e5.x = this.m_a[t2], e5.y = this.m_a[t2 + 1], e5;
  }
  writePoint2D(t2, e5) {
    this.write(t2, e5.x), this.write(t2 + 1, e5.y);
  }
  insert(t2, e5, s4) {
    this.checkResize(s4 + 2), this.m_a.copyWithin(t2 + 2, t2, s4), this.m_a[t2] = e5.x, this.m_a[t2 + 1] = e5.y;
  }
  insertRangeFromPoints(t2, e5, s4, i2, n6, r) {
    const o2 = this.m_size;
    if (this.checkResize(Math.max(r, 0) + 2 * i2), this.m_a.copyWithin(t2 + 2 * i2, t2, r >= 0 ? r : o2), n6) for (let h2 = s4, a2 = t2, m2 = 0; m2 < i2; ++m2, ++h2) {
      const t3 = e5[h2];
      this.m_a[a2++] = t3.x, this.m_a[a2++] = t3.y;
    }
    else for (let h2 = s4 + i2 - 1, a2 = t2, m2 = 0; m2 < i2; ++m2, --h2) {
      const t3 = e5[h2];
      this.m_a[a2++] = t3.x, this.m_a[a2++] = t3.y;
    }
  }
  queryRange(t2, e5, s4, i2, n6) {
    if ((t2 < 0 || e5 < 0) && P(), !i2 && (n6 <= 0 || e5 % n6 != 0) && P(), 0 === e5) return;
    if (1 === e5) return void (s4[0] = this.m_a[t2]);
    const r = this.m_a.subarray(t2, t2 + e5);
    s4.set(r);
  }
  writeRangeFromArray(t2, e5, s4, i2, n6) {
    if ((t2 < 0 || e5 < 0) && P(), 0 === e5) return;
    if (1 === e5) return void (this.m_a[t2] = s4[0]);
    let r = s4;
    e5 < s4.length && (r = s4.subarray(0, e5)), this.m_a.set(r, t2);
  }
  clone() {
    return new _nt({ ctor: Float64Array, copy: this });
  }
  restrictedClone(t2) {
    return new _nt({ ctor: Float64Array, copy: this, maxSize: t2 });
  }
  constructor(t2, e5) {
    super("number" == typeof t2 ? { ctor: Float64Array, size: t2, defaultValue: e5 } : t2);
  }
};
function rt(t2, e5, s4, n6, r) {
  if (t2.getPersistence() !== e5.getPersistence()) return false;
  const o2 = t2.getPersistence() <= 1, h2 = t2.size(), a2 = e5.size();
  if (n6 > h2 || n6 > a2) return false;
  if (r) if (o2) {
    for (let m2 = s4; m2 < n6; m2++) if (!us(t2.read(m2), e5.read(m2), r)) return false;
  } else for (let i2 = s4; i2 < n6; i2++) {
    let s5 = t2.read(i2) - e5.read(i2);
    if (s5 < 0 && (s5 = -s5), s5 > r) return false;
  }
  else for (let i2 = s4; i2 < n6; i2++) {
    const s5 = t2.read(i2), n7 = e5.read(i2);
    if (s5 !== n7) {
      if (o2 && Number.isNaN(s5) && Number.isNaN(n7)) continue;
      return false;
    }
  }
  return true;
}
function ot(t2, e5, s4, i2, n6, r) {
  if ((e5 < 0 || s4 < 0) && P(), 0 === s4) return;
  if (1 === s4) return void (t2[e5] = i2[0]);
  let o2 = i2;
  s4 < i2.length && (o2 = i2.subarray(0, s4)), t2.set(o2, e5);
}
var ht = class _ht {
  constructor() {
    this.m_minValue = -1, this.m_maxValue = -1, this.m_dy = Number.NaN, this.m_buckets = new st2(0), this.m_bucketedIndices = new st2(0);
  }
  static sortEx(t2, e5, s4, i2, n6 = 32) {
    if (s4 - e5 <= n6) return void i2.userSort(e5, s4, t2);
    new _ht().sort(t2, e5, s4, i2, n6);
  }
  sort(t2, e5, s4, i2, n6 = 32) {
    if (s4 - e5 <= n6) return void i2.userSort(e5, s4, t2);
    let r = true, o2 = Number.POSITIVE_INFINITY, h2 = Number.NEGATIVE_INFINITY;
    for (let m2 = e5; m2 < s4; m2++) {
      const e6 = i2.getValue(t2.read(m2));
      e6 < o2 && (o2 = e6), e6 > h2 && (h2 = e6);
    }
    if (this.reset(s4 - e5, o2, h2, s4 - e5)) {
      for (let r2 = e5; r2 < s4; r2++) {
        const s5 = t2.read(r2), n8 = i2.getValue(s5), o3 = this.getBucket(n8);
        this.m_buckets.write(o3, this.m_buckets.read(o3) + 1), this.m_bucketedIndices.write(r2 - e5, s5);
      }
      let n7 = this.m_buckets.read(0);
      this.m_buckets.write(0, 0);
      for (let t3 = 1, e6 = this.m_buckets.size(); t3 < e6; t3++) {
        const e7 = this.m_buckets.read(t3);
        this.m_buckets.write(t3, n7), n7 += e7;
      }
      for (let r2 = e5; r2 < s4; r2++) {
        const s5 = this.m_bucketedIndices.read(r2 - e5), n8 = i2.getValue(s5), o3 = this.getBucket(n8), h3 = this.m_buckets.read(o3);
        t2.write(h3 + e5, s5), this.m_buckets.write(o3, h3 + 1);
      }
      r = false;
    }
    if (r) return void i2.userSort(e5, s4, t2);
    let a2 = 0;
    for (let m2 = 0, _ = this.m_buckets.size(); m2 < _; m2++) {
      const s5 = a2;
      a2 = this.m_buckets.read(m2), a2 > s5 && i2.userSort(e5 + s5, e5 + a2, t2);
    }
    this.m_buckets.size() > 100 && (this.m_buckets.resize(0), this.m_bucketedIndices.resize(0));
  }
  reset(t2, e5, s4, i2) {
    if (t2 < 2 || s4 === e5) return false;
    const n6 = Math.min(_ht.c_maxBuckets, t2);
    return this.m_buckets.resize(n6), this.m_buckets.setRange(0, 0, this.m_buckets.size()), this.m_minValue = e5, this.m_maxValue = s4, this.m_bucketedIndices.resize(i2), this.m_dy = (s4 - e5) / (n6 - 1), true;
  }
  getBucket(t2) {
    return Math.trunc((t2 - this.m_minValue) / this.m_dy);
  }
  getBucketCount() {
    return this.m_buckets.size();
  }
};
ht.c_maxBuckets = 65536;
var at = class _at {
  constructor(t2) {
    this.m_buffer = null, this.m_firstFree = -1, this.m_last = 0, this.m_size = 0, this.m_capacity = 0, this.m_bufferSize = 0, this.m_stride = 0, this.m_stride = t2, this.m_realStride = t2, this.m_blockSize = Math.trunc(_at.st_realBlockSize / this.m_realStride);
  }
  dbgdelete_(t2) {
    return this.m_buffer[t2 >> _at.st_blockPower][1 + (t2 & _at.st_blockMask)] = _at.st_deadVertex, true;
  }
  deleteElement(t2) {
    (t2 >> _at.st_blockPower) * this.m_blockSize * this.m_realStride + (t2 & _at.st_blockMask) < this.m_last * this.m_realStride ? (this.m_buffer[t2 >> _at.st_blockPower][t2 & _at.st_blockMask] = this.m_firstFree, this.m_firstFree = t2) : this.m_last--, this.m_size--;
  }
  getField(t2, e5) {
    return this.m_buffer[t2 >> _at.st_blockPower][(t2 & _at.st_blockMask) + e5];
  }
  setField(t2, e5, s4) {
    this.m_buffer[t2 >> _at.st_blockPower][(t2 & _at.st_blockMask) + e5] = s4;
  }
  getStride() {
    return this.m_stride;
  }
  newElement() {
    let t2 = this.m_firstFree;
    if (-1 === t2) {
      if (this.m_last === this.m_capacity) {
        const t3 = 0 !== this.m_capacity ? Math.trunc(2 * (this.m_capacity + 1)) : 1;
        this.grow(t3);
      }
      t2 = (this.m_last / this.m_blockSize << _at.st_blockPower) + this.m_last % this.m_blockSize * this.m_realStride, this.m_last++;
    } else this.m_firstFree = this.m_buffer[t2 >> _at.st_blockPower][t2 & _at.st_blockMask];
    this.m_size++;
    const e5 = this.m_buffer[t2 >> _at.st_blockPower], s4 = t2 & _at.st_blockMask;
    for (let i2 = 0; i2 < this.m_stride; i2++) e5[s4 + i2] = -1;
    return t2;
  }
  elementToIndex(t2) {
    return (t2 >> _at.st_blockPower) * this.m_blockSize + (t2 & _at.st_blockMask) / this.m_realStride;
  }
  deleteAll(t2) {
    this.m_firstFree = -1, this.m_last = 0, this.m_size = 0, t2 && (this.m_buffer = null, this.m_capacity = 0);
  }
  size() {
    return this.m_size;
  }
  setCapacity(t2) {
    t2 > this.m_capacity && this.grow(t2);
  }
  capacity() {
    return this.m_capacity;
  }
  swap(t2, e5) {
    const s4 = this.m_buffer[t2 >> _at.st_blockPower], i2 = this.m_buffer[e5 >> _at.st_blockPower], n6 = t2 & _at.st_blockMask, r = e5 & _at.st_blockMask;
    for (let o2 = 0; o2 < this.m_stride; o2++) {
      const t3 = s4[n6 + o2];
      s4[n6 + o2] = i2[r + o2], i2[r + o2] = t3;
    }
  }
  swapField(t2, e5, s4) {
    const i2 = this.m_buffer[t2 >> _at.st_blockPower], n6 = this.m_buffer[e5 >> _at.st_blockPower], r = (t2 & _at.st_blockMask) + s4, o2 = (e5 & _at.st_blockMask) + s4, h2 = i2[r];
    i2[r] = n6[o2], n6[o2] = h2;
  }
  static impossibleIndex2() {
    return -2;
  }
  static impossibleIndex3() {
    return -3;
  }
  static isValidElement(t2) {
    return t2 >= 0;
  }
  ensureBufferBlocksCapacity(t2) {
    if (this.m_buffer.length < t2) {
      const e5 = new Array(t2);
      for (let t3 = 0; t3 < this.m_buffer.length; t3++) e5[t3] = this.m_buffer[t3];
      this.m_buffer = e5;
    }
  }
  grow(t2) {
    null === this.m_buffer && (this.m_bufferSize = 0, this.m_buffer = new Array(8));
    const e5 = Math.trunc((t2 + this.m_blockSize - 1) / this.m_blockSize);
    if (this.ensureBufferBlocksCapacity(e5), 1 === e5) {
      let e6 = 0;
      const s4 = t2 * this.m_realStride;
      for (; s4 > _at.st_sizes[e6]; ) e6++;
      const i2 = new Int32Array(_at.st_sizes[e6]);
      1 === this.m_bufferSize ? (i2.set(this.m_buffer[0]), this.m_buffer[0] = i2) : (this.m_buffer[this.m_bufferSize] = i2, this.m_bufferSize++), this.m_capacity = Math.trunc(i2.length / this.m_realStride);
    } else {
      if (1 === this.m_bufferSize && this.m_buffer[0].length < _at.st_realBlockSize) {
        const t3 = new Int32Array(_at.st_realBlockSize);
        t3.set(this.m_buffer[0]), this.m_buffer[0] = t3, this.m_capacity = this.m_blockSize;
      }
      for (; this.m_bufferSize < e5; ) this.m_buffer[this.m_bufferSize++] = new Int32Array(_at.st_realBlockSize), this.m_capacity += this.m_blockSize;
    }
  }
};
function mt(t2, e5) {
  return { element: t2, box: e5.clone() };
}
at.st_realBlockSize = 16384, at.st_blockMask = 16383, at.st_blockPower = 14, at.st_sizes = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384], at.st_deadVertex = -2125315821;
var _t2 = class __t {
  constructor(t2, e5, s4) {
    this.m_extent = new n4(), this.m_dataExtent = new n4(), this.m_childExtents = [new n4(), new n4(), new n4(), new n4()], this.m_elementNodes = new at(4), this.m_data = [], this.m_freeData = [], this.m_root = -1, this.m_height = 8, void 0 === s4 && (s4 = false), this.m_quadTreeNodes = new at(s4 ? 11 : 10), this.m_bStoreDuplicates = s4, this.reset_(t2, e5);
  }
  reset(t2, e5) {
    this.m_quadTreeNodes.deleteAll(false), this.m_elementNodes.deleteAll(false), this.m_data.length = 0, this.m_freeData.length = 0, this.reset_(t2, e5);
  }
  insert(t2, e5) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s5 = this.insertDuplicates_(t2, e5, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s5 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s5;
    }
    const s4 = this.insert_(t2, e5, 0, this.m_extent, this.m_root, false, -1);
    return -1 !== s4 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s4;
  }
  insertEx(t2, e5, s4) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s5 = this.insertDuplicates_(t2, e5, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s5 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), s5;
    }
    let i2;
    i2 = -1 === s4 ? this.m_root : this.getQuad_(s4);
    const n6 = this.getHeight(i2), r = this.getExtent(i2), o2 = this.insert_(t2, e5, n6, r, i2, false, -1);
    return -1 !== o2 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e5 }) : this.m_dataExtent.mergeEnvelope2D(e5)), o2;
  }
  removeElement(t2) {
    n2(0);
  }
  getElement(t2) {
    return this.getElementValue_(this.getData_(t2));
  }
  getElementAtIndex(t2) {
    return n2(0), 0;
  }
  getElementExtent(t2) {
    const e5 = this.getData_(t2);
    return this.getBoundingBoxValue_(e5).clone();
  }
  getElementExtentAtIndex(t2) {
    return n2(0), {};
  }
  getDataExtent() {
    return this.m_dataExtent.clone();
  }
  getQuadTreeExtent() {
    return n2(0), {};
  }
  getHeight(t2) {
    return this.m_quadTreeNodes.getField(t2, 6) >> __t.m_heightBitShift;
  }
  getMaxHeight() {
    return this.m_height;
  }
  getExtent(t2) {
    const e5 = new n4();
    if (e5.setCoords({ env2D: this.m_extent }), t2 === this.m_root) return e5;
    const s4 = [];
    let i2 = t2;
    do {
      s4.push(this.getQuadrant_(i2)), i2 = this.getParent_(i2);
    } while (i2 !== this.m_root);
    const n6 = s4.length;
    for (let r = 0; r < n6; r++) {
      const t3 = s4.at(-1);
      s4.pop(), 0 === t3 ? (e5.xmin = 0.5 * (e5.xmin + e5.xmax), e5.ymin = 0.5 * (e5.ymin + e5.ymax)) : 1 === t3 ? (e5.xmax = 0.5 * (e5.xmin + e5.xmax), e5.ymin = 0.5 * (e5.ymin + e5.ymax)) : 2 === t3 ? (e5.xmax = 0.5 * (e5.xmin + e5.xmax), e5.ymax = 0.5 * (e5.ymin + e5.ymax)) : (e5.xmin = 0.5 * (e5.xmin + e5.xmax), e5.ymax = 0.5 * (e5.ymin + e5.ymax));
    }
    return e5;
  }
  getQuad(t2) {
    return this.getQuad_(t2);
  }
  getElementCount() {
    return -1 === this.m_root ? 0 : this.getSubTreeElementCount_(this.m_root);
  }
  getSubTreeElementCount(t2) {
    return this.getSubTreeElementCount_(t2);
  }
  getContainedSubTreeElementCount(t2) {
    return this.m_bStoreDuplicates ? this.getContainedSubTreeElementCount_(t2) : this.getSubTreeElementCount_(t2);
  }
  getIntersectionCount(t2, e5, s4) {
    if (-1 === this.m_root) return 0;
    const i2 = new n4();
    i2.setCoords({ env2D: t2 }), i2.inflateCoords(e5, e5);
    const n6 = [], r = [];
    n6.push(this.m_root), r.push(this.m_extent.clone());
    const o2 = Rt(n4, 4);
    let h2 = 0;
    for (; n6.length > 0; ) {
      let t3 = false;
      const e6 = n6.at(-1), a2 = r.at(-1);
      if (n6.pop(), r.pop(), i2.containsEnvelope(a2)) {
        if (h2 += this.getSubTreeElementCount(e6), s4 > 0 && h2 >= s4) return s4;
      } else if (i2.isIntersecting(a2)) {
        for (let t4 = this.getFirstElement_(e6); -1 !== t4; t4 = this.getNextElement_(t4)) {
          const e7 = this.getData_(t4);
          if (this.getBoundingBoxValue_(e7).isIntersecting(i2) && (h2++, s4 > 0 && h2 >= s4)) return s4;
        }
        t3 = this.getHeight(e6) + 1 <= this.m_height;
      }
      if (t3) {
        __t.setChildExtents_(a2, o2);
        for (let t4 = 0; t4 < 4; t4++) {
          const s5 = this.getChild_(e6, t4);
          if (-1 !== s5 && this.getSubTreeElementCount_(s5) > 0) {
            i2.isIntersecting(o2[t4]) && (n6.push(s5), r.push(o2[t4].clone()));
          }
        }
      }
    }
    return h2;
  }
  hasData(t2, e5) {
    return this.getIntersectionCount(t2, e5, 1) >= 1;
  }
  getIterator(t2, e5) {
    return new lt(this, t2, e5);
  }
  getIteratorForQT() {
    return new lt(this);
  }
  getSortedIterator(t2, e5) {
    return new ut(this.getIterator(t2, e5));
  }
  getSortedIteratorForQT() {
    return new ut(this.getIteratorForQT());
  }
  visitLeavesNearest(t2, e5, s4, i2) {
    n2(0);
  }
  reset_(t2, e5) {
    (e5 < 0 || e5 > 127) && P("invalid height"), this.m_height = e5, this.m_extent.setCoords({ env2D: t2 }), this.m_dataExtent.setEmpty(), this.m_root = -1;
  }
  insert_(t2, e5, s4, i2, n6, r, o2) {
    if (!i2.containsEnvelope(e5)) return 0 === s4 ? -1 : this.insert_(t2, e5, 0, this.m_extent, this.m_root, r, o2);
    if (!r) for (let _ = n6; -1 !== _; _ = this.getParent_(_)) this.setSubTreeElementCount_(_, this.getSubTreeElementCount_(_) + 1);
    const h2 = new n4();
    h2.setCoords({ env2D: i2 });
    let a2, m2 = n6;
    for (a2 = s4; a2 < this.m_height && this.canPushDown_(m2); a2++) {
      __t.setChildExtents_(h2, this.m_childExtents);
      let t3 = false;
      for (let s5 = 0; s5 < 4; s5++) if (this.m_childExtents[s5].containsEnvelope(e5)) {
        t3 = true;
        let e6 = this.getChild_(m2, s5);
        -1 === e6 && (e6 = this.createChild_(m2, s5)), this.setSubTreeElementCount_(e6, this.getSubTreeElementCount_(e6) + 1), m2 = e6, h2.setCoords({ env2D: this.m_childExtents[s5] });
        break;
      }
      if (!t3) break;
    }
    return this.insertAtQuad_(t2, e5, a2, h2, m2, r, n6, o2, -1);
  }
  insertDuplicates_(t2, e5, s4, i2, n6, r, o2) {
    if (!r) {
      if (!i2.containsEnvelope(e5)) return -1;
      this.setSubTreeElementCount_(n6, this.getSubTreeElementCount_(n6) + 1), this.setContainedSubTreeElementCount_(n6, this.getContainedSubTreeElementCount_(n6) + 1);
    }
    const h2 = Math.max(e5.width(), e5.height());
    let a2 = -1;
    const m2 = [], _ = [], l2 = [];
    m2.push(n6), _.push(i2.clone()), l2.push(s4);
    const d2 = Rt(n4, 4);
    for (; m2.length > 0; ) {
      let s5 = false;
      const i3 = m2.at(-1), u = _.at(-1), c = l2.at(-1);
      if (m2.pop(), _.pop(), l2.pop(), c + 1 < this.m_height && this.canPushDown_(i3)) {
        h2 <= Math.max(u.width(), u.height()) / 2 && (s5 = true);
      }
      if (s5) {
        __t.setChildExtents_(u, d2);
        let t3 = false;
        for (let s6 = 0; s6 < 4; s6++) if (t3 = d2[s6].containsEnvelope(e5), t3) {
          let t4 = this.getChild_(i3, s6);
          -1 === t4 && (t4 = this.createChild_(i3, s6)), m2.push(t4), _.push(d2[s6].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t4, this.getSubTreeElementCount_(t4) + 1), this.setContainedSubTreeElementCount_(t4, this.getContainedSubTreeElementCount_(t4) + 1);
          break;
        }
        if (!t3) for (let s6 = 0; s6 < 4; s6++) {
          if (d2[s6].isIntersecting(e5)) {
            let t4 = this.getChild_(i3, s6);
            -1 === t4 && (t4 = this.createChild_(i3, s6)), m2.push(t4), _.push(d2[s6].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t4, this.getSubTreeElementCount_(t4) + 1);
          }
        }
      } else a2 = this.insertAtQuad_(t2, e5, c, u, i3, r, n6, o2, a2), r = false;
    }
    return 0;
  }
  insertAtQuad_(t2, e5, s4, i2, n6, r, o2, h2, a2) {
    this.getFirstElement_(n6);
    const m2 = this.getLastElement_(n6);
    let _ = -1;
    if (r) {
      if (n6 === o2) return h2;
      this.disconnectElementHandle_(h2), _ = h2;
    } else -1 === a2 ? (_ = this.createElement_(), this.setDataValues_(this.getData_(_), t2, e5)) : _ = this.createElementFromDuplicate_(a2);
    return this.setQuad_(_, n6), -1 !== m2 ? (this.setPrevElement_(_, m2), this.setNextElement_(m2, _)) : this.setFirstElement_(n6, _), this.setLastElement_(n6, _), this.setLocalElementCount_(n6, this.getLocalElementCount_(n6) + 1), this.canFlush_(n6) && this.flush_(s4, i2, n6), _;
  }
  static setChildExtents_(t2, e5) {
    const s4 = 0.5 * (t2.xmin + t2.xmax), i2 = 0.5 * (t2.ymin + t2.ymax);
    e5[0].setCoords({ xmin: s4, ymin: i2, xmax: t2.xmax, ymax: t2.ymax }), e5[1].setCoords({ xmin: t2.xmin, ymin: i2, xmax: s4, ymax: t2.ymax }), e5[2].setCoords({ xmin: t2.xmin, ymin: t2.ymin, xmax: s4, ymax: i2 }), e5[3].setCoords({ xmin: s4, ymin: t2.ymin, xmax: t2.xmax, ymax: i2 });
  }
  disconnectElementHandle_(t2) {
    const e5 = this.getQuad_(t2), s4 = this.getFirstElement_(e5), i2 = this.getLastElement_(e5), n6 = this.getPrevElement_(t2), r = this.getNextElement_(t2);
    s4 === t2 ? (-1 !== r ? this.setPrevElement_(r, -1) : this.setLastElement_(e5, -1), this.setFirstElement_(e5, r)) : i2 === t2 ? (this.setNextElement_(n6, -1), this.setLastElement_(e5, n6)) : (this.setPrevElement_(r, n6), this.setNextElement_(n6, r)), this.setPrevElement_(t2, -1), this.setNextElement_(t2, -1), this.setLocalElementCount_(e5, this.getLocalElementCount_(e5) - 1);
  }
  canFlush_(t2) {
    return this.getLocalElementCount_(t2) === __t.m_flushingCount && !this.hasChildren_(t2);
  }
  flush_(t2, e5, s4) {
    let i2;
    const n6 = new n4();
    let r = this.getFirstElement_(s4), o2 = -1, h2 = -1;
    do {
      h2 = this.getData_(r), i2 = this.getElementValue_(h2), n6.setCoords({ env2D: this.getBoundingBoxValue_(h2) }), o2 = this.getNextElement_(r), this.m_bStoreDuplicates ? this.insertDuplicates_(i2, n6, t2, e5, s4, true, r) : this.insert_(i2, n6, t2, e5, s4, true, r), r = o2;
    } while (-1 !== r);
  }
  canPushDown_(t2) {
    return this.getLocalElementCount_(t2) >= __t.m_flushingCount || this.hasChildren_(t2);
  }
  hasChildren_(t2) {
    return -1 !== this.getChild_(t2, 0) || -1 !== this.getChild_(t2, 1) || -1 !== this.getChild_(t2, 2) || -1 !== this.getChild_(t2, 3);
  }
  createChild_(t2, e5) {
    const s4 = this.m_quadTreeNodes.newElement();
    return this.setChild_(t2, e5, s4), this.setSubTreeElementCount_(s4, 0), this.setLocalElementCount_(s4, 0), this.setParent_(s4, t2), this.setHeightAndQuadrant_(s4, this.getHeight_(t2) + 1, e5), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(s4, 0), s4;
  }
  createRoot_() {
    this.m_root = this.m_quadTreeNodes.newElement(), this.setSubTreeElementCount_(this.m_root, 0), this.setLocalElementCount_(this.m_root, 0), this.setHeightAndQuadrant_(this.m_root, 0, 0), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(this.m_root, 0);
  }
  createElement_() {
    const t2 = this.m_elementNodes.newElement();
    let e5;
    return this.m_freeData.length > 0 ? (e5 = this.m_freeData.at(-1), this.m_freeData.pop()) : (e5 = this.m_data.length, this.m_data.length = e5 + 1), this.setData_(t2, e5), t2;
  }
  createElementFromDuplicate_(t2) {
    const e5 = this.m_elementNodes.newElement(), s4 = this.getData_(t2);
    return this.setData_(e5, s4), e5;
  }
  freeElementAndBoxNode_(t2) {
    n2(0);
  }
  getChild_(t2, e5) {
    return this.m_quadTreeNodes.getField(t2, e5);
  }
  setChild_(t2, e5, s4) {
    this.m_quadTreeNodes.setField(t2, e5, s4);
  }
  getFirstElement_(t2) {
    return this.m_quadTreeNodes.getField(t2, 4);
  }
  setFirstElement_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 4, e5);
  }
  getLastElement_(t2) {
    return this.m_quadTreeNodes.getField(t2, 5);
  }
  setLastElement_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 5, e5);
  }
  getQuadrant_(t2) {
    return this.m_quadTreeNodes.getField(t2, 6) & __t.m_quadrantMask;
  }
  getHeight_(t2) {
    return this.m_quadTreeNodes.getField(t2, 6) >> __t.m_heightBitShift;
  }
  setHeightAndQuadrant_(t2, e5, s4) {
    const i2 = e5 << __t.m_heightBitShift | s4;
    this.m_quadTreeNodes.setField(t2, 6, i2);
  }
  getLocalElementCount_(t2) {
    return this.m_quadTreeNodes.getField(t2, 7);
  }
  setLocalElementCount_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 7, e5);
  }
  getSubTreeElementCount_(t2) {
    return this.m_quadTreeNodes.getField(t2, 8);
  }
  setSubTreeElementCount_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 8, e5);
  }
  getParent_(t2) {
    return this.m_quadTreeNodes.getField(t2, 9);
  }
  setParent_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 9, e5);
  }
  getContainedSubTreeElementCount_(t2) {
    return this.m_quadTreeNodes.getField(t2, 10);
  }
  setContainedSubTreeElementCount_(t2, e5) {
    this.m_quadTreeNodes.setField(t2, 10, e5);
  }
  getData_(t2) {
    return this.m_elementNodes.getField(t2, 0);
  }
  setData_(t2, e5) {
    this.m_elementNodes.setField(t2, 0, e5);
  }
  getPrevElement_(t2) {
    return this.m_elementNodes.getField(t2, 1);
  }
  getNextElement_(t2) {
    return this.m_elementNodes.getField(t2, 2);
  }
  setPrevElement_(t2, e5) {
    this.m_elementNodes.setField(t2, 1, e5);
  }
  setNextElement_(t2, e5) {
    this.m_elementNodes.setField(t2, 2, e5);
  }
  getQuad_(t2) {
    return this.m_elementNodes.getField(t2, 3);
  }
  setQuad_(t2, e5) {
    this.m_elementNodes.setField(t2, 3, e5);
  }
  getElementValue_(t2) {
    return this.m_data[t2].element;
  }
  getBoundingBoxValue_(t2) {
    return this.m_data[t2].box;
  }
  setDataValues_(t2, e5, s4) {
    this.m_data[t2] = mt(e5, s4);
  }
};
_t2.m_quadrantMask = 3, _t2.m_heightBitShift = 2, _t2.m_flushingCount = 5;
var lt = class {
  constructor(t2, e5, s4) {
    this.m_bLinear = false, this.m_queryStart = new ei(), this.m_queryEnd = new ei(), this.m_queryBox = new n4(), this.m_tolerance = 0, this.m_currentElementHandle = -1, this.m_nextElementHandle = -1, this.m_quadsStack = [], this.m_extentsStack = [], this.m_childExtents = [new n4(), new n4(), new n4(), new n4()], this.m_quadTree = t2, e5 && this.resetIterator(e5, s4);
  }
  resetIterator(t2, e5) {
    if (void 0 === e5 && (e5 = 0), t2 instanceof n4) return this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, this.m_queryBox.setCoords({ env2D: t2 }), this.m_queryBox.inflateCoords(e5, e5), this.m_tolerance = Number.NaN, void (-1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent) ? (this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root), this.m_bLinear = false) : this.m_nextElementHandle = -1);
    if (this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, t2.queryLooseEnvelope(this.m_queryBox), this.m_queryBox.inflateCoords(e5, e5), -1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)) {
      const s4 = t2.getGeometryType();
      if (this.m_bLinear = s4 === a.enumLine, this.m_bLinear) {
        const s5 = t2;
        this.m_queryStart.assign(s5.getStartXY()), this.m_queryEnd.assign(s5.getEndXY()), this.m_tolerance = e5;
      } else this.m_tolerance = Number.NaN;
      this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root);
    } else this.m_nextElementHandle = -1;
  }
  next() {
    if (0 === this.m_quadsStack.length) return -1;
    this.m_currentElementHandle = this.m_nextElementHandle;
    const t2 = new ei(), e5 = new ei(), s4 = new n4();
    let i2 = false;
    for (; !i2; ) {
      for (; -1 !== this.m_currentElementHandle; ) {
        const n6 = this.m_quadTree.getData_(this.m_currentElementHandle);
        if (s4.setCoords({ env2D: this.m_quadTree.getBoundingBoxValue_(n6) }), s4.isIntersecting(this.m_queryBox)) {
          if (!this.m_bLinear) {
            i2 = true;
            break;
          }
          if (t2.setCoordsPoint2D(this.m_queryStart), e5.setCoordsPoint2D(this.m_queryEnd), s4.inflateCoords(this.m_tolerance, this.m_tolerance), s4.clipLine(t2, e5) > 0) {
            i2 = true;
            break;
          }
        }
        this.m_currentElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle);
      }
      if (-1 === this.m_currentElementHandle) {
        const s5 = this.m_quadsStack.at(-1), i3 = this.m_extentsStack.at(-1);
        _t2.setChildExtents_(i3, this.m_childExtents), this.m_quadsStack.pop(), this.m_extentsStack.pop();
        for (let n6 = 0; n6 < 4; n6++) {
          const i4 = this.m_quadTree.getChild_(s5, n6);
          if (-1 !== i4 && this.m_quadTree.getSubTreeElementCount(i4) > 0 && this.m_childExtents[n6].isIntersecting(this.m_queryBox)) if (this.m_bLinear) {
            t2.setCoordsPoint2D(this.m_queryStart), e5.setCoordsPoint2D(this.m_queryEnd);
            const s6 = new n4();
            s6.setCoords({ env2D: this.m_childExtents[n6] }), s6.inflateCoords(this.m_tolerance, this.m_tolerance), s6.clipLine(t2, e5) > 0 && (this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n6].clone()));
          } else this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n6].clone());
        }
        if (0 === this.m_quadsStack.length) return -1;
        this.m_currentElementHandle = this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1));
      }
    }
    return this.m_nextElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle), this.m_currentElementHandle;
  }
  clone() {
    return n2(0), {};
  }
};
var ut = class {
  constructor(t2) {
    this.m_bucketSort = new ht(), this.m_sortedHandles = new st2(0), this.m_index = -1, this.m_quadTreeIteratorImpl = t2;
  }
  resetIterator(t2, e5) {
    this.m_quadTreeIteratorImpl.resetIterator(t2, e5), this.m_sortedHandles.resize(0), this.m_index = -1;
  }
  next() {
    if (-1 === this.m_index) {
      let t2 = -1;
      for (; -1 !== (t2 = this.m_quadTreeIteratorImpl.next()); ) this.m_sortedHandles.add(t2);
      const e5 = this, s4 = { userSort(t3, s5, i2) {
        i2.sort(t3, s5, (t4, s6) => e5.m_quadTreeIteratorImpl.m_quadTree.getElement(t4) - e5.m_quadTreeIteratorImpl.m_quadTree.getElement(s6));
      }, getValue: (t3) => e5.m_quadTreeIteratorImpl.m_quadTree.getElement(t3) };
      this.m_bucketSort.sort(this.m_sortedHandles, 0, this.m_sortedHandles.size(), s4);
    }
    return this.m_index === this.m_sortedHandles.size() - 1 ? -1 : (this.m_index++, this.m_sortedHandles.read(this.m_index));
  }
  clone() {
    return n2(0), {};
  }
};
var dt = class {
  constructor(t2 = false) {
    this.m_bNotifyOnActions = t2;
  }
  onDelete(t2) {
  }
  onSet(t2) {
  }
  onEndSearch(t2) {
  }
  onAddUniqueElementFailed(t2) {
  }
  onDeleteImpl(t2, e5) {
    this.m_bNotifyOnActions && this.onDelete(t2.getElement(e5));
  }
  onSetImpl(t2, e5) {
    this.m_bNotifyOnActions && this.onSet(t2.getElement(e5));
  }
  onAddUniqueElementFailedImpl(t2) {
    this.m_bNotifyOnActions && this.onAddUniqueElementFailed(t2);
  }
  onEndSearchImpl(t2) {
    this.m_bNotifyOnActions && this.onEndSearch(t2);
  }
};
var ct2 = class _ct {
  static st_nullNode() {
    return -1;
  }
  constructor() {
    this.m_defaultTreap = -1, this.m_random = 124234251, this.m_comparator = null, this.m_treapData = new at(7), this.m_treapCount = 0, this.m_maxDepthEver = 0, this.m_bBalancing = true;
  }
  setComparator(t2) {
    this.m_comparator = t2;
  }
  getComparator() {
    return this.m_comparator;
  }
  disableBalancing() {
    this.m_bBalancing = false;
  }
  enableBalancing() {
    this.m_bBalancing || (n2(this.m_treapCount <= 1), this.rebalance(-1), this.m_bBalancing = true);
  }
  isAutoBalancing() {
    return this.m_bBalancing;
  }
  rebalance(t2) {
    if (this.m_bBalancing) return;
    if (-1 === t2 && (t2 = this.m_defaultTreap), 0 === this.size(t2)) return;
    const e5 = [];
    for (let s4 = this.getFirst(t2); -1 !== s4; s4 = this.getNext(s4)) e5.push(s4), this.setParent_(s4, -1), this.setRight_(s4, -1), this.setLeft_(s4, -1);
    this.setRoot_(-1, t2), this.setFirst_(-1, t2), this.setLast_(-1, t2), this.setSize_(0, t2), this.m_bBalancing = true;
    for (const s4 of e5) this.addBiggestElement_(s4, t2);
    this.m_bBalancing = false;
  }
  setCapacity(t2) {
    this.m_treapData.setCapacity(t2);
  }
  createTreap(t2) {
    const e5 = this.m_treapData.newElement();
    return this.setSize_(0, e5), this.setTreapData_(t2, e5), this.m_treapCount++, e5;
  }
  deleteTreap(t2) {
    this.m_treapData.deleteElement(t2), this.m_treapCount--;
  }
  addElement(t2, e5 = -1) {
    return -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap), this.addElement_(t2, 0, e5);
  }
  addUniqueElement(t2, e5 = -1) {
    return -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap), this.addElement_(t2, 1, e5);
  }
  addBiggestElement(t2, e5 = -1) {
    -1 === e5 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e5 = this.m_defaultTreap);
    const s4 = this.newNode_(t2);
    return this.addBiggestElement_(s4, e5), s4;
  }
  addElementAtPosition(t2, e5, s4, i2, n6, r = -1) {
    if (-1 === r && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), r = this.m_defaultTreap), this.getRoot_(r) === _ct.st_nullNode()) {
      const t3 = this.newNode_(s4);
      return this.setRoot_(t3, r), this.addToList_(-1, t3, r), t3;
    }
    let o2, h2, a2, m2, _;
    if (n6 ? (o2 = e5 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s4, e5) : -1, h2 = t2 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s4, t2) : 1) : (o2 = -1, h2 = 1), i2 && (0 === o2 || 0 === h2)) {
      this.m_comparator.onAddUniqueElementFailedImpl(s4);
      const i3 = 0 === o2 ? e5 : t2;
      return this.setDuplicateElement_(i3, r), -1;
    }
    _ = e5 !== _ct.st_nullNode() && t2 !== _ct.st_nullNode() ? this.m_random > qs(this.m_random) >> 1 : e5 !== _ct.st_nullNode(), _ ? (m2 = o2, a2 = e5) : (m2 = h2, a2 = t2);
    let l2 = -1, u = -1, c = true;
    for (; ; ) {
      if (m2 < 0) {
        const t3 = this.getLeft(a2);
        if (t3 === _ct.st_nullNode()) {
          u = a2, l2 = this.newNode_(s4), this.setLeft_(a2, l2), this.setParent_(l2, a2);
          break;
        }
        a2 = t3;
      } else {
        const t3 = this.getRight(a2);
        if (t3 === _ct.st_nullNode()) {
          u = this.getNext(a2), l2 = this.newNode_(s4), this.setRight_(a2, l2), this.setParent_(l2, a2);
          break;
        }
        a2 = t3;
      }
      c && (m2 *= -1, c = false);
    }
    return this.bubbleUp_(l2), this.getParent(l2) === _ct.st_nullNode() && this.setRoot_(l2, r), this.addToList_(u, l2, r), l2;
  }
  replaceElementAtPosition(t2, e5, s4, i2, n6 = -1) {
    if (i2) {
      const i3 = this.getNext(t2);
      let r = -1;
      i3 !== _ct.st_nullNode() && (r = this.m_comparator.compare(this, e5, i3));
      const o2 = this.getPrev(t2);
      let h2 = -1;
      if (o2 !== _ct.st_nullNode() && (h2 = this.m_comparator.compare(this, e5, o2)), s4 && (0 === r || 0 === h2)) {
        this.m_comparator.onAddUniqueElementFailedImpl(e5);
        const t3 = 0 === r ? i3 : o2;
        return n6 === _ct.st_nullNode() && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), n6 = this.m_defaultTreap), this.setDuplicateElement_(t3, n6), -1;
      }
    }
    return this.setElement_(t2, e5), t2;
  }
  getDuplicateElement(t2 = -1) {
    return -1 === t2 ? this.getDuplicateElement_(this.m_defaultTreap) : this.getDuplicateElement_(t2);
  }
  deleteNode(t2, e5 = -1) {
    this.m_comparator && this.m_comparator.onDeleteImpl(this, t2), -1 === e5 && (e5 = this.m_defaultTreap), this.m_bBalancing ? this.deleteNode_(t2, e5) : this.unbalancedDelete_(t2, e5);
  }
  search(t2, e5 = -1) {
    let s4 = this.getRoot(e5);
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = this.m_comparator.compare(this, t2, s4);
      if (!e6) return s4;
      s4 = e6 < 0 ? this.getLeft(s4) : this.getRight(s4);
    }
    return this.m_comparator.onEndSearchImpl(t2), _ct.st_nullNode();
  }
  searchLowerBound(t2, e5 = -1) {
    let s4 = this.getRoot(e5), i2 = -1;
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = t2.compare(this, s4);
      if (!e6) return s4;
      e6 < 0 ? s4 = this.getLeft(s4) : (i2 = s4, s4 = this.getRight(s4));
    }
    return i2;
  }
  searchUpperBound(t2, e5 = -1) {
    let s4 = this.getRoot(e5), i2 = -1;
    for (; s4 !== _ct.st_nullNode(); ) {
      const e6 = t2.compare(this, s4);
      if (!e6) return s4;
      e6 < 0 ? (i2 = s4, s4 = this.getLeft(s4)) : s4 = this.getRight(s4);
    }
    return i2;
  }
  getElement(t2) {
    return this.m_treapData.getField(t2, 3);
  }
  getLeft(t2) {
    return this.m_treapData.getField(t2, 0);
  }
  getRight(t2) {
    return this.m_treapData.getField(t2, 1);
  }
  getParent(t2) {
    return this.m_treapData.getField(t2, 2);
  }
  getNext(t2) {
    return this.m_treapData.getField(t2, 6);
  }
  getPrev(t2) {
    return this.m_treapData.getField(t2, 5);
  }
  getFirst(t2 = -1) {
    return -1 === t2 ? this.getFirst_(this.m_defaultTreap) : this.getFirst_(t2);
  }
  getLast(t2 = -1) {
    return -1 === t2 ? this.getLast_(this.m_defaultTreap) : this.getLast_(t2);
  }
  getTreapData(t2 = -1) {
    return -1 === t2 ? this.getTreapData_(this.m_defaultTreap) : this.getTreapData_(t2);
  }
  setElement(t2, e5) {
    null !== this.m_comparator && this.m_comparator.onSetImpl(this, t2), this.setElement_(t2, e5);
  }
  getRoot(t2 = -1) {
    return -1 === t2 ? this.getRoot_(this.m_defaultTreap) : this.getRoot_(t2);
  }
  clear() {
    this.m_treapData.deleteAll(false), this.m_defaultTreap = _ct.st_nullNode(), this.m_treapCount = 0, this.m_maxDepthEver = 0;
  }
  addToList_(t2, e5, s4) {
    let i2;
    -1 !== t2 ? (i2 = this.getPrev(t2), this.setPrev_(t2, e5)) : i2 = this.getLast_(s4), this.setPrev_(e5, i2), -1 !== i2 && this.setNext_(i2, e5), this.setNext_(e5, t2), t2 === this.getFirst_(s4) && this.setFirst_(e5, s4), -1 === t2 && this.setLast_(e5, s4), this.setSize_(this.getSize_(s4) + 1, s4);
  }
  size(t2 = -1) {
    return -1 === t2 ? this.getSize_(this.m_defaultTreap) : this.getSize_(t2);
  }
  getMaxDepth(t2 = -1) {
    return this.getMaxDepthHelper_(this.getRoot(t2));
  }
  getMaxDepthEver() {
    return this.m_maxDepthEver;
  }
  static st_isValidNode(t2) {
    return at.isValidElement(t2);
  }
  dbgCheck_(t2) {
  }
  getPriority_(t2) {
    return this.m_treapData.getField(t2, 4);
  }
  bubbleDown_(t2) {
    let e5 = this.getLeft(t2), s4 = this.getRight(t2);
    const i2 = this.getPriority_(t2);
    for (; e5 !== _ct.st_nullNode() || s4 !== _ct.st_nullNode(); ) {
      const n6 = e5 !== _ct.st_nullNode() ? this.getPriority_(e5) : os(), r = s4 !== _ct.st_nullNode() ? this.getPriority_(s4) : os();
      if (i2 <= Math.min(n6, r)) return;
      n6 <= r ? this.rotateRight_(e5) : this.rotateLeft_(t2), e5 = this.getLeft(t2), s4 = this.getRight(t2);
    }
  }
  bubbleUp_(t2) {
    if (!this.m_bBalancing) return;
    const e5 = this.getPriority_(t2);
    let s4 = this.getParent(t2);
    for (; s4 !== _ct.st_nullNode() && this.getPriority_(s4) > e5; ) this.getLeft(s4) === t2 ? this.rotateRight_(t2) : this.rotateLeft_(s4), s4 = this.getParent(t2);
  }
  rotateLeft_(t2) {
    const e5 = t2, s4 = this.getRight(t2);
    let i2;
    this.setParent_(s4, this.getParent(e5)), this.setParent_(e5, s4), i2 = this.getLeft(s4), this.setRight_(e5, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e5), this.setLeft_(s4, e5), i2 = this.getParent(s4), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e5 ? this.setLeft_(i2, s4) : this.setRight_(i2, s4));
  }
  rotateRight_(t2) {
    const e5 = this.getParent(t2), s4 = t2;
    let i2;
    this.setParent_(s4, this.getParent(e5)), this.setParent_(e5, s4), i2 = this.getRight(s4), this.setLeft_(e5, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e5), this.setRight_(s4, e5), i2 = this.getParent(s4), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e5 ? this.setLeft_(i2, s4) : this.setRight_(i2, s4));
  }
  setParent_(t2, e5) {
    this.m_treapData.setField(t2, 2, e5);
  }
  setLeft_(t2, e5) {
    this.m_treapData.setField(t2, 0, e5);
  }
  setRight_(t2, e5) {
    this.m_treapData.setField(t2, 1, e5);
  }
  setPriority_(t2, e5) {
    this.m_treapData.setField(t2, 4, e5);
  }
  setPrev_(t2, e5) {
    this.m_treapData.setField(t2, 5, e5);
  }
  setNext_(t2, e5) {
    this.m_treapData.setField(t2, 6, e5);
  }
  setRoot_(t2, e5) {
    this.m_treapData.setField(e5, 0, t2);
  }
  setFirst_(t2, e5) {
    this.m_treapData.setField(e5, 1, t2);
  }
  setLast_(t2, e5) {
    this.m_treapData.setField(e5, 2, t2);
  }
  setDuplicateElement_(t2, e5) {
    this.m_treapData.setField(e5, 3, t2);
  }
  setSize_(t2, e5) {
    this.m_treapData.setField(e5, 4, t2);
  }
  setTreapData_(t2, e5) {
    this.m_treapData.setField(e5, 5, t2);
  }
  getRoot_(t2) {
    return -1 === t2 ? _ct.st_nullNode() : this.m_treapData.getField(t2, 0);
  }
  getFirst_(t2) {
    return -1 === t2 ? _ct.st_nullNode() : this.m_treapData.getField(t2, 1);
  }
  getLast_(t2) {
    return -1 === t2 ? _ct.st_nullNode() : this.m_treapData.getField(t2, 2);
  }
  getDuplicateElement_(t2) {
    return -1 === t2 ? _ct.st_nullNode() : this.m_treapData.getField(t2, 3);
  }
  getSize_(t2) {
    return -1 === t2 ? 0 : this.m_treapData.getField(t2, 4);
  }
  getTreapData_(t2) {
    return this.m_treapData.getField(t2, 5);
  }
  newNode_(t2) {
    const e5 = this.m_treapData.newElement();
    return this.setPriority_(e5, this.generatePriority_()), this.setElement_(e5, t2), e5;
  }
  freeNode_(t2, e5) {
    t2 !== _ct.st_nullNode() && this.m_treapData.deleteElement(t2);
  }
  generatePriority_() {
    return this.m_random = qs(this.m_random), this.m_random & os() >> 1;
  }
  maxPriority() {
    return n2(0), 0;
  }
  getMaxDepthHelper_(t2) {
    return t2 === _ct.st_nullNode() ? 0 : 1 + Math.max(this.getMaxDepthHelper_(this.getLeft(t2)), this.getMaxDepthHelper_(this.getRight(t2)));
  }
  addElement_(t2, e5, s4) {
    if (this.getRoot(s4) === _ct.st_nullNode()) {
      const e6 = this.newNode_(t2);
      return this.setRoot_(e6, s4), this.addToList_(-1, e6, s4), this.m_maxDepthEver = Math.max(this.m_maxDepthEver, 1), e6;
    }
    let i2 = this.getRoot_(s4), n6 = -1, r = -1, o2 = 1;
    for (; ; ) {
      const h2 = -1 === e5 ? 1 : this.m_comparator.compare(this, t2, i2);
      if (h2 < 0) {
        const e6 = this.getLeft(i2);
        if (e6 === _ct.st_nullNode()) {
          r = i2, n6 = this.newNode_(t2), this.setLeft_(i2, n6), this.setParent_(n6, i2);
          break;
        }
        i2 = e6;
      } else {
        if (1 === e5 && 0 === h2) return this.m_comparator.onAddUniqueElementFailedImpl(t2), this.setDuplicateElement_(i2, s4), -1;
        const o3 = this.getRight(i2);
        if (o3 === _ct.st_nullNode()) {
          r = this.getNext(i2), n6 = this.newNode_(t2), this.setRight_(i2, n6), this.setParent_(n6, i2);
          break;
        }
        i2 = o3;
      }
      o2++;
    }
    return this.bubbleUp_(n6), this.getParent(n6) === _ct.st_nullNode() && this.setRoot_(n6, s4), this.addToList_(r, n6, s4), this.m_maxDepthEver = Math.max(o2, this.m_maxDepthEver), n6;
  }
  removeFromList_(t2, e5) {
    const s4 = this.getPrev(t2), i2 = this.getNext(t2);
    -1 !== s4 ? this.setNext_(s4, i2) : this.setFirst_(i2, e5), -1 !== i2 ? this.setPrev_(i2, s4) : this.setLast_(s4, e5), this.setSize_(this.getSize_(e5) - 1, e5);
  }
  unbalancedDelete_(t2, e5) {
    this.removeFromList_(t2, e5);
    let s4 = this.getLeft(t2), i2 = this.getRight(t2), n6 = this.getParent(t2), r = t2;
    if (-1 !== s4 && -1 !== i2) {
      let o3;
      this.m_random = qs(this.m_random), o3 = this.m_random > os() >> 1 ? this.getNext(t2) : this.getPrev(t2);
      const h2 = this.getParent(o3) === t2;
      this.m_treapData.swapField(t2, o3, 0), this.m_treapData.swapField(t2, o3, 1), this.m_treapData.swapField(t2, o3, 2), -1 !== n6 ? this.getLeft(n6) === t2 ? this.setLeft_(n6, o3) : this.setRight_(n6, o3) : this.setRoot_(o3, e5), h2 ? (s4 === o3 ? (this.setLeft_(o3, t2), this.setParent_(i2, o3)) : i2 === o3 && (this.setRight_(o3, t2), this.setParent_(s4, o3)), this.setParent_(t2, o3), n6 = o3) : (this.setParent_(s4, o3), this.setParent_(i2, o3), n6 = this.getParent(t2), r = o3), s4 = this.getLeft(t2), i2 = this.getRight(t2), -1 !== s4 && this.setParent_(s4, t2), -1 !== i2 && this.setParent_(i2, t2);
    }
    const o2 = -1 !== s4 ? s4 : i2;
    -1 === n6 ? this.setRoot_(o2, e5) : this.getLeft(n6) === r ? this.setLeft_(n6, o2) : this.setRight_(n6, o2), -1 !== o2 && this.setParent_(o2, n6), this.freeNode_(t2, e5);
  }
  deleteNode_(t2, e5) {
    this.setPriority_(t2, os());
    let s4 = _ct.st_nullNode(), i2 = _ct.st_nullNode();
    const n6 = this.getRoot_(e5), r = n6 === t2;
    if (r && (s4 = this.getLeft(n6), i2 = this.getRight(n6), s4 === _ct.st_nullNode() && i2 === _ct.st_nullNode())) return this.removeFromList_(n6, e5), this.freeNode_(n6, e5), void this.setRoot_(_ct.st_nullNode(), e5);
    this.bubbleDown_(t2);
    const o2 = this.getParent(t2);
    o2 !== _ct.st_nullNode() && (this.getLeft(o2) === t2 ? this.setLeft_(o2, _ct.st_nullNode()) : this.setRight_(o2, _ct.st_nullNode())), this.removeFromList_(t2, e5), this.freeNode_(t2, e5), r && this.setRoot_(s4 === _ct.st_nullNode() || this.getParent(s4) !== _ct.st_nullNode() ? i2 : s4, e5);
  }
  setElement_(t2, e5) {
    this.m_treapData.setField(t2, 3, e5);
  }
  addBiggestElement_(t2, e5) {
    if (this.getRoot_(e5) === _ct.st_nullNode()) return this.setRoot_(t2, e5), void this.addToList_(-1, t2, e5);
    const s4 = this.getLast_(e5);
    this.setRight_(s4, t2), this.setParent_(t2, s4), this.bubbleUp_(t2), this.getParent(t2) === _ct.st_nullNode() && this.setRoot_(t2, e5), this.addToList_(-1, t2, e5);
  }
};
var pt2 = class _pt {
  constructor(t2) {
    this.m_lists = new at(6), this.m_listOfLists = _pt.st_nullNode(), void 0 === t2 ? (this.m_listNodes = new at(3), this.m_bStoreListIndexWithNode = false) : (this.m_listNodes = new at(t2 ? 4 : 3), this.m_bStoreListIndexWithNode = t2);
  }
  freeNode_(t2) {
    this.m_listNodes.deleteElement(t2);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(t2) {
    n2(0);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  setPrev_(t2, e5) {
    this.m_listNodes.setField(t2, 1, e5);
  }
  setNext_(t2, e5) {
    this.m_listNodes.setField(t2, 2, e5);
  }
  setData_(t2, e5) {
    n2(0);
  }
  setList_(t2, e5) {
    return this.m_listNodes.setField(t2, 3, e5);
  }
  setListSize_(t2, e5) {
    this.m_lists.setField(t2, 4, e5);
  }
  setNextList_(t2, e5) {
    n2(0);
  }
  setPrevList_(t2, e5) {
    this.m_lists.setField(t2, 2, e5);
  }
  createList(t2) {
    const e5 = this.newList_();
    return this.m_lists.setField(e5, 3, this.m_listOfLists), this.m_lists.setField(e5, 4, 0), this.m_lists.setField(e5, 5, t2), this.m_listOfLists !== _pt.st_nullNode() && this.setPrevList_(this.m_listOfLists, e5), this.m_listOfLists = e5, e5;
  }
  deleteList(t2) {
    this.clear(t2);
    const e5 = this.m_lists.getField(t2, 2), s4 = this.m_lists.getField(t2, 3);
    return e5 !== _pt.st_nullNode() ? this.setNextList_(e5, s4) : this.m_listOfLists = s4, s4 !== _pt.st_nullNode() && this.setPrevList_(s4, e5), this.freeList_(t2), s4;
  }
  reserveLists(t2) {
    n2(0);
  }
  getListData(t2) {
    return this.m_lists.getField(t2, 5);
  }
  getList(t2) {
    return n2(0), 0;
  }
  setListData(t2, e5) {
    this.m_lists.setField(t2, 5, e5);
  }
  addElement(t2, e5) {
    return this.insertElement(t2, -1, e5);
  }
  insertElement(t2, e5, s4) {
    const i2 = this.newNode_();
    let n6 = -1;
    e5 !== _pt.st_nullNode() && (n6 = this.getPrev(e5), this.setPrev_(e5, i2)), this.setNext_(i2, e5), n6 !== _pt.st_nullNode() && this.setNext_(n6, i2);
    if (e5 === this.m_lists.getField(t2, 0) && this.m_lists.setField(t2, 0, i2), e5 === _pt.st_nullNode()) {
      const e6 = this.m_lists.getField(t2, 1);
      this.setPrev_(i2, e6), -1 !== e6 && this.setNext_(e6, i2), this.m_lists.setField(t2, 1, i2);
    }
    return this.setData(i2, s4), this.setListSize_(t2, this.getListSize(t2) + 1), this.m_bStoreListIndexWithNode && this.setList_(i2, t2), i2;
  }
  deleteElement(t2, e5) {
    const s4 = this.getPrev(e5), i2 = this.getNext(e5);
    return s4 !== _pt.st_nullNode() ? this.setNext_(s4, i2) : this.m_lists.setField(t2, 0, i2), i2 !== _pt.st_nullNode() ? this.setPrev_(i2, s4) : this.m_lists.setField(t2, 1, s4), this.freeNode_(e5), this.setListSize_(t2, this.getListSize(t2) - 1), i2;
  }
  reserveNodes(t2) {
    this.m_listNodes.setCapacity(t2);
  }
  getData(t2) {
    return this.m_listNodes.getField(t2, 0);
  }
  getElement(t2) {
    return this.getData(t2);
  }
  setData(t2, e5) {
    this.m_listNodes.setField(t2, 0, e5);
  }
  getNext(t2) {
    return this.m_listNodes.getField(t2, 2);
  }
  getPrev(t2) {
    return this.m_listNodes.getField(t2, 1);
  }
  getFirst(t2) {
    return this.m_lists.getField(t2, 0);
  }
  getLast(t2) {
    return this.m_lists.getField(t2, 1);
  }
  static st_nullNode() {
    return -1;
  }
  clear(t2) {
    if (void 0 !== t2) {
      let e5 = this.getLast(t2);
      for (; e5 !== _pt.st_nullNode(); ) {
        const t3 = e5;
        e5 = this.getPrev(t3), this.freeNode_(t3);
      }
      return this.m_lists.setField(t2, 0, -1), this.m_lists.setField(t2, 1, -1), void this.setListSize_(t2, 0);
    }
    for (let e5 = this.getFirstList(); -1 !== e5; ) e5 = this.deleteList(e5);
  }
  isEmpty(t2) {
    return n2(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getListSize(t2) {
    return this.m_lists.getField(t2, 4);
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(t2) {
    return this.m_lists.getField(t2, 3);
  }
};
var gt = class extends dt {
  constructor(t2) {
    super(), this.m_intervalTree = t2;
  }
  compare(t2, e5, s4) {
    const i2 = t2.getElement(s4), n6 = this.m_intervalTree.getValue_(e5), r = this.m_intervalTree.getValue_(i2);
    return n6 < r ? -1 : n6 === r ? ft2.isLeft_(e5) && ft2.isRight_(i2) ? -1 : ft2.isLeft_(i2) && ft2.isRight_(e5) ? 1 : 0 : 1;
  }
};
var ft2 = class _ft {
  constructor(t2) {
    this.m_bEnvelopesRef = false, this.m_intervals = [], this.m_envelopesRef = null, this.m_intervalNodes = new at(3), this.m_intervalHandles = [], this.m_endIndicesUnique = [], this.m_cCount = -1, this.m_root = -1, this.m_bSortIntervals = false, this.m_bConstructing = false, this.m_bConstructionEnded = false, this.m_bOfflineDynamic = t2, this.m_tertiaryNodes = new at(this.m_bOfflineDynamic ? 5 : 4), this.m_secondaryTreaps = new ct2(), this.m_secondaryTreaps.setComparator(new gt(this)), this.m_secondaryLists = new pt2();
  }
  addEnvelopesRef(t2) {
    this.reset_(true, true), this.m_bEnvelopesRef = true, this.m_envelopesRef = t2, this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_envelopesRef.length);
  }
  startConstruction() {
    this.reset_(true, false);
  }
  addInterval(t2) {
    this.m_bConstructing || C(""), this.m_intervals.push(t2.clone());
  }
  addIntervalCoords(t2, e5) {
    n2(0);
  }
  endConstruction() {
    this.m_bConstructing || C(""), this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_intervals.length);
  }
  insert(t2) {
    if (this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), -1 === this.m_root) {
      const t3 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
      if (this.m_bSortIntervals) {
        const e6 = new st2(0);
        this.querySortedEndPointIndices_(e6), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(e6), this.m_intervalHandles.length = t3, this.m_intervalHandles.fill(-1), this.m_bSortIntervals = false;
      } else this.m_intervalHandles.fill(-1, 0, t3);
      this.m_root = this.createRoot_();
    }
    const e5 = this.insertIntervalEnd_(t2 << 1, this.m_root), s4 = this.getSecondaryFromInterval_(e5), i2 = this.m_secondaryTreaps.addElement(1 + (t2 << 1), s4);
    this.setRightEnd_(e5, i2), this.m_intervalHandles[t2] = e5, this.m_cCount++;
  }
  remove(t2) {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C("");
    const e5 = this.m_intervalHandles[t2];
    let s4;
    -1 === e5 && P("the interval does not exist in the interval tree"), this.m_intervalHandles[t2] = -1, this.m_cCount--;
    let i2 = this.getSecondaryFromInterval_(e5), n6 = -1;
    n6 = this.m_secondaryTreaps.getTreapData(i2), this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(e5), i2), this.m_secondaryTreaps.deleteNode(this.getRightEnd_(e5), i2), s4 = this.m_secondaryTreaps.size(i2), 0 === s4 && (this.m_secondaryTreaps.deleteTreap(i2), this.setSecondaryToTertiary_(n6, -1)), this.m_intervalNodes.deleteElement(e5);
    let r = this.getPptr_(n6), o2 = this.getLptr_(n6), h2 = this.getRptr_(n6);
    for (; !(s4 > 0 || n6 === this.m_root || -1 !== o2 && -1 !== h2); ) n6 === this.getLptr_(r) ? -1 !== o2 ? (this.setLptr_(r, o2), this.setPptr_(o2, r), this.setLptr_(n6, -1), this.setPptr_(n6, -1)) : -1 !== h2 ? (this.setLptr_(r, h2), this.setPptr_(h2, r), this.setRptr_(n6, -1), this.setPptr_(n6, -1)) : (this.setLptr_(r, -1), this.setPptr_(n6, -1)) : -1 !== o2 ? (this.setRptr_(r, o2), this.setPptr_(o2, r), this.setLptr_(n6, -1), this.setPptr_(n6, -1)) : -1 !== h2 ? (this.setRptr_(r, h2), this.setPptr_(h2, r), this.setRptr_(n6, -1), this.setPptr_(n6, -1)) : (this.setRptr_(r, -1), this.setPptr_(n6, -1)), this.m_tertiaryNodes.deleteElement(n6), n6 = r, i2 = this.getSecondaryFromTertiary_(n6), s4 = -1 !== i2 ? this.m_secondaryTreaps.size(i2) : 0, o2 = this.getLptr_(n6), h2 = this.getRptr_(n6), r = this.getPptr_(n6);
  }
  size() {
    return this.m_cCount;
  }
  getIteratorQuery(t2, e5) {
    return t2 instanceof x2 ? new vt2(this, t2, e5) : (n2(0), {});
  }
  getIterator() {
    return new vt2(this);
  }
  querySortedEndPointIndices_(t2) {
    const e5 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
    for (let s4 = 0; s4 < 2 * e5; s4++) t2.add(s4);
    this.sortEndIndices_(t2, 0, 2 * e5);
  }
  querySortedDuplicatesRemoved_(t2) {
    let e5 = Number.NaN;
    for (let s4 = 0; s4 < t2.size(); s4++) {
      const i2 = t2.read(s4), n6 = this.getValue_(i2);
      n6 !== e5 && (this.m_endIndicesUnique.push(i2), e5 = n6);
    }
  }
  insertIntervalsStatic_() {
    const e5 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length, s4 = new st2(0);
    this.querySortedEndPointIndices_(s4), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(s4), this.m_intervalNodes.setCapacity(e5), this.m_secondaryLists.reserveNodes(2 * e5);
    const i2 = Lt(e5, -1);
    this.m_root = this.createRoot_();
    for (let t2 = 0; t2 < s4.size(); t2++) {
      const e6 = s4.read(t2);
      let n6 = i2[e6 >> 1];
      if (-1 !== n6) {
        const t3 = this.getSecondaryFromInterval_(n6);
        this.setRightEnd_(n6, this.m_secondaryLists.addElement(t3, e6));
      } else n6 = this.insertIntervalEnd_(e6, this.m_root), i2[e6 >> 1] = n6;
    }
  }
  createRoot_() {
    const t2 = this.calculateDiscriminantIndex1_(0, this.m_endIndicesUnique.length - 1);
    return this.createTertiaryNode_(t2);
  }
  insertIntervalEnd_(t2, e5) {
    let s4 = -1, i2 = e5, n6 = -1, r = -1, o2 = 0, h2 = this.m_endIndicesUnique.length - 1, a2 = 0;
    const m2 = t2 >> 1;
    let _ = Number.NaN, l2 = Number.NaN, u = true;
    const d2 = this.getMin_(m2), c = this.getMax_(m2);
    let p3 = -1;
    for (; u; ) {
      a2 = o2 + (h2 - o2 >> 1), p3 = this.calculateDiscriminantIndex1_(o2, h2);
      const e6 = this.getDiscriminantFromIndex1_(p3);
      if (c < e6) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s4 = i2, _ = e6, i2 = this.getLptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 > e6) {
            const t3 = this.createTertiaryNode_(p3);
            e6 < _ ? this.setLptr_(s4, t3) : this.setRptr_(s4, t3), this.setRptr_(t3, i2), this.m_bOfflineDynamic && (this.setPptr_(t3, s4), this.setPptr_(i2, t3)), s4 = t3, _ = e6, i2 = -1, l2 = Number.NaN;
          }
        }
        h2 = a2;
        continue;
      }
      if (d2 > e6) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s4 = i2, _ = e6, i2 = this.getRptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 < e6) {
            const t3 = this.createTertiaryNode_(p3);
            e6 < _ ? this.setLptr_(s4, t3) : this.setRptr_(s4, t3), this.setLptr_(t3, i2), this.m_bOfflineDynamic && (this.setPptr_(t3, s4), this.setPptr_(i2, t3)), s4 = t3, _ = e6, i2 = -1, l2 = Number.NaN;
          }
        }
        o2 = a2 + 1;
        continue;
      }
      let m3 = -1;
      m3 = -1 === i2 || p3 !== this.getDiscriminantIndex1_(i2) ? this.createTertiaryNode_(p3) : i2, n6 = this.getSecondaryFromTertiary_(m3), -1 === n6 && (n6 = this.createSecondary_(m3), this.setSecondaryToTertiary_(m3, n6));
      const g2 = this.addEndIndex_(n6, t2);
      r = this.createIntervalNode_(), this.setSecondaryToInterval_(r, n6), this.setLeftEnd_(r, g2), -1 !== i2 && p3 === this.getDiscriminantIndex1_(i2) || (e6 < _ ? this.setLptr_(s4, m3) : this.setRptr_(s4, m3), this.m_bOfflineDynamic && this.setPptr_(m3, s4), -1 !== i2 && (l2 < e6 ? this.setLptr_(m3, i2) : this.setRptr_(m3, i2), this.m_bOfflineDynamic && this.setPptr_(i2, m3))), u = false;
      break;
    }
    return r;
  }
  createTertiaryNode_(t2) {
    const e5 = this.m_tertiaryNodes.newElement();
    return this.setDiscriminantIndex1_(e5, t2), e5;
  }
  createSecondary_(t2) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.createTreap(t2) : this.m_secondaryLists.createList(t2);
  }
  createIntervalNode_() {
    return this.m_intervalNodes.newElement();
  }
  reset() {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), this.reset_(false, this.m_bEnvelopesRef);
  }
  reset_(t2, e5) {
    t2 ? (this.m_bEnvelopesRef = false, this.m_envelopesRef = null, this.m_bSortIntervals = true, this.m_bConstructing = true, this.m_bConstructionEnded = false, this.m_endIndicesUnique.length = 0, e5 ? (this.m_intervals.length = 0, this.m_bEnvelopesRef = true) : this.m_intervals.length = 0) : this.m_bSortIntervals = false, this.m_bOfflineDynamic ? this.m_secondaryTreaps.clear() : this.m_secondaryLists.clear(), this.m_intervalNodes.deleteAll(false), this.m_tertiaryNodes.deleteAll(false), this.m_root = -1, this.m_cCount = 0;
  }
  getDiscriminant_(t2) {
    const e5 = this.getDiscriminantIndex1_(t2);
    return this.getDiscriminantFromIndex1_(e5);
  }
  getDiscriminantFromIndex1_(t2) {
    if (-1 === t2) return Number.NaN;
    if (t2 > 0) {
      const e6 = t2 - 2, s5 = this.m_endIndicesUnique[e6], i2 = this.m_endIndicesUnique[e6 + 1];
      return 0.5 * (this.getValue_(s5) + this.getValue_(i2));
    }
    const e5 = -t2 - 2, s4 = this.m_endIndicesUnique[e5];
    return this.getValue_(s4);
  }
  calculateDiscriminantIndex1_(t2, e5) {
    let s4;
    if (t2 < e5) {
      s4 = t2 + (e5 - t2 >> 1) + 2;
    } else s4 = -(t2 + 2);
    return s4;
  }
  setDiscriminantIndex1_(t2, e5) {
    this.m_tertiaryNodes.setField(t2, 0, e5);
  }
  setSecondaryToTertiary_(t2, e5) {
    this.m_tertiaryNodes.setField(t2, 1, e5);
  }
  setLptr_(t2, e5) {
    this.m_tertiaryNodes.setField(t2, 2, e5);
  }
  setRptr_(t2, e5) {
    this.m_tertiaryNodes.setField(t2, 3, e5);
  }
  setPptr_(t2, e5) {
    this.m_tertiaryNodes.setField(t2, 4, e5);
  }
  setSecondaryToInterval_(t2, e5) {
    this.m_intervalNodes.setField(t2, 0, e5);
  }
  addEndIndex_(t2, e5) {
    let s4 = -1;
    return s4 = this.m_bOfflineDynamic ? this.m_secondaryTreaps.addElement(e5, t2) : this.m_secondaryLists.addElement(t2, e5), s4;
  }
  setLeftEnd_(t2, e5) {
    this.m_intervalNodes.setField(t2, 1, e5);
  }
  setRightEnd_(t2, e5) {
    this.m_intervalNodes.setField(t2, 2, e5);
  }
  getFirst_(t2) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getFirst(t2) : this.m_secondaryLists.getFirst(t2);
  }
  getLast_(t2) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getLast(t2) : this.m_secondaryLists.getLast(t2);
  }
  static isLeft_(t2) {
    return !(1 & t2);
  }
  static isRight_(t2) {
    return !(1 & ~t2);
  }
  getDiscriminantIndex1_(t2) {
    return this.m_tertiaryNodes.getField(t2, 0);
  }
  getSecondaryFromTertiary_(t2) {
    return this.m_tertiaryNodes.getField(t2, 1);
  }
  getLptr_(t2) {
    return this.m_tertiaryNodes.getField(t2, 2);
  }
  getRptr_(t2) {
    return this.m_tertiaryNodes.getField(t2, 3);
  }
  getPptr_(t2) {
    return this.m_tertiaryNodes.getField(t2, 4);
  }
  getSecondaryFromInterval_(t2) {
    return this.m_intervalNodes.getField(t2, 0);
  }
  getLeftEnd_(t2) {
    return this.m_intervalNodes.getField(t2, 1);
  }
  getRightEnd_(t2) {
    return this.m_intervalNodes.getField(t2, 2);
  }
  getMin_(t2) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t2].xmin : this.m_intervals[t2].vmin;
  }
  getMax_(t2) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t2].xmax : this.m_intervals[t2].vmax;
  }
  sortEndIndices_(t2, e5, s4) {
    const i2 = this, n6 = { userSort(t3, e6, s5) {
      i2.sortEndIndicesHelper_(s5, t3, e6);
    }, getValue: (t3) => i2.getValue_(t3) };
    new ht().sort(t2, e5, s4, n6);
  }
  sortEndIndicesHelper_(t2, e5, s4) {
    t2.sort(e5, s4, (t3, e6) => {
      const s5 = this.getValue_(t3), i2 = this.getValue_(e6);
      return s5 < i2 || s5 === i2 && _ft.isLeft_(t3) && _ft.isRight_(e6) ? -1 : 1;
    });
  }
  getValue_(t2) {
    if (!this.m_bEnvelopesRef) {
      const e6 = this.m_intervals[t2 >> 1];
      return _ft.isLeft_(t2) ? e6.vmin : e6.vmax;
    }
    const e5 = this.m_envelopesRef[t2 >> 1];
    return _ft.isLeft_(t2) ? e5.xmin : e5.xmax;
  }
};
var vt2 = class {
  constructor(t2, e5, s4) {
    this.m_query = x2.constructEmpty(), this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_nextEndHandle = -1, this.m_tertiaryStack = [], this.m_functionIndex = 0, this.m_intervalTree = t2, this.m_functionStack = new Array(2), this.m_functionStack[0] = this.nullFunc_, this.m_functionStack[1] = this.nullFunc_, void 0 !== e5 && this.resetIterator(e5, s4);
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  resetIterator(t2, e5) {
    if ("number" == typeof t2) {
      const s4 = new x2();
      s4.setCoords(t2, t2), this.resetIterator(s4, e5);
    } else void 0 === e5 && (e5 = 0), this.m_query.vmin = t2.vmin - e5, this.m_query.vmax = t2.vmax + e5, this.m_tertiaryStack.length = 0, this.m_functionIndex = 0, this.m_functionStack[0] = this.initialize_;
  }
  next() {
    if (this.m_intervalTree.m_bConstructionEnded || C(""), this.m_functionIndex < 0) return -1;
    for (; this.m_fi = this.m_functionStack[this.m_functionIndex], this.m_fi(); ) ;
    return -1 !== this.m_currentEndHandle ? this.getCurrentEndIndex_() >> 1 : -1;
  }
  initialize_() {
    return this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_intervalTree.m_tertiaryNodes.size() > 0 ? (this.m_functionStack[0] = this.pIn_, this.m_nextTertiaryHandle = this.m_intervalTree.m_root, true) : (this.m_functionIndex = -1, false);
  }
  pIn_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    const t2 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t2) {
      const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    if (t2 < this.m_query.vmin) {
      const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t3), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    this.m_functionStack[this.m_functionIndex] = this.pL_, this.m_forkedHandle = this.m_tertiaryHandle;
    const e5 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== e5 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e5), this.m_functionStack[++this.m_functionIndex] = this.all_), true;
  }
  pL_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pR_, this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_forkedHandle), true;
    if (this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle) < this.m_query.vmin) {
      const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t3), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    const t2 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t2 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t2), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const e5 = this.m_intervalTree.getRptr_(this.m_tertiaryHandle);
    return -1 !== e5 && this.m_tertiaryStack.push(e5), true;
  }
  pR_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pT_, true;
    const t2 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t2) {
      const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    const e5 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== e5 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e5), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const s4 = this.m_intervalTree.getLptr_(this.m_tertiaryHandle);
    return -1 !== s4 && this.m_tertiaryStack.push(s4), true;
  }
  pT_() {
    if (0 === this.m_tertiaryStack.length) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    this.m_tertiaryHandle = this.m_tertiaryStack.at(-1), this.m_tertiaryStack.pop();
    const t2 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return -1 !== t2 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t2), this.m_functionStack[++this.m_functionIndex] = this.all_), -1 !== this.m_intervalTree.getLptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)), -1 !== this.m_intervalTree.getRptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)), true;
  }
  left_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) <= this.m_query.vmax ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  right_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isRight_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) >= this.m_query.vmin ? (this.m_nextEndHandle = this.getPrev_(), false) : (this.m_functionIndex--, true);
  }
  all_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  getNext_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle);
  }
  getPrev_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle);
  }
  getCurrentEndIndex_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle);
  }
};
var yt2 = class {
  constructor() {
    this.m_tolerance = 0, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_intervalTreeRed = null, this.m_intervalTreeBlue = null, this.m_iteratorRed = null, this.m_iteratorBlue = null, this.m_envelopesRed = [], this.m_envelopesBlue = [], this.m_elementsRed = [], this.m_elementsBlue = [], this.m_sortedEndIndicesRed = new st2(0), this.m_sortedEndIndicesBlue = new st2(0), this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_queuedEnvelopes = new pt2(), this.m_queuedIndicesRed = [], this.m_queuedIndicesBlue = [], this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_bDone = true, this.m_function = this.nullFunc_, this.reset_();
  }
  startConstruction() {
    this.reset_(), this.m_bAddRedRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addEnvelope(t2, e5) {
    this.m_bAddRedRed || C(""), this.m_elementsRed.push(t2), this.m_envelopesRed.push(new n4(e5));
  }
  endConstruction() {
    this.m_bAddRedRed || C(""), this.m_bAddRedRed = false, this.m_envelopesRed.length > 0 && (this.m_function = this.initialize_, this.m_bDone = false);
  }
  startRedConstruction() {
    this.reset_(), this.m_bAddRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addRedEnvelope(t2, e5) {
    this.m_bAddRed || C(""), this.m_elementsRed.push(t2), this.m_envelopesRed.push(e5.clone());
  }
  endRedConstruction() {
    this.m_bAddRed || C(""), this.m_bAddRed = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeBlue_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeRed_), this.m_bDone = false);
  }
  startBlueConstruction() {
    this.reset_(), this.m_bAddBlue = true, this.m_elementsBlue.length = 0, this.m_envelopesBlue.length = 0;
  }
  addBlueEnvelope(t2, e5) {
    this.m_bAddBlue || C(""), this.m_elementsBlue.push(t2), this.m_envelopesBlue.push(e5.clone());
  }
  endBlueConstruction() {
    this.m_bAddBlue || C(""), this.m_bAddBlue = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeRed_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeBlue_), this.m_bDone = false);
  }
  next() {
    if (this.m_bDone) return false;
    for (; this.m_function(); ) ;
    return !this.m_bDone;
  }
  getHandleA() {
    return this.m_envelopeHandleA;
  }
  getHandleB() {
    return this.m_envelopeHandleB;
  }
  setTolerance(t2) {
    this.m_tolerance = t2;
  }
  getElement(t2) {
    return this.m_elementsRed[t2];
  }
  getRedEnvelope(t2) {
    return this.m_envelopesRed[t2];
  }
  getBlueEnvelope(t2) {
    return this.m_envelopesBlue[t2];
  }
  getRedElement(t2) {
    return this.m_elementsRed[t2];
  }
  getBlueElement(t2) {
    return this.m_elementsBlue[t2];
  }
  isTop_(t2) {
    return !(1 & ~t2);
  }
  isBottom_(t2) {
    return !(1 & t2);
  }
  reset_() {
    this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_bDone = true;
  }
  initialize_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t2 = 0; t2 < 2 * this.m_envelopesRed.length; t2++) this.m_sortedEndIndicesRed.add(t2);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, 2 * this.m_envelopesRed.length, true), this.m_sweepIndexRed = 2 * this.m_envelopesRed.length, this.m_function = this.sweep_, true;
  }
  initializeRed_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t2 = 0; t2 < 2 * this.m_envelopesRed.length; t2++) this.m_sortedEndIndicesRed.add(t2);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_function = this.sweepRedBlue_, this.resetBlue_();
  }
  initializeBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null == this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesBlue.resize(0);
    for (let t2 = 0; t2 < 2 * this.m_envelopesBlue.length; t2++) this.m_sortedEndIndicesBlue.add(t2);
    return this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, this.resetRed_();
  }
  initializeRedBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), null === this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesRed.resize(0), this.m_sortedEndIndicesBlue.resize(0);
    for (let t2 = 0; t2 < 2 * this.m_envelopesRed.length; t2++) this.m_sortedEndIndicesRed.add(t2);
    for (let t2 = 0; t2 < 2 * this.m_envelopesBlue.length; t2++) this.m_sortedEndIndicesBlue.add(t2);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, true;
  }
  sweep_() {
    const t2 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e5 = t2 >> 1;
    if (this.isBottom_(t2)) return this.m_intervalTreeRed.remove(e5), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    const s4 = x2.construct(this.m_envelopesRed[e5].xmin, this.m_envelopesRed[e5].xmax);
    return this.m_iteratorRed.resetIterator(s4, this.m_tolerance), this.m_envelopeHandleA = e5, this.m_function = this.iterate_, true;
  }
  sweepBruteForce_() {
    return -1 == --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_sweepIndexRed, this.m_function = this.iterateBruteForce_, true);
  }
  sweepRedBlueBruteForce_() {
    return -1 == --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_envelopesBlue.length, this.m_function = this.iterateRedBlueBruteForce_, true);
  }
  sweepRedBlue_() {
    const t2 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed - 1), e5 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue - 1), s4 = this.getAdjustedValue_(t2, true), i2 = this.getAdjustedValue_(e5, false);
    return s4 > i2 ? this.sweepRed_() : s4 < i2 ? this.sweepBlue_() : this.isTop_(t2) ? this.sweepRed_() : this.isTop_(e5) ? this.sweepBlue_() : this.sweepRed_();
  }
  sweepRed_() {
    const t2 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e5 = t2 >> 1;
    if (this.isBottom_(t2)) return -1 !== this.m_queuedListRed && -1 !== this.m_queuedIndicesRed[e5] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, this.m_queuedIndicesRed[e5]), this.m_queuedIndicesRed[e5] = -1) : this.m_intervalTreeRed.remove(e5), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListBlue && this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue) > 0) {
      let t3 = this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);
      for (; -1 !== t3; ) {
        const e6 = this.m_queuedEnvelopes.getData(t3);
        this.m_intervalTreeBlue.insert(e6), this.m_queuedIndicesBlue[e6] = -1;
        const s4 = this.m_queuedEnvelopes.getNext(t3);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, t3), t3 = s4;
      }
    }
    if (this.m_intervalTreeBlue.size() > 0) {
      const t3 = x2.construct(this.m_envelopesRed[e5].xmin, this.m_envelopesRed[e5].xmax);
      this.m_iteratorBlue.resetIterator(t3, this.m_tolerance), this.m_envelopeHandleA = e5, this.m_function = this.iterateBlue_;
    } else -1 === this.m_queuedListRed && (Zt(this.m_queuedIndicesRed, this.m_envelopesRed.length, -1), this.m_queuedListRed = this.m_queuedEnvelopes.createList(1)), this.m_queuedIndicesRed[e5] = this.m_queuedEnvelopes.addElement(this.m_queuedListRed, e5), this.m_function = this.sweepRedBlue_;
    return true;
  }
  sweepBlue_() {
    const t2 = this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue), e5 = t2 >> 1;
    if (this.isBottom_(t2)) return -1 !== this.m_queuedListBlue && -1 !== this.m_queuedIndicesBlue[e5] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, this.m_queuedIndicesBlue[e5]), this.m_queuedIndicesBlue[e5] = -1) : this.m_intervalTreeBlue.remove(e5), 0 !== this.m_sweepIndexBlue || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListRed && this.m_queuedEnvelopes.getListSize(this.m_queuedListRed) > 0) {
      let t3 = this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);
      for (; -1 !== t3; ) {
        const e6 = this.m_queuedEnvelopes.getData(t3);
        this.m_intervalTreeRed.insert(e6), this.m_queuedIndicesRed[e6] = -1;
        const s4 = this.m_queuedEnvelopes.getNext(t3);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, t3), t3 = s4;
      }
    }
    if (this.m_intervalTreeRed.size() > 0) {
      const t3 = x2.construct(this.m_envelopesBlue[e5].xmin, this.m_envelopesBlue[e5].xmax);
      this.m_iteratorRed.resetIterator(t3, this.m_tolerance), this.m_envelopeHandleB = e5, this.m_function = this.iterateRed_;
    } else -1 === this.m_queuedListBlue && (Zt(this.m_queuedIndicesBlue, this.m_envelopesBlue.length, -1), this.m_queuedListBlue = this.m_queuedEnvelopes.createList(0)), this.m_queuedIndicesBlue[e5] = this.m_queuedEnvelopes.addElement(this.m_queuedListBlue, e5), this.m_function = this.sweepRedBlue_;
    return true;
  }
  iterate_() {
    if (this.m_envelopeHandleB = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleB) return false;
    const t2 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t2), this.m_function = this.sweep_, true;
  }
  iterateRed_() {
    if (this.m_envelopeHandleA = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleA) return false;
    this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1;
    const t2 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue) >> 1;
    return this.m_intervalTreeBlue.insert(t2), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBlue_() {
    if (this.m_envelopeHandleB = this.m_iteratorBlue.next(), -1 !== this.m_envelopeHandleB) return false;
    const t2 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t2), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBruteForce_() {
    if (-1 == --this.m_sweepIndexBlue) return this.m_function = this.sweepBruteForce_, true;
    const t2 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e5 = this.m_envelopesRed[this.m_sweepIndexBlue];
    return t2.inflateCoords(this.m_tolerance, this.m_tolerance), !t2.isIntersecting(e5) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  iterateRedBlueBruteForce_() {
    if (-1 == --this.m_sweepIndexBlue) return this.m_function = this.sweepRedBlueBruteForce_, true;
    const t2 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e5 = this.m_envelopesBlue[this.m_sweepIndexBlue];
    return t2.inflateCoords(this.m_tolerance, this.m_tolerance), !t2.isIntersecting(e5) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  resetRed_() {
    return this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_intervalTreeRed.size() > 0 && this.m_intervalTreeRed.reset(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_bDone = false, true;
  }
  resetBlue_() {
    return this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), this.m_intervalTreeBlue.size() > 0 && this.m_intervalTreeBlue.reset(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_bDone = false, true;
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  sortYEndIndices_(t2, e5, s4, i2) {
    const n6 = this, r = { userSort(t3, e6, s5) {
      n6.sortYEndIndicesHelper_(s5, t3, e6, i2);
    }, getValue: (t3) => n6.getAdjustedValue_(t3, i2) };
    new ht().sort(t2, e5, s4, r);
  }
  sortYEndIndicesHelper_(t2, e5, s4, i2) {
    t2.sort(e5, s4, (t3, e6) => {
      const s5 = this.getAdjustedValue_(t3, i2), n6 = this.getAdjustedValue_(e6, i2);
      return s5 < n6 || s5 === n6 && this.isBottom_(t3) && this.isTop_(e6) ? -1 : 1;
    });
  }
  getAdjustedValue_(t2, e5) {
    const s4 = 0.5 * this.m_tolerance;
    if (e5) {
      const e6 = this.m_envelopesRed[t2 >> 1];
      return this.isBottom_(t2) ? e6.ymin - s4 : e6.ymax + s4;
    }
    const i2 = this.m_envelopesBlue[t2 >> 1];
    return this.isBottom_(t2) ? i2.ymin - s4 : i2.ymax + s4;
  }
};
var xt = B3;
var bt = class _bt {
  constructor(t2, e5) {
    this.tolerance = void 0 !== t2 ? t2 : Number.NaN, this.resolution = void 0 !== e5 ? e5 : Number.NaN;
  }
  add(t2) {
    return new _bt(this.tolerance + t2, this.resolution);
  }
  scale(t2) {
    return new _bt(this.tolerance * t2, this.resolution * t2);
  }
  total() {
    return this.tolerance + this.resolution;
  }
};
function Et2(t2, e5, i2, n6, r) {
  const o2 = n6 * n6, h2 = t2.sub(e5), a2 = i2.sub(e5), m2 = h2.sqrLength(), _ = a2.sqrLength();
  if (m2 <= o2 || _ <= o2) return true;
  const l2 = $(h2.crossProduct(a2));
  if (l2 <= o2 * m2 || l2 <= o2 * _) {
    return h2.dotProduct(a2) >= 0;
  }
  return false;
}
function Nt(t2, e5, s4) {
  return (i2) => 0 === s4 ? (i2 + t2) * e5 : 1 * (i2 - t2 * e5) / e5;
}
function Dt2(t2, e5) {
  const s4 = new n4();
  return t2.queryLooseEnvelope(s4), s4.mergeEnvelope2D(e5), s4;
}
function Ct2(t2, e5) {
  const s4 = n4.constructEmpty();
  t2.queryLooseEnvelope(s4);
  const i2 = n4.constructEmpty();
  return e5.queryLooseEnvelope(i2), s4.mergeEnvelope2D(i2), s4;
}
function It2(t2, e5) {
  return (Number.isFinite(t2) || Number.isNaN(t2)) && (Number.isFinite(e5) || Number.isNaN(e5));
}
function Tt2(t2, e5) {
  return Number.isFinite(t2) && Number.isFinite(e5);
}
function Rt2(t2, e5, s4) {
  const i2 = n4.constructEmpty();
  i2.setFromPoints(t2, e5);
  return Lt2(0, null, i2.calculateToleranceFromEnvelope(), s4, false);
}
function wt2(t2, e5, s4) {
  return Lt2(0, t2, e5.calculateToleranceFromEnvelope(), s4, false);
}
function At2(t2, e5, s4) {
  return Lt2(1, t2, e5.calculateToleranceFromEnvelope(), s4, false);
}
function qt2(t2, e5, s4) {
  return At2(t2, e5.queryInterval(1, 0), s4);
}
function zt2(t2, e5, s4) {
  const i2 = n4.constructEmpty();
  return e5.queryEnvelope(i2), wt2(t2, i2, s4);
}
function Bt2(t2, e5, s4 = false) {
  return Lt2(0, t2, e5.calculateToleranceFromEnvelope(), s4, true).total();
}
function St2(t2, e5, s4) {
  const i2 = n4.constructEmpty();
  return e5.queryEnvelope(i2), Bt2(t2, i2, s4);
}
function Lt2(t2, e5, s4, i2, n6) {
  const r = new bt(0, 0);
  if (null !== e5 && (r.tolerance = e5.getTolerance(t2), (!n6 || i2) && null !== e5)) {
    const s5 = e5.getResolution(t2);
    r.resolution = s5, i2 && (r.resolution *= 2);
  }
  i2 && (s4 *= 4, r.tolerance *= 1.01, r.resolution *= 1.01);
  return r.total() < s4 ? new bt(s4, 0) : r;
}
function Pt2(t2) {
  return Math.sqrt(2) * (2 * t2.tolerance + t2.resolution);
}
function Ft2(t2) {
  return Math.sqrt(2) * (t2.tolerance + t2.resolution);
}
function Ht(t2) {
  return t2 >= 3;
}
function kt2(t2, e5) {
  const s4 = [0];
  return t2.getImpl().getIsSimple(e5, s4) >= 3;
}
function Vt2(t2, e5) {
  t2.getImpl().setIsSimple(3, e5);
}
function Mt2(t2, e5, n6, r) {
  if ($(e5.x - t2.x) + $(e5.y - t2.y) <= n6 * n6) {
    const s4 = t2.z, n7 = e5.z;
    return us(s4, n7, r);
  }
  return false;
}
function Ot2(t2) {
  return t2 >= 4;
}
function Yt2(t2, e5) {
  return t2 === a.enumPolygon ? Ht(e5) : e5 >= 1;
}
function Xt(t2, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t2.queryLooseEnvelope(i2), e5.queryLooseEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const o2 = t2.querySegmentIterator(), h2 = e5.querySegmentIterator(), a2 = n4.constructEmpty(), m2 = n4.constructEmpty(), _ = new yt2();
  _.setTolerance(s4);
  let l2 = false;
  for (_.startRedConstruction(); o2.nextPath(); ) for (; o2.hasNextSegment(); ) {
    o2.nextSegment().queryLooseEnvelope(a2), a2.isIntersecting(r) && (l2 = true, _.addRedEnvelope(o2.getStartPointIndex(), a2));
  }
  if (_.endRedConstruction(), !l2) return null;
  let u = false;
  for (_.startBlueConstruction(); h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    h2.nextSegment().queryLooseEnvelope(m2), m2.isIntersecting(r) && (u = true, _.addBlueEnvelope(h2.getStartPointIndex(), m2));
  }
  return _.endBlueConstruction(), u ? _ : null;
}
function Ut2(t2, e5, s4, i2, n6) {
  t2.getGeometryType(), e5.getGeometryType();
  const r = n4.constructEmpty(), o2 = n4.constructEmpty();
  t2.queryLooseEnvelope(r), e5.queryLooseEnvelope(o2), r.inflateCoords(s4, s4), o2.inflateCoords(s4, s4);
  const h2 = n4.constructEmpty();
  h2.setCoords({ env2D: r }), h2.intersect(o2);
  const a2 = new yt2();
  a2.setTolerance(s4);
  let m2 = false;
  a2.startRedConstruction();
  for (let l2 = 0, u = t2.getPathCount(); l2 < u; l2++) t2.queryLoosePathEnvelope(l2, r), r.isIntersecting(h2) && (m2 = true, a2.addRedEnvelope(l2, r));
  if (a2.endRedConstruction(), !m2) return null;
  let _ = false;
  a2.startBlueConstruction();
  for (let l2 = 0, u = e5.getPathCount(); l2 < u; l2++) e5.queryLoosePathEnvelope(l2, o2), o2.isIntersecting(h2) && (_ = true, a2.addBlueEnvelope(l2, o2));
  return a2.endBlueConstruction(), _ ? a2 : null;
}
function Gt2(t2, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t2.queryLooseEnvelope(i2), e5.queryEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const o2 = t2.querySegmentIterator(), h2 = new yt2();
  h2.setTolerance(s4);
  let a2 = false;
  for (h2.startRedConstruction(); o2.nextPath(); ) for (; o2.hasNextSegment(); ) {
    o2.nextSegment().queryLooseEnvelope(i2), i2.isIntersecting(r) && (a2 = true, h2.addRedEnvelope(o2.getStartPointIndex(), i2));
  }
  if (h2.endRedConstruction(), !a2) return null;
  let m2 = false;
  h2.startBlueConstruction();
  for (let _ = 0, l2 = e5.getPointCount(); _ < l2; _++) {
    const t3 = e5.getXY(_);
    r.contains(t3) && (m2 = true, h2.addBlueEnvelope(_, n4.construct(t3.x, t3.y, t3.x, t3.y)));
  }
  return h2.endBlueConstruction(), m2 ? h2 : null;
}
function Zt2(t2, e5, s4) {
  const i2 = n4.constructEmpty(), n6 = n4.constructEmpty();
  t2.queryEnvelope(i2), e5.queryEnvelope(n6), i2.inflateCoords(s4, s4), n6.inflateCoords(s4, s4);
  const r = n4.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n6);
  const o2 = new yt2();
  o2.setTolerance(s4);
  let h2 = false;
  o2.startRedConstruction();
  const m2 = new ei();
  for (let a2 = 0, u = t2.getPointCount(); a2 < u; a2++) t2.queryXY(a2, m2), r.contains(m2) && (h2 = true, o2.addRedEnvelope(a2, n4.construct(m2.x, m2.y, m2.x, m2.y)));
  if (o2.endRedConstruction(), !h2) return null;
  let _ = false;
  o2.startBlueConstruction();
  const l2 = new ei();
  for (let a2 = 0, u = e5.getPointCount(); a2 < u; a2++) e5.queryXY(a2, l2), r.contains(l2) && (_ = true, o2.addBlueEnvelope(a2, n4.construct(l2.x, l2.y, l2.x, l2.y)));
  return o2.endBlueConstruction(), _ ? o2 : null;
}
function Qt2(t2) {
  const e5 = new n4();
  return t2.queryLooseEnvelope(e5), e5.inflateCoords(1, 1), jt2(t2, e5);
}
function jt2(t2, e5, s4) {
  const i2 = new n4();
  if (t2.queryLooseEnvelope(i2), i2.isEmpty()) return null;
  t2.getGeometryType();
  const n6 = new _t2(i2, 8);
  let r = -1;
  const o2 = new n4();
  let h2 = false;
  do {
    for (let s5 = 0, a2 = t2.getPathCount(); s5 < a2; s5++) if (t2.queryLoosePathEnvelope(s5, o2), o2.isIntersecting(e5)) {
      if (r = n6.insertEx(s5, o2, r), -1 === r) {
        h2 && b("build_quad_tree_for_paths"), i2.assign(t2.calculateEnvelope2D(false)), h2 = true, n6.reset(i2, 8);
        break;
      }
      h2 = false;
    }
  } while (h2);
  return n6;
}
function Wt(t2, e5) {
  if (!e5) {
    const e6 = new n4();
    t2.queryLooseEnvelope(e6);
    const s5 = new _t2(e6, 8);
    let i3 = -1;
    const n7 = new n4(), r2 = t2.querySegmentIterator();
    let o3 = false;
    for (; r2.nextPath(); ) for (; r2.hasNextSegment(); ) {
      const h3 = r2.nextSegment(), a2 = r2.getStartPointIndex();
      if (h3.queryLooseEnvelope(n7), i3 = s5.insertEx(a2, n7, i3), -1 === i3) {
        o3 && b(""), e6.assign(t2.calculateEnvelope2D(false)), o3 = true, s5.reset(e6, 8), r2.resetToFirstPath();
        break;
      }
    }
    return s5;
  }
  const s4 = new n4();
  t2.queryLooseEnvelope(s4);
  const i2 = new _t2(s4, 8);
  let n6 = -1;
  const r = new n4(), o2 = t2.querySegmentIterator();
  let h2 = false;
  for (; o2.nextPath(); ) for (; o2.hasNextSegment(); ) {
    const a2 = o2.nextSegment(), m2 = o2.getStartPointIndex();
    if (a2.queryLooseEnvelope(r), r.isIntersecting(e5) && (n6 = i2.insertEx(m2, r, n6), -1 === n6)) {
      h2 && b(""), s4.assign(t2.calculateEnvelope2D(false)), h2 = true, i2.reset(s4, 8), o2.resetToFirstPath();
      break;
    }
  }
  return i2;
}
function Jt(t2, e5) {
  if (e5) {
    const s4 = new _t2(e5, 8), i2 = new ei(), n6 = new n4();
    let r = false;
    for (let o2 = 0; o2 < t2.getPointCount(); o2++) {
      if (i2.setCoordsPoint2D(t2.getXY(o2)), !e5.contains(i2)) continue;
      n6.setCoords({ pt: i2 });
      -1 !== s4.insert(o2, n6) || (r && b(""), r = true, s4.reset(t2.calculateEnvelope2D(), 8), o2 = -1);
    }
    return s4;
  }
  return z("no-extent version not yet impl"), null;
}
function Kt2(t2, e5, s4, i2, n6) {
  let r = false;
  const o2 = n6.vmin, h2 = n6.vmax;
  for (let a2 = s4; a2 < e5; a2 += i2) {
    const e6 = t2.read(a2);
    e6 < o2 ? (r = true, t2.write(a2, o2)) : e6 > h2 && (r = true, t2.write(a2, h2));
  }
  return r;
}
function $t(t2, e5, s4, i2) {
  if (!t2.hasAttribute(s4)) return false;
  const n6 = t2.getGeometryType();
  if (n6 === a.enumGeometryCollection) {
    const n7 = t2, r = n7.getGeometryCount();
    let o2 = 0;
    for (let t3 = 0; t3 < r; ++t3) {
      o2 |= $t(n7.getGeometry(t3), e5, s4, i2) ? 1 : 0;
    }
    return !!o2;
  }
  if (y(n6)) {
    const n7 = t2, r = xt.getPersistence(s4), o2 = xt.getComponentCount(s4), h2 = n7.getPointCount();
    if (1 === r) {
      const t3 = Kt2(n7.getAttributeStreamRef(s4), h2 * o2, i2, o2, e5);
      return t3 && n7.notifyModified(), t3;
    }
    if (2 === r) {
      const t3 = Kt2(n7.getAttributeStreamRef(s4), h2 * o2, i2, o2, e5);
      return t3 && n7.notifyModified(), t3;
    }
    b("snap_coordinate not implemented");
  }
  if (n6 === a.enumEnvelope) {
    const n7 = t2, r = n7.queryInterval(s4, i2);
    let o2 = false;
    return r.vmin < e5.vmin && (o2 = true, r.vmin = e5.vmin), r.vmax > e5.vmax && (o2 = true, r.vmax = e5.vmax), o2 && n7.setIntervalEnvelope(s4, i2, r), o2;
  }
  if (n6 === a.enumPoint) {
    const n7 = t2;
    let r = n7.getAttributeAsDbl(s4, i2), o2 = false;
    return r < e5.vmin && (o2 = true, r = e5.vmin), r > e5.vmax && (o2 = true, r = e5.vmax), o2 && n7.setAttributeBasic(s4, i2, r), o2;
  }
  if (f(n6)) {
    const n7 = t2;
    let r = n7.getStartAttributeAsDbl(s4, i2), o2 = false;
    return r < e5.vmin && (o2 = true, r = e5.vmin), r > e5.vmax && (o2 = true, r = e5.vmax), o2 && n7.setStartAttribute(s4, i2, r), r = n7.getEndAttributeAsDbl(s4, i2), r < e5.vmin && (o2 = true, r = e5.vmin), r > e5.vmax && (o2 = true, r = e5.vmax), o2 && n7.setEndAttribute(s4, i2, r), o2;
  }
  b("snap_coordinate not implemented");
}
var te = B3;
var ee = class _ee {
  constructor(t2) {
    if (this.m_description = null, this.x = Number.NaN, this.y = Number.NaN, this.m_attribs = null, t2) {
      if (!t2.copy) return t2.move ? (this.m_description = t2.move.m_description, t2.move.m_description = null, this.m_attribs = t2.move.m_attribs, t2.move.m_attribs = null, this.x = t2.move.x, void (this.y = t2.move.y)) : t2.vd ? (this.m_description = t2.vd, void (t2.attribBuffer ? (this.m_attribs = t2.attribBuffer, t2.initDefaultValues && this.setDefaultAttributeValues()) : this.ensureAttributes())) : t2.pt ? (this.m_description = M(), void this.setXY(t2.pt)) : void ("x" in t2 && ("z" in t2 ? (this.m_description = O2(), this.ensureAttributes(), this.setXYZ(new X2(t2.x, t2.y, t2.z))) : (this.m_description = M(), this.setXYCoords(t2.x, t2.y))));
      t2.copy.copyTo(this);
    } else this.m_description = M();
  }
  assignCopy(t2) {
    return this.m_attribs = null, t2.copyTo(this), this;
  }
  assignMove(t2) {
    return this.m_attribs = null, t2.copyTo(this), t2.setEmpty(), this;
  }
  getXY() {
    return new ei(this.x, this.y);
  }
  queryXY(t2) {
    t2.x = this.x, t2.y = this.y;
  }
  setXY(t2) {
    this.x = t2.x, this.y = t2.y;
  }
  setXYCoords(t2, e5) {
    this.x = t2, this.y = e5;
  }
  getXYZ() {
    const t2 = new X2();
    return t2.x = this.x, t2.y = this.y, t2.z = this.getZ(), t2;
  }
  setXYZ(t2) {
    this.addAttribute(1), this.x = t2.x, this.y = t2.y, this.m_attribs[0] = t2.z;
  }
  getX() {
    return this.x;
  }
  setX(t2) {
    this.x = t2;
  }
  getY() {
    return this.y;
  }
  setY(t2) {
    this.y = t2;
  }
  getZ() {
    return this.m_description.hasZ() ? this.m_attribs[0] : te.getDefaultValue(1);
  }
  setZ(t2) {
    this.addAttribute(1), this.m_attribs[0] = t2;
  }
  getM() {
    return this.getAttributeAsDbl(2, 0);
  }
  setM(t2) {
    this.addAttribute(2), this.m_description.hasZ() ? this.m_attribs[1] = t2 : this.m_attribs[0] = t2;
  }
  getID() {
    return this.getAttributeAsInt(3, 0);
  }
  setID(t2) {
    this.setAttributeBasic(3, 0, t2);
  }
  isEqualXY(t2, e5) {
    return void 0 === e5 && (e5 = 0), Math.abs(t2.x - this.x) <= e5 && Math.abs(t2.y - this.y) <= e5;
  }
  isEqualXYCoords(t2, e5, s4) {
    return void 0 === s4 && (s4 = 0), Math.abs(t2 - this.x) <= s4 && Math.abs(e5 - this.y) <= s4;
  }
  getAttributeAsDbl(t2, e5) {
    if (0 === t2) {
      if (0 === e5) return this.x;
      if (1 === e5) return this.y;
      A("");
    }
    const s4 = te.getComponentCount(t2);
    (e5 < 0 || e5 >= s4) && A("");
    const i2 = this.m_description.getAttributeIndex(t2);
    return i2 >= 0 ? this.m_attribs[this.m_description.getPointAttributeOffset(i2) - 2 + e5] : te.getDefaultValue(t2);
  }
  getAttributeAsInt(t2, e5) {
    return Math.trunc(this.getAttributeAsDbl(t2, e5));
  }
  setAttributeBasic(t2, e5, s4) {
    if (0 === t2) return void (0 === e5 ? this.x = s4 : 1 === e5 ? this.y = s4 : A(""));
    const i2 = te.getComponentCount(t2);
    (e5 < 0 || e5 >= i2) && A("");
    let n6 = this.m_description.getAttributeIndex(t2);
    n6 < 0 && (this.addAttribute(t2), n6 = this.m_description.getAttributeIndex(t2)), this.m_attribs[this.m_description.getPointAttributeOffset(n6) - 2 + e5] = s4;
  }
  copyAttributesFrom(t2, e5) {
    if (this === t2) return;
    const s4 = t2.getDescription();
    for (let i2 = e5 && s4.hasZ() ? 2 : 1, n6 = s4.getAttributeCount(); i2 < n6; ++i2) {
      const e6 = s4.getSemantics(i2), n7 = te.getComponentCount(e6);
      for (let s5 = 0; s5 < n7; ++s5) {
        const i3 = t2.getAttributeAsDbl(e6, s5);
        this.setAttributeBasic(e6, s5, i3);
      }
    }
  }
  getAttributeArray() {
    return this.m_attribs;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t2) {
    this.m_description !== t2 && this.assignVertexDescriptionImpl(t2);
  }
  mergeVertexDescription(t2) {
    this.m_description !== t2 && (this.m_description.hasAttributesFrom(t2) || this.mergeVertexDescriptionImpl(t2));
  }
  hasAttribute(t2) {
    return this.m_description.hasAttribute(t2);
  }
  addAttribute(t2) {
    if (this.m_description.hasAttribute(t2)) return;
    const e5 = k3(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t2) {
    if (!this.m_description.hasAttribute(t2)) return;
    const e5 = V2(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t2 = M();
    t2 !== this.m_description && this.assignVertexDescription(t2);
  }
  getGeometryType() {
    return a.enumPoint;
  }
  getDimension() {
    return 0;
  }
  queryEnvelope(t2) {
    if (t2 instanceof re) return t2.setEmpty(), t2.assignVertexDescription(this.m_description), void t2.merge(this);
    if (t2 instanceof U3) {
      if (this.isEmpty()) return void t2.setEmpty();
      const e5 = this.getXYZ();
      return t2.xmin = e5.x, t2.ymin = e5.y, t2.zmin = e5.z, t2.xmax = e5.x, t2.ymax = e5.y, void (t2.zmax = e5.z);
    }
    this.isEmpty() ? t2.setEmpty() : (t2.xmin = this.x, t2.ymin = this.y, t2.xmax = this.x, t2.ymax = this.y);
  }
  queryLooseEnvelope(t2) {
    this.queryEnvelope(t2);
  }
  queryInterval(t2, e5) {
    const s4 = new x2();
    if (this.isEmpty()) return s4.setEmpty(), s4;
    const i2 = this.getAttributeAsDbl(t2, e5);
    return s4.vmin = i2, s4.vmax = i2, s4;
  }
  applyTransformation(t2) {
    if (!this.isEmpty()) {
      if (1 === t2.m_TransformationType) {
        const e5 = this.getXY();
        return t2.transformInPlace(e5), void this.setXY(e5);
      }
      z("3d not impl");
    }
  }
  transformAttribute(t2, e5, s4, i2, n6) {
    if (this.isEmpty()) return;
    this.addAttribute(t2);
    const r = this.getAttributeAsDbl(t2, e5), o2 = Nt(s4, i2, n6);
    this.setAttributeBasic(t2, e5, o2(r));
  }
  createInstance() {
    return new _ee({ vd: this.m_description });
  }
  copyTo(t2) {
    if (this === t2) return;
    t2.getGeometryType() !== a.enumPoint && P();
    const e5 = t2;
    e5.x = this.x, e5.y = this.y, this.m_attribs ? (e5.assignVertexDescription(this.m_description), e5.m_attribs = this.m_attribs.slice()) : (e5.releaseAttributes(), e5.assignVertexDescription(this.m_description));
  }
  isEmpty() {
    return Number.isNaN(this.x) || Number.isNaN(this.y);
  }
  setEmpty() {
    this.m_description || (this.m_description = M(), this.releaseAttributes()), this.x = Number.NaN, this.y = Number.NaN, this.m_attribs && Tt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, this.m_description.getTotalComponentCount() - 2);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t2) {
    return 0;
  }
  equals(t2, e5) {
    if (t2 === this) return true;
    if (t2.getGeometryType() !== a.enumPoint) return false;
    const s4 = t2;
    if (this.m_description !== s4.m_description) return false;
    if (this.isEmpty() !== s4.isEmpty()) return false;
    if (this.isEmpty()) return true;
    if (void 0 === e5 && (e5 = 0), Math.abs(this.x - s4.x) > e5) return false;
    if (Math.abs(this.y - s4.y) > e5) return false;
    for (let n6 = 0, r = this.m_description.getTotalComponentCount() - 2; n6 < r; n6++) if (!us(this.m_attribs[n6], s4.m_attribs[n6], e5)) return false;
    return true;
  }
  getBoundary() {
    return null;
  }
  clone() {
    const t2 = new _ee({ vd: this.m_description });
    return this.copyTo(t2), t2;
  }
  swap(t2) {
    if (this === t2) return;
    t2.getGeometryType() !== a.enumPoint && P("wrong geometry type");
    const e5 = t2;
    e5.m_description = Mt(this.m_description, this.m_description = e5.m_description), e5.x = Mt(this.x, this.x = e5.x), e5.y = Mt(this.y, this.y = e5.y), e5.m_attribs = Mt(this.m_attribs, this.m_attribs = e5.m_attribs);
  }
  replaceNaNs(t2, e5) {
    if (this.addAttribute(t2), this.isEmpty()) return;
    const s4 = te.getComponentCount(t2);
    for (let i2 = 0; i2 < s4; i2++) {
      const s5 = this.getAttributeAsDbl(t2, i2);
      Number.isNaN(s5) && this.setAttributeBasic(t2, i2, e5);
    }
  }
  lerp(t2, e5, s4) {
    if (t2.getDescription() !== e5.getDescription() && P("Point.lerp"), this.assignVertexDescription(t2.getDescription()), t2.isEmpty() || e5.isEmpty()) return this.setEmpty(), this;
    this.ensureAttributes();
    const i2 = z3();
    t2.queryValues(i2, i2.length);
    const n6 = z3();
    e5.queryValues(n6, n6.length);
    const r = z3();
    let o2 = i2, h2 = n6;
    const a2 = r;
    let m2 = 0;
    for (let l2 = 0, u = this.m_description.getAttributeCount(); l2 < u; l2++) {
      const t3 = this.m_description.getSemantics(l2), e6 = te.getInterpolation(t3), i3 = te.getComponentCount(t3), n7 = te.getDefaultValue(t3);
      yt(e6, o2, h2, a2, m2, i3, s4, n7), o2 = o2.slice(i3), h2 = h2.slice(i3), m2 += i3;
    }
    return this.setValues(r, m2), this;
  }
  setDefaultAttributeValues() {
    const t2 = this.m_description.getTotalComponentCount() - 2;
    t2 > 0 && (this.m_attribs ? Tt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, t2) : this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  static sqrDistance2D(t2, e5) {
    return ei.sqrDistanceCoords(t2.x, t2.y, e5.x, e5.y);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t2) {
    const e5 = H2(this.getDescription(), t2);
    this.assignVertexDescription(e5);
  }
  releaseAttributes() {
    this.m_attribs = null;
  }
  assignVertexDescriptionImpl(t2) {
    this.m_description || (this.m_description = M());
    const e5 = L3();
    Y2(t2, this.m_description, e5);
    let s4 = null;
    t2.getTotalComponentCount() - 2 > 0 && (s4 = t2.getDefaultPointAttributes().slice(2));
    for (let i2 = 1, n6 = t2.getAttributeCount(); i2 < n6; i2++) {
      const n7 = e5[i2];
      if (-1 !== n7) {
        const e6 = this.m_description.getPointAttributeOffset(n7) - 2, r = t2.getPointAttributeOffset(i2) - 2, o2 = te.getComponentCount(t2.getSemantics(i2));
        for (let t3 = 0; t3 < o2; t3++) s4[r + t3] = this.m_attribs[e6 + t3];
      }
    }
    this.m_attribs = s4, this.m_description = t2;
  }
  ensureAttributes() {
    this.m_description.getTotalComponentCount() - 2 > 0 && null === this.m_attribs && (this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  queryValues(t2, e5) {
    const s4 = this.m_description.getTotalComponentCount();
    n2(s4 <= e5), t2[0] = this.x, t2[1] = this.y, Tt(t2, this.m_attribs, 2, 0, s4 - 2);
  }
  copyCommonAttributesTo(t2) {
    t2.x = this.x, t2.y = this.y;
    const e5 = t2.getDescription();
    if (e5 === this.m_description) this.m_attribs && Tt(t2.m_attribs, this.m_attribs, 0, 0, this.m_description.getTotalComponentCount() - 2);
    else {
      let s4 = 0;
      for (let i2 = 1, n6 = e5.getAttributeCount(); i2 < n6; i2++) {
        const n7 = e5.getSemantics(i2);
        let r = te.getComponentCount(n7);
        if (this.m_description.hasAttribute(n7)) {
          let e6 = this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(n7)) - 2;
          for (; 0 !== r; ) t2.m_attribs[s4++] = this.m_attribs[e6++], r--;
        } else {
          const e6 = te.getDefaultValue(n7);
          for (; 0 !== r; ) t2.m_attribs[s4++] = e6, r--;
        }
      }
    }
  }
  setValues(t2, e5) {
    const s4 = this.m_description.getTotalComponentCount();
    n2(s4 <= e5), this.x = t2[0], this.y = t2[1], Tt(this.m_attribs, t2, 0, 2, s4 - 2);
  }
  dbgDefaultAttribs() {
  }
};
ee.type = a.enumPoint;
var se = B3;
function ie(t2, e5) {
  return e5 * (t2.getTotalComponentCount() - 2);
}
var ne = class {
  constructor(t2) {
    if (this.m_attributes = null, t2) if (void 0 !== t2.xmin) this.m_envelope2D = new n4(t2.xmin, t2.ymin, t2.xmax, t2.ymax);
    else if (void 0 !== t2.env2D) this.m_envelope2D = new n4(t2.env2D);
    else if (t2.move) this.m_envelope2D = new n4(t2.move.m_envelope2D), this.m_attributes = t2.move.m_attributes, t2.move.m_attributes = null;
    else {
      if (!t2.moveEnv) throw new Error("unrecognized EnvelopeData constructor options");
      {
        const e5 = t2.moveEnv.accessEnvelopeData();
        this.m_envelope2D = new n4(e5.m_envelope2D), this.m_attributes = e5.m_attributes, e5.m_attributes = null;
      }
    }
    else this.m_envelope2D = n4.constructEmpty();
  }
  ensureAttributes(e5) {
    const s4 = e5.getTotalComponentCount() - 2;
    !this.m_attributes && s4 && (this.m_attributes = Lt(2 * s4, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  copyTo(e5, s4) {
    const i2 = s4, n6 = e5.getTotalComponentCount() - 2;
    if (i2.m_description !== e5 && (i2.releaseAttributes_(), i2.m_description = e5, n6 && (i2.m_data.m_attributes = Lt(2 * n6, Number.NaN))), n6) {
      n2(this.m_attributes && i2.m_data.m_attributes);
      const t2 = 2 * n6;
      Tt(i2.m_data.m_attributes, this.m_attributes, 0, 0, t2);
    }
    i2.m_data.m_envelope2D = new n4(this.m_envelope2D);
  }
  copyToIfNotNull(t2, e5) {
    e5.m_envelope2D = new n4(this.m_envelope2D), e5.releaseAttributes();
    t2.getTotalComponentCount() - 2 && this.m_attributes && (e5.m_attributes = this.m_attributes.slice());
  }
  releaseAttributes() {
    this.m_attributes = null;
  }
  isEmpty() {
    return this.m_envelope2D.isEmpty();
  }
  transformAttribute(t2, e5, s4, i2, n6) {
    n2(0);
  }
  queryInterval(t2, e5, s4, i2) {
    if (this.isEmpty()) return void i2.setEmpty();
    if (0 === e5) return void (0 === s4 ? this.m_envelope2D.queryIntervalX(i2) : 1 === s4 ? this.m_envelope2D.queryIntervalY(i2) : A(""));
    const n6 = se.getComponentCount(e5);
    (s4 < 0 || s4 >= n6) && A("");
    const r = t2.getAttributeIndex(e5);
    if (r >= 0) return i2.vmin = this.m_attributes[ie(t2, 0) + t2.getPointAttributeOffset(r) - 2 + s4], void (i2.vmax = this.m_attributes[ie(t2, 1) + t2.getPointAttributeOffset(r) - 2 + s4]);
    {
      const t3 = se.getDefaultValue(e5);
      return void i2.setCoords(t3, t3);
    }
  }
  queryEnvelope3D(t2, e5) {
    const s4 = new x2();
    this.queryInterval(t2, 1, 0, s4), e5.setCoords(this.m_envelope2D.xmin, this.m_envelope2D.ymin, s4.vmin, this.m_envelope2D.xmax, this.m_envelope2D.ymax, s4.vmax);
  }
  setEmpty(e5) {
    this.m_envelope2D.setEmpty();
    const s4 = e5.getTotalComponentCount() - 2;
    s4 && (this.m_attributes ? this.dbgAssertSize(s4) : this.m_attributes = Lt(2 * s4, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  dbgAssertSize(t2) {
  }
};
var re = class e {
  constructor(t2) {
    if (this.m_EnvelopeType = 4, this.m_description = M(), void 0 === t2) this.m_data = new ne();
    else if (void 0 !== t2.vd) this.m_description = t2.vd, this.m_data = new ne(), this.ensureAttributes_();
    else if (t2 == null ? void 0 : t2.env2D) this.m_data = new ne({ env2D: t2.env2D });
    else if (void 0 !== t2.xmin) this.m_data = new ne({ xmin: t2.xmin, ymin: t2.ymin, xmax: t2.xmax, ymax: t2.ymax });
    else if (t2.copy) this.m_data = new ne(), t2.copy.copyTo(this);
    else if (t2.move) this.m_description = t2.move.m_description, t2.move.m_description = null, this.m_data = new ne({ move: t2.move.m_data });
    else {
      if (!t2.centerPoint) throw new Error("unrecognized Envelope constructor options");
      this.m_description = t2.centerPoint.getDescription(), this.m_data = new ne(), this.ensureAttributes_(), this.setFromPoint(t2.centerPoint, t2.width, t2.height);
    }
  }
  accessEnvelopeData() {
    return this.m_description = null, this.m_data;
  }
  assignMove(t2) {
    return this === t2 || (this.m_description = t2.m_description, t2.m_description = null, this.m_data = new ne({ move: t2.m_data })), this;
  }
  assignCopy(t2) {
    return this === t2 || t2.copyTo(this), this;
  }
  transformAttribute(t2, e5, s4, i2, n6) {
    n2(0);
  }
  setAttributeBasic(t2, e5, s4) {
    if (this.addAttribute(t2), this.m_data.isEmpty()) return;
    const i2 = this.queryInterval(t2, e5);
    i2.vmin = s4, i2.vmax = s4, this.setIntervalEnvelope(t2, e5, i2);
  }
  mergeVertexDescriptionImpl(t2) {
    const e5 = H2(this.getDescription(), t2);
    this.assignVertexDescription(e5);
  }
  asEnvelope2D() {
    return new n4(this.m_data.m_envelope2D);
  }
  assignVertexDescription(t2) {
    this.m_description !== t2 && this.assignVertexDescriptionImpl(t2);
  }
  getGeometryType() {
    return a.enumEnvelope;
  }
  getDimension() {
    return 2;
  }
  getXMin() {
    return this.m_data.m_envelope2D.xmin;
  }
  getYMin() {
    return this.m_data.m_envelope2D.ymin;
  }
  getXMax() {
    return this.m_data.m_envelope2D.xmax;
  }
  getYMax() {
    return this.m_data.m_envelope2D.ymax;
  }
  width() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.width();
  }
  height() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.height();
  }
  getCenterXY() {
    return this.m_data.isEmpty() ? new ei() : this.m_data.m_envelope2D.getCenter();
  }
  getCenter(t2) {
    if (t2.assignVertexDescription(this.m_description), this.m_data.isEmpty()) return void t2.setEmpty();
    const e5 = this.m_description.getAttributeCount();
    for (let s4 = 1; s4 < e5; s4++) {
      const e6 = this.m_description.getSemantics(s4), i2 = se.getComponentCount(e6);
      for (let s5 = 0; s5 < i2; s5++) {
        const i3 = 0.5 * (this.getAttributeAsDblImpl(0, e6, s5) + this.getAttributeAsDblImpl(1, e6, s5));
        t2.setAttributeBasic(e6, s5, i3);
      }
    }
    t2.setXY(this.m_data.m_envelope2D.getCenter());
  }
  setCoords(t2, e5, s4, i2) {
    this.m_data.m_envelope2D.setCoords({ xmin: t2, ymin: e5, xmax: s4, ymax: i2 });
  }
  setEnvelope(t2) {
    if (t2 instanceof n4) this.m_data.m_envelope2D = new n4(t2), this.m_data.m_envelope2D.normalize();
    else {
      this.addAttribute(1), this.m_data.m_envelope2D = t2.getEnvelope2D(), this.m_data.m_envelope2D.normalize();
      const e5 = x2.constructEmpty();
      e5.setCoords(t2.zmin, t2.zmax), this.setInterval(1, 0, e5.vmin, e5.vmax);
    }
  }
  merge(t2) {
    if (t2 instanceof n4) return t2.isValid() || P(""), void this.m_data.m_envelope2D.mergeEnvelope2D(t2);
    if (t2 instanceof e) {
      if (t2.m_data.isEmpty()) return;
      const e5 = t2.getDescription();
      this.mergeVertexDescription(e5), this.m_data.m_envelope2D.mergeEnvelope2D(t2.m_data.m_envelope2D);
      for (let s4 = 1, i2 = e5.getAttributeCount(); s4 < i2; s4++) {
        const i3 = e5.getSemantics(s4), n6 = se.getComponentCount(i3);
        for (let e6 = 0; e6 < n6; e6++) {
          const s5 = t2.queryInterval(i3, e6), n7 = this.queryInterval(i3, e6);
          n7.merge(s5), this.setIntervalEnvelope(i3, e6, n7);
        }
      }
    } else if (t2 instanceof ee) {
      const e5 = t2;
      if (e5.isEmpty()) return;
      const s4 = e5.getDescription();
      if (this.mergeVertexDescription(s4), this.m_data.isEmpty()) return void this.setFromPoint(e5);
      this.m_data.m_envelope2D.merge(e5.getXY());
      for (let t3 = 1, i2 = s4.getAttributeCount(); t3 < i2; t3++) {
        const i3 = s4.getSemantics(t3), n6 = se.getComponentCount(i3);
        for (let t4 = 0; t4 < n6; t4++) {
          const s5 = e5.getAttributeAsDbl(i3, t4), n7 = this.queryInterval(i3, t4);
          n7.mergeCoordinate(s5), this.setIntervalEnvelope(i3, t4, n7);
        }
      }
    } else z("unrecognized type for envelope.merge");
  }
  intersect(t2) {
    if (!this.m_data.m_envelope2D.intersect(t2.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e5 = t2.getDescription();
    this.mergeVertexDescription(e5);
    for (let s4 = 1, i2 = this.m_description.getAttributeCount(); s4 < i2; s4++) {
      const e6 = this.m_description.getSemantics(s4), i3 = se.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; s5++) {
        const i4 = t2.queryInterval(e6, s5), n6 = this.queryInterval(e6, s5);
        n6.intersect(i4), this.setIntervalEnvelope(e6, s5, n6);
      }
    }
    return true;
  }
  intersectCommonAttributes(t2) {
    if (!this.m_data.m_envelope2D.intersect(t2.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e5 = t2.getDescription();
    for (let s4 = 1, i2 = this.m_description.getAttributeCount(); s4 < i2; s4++) {
      const i3 = this.m_description.getSemantics(s4);
      if (!e5.hasAttribute(i3)) continue;
      const n6 = se.getComponentCount(i3);
      for (let e6 = 0; e6 < n6; e6++) {
        const s5 = t2.queryInterval(i3, e6), n7 = this.queryInterval(i3, e6);
        n7.intersect(s5), this.setIntervalEnvelope(i3, e6, n7);
      }
    }
    return true;
  }
  move(t2, e5) {
    this.m_data.m_envelope2D.move(t2, e5);
  }
  centerAt(t2, e5) {
    this.m_data.m_envelope2D.centerAtCoords(t2, e5);
  }
  centerAtPoint(t2) {
    this.m_data.m_envelope2D.centerAt(t2);
  }
  reaspect(t2, e5) {
    this.m_data.m_envelope2D.reaspect(t2, e5);
  }
  inflateCoords(t2, e5) {
    this.m_data.m_envelope2D.inflateCoords(t2, e5);
  }
  containsCoords(t2, e5) {
    return this.m_data.m_envelope2D.containsCoords(t2, e5);
  }
  contains(t2) {
    return this.m_data.m_envelope2D.contains(t2);
  }
  containsPoint(t2) {
    return !t2.isEmpty() && this.m_data.m_envelope2D.contains(t2.getXY());
  }
  containsEnvelope(t2) {
    return this.m_data.m_envelope2D.containsEnvelope(t2.m_data.m_envelope2D);
  }
  setIntervalEnvelope(t2, e5, s4) {
    if (this.addAttribute(t2), this.m_data.isEmpty()) return;
    const i2 = new x2(s4);
    if (i2.normalize(), 0 === t2) {
      if (i2.isEmpty()) return void this.setEmpty();
      0 === e5 ? (this.m_data.m_envelope2D.xmin = i2.vmin, this.m_data.m_envelope2D.xmax = i2.vmax) : 1 === e5 ? (this.m_data.m_envelope2D.ymin = i2.vmin, this.m_data.m_envelope2D.ymax = i2.vmax) : A("");
    } else this.setAttributeAsDblImpl(0, t2, e5, i2.vmin), this.setAttributeAsDblImpl(1, t2, e5, i2.vmax);
  }
  setInterval(t2, e5, s4, i2) {
    this.setIntervalEnvelope(t2, e5, new x2(s4, i2));
  }
  queryInterval(t2, e5) {
    const s4 = new x2();
    return this.m_data.queryInterval(this.m_description, t2, e5, s4), s4;
  }
  queryEnvelope(t2) {
    2 !== t2.m_EnvelopeType ? 3 !== t2.m_EnvelopeType ? 4 !== t2.m_EnvelopeType ? z("unrecognized type for queryEnveloper") : this.copyTo(t2) : this.m_data.queryEnvelope3D(this.m_description, t2) : t2.setCoords({ env2D: this.m_data.m_envelope2D });
  }
  applyTransformation(t2) {
    1 !== t2.m_TransformationType ? n2(0) : t2.transformEnvInPlace(this.m_data.m_envelope2D);
  }
  createInstance() {
    return new e({ vd: this.m_description });
  }
  copyTo(t2) {
    t2 !== this && this.m_data.copyTo(this.m_description, t2);
  }
  isEmpty() {
    return this.m_data.isEmpty();
  }
  setEmpty() {
    this.m_description || (this.m_description = M()), this.m_data.setEmpty(this.m_description);
  }
  calculateArea2D() {
    return this.m_data.m_envelope2D.getArea();
  }
  calculateLength2D() {
    return this.m_data.m_envelope2D.getLength();
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  equals(t2, e5) {
    if (t2 === this) return true;
    const s4 = t2;
    if (this.m_description !== s4.m_description) return false;
    if (this.m_data.isEmpty() !== s4.m_data.isEmpty()) return false;
    if (this.m_data.isEmpty()) return true;
    if (void 0 === e5 && (e5 = 0), Math.abs(this.m_data.m_envelope2D.xmin - s4.m_data.m_envelope2D.xmin) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymin - s4.m_data.m_envelope2D.ymin) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.xmax - s4.m_data.m_envelope2D.xmax) > e5) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymax - s4.m_data.m_envelope2D.ymax) > e5) return false;
    for (let n6 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); n6 < r; n6++) if (!us(this.m_data.m_attributes[n6], s4.m_data.m_attributes[n6], e5)) return false;
    return true;
  }
  getBoundary() {
    return z("getBoundary not available in this context. Use the boundary operator with an envelope parameter"), null;
  }
  clone() {
    return new e({ copy: this });
  }
  swap(t2) {
    if (this === t2) return;
    t2.getGeometryType() !== a.enumEnvelope && P("wrong geometry type");
    const e5 = t2;
    e5.m_description = Mt(this.m_description, this.m_description = e5.m_description), e5.m_data.m_envelope2D = Mt(this.m_data.m_envelope2D, this.m_data.m_envelope2D = e5.m_data.m_envelope2D), e5.m_data.m_attributes = Mt(this.m_data.m_attributes, this.m_data.m_attributes = e5.m_data.m_attributes);
  }
  queryCoordinates(t2) {
    this.m_data.isEmpty() && P(""), this.m_data.m_envelope2D.queryCorners(t2);
  }
  queryCornerByVal(t2, e5) {
    (t2 < 0 || t2 > 3) && A(""), e5.assignVertexDescription(this.m_description);
    const s4 = this.getDescription().getAttributeCount();
    for (let i2 = 1; i2 < s4; i2++) {
      const s5 = this.m_description.getSemantics(i2), n6 = se.getComponentCount(s5);
      for (let i3 = 0; i3 < n6; i3++) e5.setAttributeBasic(s5, i3, this.getAttributeAsDblImpl(t2 % 2, s5, i3));
    }
    e5.setXY(this.m_data.m_envelope2D.queryCorner(t2));
  }
  queryCorner(t2, e5) {
    e5.assign(this.m_data.m_envelope2D.queryCorner(t2));
  }
  getDescription() {
    return this.m_description;
  }
  mergeVertexDescription(t2) {
    this.m_description !== t2 && (this.m_description && this.m_description.hasAttributesFrom(t2) || this.mergeVertexDescriptionImpl(t2));
  }
  hasAttribute(t2) {
    return this.m_description.hasAttribute(t2);
  }
  addAttribute(t2) {
    if (this.m_description.hasAttribute(t2)) return;
    const e5 = k3(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t2) {
    if (!this.m_description.hasAttribute(t2)) return;
    const e5 = V2(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t2 = M();
    t2 !== this.m_description && this.assignVertexDescription(t2);
  }
  queryLooseEnvelope(t2) {
    this.queryEnvelope(t2);
  }
  replaceNaNs(t2, e5) {
    if (this.addAttribute(t2), this.m_data.isEmpty()) return;
    const s4 = se.getComponentCount(t2);
    for (let i2 = 0; i2 < s4; i2++) {
      const s5 = this.queryInterval(t2, i2);
      s5.isEmpty() && (s5.vmin = e5, s5.vmax = e5, this.setIntervalEnvelope(t2, i2, s5));
    }
  }
  getImpl() {
    return this;
  }
  setFromPoint(t2, e5, s4) {
    this.m_data.m_envelope2D.setCoords({ center: t2.getXY(), width: e5 ?? 0, height: s4 ?? 0 });
    const i2 = t2.getDescription();
    for (let n6 = 1, r = i2.getAttributeCount(); n6 < r; n6++) {
      const e6 = i2.getSemantics(n6), s5 = se.getComponentCount(e6);
      for (let i3 = 0; i3 < s5; i3++) {
        const s6 = t2.getAttributeAsDbl(e6, i3);
        this.setInterval(e6, i3, s6, s6);
      }
    }
  }
  assignVertexDescriptionImpl(e5) {
    const s4 = L3();
    Y2(e5, this.m_description, s4);
    let i2 = null;
    const n6 = e5.getTotalComponentCount() - 2, r = this.m_description ? this.m_description.getTotalComponentCount() - 2 : 0;
    n6 > 0 && (i2 = Lt(2 * n6, Number.NaN));
    for (let t2 = 1; t2 < e5.getAttributeCount(); t2++) {
      const o2 = s4[t2];
      if (-1 !== o2) {
        const s5 = e5.getPointAttributeOffset(t2) - 2, h2 = se.getComponentCount(e5.getSemantics(t2)), a2 = this.m_description.getPointAttributeOffset(o2) - 2;
        Tt(i2, this.m_data.m_attributes, s5, a2, h2), Tt(i2, this.m_data.m_attributes, n6 + s5, r + a2, h2);
      }
    }
    this.releaseAttributes_(), this.m_data.m_attributes = i2, this.m_description = e5;
  }
  getAttributeAsDblImpl(t2, e5, s4) {
    if (this.m_data.isEmpty() && x(""), 0 === e5) return t2 ? s4 ? this.m_data.m_envelope2D.ymax : this.m_data.m_envelope2D.xmax : s4 ? this.m_data.m_envelope2D.ymin : this.m_data.m_envelope2D.xmin;
    s4 >= se.getComponentCount(e5) && A("");
    const i2 = this.m_description.getAttributeIndex(e5);
    return i2 >= 0 ? this.m_data.m_attributes[ie(this.m_description, t2) + this.m_description.getPointAttributeOffset(i2) - 2 + s4] : B3.getDefaultValue(e5);
  }
  setAttributeAsDblImpl(t2, e5, s4, i2) {
    0 === e5 && (t2 ? 1 === s4 ? this.m_data.m_envelope2D.ymax = i2 : 0 === s4 ? this.m_data.m_envelope2D.xmax = i2 : A("") : 1 === s4 ? this.m_data.m_envelope2D.ymin = i2 : 0 === s4 ? this.m_data.m_envelope2D.xmin = i2 : A(""));
    const n6 = se.getComponentCount(e5);
    (s4 < 0 || s4 >= n6) && A(""), this.addAttribute(e5);
    const r = this.m_description.getAttributeIndex(e5);
    this.m_data.m_attributes[ie(this.m_description, t2) + this.m_description.getPointAttributeOffset(r) - 2 + s4] = i2;
  }
  releaseAttributes_() {
    this.m_data.releaseAttributes();
  }
  ensureAttributes_() {
    this.m_data.ensureAttributes(this.m_description);
  }
};
re.type = a.enumEnvelope;
var oe = Object.freeze(Object.defineProperty({ __proto__: null, Envelope: re, EnvelopeData: ne }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/QuadraticBezier.js
var me = class {
  constructor() {
    this.posStream = null, this.streams = null;
  }
  get(t2) {
    return t2 > 0 ? this.streams[t2 - 1] : this.posStream;
  }
  set(t2, e5) {
    t2 > 0 ? this.streams[t2 - 1] = e5 : this.posStream = e5;
  }
  destroyAndSetSize(t2) {
    if (this.streams = null, t2 > 1) {
      this.streams = new Array(t2 - 1);
      for (let e5 = 0; e5 < t2 - 1; ++e5) this.streams[e5] = null;
    }
    this.posStream = null;
  }
  swap(t2) {
    [this.streams, t2.streams] = [t2.streams, this.streams], [this.posStream, t2.posStream] = [t2.posStream, this.posStream];
  }
  empty() {
    return null === this.posStream && null === this.streams;
  }
};
function ue(t2, s4, n6, i2, r) {
  (s4 < 0 || n6 < 0 || i2 < 1 || s4 + i2 * (n6 - 1) + 1 > t2.size()) && P("Index out of bound");
  for (let e5 = s4, o2 = s4 + i2 * (n6 - 1) + 1; e5 < o2; e5 += i2) t2.writeAsDbl(e5, r(t2.readAsDbl(e5)));
}
function le(t2, e5, s4) {
  if (t2) for (let n6 = e5.length - 1; n6 >= 0; --n6) s4(e5[n6]);
  else e5.forEach(s4);
}
function ce(t2, e5) {
  let s4 = qs(t2);
  const n6 = e5.length / ls();
  for (let i2 = 0; i2 < e5.length; ++i2) {
    const t3 = Math.trunc(s4 * n6);
    s4 = qs(s4);
    const i3 = Math.trunc(s4 * n6), r = e5[t3];
    e5[t3] = e5[i3], e5[i3] = r;
  }
}
function fe(t2, e5, s4) {
  const n6 = t2.getDescription().getTotalComponentCount();
  t2.setX(e5[0]), t2.setY(e5[1]), Tt(t2.getAttributeArray(), e5, 0, 2, n6 - 2);
}
var Pe = B3;
var ye = "can not assign an empty point to a vertex";
var xe = class {
  constructor(t2) {
    if (this.m_accelerators = null, void 0 !== t2 && t2.move) this.m_description = t2.move.m_description, t2.move.m_description = M(), this.m_vertexAttributes = t2.move.m_vertexAttributes, t2.move.m_vertexAttributes = new me(), this.m_envelopeData = t2.move.m_envelopeData, t2.move.m_envelopeData = new ne(), this.m_pointCount = t2.move.m_pointCount, this.m_reservedPointCount = t2.move.m_reservedPointCount, this.m_flags = t2.move.m_flags, this.m_bFillRule = t2.move.m_bFillRule, this.m_bPathStarted = t2.move.m_bPathStarted, this.m_bPolygon = t2.move.m_bPolygon, this.m_simpleTolerance = t2.move.m_simpleTolerance;
    else {
      const e5 = void 0 !== t2 && t2.vd ? t2.vd : M();
      this.m_description = e5, this.m_vertexAttributes = new me(), this.m_envelopeData = new ne(), this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_flags = 4063, this.m_bFillRule = this.m_bPathStarted = this.m_bPolygon = false, this.m_simpleTolerance = 0, void 0 !== t2 && t2.copy && t2.copy.copyTo(this);
    }
  }
  equalsBase(e5, s4) {
    if (!y(e5.getGeometryType())) return false;
    const n6 = e5;
    if (this === n6) return true;
    if (!this.m_description.equals(n6.getDescription())) return false;
    if (this.isEmptyImpl() !== n6.isEmptyImpl()) return false;
    if (this.isEmptyImpl()) return true;
    const i2 = this.getPointCount();
    if (i2 !== n6.getPointCount()) return false;
    for (let t2 = 0; t2 < this.m_description.getAttributeCount(); t2++) {
      const e6 = this.m_description.getSemantics(t2), r = this.getAttributeStreamRef(e6), o2 = n6.getAttributeStreamRef(e6), a2 = Pe.getComponentCount(e6);
      if (!r.equals(o2, 0, i2 * a2, s4)) return false;
    }
    if (s4) {
      if (!this.equalsImplTol(e5, s4)) return false;
    } else if (!this.equalsImpl(e5)) return false;
    return true;
  }
  transformAttribute(t2, e5, s4, n6, i2) {
    this.addAttribute(t2), this.isEmpty() || 0 === s4 && 1 === n6 || (ue(this.getAttributeStreamRef(t2), e5, this.getPointCount(), Pe.getComponentCount(t2), Nt(s4, n6, i2)), this.notifyModified());
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t2) {
    this.m_description !== t2 && this.assignVertexDescriptionImpl(t2);
  }
  mergeVertexDescriptionImpl(t2) {
    const e5 = this.getDescription(), s4 = H2(e5, t2);
    this.assignVertexDescription(s4);
  }
  mergeVertexDescription(t2) {
    this.m_description !== t2 && (this.m_description.hasAttributesFrom(t2) || this.mergeVertexDescriptionImpl(t2));
  }
  hasAttribute(t2) {
    return this.m_description.hasAttribute(t2);
  }
  addAttribute(t2) {
    if (this.m_description.hasAttribute(t2)) return;
    const e5 = k3(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t2) {
    if (!this.m_description.hasAttribute(t2)) return;
    const e5 = V2(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t2 = M();
    t2 !== this.m_description && this.assignVertexDescription(t2);
  }
  getAttributeStreamRef(t2) {
    this.throwIfEmpty(), this.m_description.hasAttribute(t2) || P("AttributeStream : Geometry does not have the attribute");
    const s4 = this.m_description.getAttributeIndex(t2);
    return this.m_vertexAttributes.get(s4);
  }
  setAttributeStreamRef(t2, s4) {
    s4 || P("stream"), s4 && Pe.getPersistence(t2) !== s4.getPersistence() && P(""), this.addAttribute(t2);
    const n6 = this.m_description.getAttributeIndex(t2);
    this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_vertexAttributes.set(n6, s4), this.notifyModifiedFlags(2001);
  }
  notifyModifiedFlags(t2) {
    65535 === t2 && (this.m_reservedPointCount = -1, this.notifyModifiedAllImpl()), this.setDirtyFlagProtected(t2, true), this.clearAccelerators(), 32 & t2 && this.verifyAllStreamsAfterSizeChange();
  }
  notifyModified() {
    this.notifyModifiedFlags(2001);
  }
  getPointCount() {
    return this.m_pointCount;
  }
  getPointByVal(t2, e5) {
    const s4 = e5;
    s4.assignVertexDescription(this.m_description);
    for (let n6 = 0; n6 < this.m_description.getAttributeCount(); n6++) {
      const e6 = this.m_description.getSemantics(n6);
      for (let i2 = 0, r = Pe.getComponentCount(e6); i2 < r; i2++) {
        const o2 = this.m_vertexAttributes.get(n6).readAsDbl(r * t2 + i2);
        s4.setAttributeBasic(e6, i2, o2);
      }
    }
  }
  setPointByVal(t2, s4) {
    const n6 = s4;
    n6.isEmpty() && P(ye);
    const i2 = n6.getDescription();
    i2 !== this.m_description && this.mergeVertexDescription(i2);
    const r = this.m_vertexAttributes.get(0);
    r.write(2 * t2, n6.getX()), r.write(2 * t2 + 1, n6.getY());
    for (let e5 = 1, o2 = this.m_description.getAttributeCount(); e5 < o2; e5++) {
      const s5 = this.m_description.getSemantics(e5), i3 = Pe.getComponentCount(s5);
      for (let r2 = 0; r2 < i3; r2++) {
        const o3 = n6.getAttributeAsDbl(s5, r2);
        this.m_vertexAttributes.get(e5).writeAsDbl(t2 * i3 + r2, o3);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  setPointByValFromArray(t2, e5, n6, i2) {
    n2(0);
  }
  getPointByValAsArray(t2, e5, n6, i2) {
    n2(0);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isEmptyImpl() {
    return 0 === this.m_pointCount;
  }
  getAttributeAsDbl(t2, e5, s4) {
    const i2 = Pe.getComponentCount(t2);
    s4 >= i2 && A("");
    const r = this.m_description.getAttributeIndex(t2);
    return r >= 0 ? this.m_vertexAttributes.get(r).readAsDbl(e5 * i2 + s4) : Pe.getDefaultValue(t2);
  }
  queryAttributeAsDbl(t2, e5, s4, i2) {
    const r = Pe.getComponentCount(t2);
    i2 < r && A("");
    const o2 = this.m_description.getAttributeIndex(t2);
    if (o2 >= 0) {
      const t3 = e5 * r, n6 = this.m_vertexAttributes.get(o2);
      for (let e6 = 0; e6 < r; e6++) s4[e6] = n6.readAsDbl(t3 + e6);
    } else {
      const e6 = Pe.getDefaultValue(t2);
      for (let t3 = 0; t3 < r; t3++) s4[t3] = e6;
    }
  }
  getAttributeAsInt(t2, e5, s4) {
    return Math.trunc(this.getAttributeAsDbl(t2, e5, s4));
  }
  queryAttributeAsInt(t2, e5, n6, i2) {
    n2(0);
  }
  setAttribute(t2, e5, s4, i2) {
    const r = Pe.getComponentCount(t2);
    s4 >= r && A(""), this.addAttribute(t2);
    const o2 = this.m_description.getAttributeIndex(t2);
    this.notifyModifiedFlags(2001), this.m_vertexAttributes.get(o2).writeAsDbl(e5 * r + s4, i2);
  }
  setAttributeFromArray(t2, e5, s4, i2) {
    (e5 < 0 || e5 >= this.m_pointCount) && A("");
    const r = Pe.getComponentCount(t2);
    i2 !== r && A(""), this.addAttribute(t2);
    const o2 = this.m_description.getAttributeIndex(t2);
    this.notifyModifiedFlags(2001);
    const a2 = this.m_vertexAttributes.get(o2);
    for (let n6 = 0; n6 < r; ++n6) a2.writeAsDbl(e5 * r + n6, s4[n6]);
  }
  getXY(t2) {
    return this.m_vertexAttributes.get(0).readPoint2D(2 * t2);
  }
  queryXY(t2, e5) {
    return this.m_vertexAttributes.get(0).queryPoint2D(2 * t2, e5);
  }
  setXY(t2, e5) {
    this.m_vertexAttributes.get(0).writePoint2D(2 * t2, e5), this.notifyModifiedFlags(2001);
  }
  setXYCoords(t2, e5, s4) {
    const n6 = this.m_vertexAttributes.get(0);
    n6.write(2 * t2, e5), n6.write(2 * t2 + 1, s4), this.notifyModifiedFlags(2001);
  }
  getXYZ(t2) {
    const e5 = this.m_vertexAttributes.get(0), s4 = X2.getNAN();
    return s4.x = e5.read(2 * t2), s4.y = e5.read(2 * t2 + 1), this.m_description.hasAttribute(1) ? s4.z = this.m_vertexAttributes.get(1).read(t2) : s4.z = Pe.getDefaultValue(1), s4;
  }
  setXYZ(t2, e5) {
    this.addAttribute(1), this.notifyModifiedFlags(2001);
    const s4 = this.m_vertexAttributes.get(0);
    s4.write(2 * t2, e5.x), s4.write(2 * t2 + 1, e5.y);
    this.m_vertexAttributes.get(1).write(t2, e5.z);
  }
  queryEnvelope(t2) {
    t2 instanceof n4 || t2 instanceof U3 ? this.updateEnvelope(t2) : (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t2));
  }
  queryLooseEnvelope(t2) {
    this.updateLooseEnvelope(t2);
  }
  queryInterval(t2, e5) {
    const s4 = x2.constructEmpty();
    return this.isEmptyImpl() || (this.updateAllDirtyIntervals(true), this.m_envelopeData.queryInterval(this.m_description, t2, e5, s4)), s4;
  }
  setAttributeBasic(t2, e5, s4) {
    this.setAttributeImpl(t2, e5, s4);
  }
  setAttributeImpl(t2, e5, s4) {
    if (this.addAttribute(t2), this.isEmpty()) return;
    let n6 = false;
    const i2 = Pe.getComponentCount(t2), r = this.getAttributeStreamRef(t2), o2 = Number.isNaN(s4);
    if (1 === r.getPersistence()) {
      const t3 = r;
      for (let r2 = e5, a2 = this.m_pointCount * i2; r2 < a2; r2 += i2) {
        const e6 = t3.read(r2);
        (o2 || e6 === s4) && Number.isNaN(e6) || (t3.write(r2, s4), n6 = true);
      }
    } else for (let a2 = e5, h2 = this.m_pointCount * i2; a2 < h2; a2 += i2) {
      r.readAsDbl(a2) !== s4 && (r.writeAsDbl(a2, s4), n6 = true);
    }
    n6 && this.notifyModifiedFlags(2001);
  }
  replaceNaNs(t2, e5) {
    if (this.addAttribute(t2), this.isEmpty()) return;
    let s4 = false;
    const n6 = Pe.getComponentCount(t2), i2 = this.getAttributeStreamRef(t2);
    for (let r = 0; r < n6; r++) if (1 === i2.getPersistence()) {
      const t3 = i2;
      for (let i3 = 0, r2 = this.m_pointCount * n6; i3 < r2; i3++) {
        const n7 = t3.read(i3);
        Number.isNaN(n7) && (t3.write(i3, e5), s4 = true);
      }
    } else for (let t3 = 0, o2 = this.m_pointCount * n6; t3 < o2; t3++) {
      const n7 = i2.readAsDbl(t3);
      Number.isNaN(n7) && (i2.writeAsDbl(t3, e5), s4 = true);
    }
    s4 && this.notifyModifiedFlags(2001);
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  setEnvelopeForImport(t2) {
    this.m_description.equals(t2.getDescription()) || P(""), this.m_envelopeData = new ne({ moveEnv: t2 }), this.setDirtyFlagProtected(192, false);
  }
  copyTo(t2) {
    t2.getGeometryType() !== this.getGeometryType() && P(""), this !== t2 && this.copyToUnchecked(t2, false);
  }
  queryCoordinates(t2, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o2 = this.getAttributeStreamRef(0);
    for (let e5 = 2 * n6, a2 = 2 * r, h2 = 0; e5 < a2; e5 += 2, h2++) o2.queryPoint2D(e5, t2[h2]);
    return r;
  }
  queryCoordinates3D(t2, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o2 = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = Pe.getDefaultValue(1), m2 = this.m_description.hasAttribute(1);
    m2 && (a2 = this.getAttributeStreamRef(1));
    let u = 0;
    for (let e5 = n6; e5 < r; e5++, u++) t2[u].x = o2.read(2 * e5), t2[u].y = o2.read(2 * e5 + 1), t2[u].z = m2 ? a2.read(e5) : h2;
    return r;
  }
  clearAndSetDirtyFlagProtected(t2, e5) {
    let s4 = 0;
    const n6 = t2 & ~e5, i2 = e5 | n6;
    s4 = this.m_flags, (s4 & i2) !== e5 && (this.m_flags = s4 & ~n6 | e5);
  }
  getIsSimple(t2, e5) {
    e5[0] = 0;
    let s4 = -1;
    const n6 = this.m_flags, i2 = this.m_simpleTolerance;
    if (!(1 & n6)) {
      s4 = (14 & n6) >> 1, e5[0] = i2, i2 < t2 && (s4 = -1);
    }
    return s4;
  }
  setIsSimple(t2, e5, n6 = false) {
    if (2 === t2 ? n2(this.getGeometryType() === a.enumPolyline) : 1 === t2 ? n2(this.getGeometryType() === a.enumMultiPoint || this.getGeometryType() === a.enumPolyline) : 3 === t2 && n2(this.getGeometryType() === a.enumPolygon), -1 === t2) this.setDirtyFlagProtected(17, true);
    else {
      let s4 = t2 << 1;
      n6 || (s4 |= 16);
      const i2 = 31;
      this.clearAndSetDirtyFlagProtected(i2, s4), this.m_simpleTolerance !== e5 && (this.m_simpleTolerance = e5);
    }
  }
  attributeStreamIsAllocated(t2) {
    this.throwIfEmpty();
    const e5 = this.m_description.getAttributeIndex(t2);
    return e5 >= 0 && null !== this.m_vertexAttributes.get(e5);
  }
  capacity() {
    return -1 === this.m_reservedPointCount && 0 === this.m_pointCount ? 0 : this.m_reservedPointCount;
  }
  getDescriptionImpl() {
    return this.m_description;
  }
  copyToUnchecked(t2, e5 = false) {
    e5 && this.hasDirtyFlag(32) && T("Cannot do shallow clone on unprepared geometry");
    const n6 = t2, o2 = this.getGeometryType(), a2 = n6.getGeometryType();
    n2(o2 === a2 || o2 === a.enumPolygon && a2 === a.enumPolyline, "failure in copyToUnchcked"), n6.clearAccelerators(), n6.m_description = this.m_description, n6.m_vertexAttributes.destroyAndSetSize(0), n6.m_envelopeData.releaseAttributes();
    const h2 = this.m_description.getAttributeCount(), m2 = new me();
    if (!this.m_vertexAttributes.empty()) {
      m2.destroyAndSetSize(h2);
      for (let t3 = 0; t3 < h2; t3++) if (this.m_vertexAttributes.get(t3)) if (e5) m2.set(t3, this.m_vertexAttributes.get(t3));
      else {
        const e6 = Pe.getComponentCount(this.m_description.getSemantics(t3));
        m2.set(t3, this.m_vertexAttributes.get(t3).restrictedClone(this.getPointCount() * e6));
      }
    }
    if (this.m_envelopeData.copyToIfNotNull(this.m_description, n6.m_envelopeData), n6.m_flags = this.m_flags, n6.m_simpleTolerance = this.m_simpleTolerance, o2 !== a2) {
      const t3 = [Number.NaN];
      n6.getIsSimple(0, t3) >= 3 ? n6.setIsSimple(1, t3[0]) : n6.setIsSimple(-1, 0);
    }
    n6.m_vertexAttributes.swap(m2), m2.destroyAndSetSize(0), n6.m_pointCount = this.m_pointCount, n6.hasDirtyFlag(32) ? (n2(!e5), n6.m_reservedPointCount = -1) : n6.m_reservedPointCount = n6.m_pointCount;
    try {
      this.copyToImpl(n6, e5);
    } catch (u) {
      throw n6.setEmpty(), u;
    }
    n6.verifyAllStreamsAfterSizeChange();
  }
  buildRasterizedGeometryAccelerator(t2, e5) {
    return false;
  }
  getAccelerators() {
    return this.m_accelerators;
  }
  clearAccelerators() {
    this.m_accelerators && this.m_accelerators.release(), this.m_accelerators = null;
  }
  ensureUniqueAccelerators() {
    if (this.m_accelerators && !this.m_accelerators.uniqueUse()) {
      const t2 = this.m_accelerators.clone();
      this.m_accelerators.release(), this.m_accelerators = t2;
    }
  }
  interpolateTwoVertices(t2, e5, i2, r) {
    (t2 < 0 || t2 >= this.m_pointCount) && A(""), (e5 < 0 || e5 >= this.m_pointCount) && A(""), r.assignVertexDescription(this.m_description);
    const o2 = Lt(Pe.maxComponentCount(), Number.NaN), a2 = Lt(Pe.maxComponentCount(), Number.NaN), h2 = z3();
    let m2 = 0;
    for (let n6 = 0; n6 < this.m_description.getAttributeCount(); n6++) {
      const r2 = this.m_description.getSemantics(n6), u = Pe.getInterpolation(r2), l2 = Pe.getComponentCount(r2), c = Pe.getDefaultValue(r2);
      this.queryAttributeAsDbl(r2, t2, o2, l2), this.queryAttributeAsDbl(r2, e5, a2, l2), n2(m2 + l2 <= q), yt(u, o2, a2, h2, m2, l2, i2, c), m2 += l2;
    }
    fe(r, h2);
  }
  getShortestDistance(t2, e5) {
    return ei.distance(this.getXY(t2), this.getXY(e5));
  }
  getShortestSqrDistance(t2, e5) {
    return ei.sqrDistance(this.getXY(t2), this.getXY(e5));
  }
  resizeImpl(t2) {
    if (t2 < 0 && P(), (t2 = Math.ceil(t2)) === this.m_pointCount) return;
    this.m_pointCount = t2;
    const s4 = this.m_pointCount <= this.m_reservedPointCount ? 2001 : 4095;
    this.notifyModifiedFlags(s4);
  }
  assignVertexDescriptionImpl(t2) {
    if (!this.m_vertexAttributes.empty()) {
      const e5 = L3();
      Y2(t2, this.m_description, e5);
      const s4 = new me();
      s4.destroyAndSetSize(t2.getAttributeCount());
      for (let n6 = 0; n6 < t2.getAttributeCount(); n6++) {
        const t3 = e5[n6];
        -1 !== t3 ? s4.set(n6, this.m_vertexAttributes.get(t3)) : this.m_reservedPointCount = -1;
      }
      s4.swap(this.m_vertexAttributes);
    }
    this.m_description = t2, this.m_envelopeData.releaseAttributes(), this.notifyModifiedFlags(4095);
  }
  hasDirtyFlag(t2) {
    return !!(this.m_flags & t2);
  }
  setDirtyFlagProtected(t2, e5) {
    e5 ? this.m_flags |= t2 : this.m_flags &= ~t2;
  }
  notifyModifiedAllImpl() {
  }
  verifyAllStreamsAfterSizeChange() {
    this.hasDirtyFlag(32) && this.verifyAllStreamsAfterSizeChangeImpl();
  }
  verifyAllStreamsAfterSizeChangeImpl() {
    if (this.hasDirtyFlag(32)) {
      if (this.m_reservedPointCount < this.m_pointCount) {
        this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_reservedPointCount = Number.MAX_SAFE_INTEGER;
        let t2 = 0;
        t2 = this.m_pointCount < 4 ? 3 : this.m_pointCount <= 128 ? 2 * this.m_pointCount : Math.trunc((4 * this.m_pointCount + 2) / 3);
        for (let e5 = 0; e5 < this.m_description.getAttributeCount(); e5++) {
          const s4 = this.m_description.getSemantics(e5);
          let n6 = 0;
          if (null !== this.m_vertexAttributes.get(e5)) {
            const i2 = Pe.getComponentCount(s4);
            n6 = this.m_vertexAttributes.get(e5).size() / i2, n6 < this.m_pointCount && (this.m_vertexAttributes.get(e5).resize(t2 * i2, Pe.getDefaultValue(s4)), n6 = t2);
          } else this.m_vertexAttributes.set(e5, j3(s4, t2)), n6 = t2;
          n6 < this.m_reservedPointCount && (this.m_reservedPointCount = n6);
        }
      }
      this.verifyStreamsAfterSizeChangeExtraImpl(), this.setDirtyFlagProtected(32, false);
    }
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
  }
  updateAllDirtyIntervals(t2) {
    if (t2 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) {
      if (this.isEmpty()) return this.hasDirtyFlag(192) && this.m_envelopeData.setEmpty(this.m_description), void this.setDirtyFlagProtected(192, false);
      const e5 = this.updateXYImpl(t2), s4 = new re({ vd: this.m_description });
      s4.setEnvelope(e5);
      for (let t3 = 1; t3 < this.m_description.getAttributeCount(); t3++) {
        const e6 = this.m_description.getSemantics(t3), n6 = Pe.getComponentCount(e6), i2 = this.m_vertexAttributes.get(t3);
        for (let t4 = 0; t4 < n6; t4++) {
          const r = new x2();
          r.setEmpty();
          for (let e7 = 0; e7 < this.m_pointCount; e7++) {
            const s5 = i2.readAsDbl(e7 * n6 + t4);
            r.mergeCoordinate(s5);
          }
          s4.setIntervalEnvelope(e6, t4, r);
        }
      }
      (t2 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) && (this.m_envelopeData = new ne({ moveEnv: s4 }), this.clearDirtyIntervalsFlag(t2));
    }
  }
  updateXYImpl(t2) {
    const e5 = n4.constructEmpty(), s4 = this.m_vertexAttributes.get(0);
    return e5.mergePointsInterleaved(s4, 0, this.m_pointCount), e5;
  }
  updateEnvelope3D(t2) {
    n2(0);
  }
  updateLooseEnvelope(t2) {
    this.updateAllDirtyIntervals(false), t2 instanceof n4 ? t2.assign(this.m_envelopeData.m_envelope2D) : this.m_envelopeData.queryEnvelope3D(this.m_description, t2);
  }
  updateEnvelope(t2) {
    this.updateAllDirtyIntervals(true), t2.assign(this.m_envelopeData.m_envelope2D);
  }
  setEmptyImpl() {
    this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_vertexAttributes.destroyAndSetSize(0), this.notifyModifiedFlags(4095);
  }
  clearDirtyIntervalsFlag(t2) {
    this.setDirtyFlagProtected(192, false);
  }
  reserveImpl(t2, s4) {
    if (t2 < 0 && P(""), 0 === t2) return;
    let n6 = t2 = Math.ceil(t2);
    if (this.m_reservedPointCount < n6) {
      this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), s4 ? (null === this.m_vertexAttributes.get(0) && this.m_vertexAttributes.set(0, W2(0, 0)), this.m_vertexAttributes.get(0).resizeRounded(2 * n6), n6 = this.m_vertexAttributes.get(0).size() >> 1) : null === this.m_vertexAttributes.get(0) ? this.m_vertexAttributes.set(0, W2(0, n6)) : this.m_vertexAttributes.get(0).resize(2 * n6);
      for (let t3 = 1; t3 < this.m_description.getAttributeCount(); t3++) {
        const e5 = this.m_description.getSemantics(t3), s5 = Pe.getComponentCount(e5);
        null !== this.m_vertexAttributes.get(t3) ? this.m_vertexAttributes.get(t3).resize(n6 * s5) : this.m_vertexAttributes.set(t3, W2(e5, n6));
      }
      this.reserveImplImpl(n6, s4), this.m_reservedPointCount = n6;
    }
  }
  reserveRounded(t2) {
    t2 < 0 && P(), t2 = Math.ceil(t2), this.reserveImpl(t2, true);
  }
  reserveImplImpl(t2, e5) {
  }
  throwIfEmpty() {
    this.isEmptyImpl() && x("");
  }
};
var Ce = class _Ce extends xe {
  constructor(t2) {
    super(t2), t2 && (t2.points ? this.addPoints2D(t2.points, t2.pointsSize, 0, -1) : t2.point && this.add(t2.point));
  }
  assignCopy(t2) {
    return t2.copyTo(this), this;
  }
  assignMove(t2) {
    return t2.copyTo(this), t2.setEmpty(), this;
  }
  insertPoint2D(t2, s4) {
    t2 > this.getPointCount() && P("invalid point index"), t2 < 0 && (t2 = this.getPointCount());
    const n6 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let e5 = 0, i2 = this.m_description.getAttributeCount(); e5 < i2; e5++) {
      const i3 = this.m_description.getSemantics(e5), r = B3.getComponentCount(i3);
      if (0 === i3) this.m_vertexAttributes.get(e5).insert(r * t2, s4, r * n6);
      else {
        const s5 = B3.getDefaultValue(i3);
        this.m_vertexAttributes.get(e5).insertRange(r * t2, s5, r, r * n6);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint(t2, s4) {
    s4.isEmpty() && P(ye), t2 < 0 && (t2 = this.getPointCount()), this.mergeVertexDescription(s4.getDescription());
    const n6 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let e5 = 0, i2 = this.m_description.getAttributeCount(); e5 < i2; e5++) {
      const i3 = this.m_description.getSemantics(e5), r = B3.getComponentCount(i3);
      if (s4.hasAttribute(i3)) this.m_vertexAttributes.get(e5).insertAttributes(r * t2, s4, i3, r * n6);
      else {
        const s5 = B3.getDefaultValue(i3);
        this.m_vertexAttributes.get(e5).insertRange(r * t2, s5, r, r * n6);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints(t2, e5, s4) {
    if ((t2 > this.getPointCount() || s4 < 0) && A(""), t2 < 0 && (t2 = this.getPointCount()), 0 === s4) return;
    const i2 = e5[0].getDescription();
    this.mergeVertexDescription(i2);
    const r = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + s4);
    for (let n6 = 0, o2 = this.m_description.getAttributeCount(); n6 < o2; n6++) {
      const o3 = this.m_description.getSemantics(n6), a2 = B3.getComponentCount(o3);
      if (this.m_vertexAttributes.get(n6)) if (i2.hasAttribute(o3)) this.m_vertexAttributes.get(n6).insertAttributesFromPoints(t2 * a2, e5, s4, o3, r * a2);
      else {
        const e6 = B3.getDefaultValue(o3);
        this.m_vertexAttributes.get(n6).insertRange(a2 * t2, e6, a2 * s4, a2 * r);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints2D(t2, s4, n6) {
    if ((t2 > this.getPointCount() || n6 < 0) && P("invalid point index"), t2 < 0 && (t2 = this.getPointCount()), 0 === n6) return;
    const i2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + n6);
    for (let e5 = 0, r = this.m_description.getAttributeCount(); e5 < r; e5++) {
      const r2 = this.m_description.getSemantics(e5), o2 = B3.getComponentCount(r2);
      if (this.m_vertexAttributes.get(e5)) if (0 === r2) this.m_vertexAttributes.get(e5).insertRangeFromPoints(o2 * t2, s4, 0, n6, true, o2 * i2);
      else {
        const s5 = B3.getDefaultValue(r2);
        this.m_vertexAttributes.get(e5).insertRange(o2 * t2, s5, o2, o2 * i2);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  removePoints(t2, e5) {
    if ((t2 < 0 || e5 < 0 || t2 + e5 > this.getPointCount()) && A("remove_points"), 0 !== e5) {
      for (let s4 = 0, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) if (this.m_vertexAttributes.get(s4)) {
        const n7 = this.m_description.getSemantics(s4), i2 = B3.getComponentCount(n7);
        this.m_vertexAttributes.get(s4).eraseRange(i2 * t2, i2 * e5, i2 * this.m_pointCount);
      }
      this.m_pointCount -= e5, this.m_reservedPointCount > 0 && (this.m_reservedPointCount -= e5), this.notifyModifiedFlags(2001);
    }
  }
  removePoint(t2) {
    for (let e5 = 0, s4 = this.m_description.getAttributeCount(); e5 < s4; e5++) if (this.m_vertexAttributes.get(e5)) {
      const s5 = this.m_description.getSemantics(e5), n6 = B3.getComponentCount(s5);
      this.m_vertexAttributes.get(e5).eraseRange(n6 * t2, n6, n6 * this.m_pointCount);
    }
    this.m_pointCount--, this.m_reservedPointCount > 0 && this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  calculateEnvelope2D() {
    return this.updateXYImpl(true);
  }
  resizeNoInit(t2) {
    this.resizeImpl(t2);
  }
  resizeAndInitNonPositionAttributes(t2) {
    const e5 = this.m_pointCount;
    if (this.resizeImpl(t2), this.m_pointCount > e5) for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
      const t3 = this.m_description.getSemantics(s4), n7 = B3.getDefaultValue(t3), i2 = B3.getComponentCount(t3);
      this.m_vertexAttributes.get(s4).insertRange(i2 * e5, n7, i2 * (this.m_pointCount - e5), i2 * e5);
    }
  }
  queryCoordinates3D(t2, s4, n6, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n6 + s4), (n6 < 0 || r < n6 || this.m_pointCount > 0 && n6 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o2 = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = B3.getDefaultValue(1), m2 = this.m_description.hasAttribute(1);
    m2 && (a2 = this.getAttributeStreamRef(1));
    let u = 0;
    for (let e5 = n6; e5 < r; e5++, u++) t2[u].x = o2.read(2 * e5), t2[u].y = o2.read(2 * e5 + 1), t2[u].z = m2 ? a2.read(e5) : h2;
    return r;
  }
  queryAttributeAsInt(t2, e5, n6, i2) {
    n2(0);
  }
  add(t2) {
    t2.isEmpty() && P(ye), this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1), this.setPointByVal(this.m_pointCount - 1, t2);
  }
  addXY(t2, e5) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const s4 = new ei(t2, e5);
    this.setXY(this.m_pointCount - 1, s4);
  }
  addXYZ(t2, e5, s4) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const n6 = new X2();
    n6.setCoords(t2, e5, s4), this.setXYZ(this.m_pointCount - 1, n6);
  }
  addPoint2D(t2) {
    this.addXY(t2.x, t2.y);
  }
  addPoint3D(t2) {
    this.addXYZ(t2.x, t2.y, t2.z);
  }
  addPoints(t2, s4, n6) {
    this === t2 && P("Multi_point_impl.add");
    const i2 = n6 < 0 ? t2.getPointCount() : n6;
    if ((s4 < 0 || s4 > t2.getPointCount() || i2 < s4) && P(""), s4 === i2) return;
    const r = t2.getDescription();
    this.mergeVertexDescription(r);
    const o2 = i2 - s4, a2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + o2);
    for (let e5 = 0, h2 = this.m_description.getAttributeCount(); e5 < h2; e5++) {
      const n7 = this.m_description.getSemantics(e5), i3 = B3.getComponentCount(n7), h3 = this.getAttributeStreamRef(n7);
      if (r.hasAttribute(n7)) {
        const e6 = t2.getAttributeStreamRef(n7);
        h3.insertRangeFromStream(a2 * i3, e6, s4 * i3, o2 * i3, true, 1, a2 * i3);
      } else {
        const t3 = B3.getDefaultValue(n7);
        h3.insertRange(a2 * i3, t3, o2 * i3, a2 * i3);
      }
    }
  }
  addPoints2D(t2, s4, n6, i2) {
    let r = s4;
    const o2 = i2 < 0 ? r : i2;
    if ((r < 0 || n6 < 0 || n6 > r || o2 < n6) && P(""), n6 === o2) return;
    r = o2 - n6;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0);
    for (let e5 = 0; e5 < r; ++e5) h2.writePoint2D(2 * (a2 + e5), t2[n6 + e5]);
    this.notifyModifiedFlags(2001);
  }
  addPoints3D(t2, s4, n6, i2) {
    let r = s4;
    const o2 = i2 < 0 ? r : i2;
    if ((r < 0 || n6 < 0 || n6 > r || o2 < n6) && P(""), this.addAttribute(1), n6 === o2) return;
    r = o2 - n6;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0), m2 = new ei();
    for (let e5 = 0; e5 < r; e5++) m2.x = t2[n6 + e5].x, m2.y = t2[n6 + e5].y, h2.writePoint2D(2 * (a2 + e5), m2);
    const u = this.getAttributeStreamRef(1);
    for (let e5 = 0; e5 < r; e5++) u.write(a2 + e5, t2[n6 + e5].z);
    this.notifyModifiedFlags(2001);
  }
  getGeometryType() {
    return a.enumMultiPoint;
  }
  getDimension() {
    return 0;
  }
  createInstance() {
    return new _Ce({ vd: this.getDescription() });
  }
  setEmpty() {
    this.setEmptyImpl();
  }
  applyTransformation(t2) {
    if (this.isEmpty()) return;
    if (t2.isIdentity()) return;
    const e5 = this.m_vertexAttributes.get(0);
    1 === t2.m_TransformationType ? e5.applyTransformation(t2, 0, this.m_pointCount) : z("3d xform not impl"), this.notifyModifiedFlags(2001);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t2) {
    return 0;
  }
  equals(t2, e5) {
    return t2.getGeometryType() === a.enumMultiPoint && this.equalsBase(t2, e5);
  }
  queryEnvelope(t2) {
    4 === t2.m_EnvelopeType ? (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t2)) : 2 === t2.m_EnvelopeType ? this.updateEnvelope(t2) : z("");
  }
  getImpl() {
    return this;
  }
  getBoundary() {
    return null;
  }
  reserve(t2) {
    this.reserveImpl(t2);
  }
  clone() {
    const t2 = this.createInstance();
    return this.copyTo(t2), t2;
  }
  swap(t2) {
    n2(0);
  }
  buildQuadTreeAccelerator(t2) {
    return false;
  }
  getHashCodeImpl() {
    return n2(0), 0;
  }
  equalsImpl(t2) {
    return true;
  }
  equalsImplTol(t2, e5) {
    return true;
  }
  copyToImpl(t2, e5) {
  }
};
Ce.type = a.enumMultiPoint;
var ve = class _ve {
  constructor() {
    this.m_EnvelopeType = 5, this.envAabb = n4.constructEmpty(), this.envRot = n4.constructEmpty();
  }
  static constructEmpty() {
    return new _ve();
  }
  width() {
    return this.envAabb.width();
  }
  height() {
    return this.envAabb.height();
  }
  maxDim() {
    return Math.max(this.width(), this.height());
  }
  setEmpty() {
    this.envAabb.setEmpty(), this.envRot.setEmpty();
  }
  setCoords(t2) {
    this.envAabb.setCoords(t2), this.envRot.setCoords({ x: be(t2), y: Ee(t2) });
  }
  setFromPoints(t2, e5) {
    this.setEmpty(), this.mergePoints(t2, e5);
  }
  mergeNe(t2) {
    this.envAabb.mergeNe(t2), this.envRot.mergeNeCoords(be(t2), Ee(t2));
  }
  mergePoints(t2, e5) {
    this.envAabb.mergePoints(t2, e5);
    for (let s4 = 0; s4 < e5; ) {
      if (!this.envRot.isEmpty()) {
        for (let n6 = s4; n6 < e5; n6++) {
          const e6 = be(t2[n6]), s5 = Ee(t2[n6]);
          this.envRot.mergeNeCoords(e6, s5);
        }
        break;
      }
      {
        const e6 = be(t2[s4]), n6 = Ee(t2[s4]);
        this.envRot.setCoords({ x: e6, y: n6 }), s4++;
      }
    }
  }
  isIntersectingPoint2D(t2) {
    return !(!this.envAabb.contains(t2) || !this.envRot.containsCoords(be(t2), Ee(t2)));
  }
  isIntersectingW(t2) {
    return this.envAabb.isIntersecting(t2.envAabb) && this.envRot.isIntersecting(t2.envRot);
  }
  containsW(t2) {
    return !(!this.envAabb.containsEnvelope(t2.envAabb) || !this.envRot.containsEnvelope(t2.envRot));
  }
  containsPoint2D(t2) {
    return this.isIntersectingPoint2D(t2);
  }
  intersectW(t2) {
    const e5 = this.envAabb.intersect(t2.envAabb), s4 = this.envRot.intersect(t2.envRot);
    return e5 && !s4 && this.envAabb.setEmpty(), s4 && !e5 && this.envRot.setEmpty(), e5 && s4;
  }
  inflate(t2) {
    this.envAabb.inflateCoords(t2, t2);
    const e5 = t2 * Bs();
    this.envRot.inflateCoords(e5, e5), e5 < 0 && _ve.st_reduceEmpty(this);
  }
  static st_reduceEmpty(t2) {
    const e5 = t2.envAabb.isEmpty(), s4 = t2.envRot.isEmpty();
    e5 && !s4 ? t2.envRot.setEmpty() : s4 && !e5 && t2.envAabb.setEmpty();
  }
};
function be(t2) {
  return t2.x - t2.y;
}
function Ee(t2) {
  return t2.x + t2.y;
}
var Se = class _Se {
  constructor() {
    this.x = p2.getNAN(), this.y = p2.getNAN();
  }
  static getNAN() {
    return new _Se();
  }
  static constructPoint2D(t2) {
    const e5 = new _Se();
    return e5.x.set(t2.x), e5.y.set(t2.y), e5;
  }
  static constructCoords(t2, e5) {
    const s4 = new _Se();
    return s4.x.set(t2), s4.y.set(e5), s4;
  }
  static constructCoordsE(t2, e5) {
    const s4 = new _Se();
    return s4.setCoordsE(t2, e5), s4;
  }
  get 0() {
    return this.x.clone();
  }
  set 0(t2) {
    this.x.setE(t2);
  }
  get 1() {
    return this.y.clone();
  }
  set 1(t2) {
    this.y.setE(t2);
  }
  clone() {
    return new _Se().setE(this);
  }
  scaleThis(t2) {
    return this.x.mulThisE(t2), this.y.mulThisE(t2), this;
  }
  setCoords(t2, e5) {
    return this.x.set(t2), this.y.set(e5), this;
  }
  setCoordsE(t2, e5) {
    return this.x.setE(t2), this.y.setE(e5), this;
  }
  set(t2) {
    return this.x.set(t2.x), this.y.set(t2.y), this;
  }
  setE(t2) {
    return this.x.setE(t2.x), this.y.setE(t2.y), this;
  }
  setWithEps(t2, e5) {
    return this.x.setWithEps(t2.x, e5), this.y.setWithEps(t2.y, e5), this;
  }
  getUnitVector() {
    const t2 = this.clone();
    return t2.normalize(), t2;
  }
  sqrLength() {
    return this.x.sqr().addE(this.y.sqr());
  }
  length() {
    return this.sqrLength().sqrt();
  }
  mulE(t2) {
    const e5 = new _Se();
    return e5.setCoordsE(this.x.mulE(t2), this.y.mulE(t2)), e5;
  }
  mul(t2) {
    const e5 = new _Se();
    return e5.setCoordsE(this.x.mul(t2), this.y.mul(t2)), e5;
  }
  mulThis(t2) {
    return this.x.mulThis(t2), this.y.mulThis(t2), this;
  }
  mulThisE(t2) {
    return this.x.mulThisE(t2), this.y.mulThisE(t2), this;
  }
  divE(t2) {
    return this.clone().divThisE(t2);
  }
  divThisE(t2) {
    return this.x.divThisE(t2), this.y.divThisE(t2), this;
  }
  normalize() {
    const t2 = this.length();
    0 === t2.value() ? (this.x = w2.clone(), this.y = I2.clone()) : (this.x.divThisE(t2), this.y.divThisE(t2));
  }
  addE(t2) {
    return this.clone().addThisE(t2);
  }
  addThisE(t2) {
    return this.x.addThisE(t2.x), this.y.addThisE(t2.y), this;
  }
  subE(t2) {
    return this.clone().subThisE(t2);
  }
  subThisE(t2) {
    return this.x.subThisE(t2.x), this.y.subThisE(t2.y), this;
  }
  static distance(t2, e5) {
    return t2.subE(e5).length();
  }
  negateThis() {
    return this.x.negateThis(), this.y.negateThis(), this;
  }
  eq(t2) {
    return this.x.eq(t2.x) && this.y.eq(t2.y);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero();
  }
  isTrueZero() {
    return !this.x.value() && !this.y.value();
  }
  rotateDirect(t2, e5) {
    const s4 = this.x.mulE(t2).subThisE(this.y.mulE(e5)), n6 = this.x.mulE(e5).addThisE(this.y.mulE(t2));
    return this.x.setE(s4), this.y.setE(n6), this;
  }
  rotateReverse(t2, e5) {
    const s4 = this.x.mulE(t2).addThisE(this.y.mulE(e5)), n6 = this.x.negate().mulThisE(e5).addThisE(this.y.mulE(t2));
    return this.x.setE(s4), this.y.setE(n6), this;
  }
  dotProduct(t2) {
    return this.x.mulE(t2.x).addE(this.y.mulE(t2.y));
  }
  crossProduct(t2) {
    return this.x.mulE(t2.y).subE(this.y.mulE(t2.x));
  }
  value() {
    return ei.construct(this.x.value(), this.y.value());
  }
};
var De = class _De {
  constructor() {
    this.a11 = new p2(1), this.a12 = new p2(0), this.a21 = new p2(0), this.a22 = new p2(1);
  }
  clone() {
    const t2 = new _De();
    return t2.a11.setE(this.a11), t2.a12.setE(this.a12), t2.a21.setE(this.a21), t2.a22.setE(this.a22), t2;
  }
  assign(t2) {
    return this.a11.setE(t2.a11), this.a12.setE(t2.a12), this.a21.setE(t2.a21), this.a22.setE(t2.a22), this;
  }
  mulThis(t2) {
    const e5 = this.a11.mulE(t2.a11).addThisE(this.a12.mulE(t2.a21)), s4 = this.a11.mulE(t2.a12).addThisE(this.a12.mulE(t2.a22)), n6 = this.a21.mulE(t2.a11).addThisE(this.a22.mulE(t2.a21)), i2 = this.a21.mulE(t2.a12).addThisE(this.a22.mulE(t2.a22));
    return this.a11 = e5, this.a12 = s4, this.a21 = n6, this.a22 = i2, this;
  }
  mulLeftThis(t2) {
    const e5 = t2.clone();
    return this.assign(e5.mulThis(this)), this;
  }
  det() {
    return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21));
  }
  invertThis() {
    const t2 = this.det();
    if (0 !== t2.value()) {
      const e5 = this.a22.divE(t2), s4 = this.a12.negate().divThisE(t2), n6 = this.a21.negate().divThisE(t2), i2 = this.a11.divE(t2);
      this.a11 = e5, this.a12 = s4, this.a21 = n6, this.a22 = i2;
    } else this.setZero();
    return !t2.isZero();
  }
  transposeThis() {
    return this.a21 = Mt(this.a12, this.a12 = this.a21), this;
  }
  eigenSymmetric(t2, e5) {
    const s4 = this.a12.clone();
    s4.addThisE(this.a21), s4.mulThisByPower2(0.5);
    let n6 = new p2(1), i2 = new p2(0);
    if (s4.isZero()) t2[0].setE(this.a11), t2[1].setE(this.a22);
    else {
      const e6 = new p2(1);
      if (this.a11.ne(this.a22)) {
        const r = this.a11.subE(this.a22).divE(s4);
        r.mulThisByPower2(0.5);
        const o2 = r.sqr();
        e6.setE(r), e6.absThis(), e6.subThisE(o2.add(1).sqrtThis()), r.gt(I2) && e6.negateThis();
        const a2 = e6.sqr().addThis(1).sqrtThis().invThis();
        i2 = e6.mulE(a2), n6.setE(a2);
        const h2 = e6.mulE(s4);
        t2[0] = this.a11.addE(h2), t2[1] = this.a22.subE(h2);
      } else n6 = new p2(1 / Math.sqrt(2)), i2 = n6.clone(), t2[0] = this.a11.addE(s4), t2[1] = this.a22.subE(s4);
    }
    e5[0].x = n6.toDouble(), e5[0].y = i2.toDouble(), e5[1].x = i2.negate().toDouble(), e5[1].y = n6.toDouble(), Math.abs(t2[0].toDouble()) > Math.abs(t2[1].toDouble()) && (t2[1] = Mt(t2[0], t2[0] = t2[1]), e5[1] = Mt(e5[0], e5[0] = e5[1]));
  }
  setZero() {
    this.a11.set(0), this.a21.set(0), this.a12.set(0), this.a22.set(0);
  }
};
var we = B3;
function Ae(t2, e5) {
  const s4 = t2.getStartXY();
  if (s4.equals(e5.getStartXY())) return true;
  if (s4.equals(e5.getEndXY())) return true;
  const n6 = t2.getEndXY();
  return !!n6.equals(e5.getStartXY()) || !!n6.equals(e5.getEndXY());
}
function Te(t2, e5) {
  let s4 = t2.calculateLowerLength2D();
  return !(s4 > e5) && (!!t2.isLine() || (s4 = t2.calculateUpperLength2D(), s4 <= e5 || 0 !== e5 && t2.calculateLength2D() <= e5));
}
function Ie(t2, e5) {
  const s4 = t2.getEndXY().sub(t2.getStartXY()).length(), n6 = t2.calculateUpperLength2D() - s4 <= e5[0];
  return e5[0] *= 0.1, n6;
}
function Me(t2, e5, n6, i2, r, o2, a2, h2) {
  let m2 = t2.calculateUpperLength2D(), u = e5.calculateUpperLength2D(), l2 = t2, c = e5, g2 = false;
  m2 > u && (c = Mt(l2, l2 = c), i2 = Mt(n6, n6 = i2), u = Mt(m2, m2 = u), g2 = true);
  const d2 = 0 === n6;
  {
    a2[0] = d2 ? 1 : 0;
    const t3 = l2.getCoord2D(a2[0]);
    h2[0] = c.getClosestCoordinate(t3, false);
    const e6 = c.getCoord2D(h2[0]);
    if (ei.distance(t3, e6) <= r) {
      const e7 = [0.5, 0.75, 0.25, 0.1, 0.9];
      let s4 = true;
      for (let n7 = 0; n7 < e7.length; n7++) if (t3.assign(l2.getCoord2D(e7[n7])), !c.isCloserThanDistance(t3, new x2(0, 1), r)) {
        s4 = false;
        break;
      }
      if (s4) return g2 && (h2[0] = Mt(a2[0], a2[0] = h2[0])), 1;
    }
  }
  if (m2 <= 3 * r) return 0;
  let _ = ks(Math.max(r / m2, 0.1), 0, 0.5), p3 = 0.01 * r, f3 = 0, P5 = 0, y2 = _, x4 = -1, C2 = 0, v3 = 1 / 32;
  for (let b2 = 0; ; b2++) {
    n2(b2 < 4095);
    const t3 = d2 ? _ : 1 - _, e6 = l2.getCoord2D(t3), n7 = c.getClosestCoordinate(e6, false);
    if (n7 === i2) return C2;
    const m3 = c.getCoord2D(n7), u2 = ei.distance(e6, m3);
    if (0 === b2 && (x4 = u2), u2 <= p3 ? (v3 = 0.5, P5 = u2, f3 = _) : (y2 = _, x4 = u2), Math.abs(P5 - x4) > 0.1 * p3 && y2 - f3 > 1e-16) _ = Q(f3, y2, v3);
    else {
      if (a2[C2] = t3, h2[C2] = n7, g2 && (h2[C2] = Mt(a2[C2], a2[C2] = h2[C2])), 1 === o2 || 1 === C2) return 1 === C2 && a2[0] > a2[1] && (a2[1] = Mt(a2[0], a2[0] = a2[1]), h2[1] = Mt(h2[0], h2[0] = h2[1])), C2 + 1;
      C2++, f3 = y2, P5 = x4, y2 = 0.8, x4 = -1, _ = 0.8, v3 = 1 / 32, p3 = 10 * r, b2 = 0;
    }
  }
}
function Ye(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  if (Fs(s4, 0, 1) && Fs(n6, 0, 1)) {
    if (0 === ei.distance(t2.getCoord2D(s4), e5.getCoord2D(n6))) {
      const h3 = 1e-12, m2 = new Se(), u = Ss();
      if (t2.queryDerivative(new p2(s4, u), m2), m2.isTrueZero()) {
        const e6 = 1 === s4 ? -1e-12 : h3;
        t2.queryDerivative(new p2(s4, u).add(e6), m2);
      }
      1 === s4 && m2.negateThis();
      const l2 = new Se();
      if (e5.queryDerivative(new p2(n6, u), l2), l2.isTrueZero()) {
        const t3 = 1 === s4 ? -1e-12 : h3;
        e5.queryDerivative(new p2(n6, u).add(t3), l2);
      }
      1 === n6 && l2.negateThis(), m2.isZero() || m2.normalize(), l2.isZero() || l2.normalize();
      const c = m2.dotProduct(l2), g2 = m2.crossProduct(l2);
      g2.scaleError(3);
      const d2 = () => {
        {
          const s5 = t2.calculateUpperLength2D(), n7 = e5.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s5, n7), 1e-10);
        }
      };
      if (c.ge(I2) && (g2.isZero() || Math.abs(g2.value()) < d2())) {
        return Me(t2, e5, s4, n6, i2, r, o2, a2);
      }
    }
  }
  return 0;
}
function Xe(t2, e5, n6) {
  if (n2(t2.isCurve() || e5.isCurve()), t2.getStartXY().equals(e5.getStartXY())) {
    if (Ye(t2, e5, 0, 0, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t2.getEndXY().equals(e5.getEndXY())) {
    if (Ye(t2, e5, 1, 1, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t2.getStartXY().equals(e5.getEndXY())) {
    if (Ye(t2, e5, 0, 1, n6, 2, [0, 0], [0, 0])) return true;
  }
  if (t2.getEndXY().equals(e5.getStartXY())) {
    if (Ye(t2, e5, 1, 0, n6, 2, [0, 0], [0, 0])) return true;
  }
  return false;
}
function Ne(t2, e5) {
  t2.m_XStart = e5.x, t2.m_YStart = e5.y;
}
function qe(t2, e5, s4) {
  t2.m_XStart = e5, t2.m_YStart = s4;
}
function Fe(t2, e5) {
  t2.m_XEnd = e5.x, t2.m_YEnd = e5.y;
}
function Ve(t2, e5, s4) {
  t2.m_XEnd = e5, t2.m_YEnd = s4;
}
function Le(t2, e5, s4) {
  e5 ? t2.m_XEnd === s4.x && t2.m_YEnd === s4.y || (t2.m_XEnd = s4.x, t2.m_YEnd = s4.y, t2.endPointModified()) : t2.m_XStart === s4.x && t2.m_YStart === s4.y || (t2.m_XStart = s4.x, t2.m_YStart = s4.y, t2.endPointModified());
}
function Re(t2, e5) {
  const s4 = new X2();
  return e5 ? (s4.x = t2.m_XEnd, s4.y = t2.m_YEnd) : (s4.x = t2.m_XStart, s4.y = t2.m_YStart), s4.z = ze(t2, e5), s4;
}
function ze(t2, e5) {
  return t2.m_description.hasZ() ? t2.m_attributes[e5 * (t2.m_description.getTotalComponentCount() - 2)] : we.getDefaultValue(1);
}
function ke(t2, e5, s4) {
  t2.m_description.hasZ() || t2.addAttribute(1), e5 ? t2.m_XEnd === s4.x && t2.m_YEnd === s4.y || (t2.m_XEnd = s4.x, t2.m_YEnd = s4.y, t2.endPointModified()) : t2.m_XStart === s4.x && t2.m_YStart === s4.y || (t2.m_XStart = s4.x, t2.m_YStart = s4.y, t2.endPointModified()), t2.m_attributes[(t2.m_description.getTotalComponentCount() - 2) * e5] = s4.z;
}
function Be(t2, e5, s4) {
  s4.assignVertexDescription(t2.m_description);
  const n6 = 0 === e5 ? t2.m_XStart : t2.m_XEnd, i2 = 0 === e5 ? t2.m_YStart : t2.m_YEnd;
  s4.setXYCoords(n6, i2);
  for (let r = 1; r < t2.m_description.getAttributeCount(); r++) {
    const n7 = t2.m_description.getSemantics(r);
    for (let i3 = 0, r2 = we.getComponentCount(n7); i3 < r2; i3++) {
      const r3 = We(t2, e5, n7, i3);
      s4.setAttributeBasic(n7, i3, r3);
    }
  }
}
function Ge(t2, e5, s4) {
  s4.isEmpty() && x(""), Le(t2, e5, s4.getXY());
  const n6 = s4.getDescription();
  n6 !== t2.m_description && t2.mergeVertexDescription(n6);
  for (let i2 = 1, r = n6.getAttributeCount(); i2 < r; i2++) {
    const r2 = n6.getSemantics(i2), o2 = we.getComponentCount(r2);
    for (let n7 = 0; n7 < o2; n7++) {
      je(t2, e5, r2, n7, s4.getAttributeAsDbl(r2, n7));
    }
  }
}
function We(t2, e5, s4, i2) {
  if ((e5 < 0 || e5 > 1) && A(""), 0 === s4) return (i2 < 0 || i2 >= 2) && A(""), 0 === e5 ? 0 === i2 ? t2.m_XStart : t2.m_YStart : 0 === i2 ? t2.m_XEnd : t2.m_YEnd;
  const r = we.getComponentCount(s4);
  (i2 < 0 || i2 >= r) && A("");
  const o2 = t2.m_description.getAttributeIndex(s4);
  return o2 >= 0 ? t2.m_attributes[e5 * (t2.m_description.getTotalComponentCount() - 2) + t2.m_description.getPointAttributeOffset(o2) - 2 + i2] : we.getDefaultValue(s4);
}
function je(t2, e5, s4, i2, r) {
  if ((e5 < 0 || e5 > 1) && A(""), 0 === s4) return 0 === e5 ? 0 === i2 ? t2.m_XStart = r : 1 === i2 ? t2.m_YStart = r : A("") : 1 === e5 ? 0 === i2 ? t2.m_XEnd = r : 1 === i2 ? t2.m_YEnd = r : A("") : A(""), void t2.endPointModified();
  const o2 = we.getComponentCount(s4);
  (i2 < 0 || i2 >= o2) && A("");
  let a2 = t2.m_description.getAttributeIndex(s4);
  a2 < 0 && (t2.addAttribute(s4), a2 = t2.m_description.getAttributeIndex(s4)), t2.m_attributes[e5 * (t2.m_description.getTotalComponentCount() - 2) + t2.m_description.getPointAttributeOffset(a2) - 2 + i2] = r;
}
function Ze(t2, e5) {
  if (t2 === e5) return;
  e5.isEmpty() && x("");
  const s4 = e5.getDescription();
  s4 !== t2.m_description && t2.mergeVertexDescription(s4);
  for (let n6 = 1, i2 = s4.getAttributeCount(); n6 < i2; n6++) {
    const i3 = s4.getSemantics(n6), r = we.getComponentCount(i3);
    for (let s5 = 0; s5 < r; s5++) {
      let n7 = We(e5, 0, i3, s5);
      je(t2, 0, i3, s5, n7), n7 = We(e5, 1, i3, s5), je(t2, 1, i3, s5, n7);
    }
  }
}
function He(t2, e5) {
  const s4 = L3();
  Y2(e5, t2.m_description, s4);
  let n6 = null;
  const i2 = e5.getTotalComponentCount() - 2, r = t2.m_description ? t2.m_description.getTotalComponentCount() - 2 : 0;
  if (i2 > 0 && (n6 = Lt(2 * i2, Number.NaN), Tt(n6, e5.getDefaultPointAttributes(), 0, 2, i2), Tt(n6, e5.getDefaultPointAttributes(), i2, 2, i2), null !== t2.m_description)) for (let o2 = 1; o2 < e5.getAttributeCount(); o2++) {
    const a2 = s4[o2];
    if (-1 !== a2) {
      const s5 = t2.m_description.getPointAttributeOffset(a2) - 2, h2 = e5.getPointAttributeOffset(o2) - 2, m2 = we.getComponentCount(e5.getSemantics(o2));
      for (let e6 = 0; e6 < m2; ++e6) n6[h2] = t2.m_attributes[s5], n6[i2 + h2] = t2.m_attributes[r + s5];
    }
  }
  t2.m_attributes = n6, t2.m_description = e5;
}
function Ue(t2) {
  return t2.absNorm() * Cs();
}
function Oe(t2, e5) {
  return Math.max(t2.absNorm(), e5.absNorm()) * Cs();
}
function Qe(t2, e5, s4) {
  const n6 = new ve();
  t2.queryEnvelopeW(x2.unit(), n6);
  const i2 = new ve();
  return e5.queryEnvelopeW(x2.unit(), i2), i2.inflate(s4), !n6.isIntersectingW(i2);
}
function Je(t2, e5, s4) {
  const n6 = St(t2, s4), i2 = St(e5, s4);
  n6.sort((t3, e6) => t3.compare(e6)), i2.sort((t3, e6) => t3.compare(e6));
  for (let r = 0; r < 3; r++) {
    if (n6[r].compare(i2[r]) < 0) return -1;
    if (0 !== n6[r].compare(i2[r])) return 1;
  }
  return 0;
}
var Ke = B3;
var $e = class {
  constructor(t2) {
    if (t2.copy) {
      if (this.m_XStart = t2.copy.m_XStart, this.m_YStart = t2.copy.m_YStart, this.m_XEnd = t2.copy.m_XEnd, this.m_YEnd = t2.copy.m_YEnd, this.m_description = t2.copy.m_description, this.m_attributes = null, this.m_description) {
        this.m_description.getTotalComponentCount() - 2 && (this.m_attributes = t2.copy.m_attributes.slice());
      }
    } else {
      if (t2.move) return this.m_description = t2.move.m_description, t2.move.m_description = null, this.m_attributes = t2.move.m_attributes, t2.move.m_attributes = null, this.m_XStart = t2.move.m_XStart, this.m_YStart = t2.move.m_YStart, this.m_XEnd = t2.move.m_XEnd, void (this.m_YEnd = t2.move.m_YEnd);
      if (void 0 !== t2.XStart) return this.m_XStart = t2.XStart, this.m_YStart = t2.YStart, this.m_XEnd = t2.XEnd, this.m_YEnd = t2.YEnd, this.m_attributes = null, this.m_description = t2.vd ? t2.vd : M(), void (t2.vd && this.setDefaultAttributeValues());
      if (void 0 !== t2.ZStart) return this.m_XStart = t2.XStart, this.m_YStart = t2.YStart, this.m_XEnd = t2.XEnd, this.m_YEnd = t2.YEnd, this.m_description = t2.vd ? t2.vd : O2(), void (t2.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t2.ZStart, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t2.ZEnd) : this.m_attributes = [t2.ZStart, t2.ZEnd]);
      if (t2.start) return this.m_XStart = t2.start.x, this.m_YStart = t2.start.y, this.m_XEnd = t2.end.x, this.m_YEnd = t2.end.y, this.m_attributes = null, void (this.m_description = M());
      if (t2.start3D) return this.m_XStart = t2.start3D.x, this.m_YStart = t2.start3D.y, this.m_XEnd = t2.end3D.x, this.m_YEnd = t2.end3D.y, this.m_description = t2.vd ? t2.vd : O2(), void (t2.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t2.start3D.z, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t2.end3D.z) : this.m_attributes = [t2.start3D.z, t2.end3D.z]);
      b("bad constructor params"), this.m_XStart = this.m_YStart = this.m_XEnd = this.m_YEnd = Number.NaN;
    }
  }
  setDefaultAttributeValues() {
    const t2 = this.m_description.getTotalComponentCount() - 2;
    t2 > 0 && (null === this.m_attributes && (this.m_attributes = Lt(2 * t2, Number.NaN)), Tt(this.m_attributes, this.m_description.getDefaultPointAttributes(), 0, 2, t2), Tt(this.m_attributes, this.m_description.getDefaultPointAttributes(), t2, 2, t2));
  }
  absNormXYZ(t2) {
    return z("not implemented"), 0;
  }
  snapControlPoints3D() {
    return z("not implemented"), false;
  }
  setCoordsForIntersector3D(t2, e5, s4) {
    z("not implemented");
  }
  transformAttribute(t2, e5, s4, n6, i2) {
    z("");
  }
  mergeVertexDescriptionImpl(t2) {
    const e5 = this.getDescription(), s4 = H2(e5, t2);
    this.assignVertexDescription(s4);
  }
  changeEndPoints(t2, e5) {
    const s4 = t2.getXY(), n6 = e5.getXY();
    this.changeEndPoints2D(s4, n6);
    let i2 = t2.getDescription();
    i2 !== this.getDescription() && this.mergeVertexDescription(i2), i2 = e5.getDescription(), i2 !== this.getDescription() && this.mergeVertexDescription(i2);
    for (let r = 1, o2 = i2.getAttributeCount(); r < o2; r++) {
      const s5 = i2.getSemantics(r), n7 = Ke.getComponentCount(s5);
      for (let i3 = 0; i3 < n7; i3++) {
        je(this, 0, s5, i3, t2.getAttributeAsDbl(s5, i3));
        je(this, 1, s5, i3, e5.getAttributeAsDbl(s5, i3));
      }
    }
  }
  getStartXY() {
    return new ei(this.m_XStart, this.m_YStart);
  }
  setStartXY(t2) {
    this.m_XStart = t2.x, this.m_YStart = t2.y, this.endPointModified();
  }
  setStartXYCoords(t2, e5) {
    this.m_XStart = t2, this.m_YStart = e5, this.endPointModified();
  }
  getStartXYZ() {
    return Re(this, 0);
  }
  setStartXYZ(t2) {
    ke(this, 0, t2);
  }
  setStartXYZCoords(t2, e5, s4) {
    ke(this, 0, X2.construct(t2, e5, s4));
  }
  queryStart(t2) {
    Be(this, 0, t2);
  }
  setStart(t2) {
    Ge(this, 0, t2);
  }
  setStart2D(t2) {
    this.setStartXY(t2);
  }
  getStartAttributeAsDbl(t2, e5) {
    return We(this, 0, t2, e5);
  }
  getStartAttributeAsInt(t2, e5) {
    return n2(0), 0;
  }
  setStartAttribute(t2, e5, s4) {
    je(this, 0, t2, e5, s4);
  }
  setStartAttributesFromPoint(t2, e5) {
    const s4 = t2.getDescription();
    for (let n6 = e5 && s4.hasZ() ? 2 : 1, i2 = s4.getAttributeCount(); n6 < i2; ++n6) {
      const e6 = s4.getSemantics(n6), i3 = Ke.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; ++s5) {
        const n7 = t2.getAttributeAsDbl(e6, s5);
        this.setStartAttribute(e6, s5, n7);
      }
    }
  }
  setEndAttributesFromPoint(t2, e5) {
    const s4 = t2.getDescription();
    for (let n6 = e5 && s4.hasZ() ? 2 : 1, i2 = s4.getAttributeCount(); n6 < i2; ++n6) {
      const e6 = s4.getSemantics(n6), i3 = Ke.getComponentCount(e6);
      for (let s5 = 0; s5 < i3; ++s5) {
        const n7 = t2.getAttributeAsDbl(e6, s5);
        this.setEndAttribute(e6, s5, n7);
      }
    }
  }
  getStartX() {
    return this.m_XStart;
  }
  getStartY() {
    return this.m_YStart;
  }
  getStartZ() {
    return n2(0), 0;
  }
  getEndX() {
    return this.m_XEnd;
  }
  getEndY() {
    return this.m_YEnd;
  }
  getEndZ() {
    return n2(0), 0;
  }
  getEndXY() {
    return new ei(this.m_XEnd, this.m_YEnd);
  }
  setEndXY(t2) {
    this.m_XEnd = t2.x, this.m_YEnd = t2.y, this.endPointModified();
  }
  setEndXYCoords(t2, e5) {
    this.m_XEnd = t2, this.m_YEnd = e5, this.endPointModified();
  }
  getEndXYZ() {
    return Re(this, 1);
  }
  setEndXYZ(t2) {
    ke(this, 1, t2);
  }
  setEndXYZCoords(t2, e5, s4) {
    ke(this, 1, X2.construct(t2, e5, s4));
  }
  queryEnd(t2) {
    Be(this, 1, t2);
  }
  setEnd(t2) {
    Ge(this, 1, t2);
  }
  setEnd2D(t2) {
    this.setEndXY(t2);
  }
  getEndAttributeAsDbl(t2, e5) {
    return We(this, 1, t2, e5);
  }
  getEndAttributeAsInt(t2, e5) {
    return n2(0), Math.trunc(0);
  }
  setEndAttribute(t2, e5, s4) {
    je(this, 1, t2, e5, s4);
  }
  getDimension() {
    return 1;
  }
  copyTo(t2) {
    if (this === t2) return;
    t2.getGeometryType() !== this.getGeometryType() && P("");
    const s4 = t2;
    s4.assignVertexDescription(this.m_description), s4.m_attributes && Tt(s4.m_attributes, this.m_attributes, 0, 0, 2 * (this.m_description.getTotalComponentCount() - 2)), s4.m_XStart = this.m_XStart, s4.m_YStart = this.m_YStart, s4.m_XEnd = this.m_XEnd, s4.m_YEnd = this.m_YEnd, this.copyToImpl(s4);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isClosed() {
    return this.m_XStart === this.m_XEnd && this.m_YStart === this.m_YEnd;
  }
  setEmpty() {
  }
  calculateArea2D() {
    return 0;
  }
  queryInterval(t2, e5) {
    const s4 = x2.constructEmpty();
    return s4.vmin = We(this, 0, t2, e5), s4.vmax = s4.vmin, s4.mergeNeCoordinate(We(this, 1, t2, e5)), s4;
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  getCoord3D(t2) {
    return n2(0), {};
  }
  getCoord2D(t2) {
    const e5 = ei.getNAN();
    return this.queryCoord2D(t2, e5), e5;
  }
  queryCoord3D(t2, e5) {
    n2(0);
  }
  getCoordZ(t2) {
    return n2(0), 0;
  }
  queryCoord(t2, e5) {
    e5.assignVertexDescription(this.m_description), e5.setXY(this.getCoord2D(t2));
    for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
      const n7 = this.m_description.getSemantics(s4), i2 = Ke.getComponentCount(n7);
      for (let s5 = 0; s5 < i2; s5++) {
        const i3 = this.getAttributeAsDbl(t2, n7, s5);
        e5.setAttributeBasic(n7, s5, i3);
      }
    }
  }
  isCloserThanDistance(t2, e5, s4) {
    const n6 = n4.constructEmpty();
    this.queryLooseEnvelopeOnInterval(e5, n6);
    if (n6.distance(t2) > s4) return false;
    const i2 = this.getClosestCoordinateOnInterval(t2, e5, s4);
    return !Number.isNaN(i2) && ei.distance(t2, this.getCoord2D(i2)) <= s4;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  isTrue3D() {
    return false;
  }
  getReversed() {
    const t2 = this.clone();
    return t2.reverse(), t2;
  }
  reverse() {
    this.m_XEnd = Mt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Mt(this.m_YStart, this.m_YStart = this.m_YEnd), this.reverseImpl();
    for (let t2 = 1, e5 = this.m_description.getAttributeCount(); t2 < e5; t2++) {
      const e6 = this.m_description.getSemantics(t2);
      for (let t3 = 0, s4 = Ke.getComponentCount(e6); t3 < s4; t3++) {
        const s5 = We(this, 0, e6, t3);
        je(this, 0, e6, t3, We(this, 1, e6, t3)), je(this, 1, e6, t3, s5);
      }
    }
    return this.afterCompletedModification(), this;
  }
  isEmptyImpl() {
    return false;
  }
  isCircular() {
    return false;
  }
  distance(t2, e5, n6, i2) {
    if (!e5 && this.isIntersecting(t2, 0, false)) {
      if (null !== n6 || null !== i2) {
        const e6 = Lt(9, Number.NaN), r2 = Lt(9, Number.NaN), o3 = this.intersect(t2, null, e6, r2, 0);
        n2(o3 <= 9), 0 === o3 && b(""), null !== n6 && (n6[0] = e6[0]), null !== i2 && (i2[0] = r2[0]);
      }
      return 0;
    }
    let r, o2 = Number.MAX_VALUE, a2 = -1, m2 = o2;
    return r = this.getStartXY(), a2 = t2.getClosestCoordinate(r, false), r.subThis(t2.getCoord2D(a2)), m2 = r.length(), m2 < o2 && (o2 = m2, null !== i2 && (i2[0] = a2), null !== n6 && (n6[0] = 0)), r = this.getEndXY(), a2 = t2.getClosestCoordinate(r, false), r.subThis(t2.getCoord2D(a2)), m2 = r.length(), m2 < o2 && (o2 = m2, null !== i2 && (i2[0] = a2), null !== n6 && (n6[0] = 1)), r = t2.getStartXY(), a2 = this.getClosestCoordinate(r, false), r.subThis(this.getCoord2D(a2)), m2 = r.length(), m2 < o2 && (o2 = m2, null !== n6 && (n6[0] = a2), null !== i2 && (i2[0] = 0)), r = t2.getEndXY(), a2 = this.getClosestCoordinate(r, false), r.subThis(this.getCoord2D(a2)), m2 = r.length(), m2 < o2 && (o2 = m2, null !== n6 && (n6[0] = a2), null !== i2 && (i2[0] = 1)), o2;
  }
  calculateSubLengthFromStart(t2) {
    return this.tToLength(t2);
  }
  calculateSubLength(t2, e5) {
    return e5 === t2 ? 0 : this.tToLength(e5) - this.tToLength(t2);
  }
  static recalculateParentT(t2, e5, s4) {
    return Q(t2, e5, s4);
  }
  moveTo(t2) {
    const e5 = this.isClosed(), s4 = new x3();
    s4.setShift(t2.sub(this.getStartXY())), this.applyTransformation(s4), e5 ? this.changeEndPoints2D(t2, t2) : this.changeEndPoints2D(t2, this.getEndXY());
  }
  moveTo3D(t2) {
    n2(0);
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t2) {
    He(this, t2);
  }
  mergeVertexDescription(t2) {
    this.m_description !== t2 && (this.m_description.hasAttributesFrom(t2) || this.mergeVertexDescriptionImpl(t2));
  }
  hasAttribute(t2) {
    return this.m_description.hasAttribute(t2);
  }
  addAttribute(t2) {
    if (this.m_description.hasAttribute(t2)) return;
    const e5 = k3(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t2) {
    if (!this.m_description.hasAttribute(t2)) return;
    const e5 = V2(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t2 = M();
    t2 !== this.m_description && this.assignVertexDescription(t2);
  }
  swap(t2) {
    if (this === t2) return;
    t2.getGeometryType() !== this.getGeometryType() && P("wrong geometry type");
    const s4 = t2;
    s4.m_description = Mt(this.m_description, this.m_description = s4.m_description), s4.m_XStart = Mt(this.m_XStart, this.m_XStart = s4.m_XStart), s4.m_YStart = Mt(this.m_YStart, this.m_YStart = s4.m_YStart), s4.m_XEnd = Mt(this.m_XEnd, this.m_XEnd = s4.m_XEnd), s4.m_YEnd = Mt(this.m_YEnd, this.m_YEnd = s4.m_YEnd), s4.m_attributes = Mt(this.m_attributes, this.m_attributes = s4.m_attributes), this.swapImpl(s4);
  }
  equals(t2, e5) {
    if (this.getGeometryType() !== t2.getGeometryType()) return false;
    const s4 = void 0 === e5;
    s4 && (e5 = 0);
    const n6 = t2;
    if (this === n6) return true;
    if (this.m_description !== n6.m_description) return false;
    if (Math.abs(this.m_XStart - n6.m_XStart) > e5 || Math.abs(this.m_XEnd - n6.m_XEnd) > e5 || Math.abs(this.m_YStart - n6.m_YStart) > e5 || Math.abs(this.m_YEnd - n6.m_YEnd) > e5) return false;
    for (let i2 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); i2 < r; i2++) if (!us(this.m_attributes[i2], n6.m_attributes[i2], e5)) return false;
    return s4 ? this.equalsImpl(n6) : this.equalsImplTol(n6, e5);
  }
  getImpl() {
    return this;
  }
  setAttributeBasic(t2, s4, n6) {
    if (this.addAttribute(t2), 0 === t2 && this.isCurve()) {
      (s4 < 0 || s4 > 1) && P("");
      const t3 = new x3(), i2 = 0 === s4 ? n6 : 0, r = 1 === s4 ? n6 : 0;
      t3.setShiftCoords(i2, r), 0 === s4 ? t3.xx = 0 : t3.yy = 0, this.applyTransformation(t3);
    } else this.setStartAttribute(t2, s4, n6), this.setEndAttribute(t2, s4, n6);
  }
  replaceNaNs(t2, e5) {
    if (this.addAttribute(t2), this.isEmpty()) return;
    const s4 = Ke.getComponentCount(t2);
    for (let n6 = 0; n6 < s4; n6++) {
      const s5 = this.getStartAttributeAsDbl(t2, n6);
      Number.isNaN(s5) && this.setStartAttribute(t2, n6, e5);
      const i2 = this.getEndAttributeAsDbl(t2, n6);
      Number.isNaN(i2) && this.setEndAttribute(t2, n6, e5);
    }
  }
};
$e.s_maxMonotonicPartParams = 8;
var ts = class extends t {
  constructor(t2, e5) {
    super(), this.m_index = -1, this.gc = t2, this.dim = e5;
  }
  next() {
    for (; ; ) {
      if (this.m_index >= this.gc.getGeometryCount()) return null;
      if (this.m_index++, this.m_index === this.gc.getGeometryCount()) return null;
      const t2 = this.gc.getGeometry(this.m_index);
      if (-1 === this.dim || 1 << t2.getDimension() & this.dim) return t2;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var es = class _es {
  constructor(t2) {
    this.m_geoms = [], this.m_description = M(), t2 && (t2.vd ? this.m_description = t2.vd : t2.copy ? t2.copy.copyTo(this) : P("constructor argument not recognized"));
  }
  getGeometryCount() {
    return this.m_geoms.length;
  }
  reserve(t2) {
  }
  addGeometry(t2) {
    if (t2.getGeometryType() === a.enumGeometryCollection) {
      const e5 = t2;
      for (let t3 = 0, s4 = e5.getGeometryCount(); t3 < s4; t3++) this.addGeometry(e5.getGeometry(t3));
    } else this.m_geoms.push(t2.clone()), this.mergeVertexDescription(t2.getDescription());
  }
  addCursor(t2) {
    for (let e5 = t2.next(); null !== e5; e5 = t2.next()) this.addGeometry(e5);
  }
  getGeometry(t2) {
    return (t2 < 0 || t2 >= this.m_geoms.length) && P("Geometry_collection.get_geometry"), this.m_geoms[t2];
  }
  modifiedElementIndex(t2) {
    this.mergeVertexDescription(this.getGeometry(t2).getDescription());
  }
  modifiedElement(t2) {
    this.mergeVertexDescription(t2.getDescription());
  }
  getGeometryType() {
    return a.enumGeometryCollection;
  }
  getDimension() {
    let t2 = 0;
    for (const e5 of this.m_geoms) t2 = Math.max(t2, e5.getDimension());
    return t2;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t2) {
    this.m_description !== t2 && this.assignVertexDescriptionImpl(t2);
  }
  assignVertexDescriptionImpl(t2) {
    for (const e5 of this.m_geoms) e5.assignVertexDescription(t2);
    this.m_description = t2;
  }
  mergeVertexDescription(t2) {
    this.m_description !== t2 && (this.m_description.hasAttributesFrom(t2) || this.mergeVertexDescriptionImpl(t2));
  }
  hasAttribute(t2) {
    return this.m_description.hasAttribute(t2);
  }
  addAttribute(t2) {
    if (this.m_description.hasAttribute(t2)) return;
    const e5 = k3(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAttribute(t2) {
    if (!this.m_description.hasAttribute(t2)) return;
    const e5 = V2(this.m_description, t2);
    this.assignVertexDescription(e5);
  }
  dropAllAttributes() {
    const t2 = M();
    t2 !== this.m_description && this.assignVertexDescription(t2);
  }
  queryInterval(t2, e5) {
    let s4 = new x2();
    const n6 = new x2();
    n6.setEmpty();
    for (const i2 of this.m_geoms) s4 = i2.queryInterval(t2, e5), n6.merge(s4);
    return n6;
  }
  queryEnvelope(t2) {
    if (4 === t2.m_EnvelopeType) {
      const e5 = new re();
      t2.setEmpty(), t2.assignVertexDescription(this.m_description);
      for (const s4 of this.m_geoms) s4.queryEnvelope(e5), t2.merge(e5);
    } else if (2 === t2.m_EnvelopeType) {
      const e5 = new n4();
      t2.setEmpty();
      for (const s4 of this.m_geoms) s4.queryEnvelope(e5), t2.mergeEnvelope2D(e5);
    }
    z("3d envelope case not implemented");
  }
  queryLooseEnvelope(t2) {
    if (2 === t2.m_EnvelopeType) {
      const e5 = new n4();
      t2.setEmpty();
      for (const s4 of this.m_geoms) s4.queryLooseEnvelope(e5), t2.mergeEnvelope2D(e5);
    }
    z("3d not impl");
  }
  isEmpty() {
    return 0 === this.m_geoms.length;
  }
  setEmpty() {
    this.m_geoms.length = 0;
  }
  applyTransformation(t2) {
    if (1 === t2.m_TransformationType) for (const e5 of this.m_geoms) e5.applyTransformation(t2);
    z("3d xform not impl");
  }
  transformAttribute(t2, e5, s4, n6, i2) {
    for (const r of this.m_geoms) r.transformAttribute(t2, e5, s4, n6, i2);
  }
  createInstance() {
    return new _es({ vd: this.getDescription() });
  }
  copyTo(t2) {
    t2.getGeometryType() !== a.enumGeometryCollection && P("");
    const s4 = t2;
    if (s4 !== this) {
      s4.m_geoms.length = 0, s4.assignVertexDescription(this.m_description);
      for (const t3 of this.m_geoms) s4.m_geoms.push(t3.clone());
    }
  }
  calculateArea2D() {
    const t2 = new n3(0);
    for (const e5 of this.m_geoms) t2.pe(e5.calculateArea2D());
    return t2.getResult();
  }
  calculateLength2D() {
    const t2 = new n3(0);
    for (const e5 of this.m_geoms) t2.pe(e5.calculateLength2D());
    return t2.getResult();
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  getBoundary() {
    const t2 = this.createInstance(), e5 = t2;
    for (const s4 of this.m_geoms) {
      const t3 = s4.getBoundary();
      t3 && e5.m_geoms.push(t3);
    }
    return t2;
  }
  clone() {
    return new _es({ copy: this });
  }
  equals(t2, e5) {
    if (t2 === this) return true;
    if (t2.getGeometryType() !== a.enumGeometryCollection) return false;
    const s4 = t2;
    if (this.m_description !== s4.m_description) return false;
    if (this.m_geoms.length !== s4.m_geoms.length) return false;
    for (let n6 = 0; n6 < this.m_geoms.length; ++n6) if (!this.m_geoms[n6].equals(s4.m_geoms[n6], e5)) return false;
    return true;
  }
  swap(t2) {
    t2.getGeometryType() !== a.enumGeometryCollection && P("");
    const s4 = t2;
    s4 !== this && (this.m_geoms = Mt(s4.m_geoms, s4.m_geoms = this.m_geoms));
  }
  setAttributeBasic(t2, e5, s4) {
    for (const n6 of this.m_geoms) n6.setAttributeBasic(t2, e5, s4);
  }
  replaceNaNs(t2, e5) {
    for (const s4 of this.m_geoms) s4.replaceNaNs(t2, e5);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t2) {
    const e5 = this.getDescription(), s4 = H2(e5, t2);
    this.assignVertexDescription(s4);
  }
};
function ss(t2, e5 = -1) {
  return new ts(t2, e5);
}
es.type = a.enumGeometryCollection;
var ns = class extends $e {
  constructor(t2) {
    super(t2);
  }
};
var is = class extends ns {
  isTrue3D() {
    return true;
  }
  constructor(t2) {
    super(t2);
  }
};
function rs2(t2, e5, s4) {
  os2(e5, t2.getStartXY(), t2.getEndXY(), s4);
}
function os2(t2, e5, s4, n6) {
  Y(e5, s4, t2, n6);
}
function as2(t2, e5) {
  return Q(t2.m_XStart, t2.m_XEnd, e5);
}
function hs2(t2, e5) {
  return Q(t2.m_YStart, t2.m_YEnd, e5);
}
function ms2(t2, e5) {
  const s4 = t2.getStartZ(), n6 = t2.getEndZ();
  return Q(s4, n6, e5);
}
function us2(t2, e5, s4) {
  const n6 = Se.constructPoint2D(t2.getStartXY()), i2 = Se.constructPoint2D(t2.getEndXY());
  s4.setCoordsE(i2.x.subE(n6.x), i2.y.subE(n6.y));
}
function ls2(t2, e5, s4) {
  e5.value() <= 0.5 ? O(2, Se.constructPoint2D(t2.getStartXY()), Se.constructPoint2D(t2.getEndXY()), e5, s4) : G2(2, Se.constructPoint2D(t2.getStartXY()), Se.constructPoint2D(t2.getEndXY()), e5, s4);
}
function cs(t2, e5, s4) {
  t2.m_XStart = e5.x, t2.m_YStart = e5.y, t2.m_XEnd = s4.x, t2.m_YEnd = s4.y, t2.afterCompletedModification();
}
function gs2(t2, e5) {
  const s4 = t2.getStartXYZ();
  s4.z *= e5;
  const n6 = t2.getEndXYZ();
  return n6.z *= e5, s4.norm(1) + n6.norm(1);
}
function ds(t2) {
  if (t2.m_YEnd < t2.m_YStart || t2.m_YEnd === t2.m_YStart && t2.m_XEnd < t2.m_XStart) {
    t2.m_XEnd = Mt(t2.m_XStart, t2.m_XStart = t2.m_XEnd), t2.m_YEnd = Mt(t2.m_YStart, t2.m_YStart = t2.m_YEnd);
    for (let e5 = 0, s4 = t2.m_description.getTotalComponentCount() - 2; e5 < s4; e5++) t2.m_attributes[e5 + s4] = Mt(t2.m_attributes[e5], t2.m_attributes[e5] = t2.m_attributes[e5 + s4]);
  }
}
function _s(t2, e5, s4, n6) {
  let i2 = 0;
  if ((t2.m_XStart === e5.m_XStart && t2.m_YStart === e5.m_YStart || t2.m_XStart === e5.m_XEnd && t2.m_YStart === e5.m_YEnd) && (i2++, !n6)) return 1;
  if (t2.m_XEnd === e5.m_XStart && t2.m_YEnd === e5.m_YStart || t2.m_XEnd === e5.m_XEnd && t2.m_YEnd === e5.m_YEnd) {
    if (i2++, 2 === i2) return 2;
    if (!n6) return 1;
  }
  return e5.isIntersectingPoint(t2.getStartXY(), s4, true) || e5.isIntersectingPoint(t2.getEndXY(), s4, true) || t2.isIntersectingPoint(e5.getStartXY(), s4, true) || t2.isIntersectingPoint(e5.getEndXY(), s4, true) ? 4 : n6 && i2 ? 0 : Ps2(t2, e5) ? 4 : 0;
}
function ps(t2, e5, s4, n6, i2, r, o2, a2) {
  null !== n6 && Zt(n6, 2, Number.NaN), null !== i2 && Zt(i2, 2, Number.NaN), null !== s4 && Ct(s4, ei, 2);
  const h2 = fs(t2, e5, 2, s4, n6, i2, r, o2, a2);
  return n6 && (n6.length = h2), i2 && (i2.length = h2), s4 && (s4.length = h2), h2;
}
function fs(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  const m2 = xs(t2, e5.getStartXY(), o2, false), u = xs(t2, e5.getEndXY(), o2, false), l2 = xs(e5, t2.getStartXY(), o2, false), c = xs(e5, t2.getEndXY(), o2, false);
  let g2 = 0, d2 = 0;
  if (!Number.isNaN(m2)) {
    let s5 = false;
    a2 && Fs(m2, 0, 1) && t2.getCoord2D(m2).isEqualPoint2D(e5.getStartXY()) && (g2++, s5 = true), s5 || (i2 && (i2[d2] = m2), r && (r[d2] = 0), n6 && n6[d2].setCoords(e5.m_XStart, e5.m_YStart), d2++);
  }
  if (!Number.isNaN(u)) {
    let o3 = false;
    a2 && Fs(u, 0, 1) && t2.getCoord2D(u).isEqualPoint2D(e5.getEndXY()) && (g2++, o3 = true), o3 || (s4 > d2 && (i2 && (i2[d2] = u), r && (r[d2] = 1), n6 && n6[d2].setCoords(e5.m_XEnd, e5.m_YEnd)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(l2) && !(0 === m2 && 0 === l2 || 0 === u && 1 === l2)) {
    let o3 = false;
    a2 && Fs(l2, 0, 1) && e5.getCoord2D(l2).isEqualPoint2D(t2.getStartXY()) && (g2++, o3 = true), o3 || (s4 > d2 && (i2 && (i2[d2] = 0), r && (r[d2] = l2), n6 && n6[d2].setCoords(t2.m_XStart, t2.m_YStart)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(c) && !(1 === m2 && 0 === c || 1 === u && 1 === c)) {
    let o3 = false;
    a2 && Fs(c, 0, 1) && e5.getCoord2D(c).isEqualPoint2D(t2.getEndXY()) && (g2++, o3 = true), o3 || (s4 > d2 && (i2 && (i2[d2] = 1), r && (r[d2] = c), n6 && n6[d2].setCoords(e5.m_XEnd, e5.m_YEnd)), d2++);
  }
  if (d2 > 0) return h2 && (r = Mt(i2, i2 = r)), 2 === d2 && s4 >= 2 && i2 && i2[0] > i2[1] && (i2[1] = Mt(i2[0], i2[0] = i2[1]), r && (r[1] = Mt(r[0], r[0] = r[1])), n6 && (n6[1] = Mt(n6[0], n6[0] = n6[1]))), d2;
  if (g2 > 0) return 0;
  const _ = Ss2(t2, e5, o2);
  return Number.isNaN(_.x) ? 0 : (n6 && (n6[0] = t2.getCoord2D(_.x)), i2 && (i2[0] = _.x), r && (r[0] = _.y), 1);
}
function Ps2(t2, e5) {
  const s4 = Cs2(t2, e5.m_XStart, e5.m_YStart), n6 = Cs2(t2, e5.m_XEnd, e5.m_YEnd);
  if (s4 < 0 && n6 < 0 || s4 > 0 && n6 > 0) return false;
  const i2 = Cs2(e5, t2.m_XStart, t2.m_YStart), r = Cs2(e5, t2.m_XEnd, t2.m_YEnd);
  if (i2 < 0 && r < 0 || i2 > 0 && r > 0) return false;
  return Es2(t2) > Es2(e5) ? bs(t2, e5) : bs(e5, t2);
}
function xs(t2, e5, s4, n6) {
  const i2 = ei.getNAN(), r = ei.getNAN();
  let o2 = false;
  t2.m_YEnd < t2.m_YStart || t2.m_YEnd === t2.m_YStart && t2.m_XEnd < t2.m_XStart ? (i2.setCoords(t2.m_XEnd, t2.m_YEnd), r.setCoords(t2.m_XStart, t2.m_YStart), o2 = true) : (i2.setCoords(t2.m_XStart, t2.m_YStart), r.setCoords(t2.m_XEnd, t2.m_YEnd));
  const a2 = o2 ? 1 : 0, h2 = o2 ? 0 : 1, m2 = ei.getNAN();
  m2.setSub(e5, i2);
  let u = m2.length(), l2 = 3 * u * Ss();
  if (u <= Math.max(s4, l2)) return n6 && 0 === u ? Number.NaN : a2;
  if (m2.setSub(e5, r), u = m2.length(), l2 = 3 * u * Ss(), u <= Math.max(s4, l2)) return n6 && 0 === u ? Number.NaN : h2;
  m2.setCoords(r.x - i2.x, r.y - i2.y);
  const c = m2.length();
  if (c > 0) {
    const t3 = 1 / c;
    m2.scale(t3);
    const n7 = ei.getNAN();
    n7.setSub(e5, i2);
    const u2 = n7.dotProduct(m2), l3 = 8 * n7.dotProductAbs(m2) * Ss();
    m2.leftPerpendicularThis();
    const g2 = n7.dotProduct(m2), d2 = 8 * n7.dotProductAbs(m2) * Ss(), _ = Math.max(s4, l3);
    if (u2 < -_ || u2 > c + _) return Number.NaN;
    const p3 = Math.max(s4, d2);
    if (Math.abs(g2) <= p3) {
      let n8 = u2 * t3;
      n8 = ks(n8, 0, 1);
      const m3 = ei.getNAN();
      if (os2(n8, i2, r, m3), ei.distance(m3, e5) <= s4) {
        if (n8 < 0.5) {
          if (ei.distance(m3, i2) <= s4 && ei.distance(e5, i2) <= s4) return a2;
        } else if (ei.distance(m3, r) <= s4 && ei.distance(e5, r) <= s4) return h2;
        return o2 ? 1 - n8 : n8;
      }
    }
  }
  return Number.NaN;
}
function Cs2(t2, e5, s4) {
  const n6 = ei.getNAN();
  n6.setCoords(e5, s4), n6.subThis(t2.getStartXY());
  const i2 = ei.getNAN();
  i2.setSub(t2.getEndXY(), t2.getStartXY());
  const r = i2.crossProduct(n6), o2 = 4 * Ss() * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o2 ? -1 : r < -o2 ? 1 : 0;
}
function vs(t2, e5, s4, n6) {
  const i2 = n6 ? t2.m_XStart : t2.m_XEnd, r = n6 ? t2.m_YStart : t2.m_YEnd, o2 = ei.getNAN();
  o2.x = e5.getEndX() - i2, o2.y = e5.getEndY() - r;
  if (s4.dotProduct(o2) > 3 * Ss() * s4.dotProductAbs(o2)) {
    o2.x = e5.getStartX() - i2, o2.y = e5.getStartY() - r;
    return s4.dotProduct(o2) <= 3 * Ss() * s4.dotProductAbs(o2);
  }
  return true;
}
function bs(t2, e5) {
  const s4 = ei.getNAN();
  return s4.x = t2.m_XEnd - t2.m_XStart, s4.y = t2.m_YEnd - t2.m_YStart, !!vs(t2, e5, s4, false) && (s4.negateThis(), !!vs(t2, e5, s4, true));
}
function Es2(t2) {
  const e5 = t2.m_XStart - t2.m_XEnd, s4 = t2.m_YStart - t2.m_YEnd;
  return e5 * e5 + s4 * s4;
}
function Ss2(t2, e5, s4) {
  const n6 = t2.m_XEnd - t2.m_XStart, i2 = t2.m_YEnd - t2.m_YStart, r = e5.m_XEnd - e5.m_XStart, o2 = e5.m_YEnd - e5.m_YStart, a2 = r * i2 - n6 * o2;
  if (0 === a2) return ei.getNAN();
  const h2 = 4 * Ss() * (Math.abs(r * i2) + Math.abs(n6 * o2)), m2 = e5.m_XStart - t2.m_XStart, u = e5.m_YStart - t2.m_YStart, l2 = r * u - m2 * o2, c = 4 * Ss() * (Math.abs(r * u) + Math.abs(m2 * o2)), g2 = l2 / a2, d2 = Math.abs(a2), _ = (c * d2 + h2 * Math.abs(l2)) / (a2 * a2) + Ss() * Math.abs(g2);
  if (g2 < -_ || g2 > 1 + _) return ei.getNAN();
  const p3 = n6 * u - m2 * i2, f3 = p3 / a2, P5 = (4 * Ss() * (Math.abs(n6 * u) + Math.abs(m2 * i2)) * d2 + h2 * Math.abs(p3)) / (a2 * a2) + Ss() * Math.abs(f3);
  if (f3 < -P5 || f3 > 1 + P5) return ei.getNAN();
  let y2 = ks(g2, 0, 1), x4 = ks(f3, 0, 1);
  const C2 = ei.getNAN();
  rs2(t2, y2, C2);
  const v3 = ei.getNAN();
  if (rs2(e5, x4, v3), !s4 || ei.distance(C2, v3) > s4) {
    const n7 = ei.getNAN();
    Y(C2, v3, 0.5, n7), y2 = t2.getClosestCoordinate(n7, false), x4 = e5.getClosestCoordinate(n7, false);
    const i3 = ei.getNAN();
    rs2(t2, y2, i3);
    const r2 = ei.getNAN();
    rs2(e5, x4, r2), i3.subThis(r2);
    const o3 = i3.length(), a3 = (t2.absNorm() + e5.absNorm()) * Cs();
    if (o3 > Math.max(s4, a3)) return ei.getNAN();
  }
  return new ei(y2, x4);
}
var Ds = class {
  constructor(t2) {
    if (this.m_segFlagStream = null, this.m_xyStream = null, this.m_bCirculator = false, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_parent = t2.parent, this.m_buffer = new this.m_parent.m_segmentBufferCTor(), this.m_description = t2.parent.getDescription(), this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), void 0 !== t2.pointIndex) {
      (t2.pointIndex < 0 || t2.pointIndex >= t2.parent.getPointCount()) && A("");
      const e5 = t2.parent.getPathIndexFromPointIndex(t2.pointIndex);
      this.m_currentPathIndex = e5, this.m_nextPathIndex = e5 + 1, this.m_nextSegmentIndex = t2.pointIndex - t2.parent.getPathStart(e5), this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex);
    } else if (void 0 !== t2.pathIndex) {
      (t2.pathIndex < 0 || t2.pathIndex >= t2.parent.getPathCount() || t2.segmentIndex < 0) && A("");
      const e5 = t2.parent.isClosedPath(t2.pathIndex) ? 0 : 1;
      t2.segmentIndex >= t2.parent.getPathSize(t2.pathIndex) - e5 && A(""), this.m_nextSegmentIndex = t2.segmentIndex, this.m_currentPathIndex = t2.pathIndex, this.m_nextPathIndex = this.m_nextSegmentIndex + 1, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex);
    }
    this.prepare(), this.m_pathBegin = -1, this.m_bCurrentPathClosed = false, this.m_bStripAttributes = false, this.m_prevPathIndex = -1, this.m_prevSegmentIndex = -1, this.m_bNeedsUpdate = false, this.m_currentPathIndex > -1 && (this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex));
  }
  stripAttributes() {
    this.m_bStripAttributes = true;
  }
  prepare() {
    this.m_bCirculator = false, this.m_parent.isEmptyImpl() ? (this.m_segFlagStream = null, this.m_xyStream = null) : (this.m_segFlagStream = this.m_parent.getSegmentFlagsStreamRef(), this.m_xyStream = this.m_parent.getAttributeStreamRef(0));
  }
  nextPath() {
    return this.m_currentPathIndex = this.m_nextPathIndex, !(this.m_currentPathIndex >= this.m_parent.getPathCount()) && (this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.m_nextPathIndex++, true);
  }
  previousPath() {
    return 0 !== this.m_nextPathIndex && (this.m_nextPathIndex--, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), this.m_currentPathIndex = this.m_nextPathIndex, this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.resetToLastSegment(), true);
  }
  getSegmentCount(t2) {
    return this.m_parent.isEmptyImpl() ? 0 : this.m_parent.getSegmentCountPath(t2);
  }
  resetToFirstPath() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  resetToLastPath() {
    this.m_nextPathIndex = this.m_parent.getPathCount(), this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1;
  }
  resetToPath(t2) {
    (t2 < 0 || t2 > this.m_parent.getPathCount()) && A(""), this.m_nextPathIndex = t2, this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  isLastPath() {
    return this.m_currentPathIndex === this.m_parent.getPathCount() - 1;
  }
  isFirstSegmentInPath() {
    return 0 === this.m_currentSegmentIndex;
  }
  isLastSegmentInPath() {
    return this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  resetToFirstSegment() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0;
  }
  resetToLastSegment() {
    this.m_nextSegmentIndex = this.m_segmentCount, this.m_currentSegmentIndex = -1;
  }
  resetTo(t2) {
    this.m_parent !== t2.m_parent && C(""), this.m_currentSegmentIndex = t2.m_currentSegmentIndex, this.m_nextSegmentIndex = t2.m_nextSegmentIndex, this.m_currentPathIndex = t2.m_currentPathIndex, this.m_nextPathIndex = t2.m_nextPathIndex, this.m_segmentCount = t2.m_segmentCount, this.m_bCirculator = t2.m_bCirculator, this.m_pathBegin = t2.m_pathBegin, this.m_bCurrentPathClosed = t2.m_bCurrentPathClosed, this.m_bStripAttributes = t2.m_bStripAttributes, this.m_description = t2.m_description;
  }
  resetToVertex(t2, e5) {
    if (this.m_currentPathIndex >= 0 && this.m_currentPathIndex < this.m_parent.getPathCount()) {
      const e6 = this.getPathBegin();
      if (t2 >= e6 && t2 < this.m_parent.getPathEnd(this.m_currentPathIndex)) return this.m_currentSegmentIndex = -1, void (this.m_nextSegmentIndex = t2 - e6);
    }
    let s4;
    s4 = e5 >= 0 && e5 < this.m_parent.getPathCount() && t2 >= this.m_parent.getPathStart(e5) && t2 < this.m_parent.getPathEnd(e5) ? e5 : this.m_parent.getPathIndexFromPointIndex(t2), this.m_nextPathIndex = s4 + 1, this.m_currentPathIndex = s4, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = t2 - this.m_parent.getPathStart(s4), this.m_segmentCount = this.getSegmentCount(s4), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex);
  }
  hasNextSegment() {
    return this.m_nextSegmentIndex < this.m_segmentCount;
  }
  hasPreviousSegment() {
    return this.m_nextSegmentIndex > 0;
  }
  nextSegment() {
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A("Segment_iterator_impl::next_segment"), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  previousSegment() {
    return this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_segmentCount + this.m_nextSegmentIndex - 1) % this.m_segmentCount : (0 === this.m_nextSegmentIndex && A(""), this.m_nextSegmentIndex--), this.m_nextSegmentIndex !== this.m_currentSegmentIndex && this.updateSegment(), this.m_buffer.get();
  }
  nextCurve() {
    if (!this.m_parent.hasNonLinearSegments()) return this.resetToLastSegment(), null;
    let t2 = 0;
    for (; ; ) {
      if (this.m_nextSegmentIndex === this.m_segmentCount || t2 === this.m_segmentCount) return null;
      const e5 = this.getPathBegin() + this.m_nextSegmentIndex;
      if (1 !== (31 & this.m_segFlagStream.read(e5))) {
        this.updateSegment();
        break;
      }
      this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : this.m_nextSegmentIndex++, t2++;
    }
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A(""), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  getPathBegin() {
    return this.m_pathBegin;
  }
  getPathIndex() {
    return this.m_currentPathIndex;
  }
  getStartPointIndex() {
    return this.getPathBegin() + this.m_currentSegmentIndex;
  }
  getEndPointIndex() {
    return this.isClosingSegment() ? this.getPathBegin() : this.getStartPointIndex() + 1;
  }
  updateSegment() {
    (this.m_nextSegmentIndex < 0 || this.m_nextSegmentIndex >= this.m_segmentCount || this.m_currentPathIndex < 0) && A(""), this.m_currentSegmentIndex = this.m_nextSegmentIndex, this.m_parent.getSegmentFromPath(this.m_currentPathIndex, this.m_currentSegmentIndex, this.m_buffer, this.m_bStripAttributes);
  }
  isClosingSegment() {
    return this.m_bCurrentPathClosed && this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  isCurve() {
    if (null !== this.m_segFlagStream) {
      return 1 !== (31 & this.m_segFlagStream.read(this.m_currentSegmentIndex));
    }
    return false;
  }
  isPathClosed() {
    return this.m_bCurrentPathClosed;
  }
  setCirculator(t2) {
    this.m_bCirculator = t2;
  }
  getImpl() {
    return this;
  }
};
var ws2 = class _ws {
  constructor(t2) {
    this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null, this.m_refCount = 1, t2 && t2.copyTo(this);
  }
  getRasterizedGeometry() {
    return this.m_rasterizedGeometry;
  }
  copyTo(t2) {
    t2 !== this && (n2(t2.uniqueUse()), t2.m_quadTree = this.m_quadTree, t2.m_quadTreeForPaths = this.m_quadTreeForPaths, t2.m_rasterizedGeometry = this.m_rasterizedGeometry);
  }
  clone() {
    const t2 = new _ws();
    return this.copyTo(t2), t2;
  }
  uniqueUse() {
    return 1 === this.m_refCount;
  }
  addRef() {
    ++this.m_refCount;
  }
  release() {
    0 == --this.m_refCount && (this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null);
  }
  setRasterizedGeometry(t2) {
    n2(this.uniqueUse());
  }
  setQuadTree(t2) {
    n2(this.uniqueUse()), this.m_quadTree = t2;
  }
  setQuadTreeForPaths(t2) {
    n2(this.uniqueUse()), this.m_quadTreeForPaths = t2;
  }
  getQuadTree() {
    return this.m_quadTree;
  }
  getQuadTreeForPaths() {
    return this.m_quadTreeForPaths;
  }
};
function As(t2) {
  return !(t2.isEmpty() || t2.getGeometryType() !== a.enumPolyline && t2.getGeometryType() !== a.enumPolygon) && !(t2.getPointCount() < 20);
}
function Ts2(t2) {
  return !(t2.isEmpty() || t2.getGeometryType() !== a.enumPolyline && t2.getGeometryType() !== a.enumPolygon) && !(t2.getPointCount() < 20);
}
function Is2(t2, e5) {
  return t2.readPoint2D(e5 + 4);
}
function Ms2(t2) {
  const e5 = t2.getGeometryType();
  return e5 === a.enumEllipticArc ? 10 : e5 === a.enumBezier ? 4 : e5 === a.enumRationalBezier2 ? 5 : e5 === a.enumBezier2 ? 2 : void b("");
}
function Ys2(t2) {
  const e5 = 31 & t2;
  return 4 === e5 ? 10 : 2 === e5 ? 4 : 8 === e5 ? 5 : 16 === e5 ? 2 : 0;
}
function Xs2(t2, e5, n6, i2) {
  const r = 4 * Ss() * (Math.abs(e5.vmin) + Math.abs(e5.vmax)), o2 = Ss();
  if (1 === t2.getMaxDerivative()) {
    n2(n6 > 0);
    const o3 = zs(t2, 0, e5, Ss(), r);
    return i2[0] = o3.root, o3.cRoots;
  }
  let a2, h2 = [];
  const m2 = new x2(e5.vmin - r, e5.vmax + r);
  h2.push(new ei(m2.vmin, m2.vmax));
  let u = 0;
  for (let s4 = t2.getMaxDerivative() - 1; s4 >= 0; s4--) {
    a2 = h2, h2 = [];
    for (let m3 = 0, l2 = a2.length; m3 < l2; m3++) {
      if (a2[m3][0] < a2[m3][1]) {
        let l3, c, g2;
        if (s4 === t2.getMaxDerivative() - 1 ? { root: l3, funcAtRoot: c, cRoots: g2 } = zs(t2, s4, x2.construct(a2[m3][0], a2[m3][1]), o2, 0.5 * r) : { root: l3, funcAtRoot: c, cRoots: g2 } = ks2(t2, s4, x2.construct(a2[m3][0], a2[m3][1]), o2, 0.5 * r), 1 === g2) {
          if (0 === s4) {
            if (u < n6) {
              if (a2[m3][0] <= e5.vmin && a2[m3][1] >= e5.vmin && l3 !== e5.vmin) {
                0 === t2.getValue(0, e5.vmin) && (l3 = e5.vmin);
              }
              if (a2[m3][0] <= e5.vmax && a2[m3][1] >= e5.vmax && l3 !== e5.vmax) {
                0 === t2.getValue(0, e5.vmax) && (l3 = e5.vmax);
              }
              i2[u] = e5.snapClip(l3), u > 0 ? i2[u] - i2[u - 1] > r && u++ : u++;
            }
          } else {
            const t3 = ei.getNAN();
            t3[0] = a2[m3][0], t3[1] = l3, h2.push(t3);
            const e6 = ei.getNAN();
            e6[0] = l3, e6[1] = a2[m3][1], h2.push(e6);
          }
          continue;
        }
      }
      h2.push(a2[m3]);
    }
  }
  return u;
}
function Ns(t2, e5, s4, n6) {
  const i2 = new p2(), r = Ws2(new p2(t2), new p2(e5), s4, i2);
  return n6[0] = i2.value(), r;
}
function qs2(t2, e5, s4, n6, i2, r) {
  const o2 = Rt(p2, 2), a2 = js2(new p2(t2), new p2(e5), new p2(s4), n6, i2, o2);
  return r[0] = o2[0].value(), r[1] = o2[1].value(), a2;
}
function Fs2(t2, e5, s4, n6, i2, r, o2) {
  const a2 = Rt(p2, 3), h2 = Zs(new p2(t2), new p2(e5), new p2(s4), new p2(n6), i2, r, a2);
  return o2[0] = a2[0].value(), o2[1] = a2[1].value(), o2[2] = a2[2].value(), h2;
}
function Vs2(t2, e5, s4, n6, i2, r, o2, a2) {
  return Rs2(t2, e5, s4, n6, i2, r, o2, a2);
}
function Ls2(t2, e5, s4, n6, i2, r) {
  return Gs2(t2, e5, s4, n6, i2, r);
}
function Rs2(t2, e5, s4, n6, i2, r, o2, a2) {
  const h2 = Lt(s4 * s4, Number.NaN);
  h2.fill(0), Tt(a2, n6, 0, 0, s4);
  const m2 = Lt(s4, Number.NaN), u = Lt(s4, Number.NaN), l2 = Lt(s4, Number.NaN);
  let c = t2(a2, s4, e5);
  const g2 = 100;
  let d2 = 0;
  for (d2 = 0; d2 < g2; d2++) {
    const n7 = c;
    for (let t3 = 0; t3 < s4; ++t3) u[t3] = a2[t3];
    if (d2 % s4 == 0) {
      h2.fill(0);
      for (let t3 = 0; t3 < s4; t3++) h2[t3 * s4 + t3] = 1;
    }
    let o3 = 0, g3 = 0;
    for (let u2 = 0; u2 < s4; ++u2) {
      for (let t3 = 0; t3 < s4; ++t3) m2[t3] = h2[u2 * s4 + t3];
      const n8 = c;
      c = Bs2(t2, e5, a2, m2, i2, r, s4);
      const l3 = n8 - c;
      l3 > o3 && (g3 = u2, o3 = l3);
    }
    for (let t3 = 0; t3 < s4; t3++) m2[t3] = a2[t3] - u[t3], l2[t3] = a2[t3] + (a2[t3] - u[t3]);
    const _ = t2(l2, s4, e5);
    if (_ < n7) {
      if (2 * (n7 - 2 * c + _) * $(n7 - c - o3) < $(n7 - _) * o3) {
        c = Bs2(t2, e5, a2, m2, i2, r, s4);
        for (let t3 = 0; t3 < s4; ++t3) h2[g3 * s4 + t3] = h2[(s4 - 1) * s4 + t3], h2[(s4 - 1) * s4 + t3] = m2[t3];
      }
    }
    if (n7 <= c) return t2(a2, s4, e5);
  }
  return c;
}
function zs(t2, e5, s4, n6, i2) {
  const r = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let o2 = s4.vmin, a2 = s4.vmax, m2 = 0, u = Number.MAX_VALUE, l2 = t2.getValue(e5, o2), c = t2.getValue(e5, a2), g2 = 0, d2 = 0, _ = 0;
  if (l2 >= 0 && c >= 0 || l2 <= 0 && c <= 0) return Math.abs(l2) < Math.abs(c) ? (r.funcAtRoot = l2, r.root = o2, r.cRoots = 0 === l2 ? 1 : 0, r) : (r.funcAtRoot = c, r.root = a2, r.cRoots = 0 === c ? 1 : 0, r);
  Math.abs(l2) < Math.abs(c) && (a2 = Mt(o2, o2 = a2), c = Mt(l2, l2 = c)), m2 = o2, g2 = l2;
  let p3 = true, f3 = 0;
  for (; 0 !== c && Math.abs(o2 - a2) > n6 * Math.abs(a2) + i2; f3++) {
    let s5 = f3 > 64;
    if (!s5) {
      d2 = l2 !== g2 && c !== g2 ? o2 * c * g2 / ((l2 - c) * (l2 - g2)) + a2 * l2 * g2 / ((c - l2) * (c - g2)) + m2 * l2 * c / ((g2 - l2) * (g2 - c)) : a2 - c * (a2 - o2) / (c - l2);
      const t3 = (3 * o2 + a2) / 4;
      if (s5 = !(d2 > t3 && d2 < a2 || d2 > a2 && d2 < t3), !s5) {
        const t4 = n6 * Math.abs(a2) + i2;
        if (p3) {
          const e6 = Math.abs(a2 - m2);
          s5 = Math.abs(d2 - a2) >= 0.5 * e6 || e6 < t4;
        } else {
          const e6 = Math.abs(m2 - u);
          s5 = Math.abs(d2 - a2) >= 0.5 * e6 || e6 < t4;
        }
      }
    }
    if (s5 ? (d2 = (o2 + a2) / 2, p3 = true) : p3 = false, _ = t2.getValue(e5, d2), 0 === _) return r.root = d2, r.funcAtRoot = _, r.cRoots = 1, r;
    if (!s5) {
      const s6 = o2 - d2, n7 = d2 - a2;
      if (Math.abs(s6) > 10 * Math.abs(n7)) {
        let s7 = a2 + 3 * n7;
        for (let n8 = 0; n8 < 2; n8++) {
          const n9 = t2.getValue(e5, s7);
          X(l2) * X(n9) > 0 ? (o2 = s7, l2 = n9) : s7 = Q(o2, a2, 0.75);
        }
      } else if (Math.abs(n7) > 10 * Math.abs(s6)) {
        let n8 = o2 - 3 * s6;
        for (let s7 = 0; s7 < 2; ++s7) {
          const s8 = t2.getValue(e5, n8);
          X(c) * X(s8) > 0 ? (a2 = n8, c = s8) : n8 = Q(o2, a2, 0.25);
        }
      }
    }
    u = m2, m2 = a2, g2 = c, X(l2) * X(_) < 0 ? (a2 = d2, c = _) : (o2 = d2, l2 = _), Math.abs(l2) < Math.abs(c) && (a2 = Mt(o2, o2 = a2), c = Mt(l2, l2 = c)), 128 === f3 && b("Root_finder iterations exceeded");
  }
  return r.root = a2, r.funcAtRoot = c, r.cRoots = 1, r;
}
function ks2(t2, e5, s4, n6, i2) {
  const r = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let o2 = s4.vmin, a2 = t2.getValue(e5, o2), m2 = s4.vmax, u = t2.getValue(e5, m2);
  if (a2 >= 0 && u >= 0 || a2 <= 0 && u <= 0) return Math.abs(a2) < Math.abs(u) ? (r.funcAtRoot = a2, r.root = o2, r.cRoots = 0 === a2 ? 1 : 0, r) : (r.funcAtRoot = u, r.root = m2, r.cRoots = 0 === u ? 1 : 0, r);
  u < 0 && (u = Mt(a2, a2 = u), m2 = Mt(o2, o2 = m2));
  let l2 = 0.5 * (o2 + m2), c = Math.abs(m2 - o2), g2 = c, d2 = t2.getValue(e5, l2), _ = t2.getValue(e5 + 1, l2);
  const p3 = 1, f3 = 4;
  let P5 = f3;
  const y2 = 2;
  let x4 = 1, C2 = 0, v3 = 0, b2 = p3;
  const E2 = 32;
  let S3 = 0;
  for (; ++S3 < 100; ) {
    let s5;
    S3 > E2 || 0 === _ || b2 === y2 && C2 > 1 || b2 === p3 && P5 < f3 ? (b2 = p3, x4 > 1 && x4--) : (b2 = y2, v3 > 1 && Math.abs(2 * d2) > Math.abs(c * _) && x4++), c = g2;
    let n7 = false;
    if (b2 === p3) do {
      if (v3 > 2) {
        const t3 = 16 * Math.abs(c);
        if (0.5 * Math.abs(o2 - m2) > t3) {
          const e6 = Math.min(o2, m2), n8 = Math.max(o2, m2);
          if (l2 === e6) {
            s5 = l2, l2 = e6 + t3, g2 = l2 - s5;
            break;
          }
          if (l2 === n8) {
            s5 = l2, l2 = n8 - t3, g2 = l2 - s5;
            break;
          }
        }
      }
      g2 = 0.5 * (m2 - o2), s5 = l2, l2 = o2 + g2, n7 = o2 === l2 || m2 === l2;
    } while (0);
    else for (; ; ) {
      g2 = x4 * d2 / _, s5 = l2, l2 -= g2, n7 = l2 === s5;
      const t3 = Math.min(o2, m2), e6 = Math.max(o2, m2);
      if (l2 < t3) {
        if (x4 > 1) {
          l2 = s5, x4--;
          continue;
        }
        g2 = s5 - t3, l2 = t3;
      } else if (l2 > e6) {
        if (x4 > 1) {
          l2 = s5, x4--;
          continue;
        }
        g2 = s5 - e6, l2 = e6;
      }
      break;
    }
    if (n7 || Math.abs(g2) < i2) {
      s5 !== l2 && (d2 = t2.getValue(e5, l2));
      break;
    }
    d2 = t2.getValue(e5, l2), _ = t2.getValue(e5 + 1, l2);
    const r2 = o2, h2 = m2;
    d2 < 0 ? (a2 = d2, o2 = l2) : (u = d2, m2 = l2), b2 === y2 && (o2 === r2 && m2 === h2 || v3 > 1 && Math.abs(g2) >= 0.5001 * Math.abs(c)) ? C2++ : C2 = 0, b2 === p3 ? (P5++, v3 = 0) : (P5 = 0, v3++);
  }
  return 100 === S3 && b("Root_finder iterations exceeded"), r.root = l2, r.funcAtRoot = d2, r.cRoots = 1, r;
}
function Bs2(t2, e5, s4, n6, i2, r, o2) {
  const a2 = n6.slice(0, o2);
  let h2 = 0;
  for (let f3 = 0; f3 < o2; f3++) h2 += n6[f3] * n6[f3];
  if (h2 = Math.sqrt(h2), h2 > 0) for (let f3 = 0; f3 < o2; f3++) a2[f3] /= h2;
  let m2 = Number.NEGATIVE_INFINITY, u = Number.POSITIVE_INFINITY;
  {
    const t3 = Lt(o2, 0);
    for (let e6 = 0; e6 < o2; e6++) t3[e6] = e6;
    t3.sort((t4, e6) => {
      const s5 = Math.abs(a2[t4]), n7 = Math.abs(a2[e6]);
      return s5 < n7 ? -1 : s5 > n7 ? 1 : 0;
    });
    for (let e6 = 0; e6 < o2; e6++) {
      const n7 = t3[e6];
      if (0 === a2[n7]) continue;
      let o3 = (i2[n7] - s4[n7]) / a2[n7], h3 = (r[n7] - s4[n7]) / a2[n7];
      h3 < o3 && (h3 = Mt(o3, o3 = h3)), o3 > m2 && (m2 = o3), h3 < u && (u = h3);
    }
  }
  let l2 = 0;
  const c = (Math.abs(m2) + Math.abs(u)) * Ss() * 100, g2 = Lt(o2, Number.NaN), d2 = a2.slice();
  function _(n7, i3) {
    for (let t3 = 0, e6 = o2; t3 < e6; t3++) g2[t3] = s4[t3] + n7 * d2[t3];
    return t2(g2, o2, e5);
  }
  c > 0 && (l2 = Ls2(_, null, m2, 0, u, c));
  const p3 = _(l2);
  for (let f3 = 0, P5 = o2; f3 < P5; f3++) s4[f3] = ks(g2[f3], i2[f3], r[f3]);
  return p3;
}
function Gs2(t2, e5, s4, n6, i2, r) {
  const o2 = Rs();
  let a2 = n6, h2 = t2(a2, e5), m2 = s4, u = i2, l2 = t2(m2, e5), c = t2(u, e5);
  h2 > l2 && (h2 = l2, a2 = m2), h2 > c && (h2 = c, a2 = u);
  let g2 = m2, d2 = u, _ = l2, p3 = c;
  _ > p3 && (_ = Mt(p3, p3 = _), d2 = Mt(g2, g2 = d2));
  let f3 = a2 - g2, P5 = g2 - d2;
  const y2 = 0.5 * Math.min(r, u - m2), x4 = 2 * y2, C2 = 100;
  let v3, b2 = 0;
  for (v3 = 0; v3 < C2 && !(u - m2 <= x4); ++v3) {
    const s5 = m2 + 0.5 * (u - m2);
    let n7 = b2 > 0;
    if (!n7 && Math.abs(P5) <= y2 && (n7 = true, b2 = 3), !n7) {
      const t3 = a2 - g2, e6 = a2 - d2, s6 = t3 * (h2 - p3);
      let i4 = e6 * (h2 - _), r3 = e6 * i4 - t3 * s6;
      i4 = 2 * (i4 - s6), i4 > 0 && (r3 = -r3), i4 = Math.abs(i4), 0 === i4 || Math.abs(r3) >= Math.abs(i4 * P5 / 2) || r3 <= i4 * (m2 - a2) || r3 >= i4 * (u - a2) ? (n7 = true, b2 = 3) : (P5 = f3, f3 = r3 / i4);
    }
    n7 && (P5 = a2 >= s5 ? m2 - a2 : u - a2, f3 = o2 * P5, b2--);
    let i3 = a2 + f3;
    i3 < m2 + y2 ? i3 = m2 + y2 : i3 > u - y2 && (i3 = u - y2);
    const r2 = t2(i3, e5);
    r2 < h2 ? (i3 >= a2 ? (m2 = a2, l2 = h2) : (u = a2, c = h2), d2 = g2, g2 = a2, a2 = i3, p3 = _, _ = h2, h2 = r2) : (i3 < a2 ? (m2 = i3, l2 = r2) : (u = i3, c = r2), r2 <= _ || g2 === a2 ? (d2 = g2, g2 = i3, p3 = _, _ = r2) : (r2 <= p3 || d2 === a2 || d2 === g2) && (d2 = i3, p3 = r2));
  }
  return a2;
}
function Ws2(t2, e5, s4, n6) {
  return t2.isZero() ? e5.isZero() ? -1 : 0 : (n6.setE(e5.clone().negateThis().divThisE(t2)), s4.containsCoordinate(n6.value()) ? 1 : 0);
}
function js2(t2, e5, s4, n6, i2, r) {
  if (0 === t2.value()) {
    if (i2) return r[0].set(1), n6.containsCoordinate(r[0].value()) ? 1 : 0;
    return Ws2(e5, s4, n6, r[0]);
  }
  if (i2) {
    let e6 = 2;
    return r[0].set(1), r[1].setE(s4).divThisE(t2), r[1].eq(r[0]) && (r[1].set(1), e6 = 1), n6.containsCoordinate(r[1].value()) || (e6 = 1), n6.containsCoordinate(r[0].value()) || (e6--, r[0].setE(r[1])), 2 === e6 && r[0].value() > r[1].value() && (r[1] = Mt(r[0], r[0] = r[1])), e6;
  }
  const o2 = e5.clone().sqrThis().subThisE(t2.clone().mulThisE(s4).mulThisE(D2));
  if (o2.lt(I2)) return 0;
  const a2 = new p2(e5.value() >= 0 ? 1 : -1), h2 = o2.clone().sqrtThis(), m2 = new p2(-0.5).mulThisE(e5.clone().addThisE(a2.clone().mulThisE(h2)));
  let u = 0;
  r[0].setE(m2.divE(t2));
  const l2 = new p2(r[0].value()), c = new p2(t2.value()).mulE(l2).addE(new p2(e5.value()).mulE(l2).addE(new p2(s4.value())));
  return c.isZero() || $s(r[0], t2, e5, s4, r[0]), n6.containsCoordinate(r[0].value()) && u++, 0 !== h2.value() && 0 !== m2.value() ? (r[u].assign(s4.divE(m2)), l2.set(r[u].value()), c.assign(new p2(t2.value()).mulE(l2).addE(new p2(e5.value()).mulE(l2).addE(new p2(s4.value())))), c.isZero() || $s(r[u], t2, e5, s4, r[u]), n6.containsCoordinate(r[u].value()) && u++, 2 === u && r[0].value() > r[1].value() && (r[1] = Mt(r[0], r[0] = r[1])), u) : u;
}
function Zs(t2, e5, s4, n6, i2, r, o2) {
  if (0 === t2.value()) {
    return js2(e5, s4, n6, i2, r, o2);
  }
  if (r) {
    let s5 = 1;
    o2[0].set(1);
    const r2 = o2.slice(s5), a2 = js2(t2, e5.addE(t2), n6.negate(), i2, false, r2);
    if (a2 > 0) {
      s5 += a2;
      for (let t3 = 1; t3 < s5; t3++) o2[t3].eq(w2) && (o2[s5 - 1] = Mt(o2[t3], o2[t3] = o2[s5 - 1]), s5--);
    }
    const h2 = o2.slice(0, s5);
    h2.sort((t3, e6) => t3.value() < e6.value() ? -1 : t3.value() > e6.value() ? 1 : 0);
    for (let t3 = 0; t3 < s5; ++t3) o2[t3] = h2[t3];
    return s5;
  }
  return tn(t2, e5, s4, n6, i2, o2);
}
function Hs2(t2, s4, n6, i2, r, o2) {
  return (o2 < s4 || s4 < 0) && P("nth_degree_real_roots"), en(t2, s4, n6, i2, r);
}
function Us(t2, e5, s4, n6) {
  return { coef0: t2.clone(), coef1: e5.clone(), coef2: s4.clone(), coef3: n6.clone(), calcF(t3) {
    return this.coef0.clone().mulThis(t3).addThisE(this.coef1).mulThis(t3).addThisE(this.coef2).mulThis(t3).addThisE(this.coef3);
  }, calcDF(t3) {
    return this.coef0.clone().mulThis(3).mulThis(t3).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t3).addThisE(this.coef2);
  }, estimateError(t3) {
    const e6 = Math.abs(t3), s5 = ((this.coef0.eps() * e6 + this.coef1.eps()) * e6 + this.coef2.eps()) * e6 + this.coef3.eps() + this.calcF(t3).eps(), n7 = this.coef0.clone().mulThis(t3).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t3).addThisE(this.coef2);
    if (n7.isZero()) {
      const e7 = this.coef0.clone().mulThis(t3).mulThis(6).addThisE(this.coef1.clone().mulThis(2));
      if (e7.isZero()) {
        const t4 = this.coef0.clone().mulThis(6);
        return Math.pow(6 * s5 / Math.abs(t4.value()), 1 / 3);
      }
      return Math.sqrt(2 * s5 / Math.abs(e7.value()));
    }
    return s5 / Math.abs(n7.value());
  } };
}
var Os2 = class {
  updateCoefs(t2) {
    if (this.lastDeriv1 === t2) return this.curCoefs = this.derivCoefs1, void (this.lastUsed = 1);
    if (this.lastDeriv2 === t2) return this.curCoefs = this.derivCoefs2, void (this.lastUsed = 2);
    let e5;
    1 === this.lastUsed ? (e5 = this.derivCoefs2, this.lastDeriv2 = t2, this.lastUsed = 2) : (e5 = this.derivCoefs1, this.lastDeriv1 = t2, this.lastUsed = 1), e5.length = 0;
    for (let s4 = 0, n6 = this.truePower - t2; s4 <= n6; ++s4) {
      e5.push(this.coefs[s4 + t2].clone());
      let n7 = s4 + t2, i2 = n7--;
      for (let e6 = 1; e6 < t2; e6++) i2 *= n7--;
      e5[s4].mulThis(i2);
    }
    this.curCoefs = e5;
  }
  constructor(t2, e5, s4, n6) {
    this.derivCoefs1 = [], this.derivCoefs2 = [], this.lastDeriv1 = -1, this.lastDeriv2 = -1, this.lastUsed = -1, this.curCoefs = null, this.coefs = t2, this.power = e5, this.truePower = 0;
    for (let i2 = e5; i2 >= 1; i2--) if (0 !== this.coefs[i2].value()) {
      this.truePower = i2;
      break;
    }
  }
  getMaxDerivative() {
    return this.truePower + 1;
  }
  getValue(t2, e5) {
    let s4 = this.coefs;
    0 === t2 ? s4 = this.coefs : (this.updateCoefs(t2), s4 = this.curCoefs);
    const n6 = new n3(0);
    let i2 = 1;
    for (let r = 0, o2 = this.truePower - t2; r <= o2; ++r) n6.pe(i2 * s4[r].value()), i2 *= e5;
    return n6.getResult();
  }
  getError(t2) {
    const e5 = Math.abs(t2), s4 = new n3(0), n6 = new p2(1), i2 = new p2(0);
    for (let o2 = 0, a2 = this.power; o2 <= a2; ++o2) i2.addThisE(this.coefs[o2].mulE(n6)), s4.pe(n6.value() * this.coefs[o2].eps()), n6.mulThis(e5);
    s4.pe(i2.eps());
    let r = 1;
    for (let o2 = 1; o2 <= this.truePower; ++o2) {
      r *= o2, this.updateCoefs(o2);
      const e6 = new p2(1), n7 = new p2(0);
      for (let s5 = 0, i3 = this.truePower - o2; s5 <= i3; ++s5) n7.addThisE(this.curCoefs[s5].mulE(e6)), e6.mulThis(t2);
      if (!n7.isZero()) return Math.pow(r * s4.getResult() / Math.abs(n7.value()), 1 / o2);
    }
    return 0;
  }
};
function Qs2(t2, e5, s4, n6, i2, r) {
  let o2 = t2, a2 = e5, h2 = a2 - o2;
  if (!r) {
    let s5 = n6.calcF(t2).value(), i3 = n6.calcF(e5).value();
    if ((s5 > 0 || s5 > i3) && (a2 = Mt(o2, o2 = a2), i3 = Mt(s5, s5 = i3)), s5 >= 0 || i3 <= 0) return false;
  }
  let m2, u = false, l2 = s4, c = 0;
  for (; c < 100; c++) {
    const t3 = n6.calcF(l2);
    if (m2 = n6.calcDF(l2), m2.isZero()) return false;
    if (!t3.value() || c > 3 && t3.isZero()) {
      u = true;
      break;
    }
    r || (t3.value() < 0 ? o2 = l2 : a2 = l2);
    const e6 = t3.value() / m2.value(), s5 = l2 - e6;
    r || (s5 >= o2 && s5 <= a2 || s5 >= a2 && s5 <= o2) && Math.abs(e6) <= 0.5 * h2 ? (l2 = s5, h2 = Math.abs(e6)) : (h2 = Math.abs(0.5 * (a2 - o2)), l2 = 0.5 * (o2 + a2));
  }
  return !!u && (i2.set(l2, n6.estimateError(l2)), true);
}
function Js(t2, e5, s4, n6, i2, r, o2, a2) {
  return Qs2(t2, e5, s4.value(), Us(n6, i2, r, o2), a2, false);
}
var Ks = class {
  constructor(t2, e5, s4) {
    this.coefs = Rt(p2, 3), this.coefs[0].setE(t2), this.coefs[1].setE(e5), this.coefs[2].setE(s4);
  }
  calcF(t2) {
    const e5 = new p2(t2);
    return this.coefs[0].mulE(e5).addE(this.coefs[1]).mulE(e5).addE(this.coefs[2]);
  }
  calcDF(t2) {
    const e5 = new p2(t2);
    return p2.st_mulByPower2(this.coefs[0], 2).mulE(e5).addE(this.coefs[1]);
  }
  estimateError(t2) {
    const e5 = Math.abs(t2), s4 = (this.coefs[0].eps() * e5 + this.coefs[1].eps()) * e5 + this.coefs[2].eps() + this.calcF(t2).eps(), n6 = new p2(2).mulE(this.coefs[0]).mul(t2).addE(this.coefs[1]);
    if (n6.isZero()) {
      const t3 = this.coefs[0].value();
      return Math.sqrt(s4 / Math.abs(t3));
    }
    return s4 / Math.abs(n6.value());
  }
};
function $s(t2, e5, s4, n6, i2) {
  return Qs2(0, 0, t2.value(), new Ks(e5, s4, n6), i2, true);
}
function tn(t2, e5, s4, n6, i2, r) {
  const o2 = Rt(p2, 3);
  let a2 = 0;
  const m2 = e5.negate().divThisE(t2.clone().mulThis(3));
  i2.containsCoordinate(m2.value()) && (o2[0].setE(m2), a2 = 1);
  const u = Rt(p2, 2), l2 = js2(t2.mul(3), e5.mul(2), s4, i2, false, u);
  if (l2 < 0) return n6.isZero() ? -1 : 0;
  for (let h2 = 0; h2 < l2; h2++) i2.containsCoordinate(u[h2].value()) && o2[a2++].setE(u[h2]);
  wt(o2, 0, a2, (t3, e6) => t3.value() < e6.value() ? -1 : t3.value() > e6.value() ? 1 : 0);
  const c = Rt(p2, 5);
  c[0].set(i2.vmin);
  for (let h2 = 0; h2 < a2; h2++) c[1 + h2].setE(o2[h2]);
  c[1 + a2].set(i2.vmax);
  const g2 = a2 + 2;
  let d2 = 1, _ = 0;
  {
    const i3 = c[0].clone();
    if (t2.clone().mulThisE(i3).addThisE(e5).mulThisE(i3).addThisE(s4).mulThisE(i3).addThisE(n6).isZero()) {
      const o3 = Us(t2, e5, s4, n6);
      i3.setError(o3.estimateError(i3.value())), r[_] = i3, _++, d2++;
    }
  }
  for (let p3 = d2; p3 < g2; p3++) {
    const o3 = c[p3].clone(), a3 = t2.clone().mulThisE(o3).addThisE(e5).mulThisE(o3).addThisE(s4).mulThisE(o3).addThisE(n6).isZero();
    if (a3 || !c[p3].eq(c[p3 - 1])) {
      if (a3 || Js(c[p3 - 1].value(), c[p3].value(), c[p3 - 1].clone().addThisE(c[p3]).divThisByPower2(2), t2, e5, s4, n6, o3)) {
        if (_ > 0 && o3.eq(r[_ - 1])) continue;
        if (_ >= 3 && b("cubic_polynomial_solver_too_many_roots"), a3) {
          const i3 = Us(t2, e5, s4, n6);
          o3.setError(i3.estimateError(o3.value()));
        }
        r[_] = o3, _++;
      }
      if (c[p3].value() === i2.vmax) break;
      a3 && p3++;
    }
  }
  return _;
}
function en(t2, e5, s4, n6, i2, r) {
  const o2 = new Os2(t2, e5, s4, Ss());
  let a2 = 0;
  if (2 === o2.truePower) a2 = js2(t2[2], t2[1], t2[0], s4, n6, i2);
  else if (1 === o2.truePower) a2 = Ws2(t2[1], t2[0], s4, i2[0]);
  else {
    if (0 === o2.truePower) return t2[0].value() ? 0 : -1;
    {
      const t3 = [];
      t3.length = e5, a2 = Xs2(o2, s4, e5, t3);
      for (let e6 = 0; e6 < a2; e6++) i2[e6].set(t3[e6]);
    }
  }
  for (let h2 = 0; h2 < a2; h2++) i2[h2].setError(o2.getError(i2[h2].value()));
  return a2;
}
var sn = B3;
var nn = class _nn extends ns {
  constructor(t2) {
    void 0 === t2 || Ot(t2, "vd") ? (super({ vd: t2 == null ? void 0 : t2.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new ei(0, 0)) : t2.from ? (super({ XStart: t2.from.x, YStart: t2.from.y, XEnd: t2.to.x, YEnd: t2.to.y, ...t2.vd }), this.m_cp = t2.cp.clone()) : t2.points ? (super({ XStart: t2.points[0].x, YStart: t2.points[0].y, XEnd: t2.points[2].x, YEnd: t2.points[2].y, ...t2.vd }), this.m_cp = t2.points[1].clone()) : t2.copy ? (super(t2), this.m_cp = t2.copy.m_cp.clone()) : b("unexpected constructor args");
  }
  getBoundary() {
    return Va(this);
  }
  assignCopy(t2) {
    return this !== t2 && t2.copyTo(this), this;
  }
  construct(t2, e5, s4) {
    this.setStartXY(t2), this.m_cp.assign(e5), this.setEndXY(s4), ur(this);
  }
  constructPoints(t2) {
    this.setStartXY(t2[0]), this.m_cp.assign(t2[1]), this.setEndXY(t2[2]), ur(this);
  }
  getGeometryType() {
    return a.enumBezier2;
  }
  queryEnvelope(t2) {
    if (2 !== t2.m_EnvelopeType) z("env type not impl");
    else {
      if (t2.setCoords(this.getStartXY()), t2.mergeNe(this.getEndXY()), t2.contains(this.m_cp)) return;
      const e5 = Sr(this);
      if (null !== e5) {
        const s4 = new ei();
        for (const n6 of e5.specialPoints) this.queryCoord2D(n6, s4), t2.mergeNe(s4);
      } else {
        const e6 = [];
        gr(this, e6);
        const s4 = new ei();
        for (const n6 of e6) this.queryCoord2D(n6, s4), t2.mergeNe(s4);
      }
    }
  }
  applyTransformation(t2) {
    if (1 === t2.m_TransformationType) {
      const e5 = Rt(ei, 3);
      return this.queryControlPoints(e5), t2.transformPoints2D(e5, 3, e5), this.setStartXY(e5[0]), this.m_cp.assign(e5[1]), this.setEndXY(e5[2]), void this.afterCompletedModification();
    }
    n2(0);
  }
  createInstance() {
    return new _nn({ vd: this.m_description });
  }
  calculateLength2D() {
    return dr(this, 1, false);
  }
  calculateLowerLength2D() {
    return ei.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    return ei.distance(this.getStartXY(), this.m_cp) + ei.distance(this.getEndXY(), this.m_cp);
  }
  queryCoord2D(t2, e5) {
    this.queryCoord2DExtended(t2, e5, false);
  }
  queryCoord2DExtended(t2, e5, s4) {
    const n6 = Rt(ei, 3);
    this.queryControlPoints(n6), Jr(n6, t2, e5, s4);
  }
  queryCoord2DE(t2, e5) {
    Kr(this, t2, e5);
  }
  getCoordX(t2) {
    if (t2 < 0 || t2 > 1) {
      const e5 = new ei();
      return this.queryCoord2DExtended(t2, e5, true), e5.x;
    }
    if (t2 <= 0.5) {
      const e5 = V(this.getStartX(), this.m_cp.x, t2), s4 = V(this.m_cp.x, this.getEndX(), t2);
      return V(e5, s4, t2);
    }
    {
      const e5 = U2(this.getStartX(), this.m_cp.x, t2), s4 = U2(this.m_cp.x, this.getEndX(), t2);
      return U2(e5, s4, t2);
    }
  }
  getCoordY(t2) {
    if (t2 < 0 || t2 > 1) {
      const e5 = new ei();
      return this.queryCoord2DExtended(t2, e5, true), e5.y;
    }
    if (t2 <= 0.5) {
      const e5 = V(this.getStartX(), this.m_cp.x, t2), s4 = V(this.m_cp.x, this.getEndX(), t2);
      return V(e5, s4, t2);
    }
    {
      const e5 = U2(this.getStartY(), this.m_cp.y, t2), s4 = U2(this.m_cp.y, this.getEndY(), t2);
      return U2(e5, s4, t2);
    }
  }
  cut(t2, e5, s4) {
    const n6 = new nu();
    return this.queryCut(t2, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t2, e5, s4, n6) {
    const i2 = s4.createQuadraticBezier();
    if (this.cutBezierIgnoreAttributes(t2, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = sn.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t2, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t3 = 1; t3 < r; t3++) {
        const s5 = this.m_description.getSemantics(t3), n7 = sn.getComponentCount(s5);
        for (let t4 = 0; t4 < n7; t4++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t4);
          i2.setEndAttribute(s5, t4, n8);
        }
      }
    }
  }
  queryDerivative(t2, e5) {
    to(this, t2, e5);
  }
  cutBezierIgnoreAttributes(t2, s4, n6) {
    if ((t2 < 0 || s4 > 1 || t2 > s4) && P("Quadratic_bezier.cut_bezier_ignore_attributes"), 0 === t2 && 1 === s4) return n6.setStartXY(this.getStartXY()), n6.m_cp.assign(this.m_cp), void n6.setEndXY(this.getEndXY());
    const i2 = Rt(ei, 3);
    this.queryControlPoints(i2), Vr(i2, t2, s4, i2), n6.constructPoints(i2);
  }
  splitBezierIgnoreAttributes(t2, e5, n6) {
    n2(0);
  }
  getAttributeAsDbl(t2, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t2) : this.getCoordY(t2);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t2) / n6 : 0, r = sn.getInterpolation(e5), o2 = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return pt(r, o2, a2, i2, sn.getDefaultValue(e5));
  }
  getClosestCoordinate(t2, e5) {
    return wr(this, t2, x2.unit(), e5);
  }
  getClosestCoordinateOnInterval(t2, e5, s4 = -1) {
    return wr(this, t2, e5, false);
  }
  getYMonotonicParts(t2, e5) {
    return this.getMonotonicParts(t2, e5);
  }
  getMonotonicParts(t2, n6) {
    t2.length < 2 && P("");
    const i2 = cr(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n2(t2.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t2[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      Xr(t2[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t2, e5, s4, n6) {
    const i2 = Rt(p2, 3), r = Rt(p2, 2), o2 = new x2(0, 1);
    let a2 = 0;
    if (t2) {
      if (i2[0] = new p2(this.getStartY()).sub(e5), i2[1] = new p2(this.m_cp.y).subE(new p2(this.getStartY())).mulThisByPower2(2), i2[2] = new p2(this.getStartY()).add(this.getEndY()).subE(new p2(this.m_cp.y).mulThisByPower2(2)), a2 = js2(i2[2], i2[1], i2[0], o2, false, r), s4) for (let h2 = 0; h2 < a2; h2++) s4[h2] = this.getCoordX(r[h2].value());
    } else if (i2[0] = new p2(this.getStartX()).sub(e5), i2[1] = new p2(this.m_cp.x).subE(new p2(this.getStartX())).mulThisByPower2(2), i2[2] = new p2(this.getStartX()).add(this.getEndX()).subE(new p2(this.m_cp.x).mulThisByPower2(2)), a2 = js2(i2[2], i2[1], i2[0], o2, false, r), s4) for (let h2 = 0; h2 < a2; h2++) s4[h2] = this.getCoordY(r[h2].value());
    if (n6) for (let h2 = 0; h2 < a2; h2++) n6[h2] = r[h2].value();
    else s4 && It(s4, a2);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t2, e5) {
    if (this.m_YStart === this.m_YEnd) return t2 === this.m_YStart ? e5 : Number.NaN;
    if (t2 === this.m_YStart) return this.m_XStart;
    if (t2 === this.m_YEnd) return this.m_XEnd;
    const n6 = [0, 0], i2 = this.intersectionWithAxis2D(true, t2, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isLine() {
    return false;
  }
  isDegenerate(t2) {
    return Te(this, t2);
  }
  isDegenerate3D(t2, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t2) {
    if (2 === t2.m_EnvelopeType) return t2.setCoords(this.getStartXY()), t2.mergeNe(this.m_cp), void t2.mergeNe(this.getEndXY());
    n2(0);
  }
  clone(t2) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t2, e5) {
    if (0 === t2) {
      const t3 = new n4();
      this.queryEnvelope(t3);
      const s4 = new x2();
      return 0 === e5 ? t3.queryIntervalX(s4) : t3.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t2, e5);
  }
  queryLooseEnvelopeOnInterval(t2, e5) {
    const s4 = Rt(ei, 4);
    this.queryControlPoints(s4), Vr(s4, t2.vmin, t2.vmax, s4), e5.setFromPoints(s4, 4);
  }
  changeEndPoints2D(t2, e5) {
    if (t2.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t2), this.setEndXY(e5), s4 ? this.m_cp.setCoordsPoint2D(t2) : n6 && this.m_cp.setCoordsPoint2D(e5), this.normalizeAfterEndpointChange();
  }
  tToLength(t2) {
    return dr(this, t2, true);
  }
  lengthToT(t2) {
    return Cr(this, t2);
  }
  calculateWeightedAreaCentroid2D(t2) {
    const e5 = Rt(ei, 3);
    Hr(this, e5);
    const s4 = e5[2], n6 = e5[1], i2 = new ei(), r = s4.y * n6.x - s4.x * n6.y;
    i2.x = -(4 * s4.x + 5 * n6.x) * r / 60, i2.y = -(4 * s4.y + 5 * n6.y) * r / 60;
    const o2 = vr(this);
    return i2.x += (e5[0].x - t2.x) * o2, i2.y += (e5[0].y - t2.y) * o2, i2;
  }
  calculateWeightedCentroid2D() {
    const t2 = new ei();
    return this.isDegenerate(0) ? (t2.setCoords(0, 0), t2) : Er(this) ? (t2.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t2) : (t2.assign(qr(this, 1)), t2);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t2) {
    this.m_cp.setCoordsPoint2D(t2), this.afterCompletedModification();
  }
  queryControlPoints(t2) {
    t2[0].assign(this.getStartXY()), t2[1].assign(this.m_cp), t2[2].assign(this.getEndXY());
  }
  setControlPoints(t2) {
    for (let s4 = 0; s4 < 3; s4++) t2[s4].isNAN() && P("NaN control points in bezier are not supported");
    this.m_XStart = t2[0].x, this.m_YStart = t2[0].y, this.m_cp.setCoordsPoint2D(t2[1]), this.m_XEnd = t2[2].x, this.m_YEnd = t2[2].y, this.afterCompletedModification();
  }
  getTangent(t2) {
    const e5 = ks(t2, 0, 1);
    let s4 = Pr(this, 1, e5);
    return s4.isZero() && (s4 = Pr(this, 2, e5), 1 === e5 && s4.negateThis()), s4;
  }
  getDerivative(t2) {
    return Pr(this, 1, ks(t2, 0, 1));
  }
  getCurvature(t2) {
    const e5 = Pr(this, 1, t2), s4 = Pr(this, 2, t2), n6 = e5.sqrLength();
    if (0 === n6) return Number.NaN;
    e5.divThis(Math.sqrt(n6));
    return e5.crossProduct(s4) / n6;
  }
  isIntersecting(t2, e5, s4) {
    return 0 !== jm(false, this, t2, e5, s4);
  }
  isIntersectingPoint(t2, e5, s4) {
    if (s4 && (t2.isEqualPoint2D(this.getStartXY()) || t2.isEqualPoint2D(this.getEndXY()))) return false;
    const n6 = new n4();
    if (this.queryLooseEnvelope(n6), n6.inflateCoords(e5, e5), !n6.contains(t2)) return false;
    const i2 = this.getClosestCoordinate(t2, false), r = new ei();
    this.queryCoord2D(i2, r);
    return ei.distance(r, t2) <= e5;
  }
  isIntersectingPoint3D(t2, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  getMonotonicPartParams(t2, s4) {
    const n6 = cr(this), i2 = n6.specialPointsCount();
    if (!s4) return n6.specialPointsCount();
    t2 < i2 && P("");
    for (let e5 = 0; e5 < i2; e5++) s4[e5] = n6.specialPoints[e5];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      Mt(this.m_XStart, this.m_XStart = this.m_XEnd), Mt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t2 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t2 < e5; t2++) this.m_attributes[t2 + e5] = Mt(this.m_attributes[t2], this.m_attributes[t2] = this.m_attributes[t2 + e5]);
      this.m_cachedValues = null;
    }
  }
  isDegenerateToLineHelper(t2) {
    const e5 = [t2];
    if (!Ie(this, e5)) return false;
    const s4 = this.getEndXY().sub(this.getStartXY()), n6 = s4.length(), i2 = this.getControlPoint1();
    i2.sub(this.getStartXY());
    return !(Math.abs(i2.crossProduct(s4)) / n6 > e5[0]);
  }
  copyIgnoreAttributes(t2) {
    const e5 = Rt(ei, 3);
    this.queryControlPoints(e5), t2.setControlPoints(e5);
  }
  calculateArea2DHelper() {
    return vr(this);
  }
  absNorm() {
    return Rr(this);
  }
  queryEnvelopeW(t2, e5) {
    const s4 = Rt(ei, 3);
    this.queryControlPoints(s4), Mr(s4, t2, e5);
  }
  setSegmentFromCoords(t2, e5) {
    this.construct(t2[0], this.getControlPoint1(), t2[e5 - 1]);
  }
  snapControlPoints(t2) {
    return ro(this, t2);
  }
  writeInBufferStream(t2, e5) {
    const s4 = new Float64Array(2);
    return s4[0] = this.m_cp.x, s4[1] = this.m_cp.y, t2.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t2, e5) {
    const s4 = new Float64Array(2);
    t2.queryRange(e5, s4.length, s4, true, 1), this.m_cp.x = s4[0], this.m_cp.y = s4[1], this.m_cachedValues = null;
  }
  needsSnapControlPoints(t2) {
    return oo(this, t2);
  }
  calculateSpecialPointsForCracking(t2, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return Xr(this);
  }
  setCoordsForIntersector(t2, e5, s4) {
    Lr(this, t2, e5, s4);
  }
  copyToImpl(t2) {
    const e5 = t2;
    e5.m_cp.setCoordsPoint2D(this.m_cp), Dr(e5, Sr(this));
  }
  reverseImpl() {
  }
  equalsImplTol(t2, e5) {
    const s4 = t2;
    return !!this.m_cp.isEqualPoint2D(s4.m_cp, e5);
  }
  equalsImpl(t2) {
    const e5 = t2;
    return !!this.m_cp.equals(e5.m_cp);
  }
  swapImpl(t2) {
    const e5 = t2;
    e5.m_cp = Mt(this.m_cp, this.m_cp = e5.m_cp), lr(this, e5);
  }
  afterCompletedModification() {
    ur(this);
  }
  intersect(t2, e5, s4, n6, i2) {
    return Om(false, this, t2, e5, s4, n6, i2);
  }
  intersectPoint(t2, e5, s4) {
    return Tr(this, t2, e5.length, e5, s4);
  }
  endPointModified() {
    ur(this);
  }
  clearEndPointModified() {
  }
};
nn.type = a.enumBezier2;
var rn = B3;
var on = class _on extends ns {
  constructor(t2) {
    return void 0 === t2 || Ot(t2, "vd") ? (super({ vd: t2 == null ? void 0 : t2.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new ei(0, 0), void (this.m_weights = [1, 0, 1])) : (t2.fromPoint && t2.weight ? t2 = { fromPoint: t2.fromPoint, controlPoint1: t2.controlPoint1, toPoint: t2.toPoint, weight0: 1, weight1: t2.weight, weight2: 1 } : t2.points && t2.weight ? t2 = { fromPoint: t2.points[0], controlPoint1: t2.points[1], toPoint: t2.points[2], weight0: 1, weight1: t2.weight, weight2: 1 } : t2.points && t2.weights && (t2 = { fromPoint: t2.points[0], controlPoint1: t2.points[1], toPoint: t2.points[2], weight0: t2.weights[0], weight1: t2.weights[1], weight2: t2.weights[2] }), t2.fromPoint && t2.weight0 ? (super({ start: t2.fromPoint, end: t2.toPoint }), (t2.weight0 <= 0 || t2.weight1 < 0 || t2.weight2 <= 0) && P("weights"), this.m_cp = t2.controlPoint1.clone(), void (this.m_weights = [t2.weight0, t2.weight1, t2.weight2])) : t2.copy ? (super(t2), this.m_cp = t2.copy.m_cp.clone(), void (this.m_weights = t2.copy.m_weights.slice())) : t2.move ? (super(t2), this.m_cp = t2.move.m_cp.clone(), void (this.m_weights = t2.move.m_weights.slice())) : void z("unexpected constructor param"));
  }
  getBoundary() {
    return Va(this);
  }
  assignMove(t2) {
    return this;
  }
  assignCopy(t2) {
    return t2.copyTo(this), this;
  }
  construct(t2, e5, s4, n6) {
    this.dropAllAttributes(), this.setCpsAndWeights(t2, e5, s4, 1, n6, 1), Un(this);
  }
  constructWeights(t2, e5, s4, n6, i2, r) {
    this.dropAllAttributes(), this.setCpsAndWeights(t2, e5, s4, n6, i2, r), Un(this);
  }
  constructArray(t2, e5) {
    this.construct(t2[0], t2[1], t2[2], e5);
  }
  constructArrayWeights(t2, e5) {
    this.dropAllAttributes(), this.setCpsAndWeightsArray(t2, e5), Un(this);
  }
  convertToStandardForm() {
  }
  getStandardFormWeight() {
    return this.m_weights[1] / Math.sqrt(this.m_weights[0] * this.m_weights[2]);
  }
  getGeometryType() {
    return a.enumRationalBezier2;
  }
  queryEnvelope(t2) {
    if (t2 instanceof n4) {
      if (t2.setCoords(this.getStartXY()), t2.mergeNe(this.getEndXY()), t2.contains(this.m_cp)) return;
      const e5 = xi(this);
      if (null !== e5) {
        const s4 = new ei();
        for (const n6 of e5.specialPoints) this.queryCoord2D(n6, s4), t2.mergeNe(s4);
      } else {
        const e6 = [], s4 = Rt(ei, 3);
        this.queryControlPoints(s4), Jn(s4, this.m_weights, e6);
        const n6 = new ei();
        for (const i2 of e6) this.queryCoord2D(i2, n6), t2.mergeNe(n6);
      }
    }
  }
  applyTransformation(t2) {
    if (t2 instanceof x3) {
      const e5 = Rt(ei, 3);
      return this.queryControlPoints(e5), t2.transformPoints2D(e5, 3, e5), this.setStartXY(e5[0]), this.m_cp.assign(e5[1]), this.setEndXY(e5[2]), void this.afterCompletedModification();
    }
  }
  createInstance() {
    return new _on({ vd: this.m_description });
  }
  calculateLength2D() {
    return Kn(this, 1, false);
  }
  calculateLowerLength2D() {
    return ei.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    if (this.m_weights[1] > 0) {
      return ei.distance(this.getStartXY(), this.m_cp) + ei.distance(this.getEndXY(), this.m_cp);
    }
    return ei.distance(this.getStartXY(), this.getEndXY());
  }
  queryCoord2D(t2, e5) {
    return this.queryCoord2DExtension(t2, e5, true);
  }
  queryCoord2DE(t2, e5) {
    Oi(this, t2, e5);
  }
  queryCoord2DExtension(t2, e5, s4) {
    if (s4) {
      if (t2 < 0) {
        return void rs2(new su({ start: this.getStartXY(), end: this.getStartXY().add(this.getTangent(0).getUnitVector()) }), t2, e5);
      }
      if (t2 > 1) {
        return void rs2(new su({ start: this.getEndXY(), end: this.getEndXY().add(this.getTangent(1).getUnitVector()) }), t2 - 1, e5);
      }
    }
    const n6 = Rt(ei, 3);
    this.queryControlPoints(n6), Ki(n6, this.m_weights, t2, e5);
  }
  getCoordX(t2) {
    const e5 = new ei();
    return this.queryCoord2DExtension(t2, e5, true), e5.x;
  }
  getCoordY(t2) {
    const e5 = new ei();
    return this.queryCoord2DExtension(t2, e5, true), e5.y;
  }
  cut(t2, e5, s4) {
    const n6 = new nu();
    return this.queryCut(t2, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t2, e5, s4, n6) {
    const i2 = s4.createQuadraticRationalBezier();
    if (this.cutBezierIgnoreAttributes(t2, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = rn.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t2, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t3 = 1; t3 < r; t3++) {
        const s5 = this.m_description.getSemantics(t3), n7 = rn.getComponentCount(s5);
        for (let t4 = 0; t4 < n7; t4++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t4);
          i2.setEndAttribute(s5, t4, n8);
        }
      }
    }
  }
  queryDerivative(t2, e5) {
    hi(this, t2, e5);
  }
  cutBezierIgnoreAttributes(t2, s4, n6) {
    (t2 < 0 || s4 > 1 || t2 > s4) && P("Quadratic_rational_bezier.cut_bezier_ignore_attributes");
    const i2 = Rt(ei, 3);
    this.queryControlPoints(i2);
    const r = [0, 0, 0];
    Xi(i2, this.m_weights, t2, s4, i2, r), n6.setControlPointsAndWeights(i2, r);
  }
  splitBezierIgnoreAttributes(t2, e5, s4) {
  }
  getAttributeAsDbl(t2, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t2) : this.getCoordY(t2);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t2) / n6 : 0, r = rn.getInterpolation(e5), o2 = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return pt(r, o2, a2, i2, rn.getDefaultValue(e5));
  }
  getClosestCoordinate(t2, e5) {
    return vi(this, t2, x2.unit(), e5, -1);
  }
  getClosestCoordinateOnInterval(t2, e5, s4 = -1) {
    return vi(this, t2, e5, false, s4);
  }
  getYMonotonicParts(t2, e5) {
    return this.getMonotonicParts(t2, e5);
  }
  getMonotonicParts(t2, n6) {
    t2.length < 2 && P("");
    const i2 = Qn(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n2(t2.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t2[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      Ti(t2[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t2, e5, s4, n6) {
    s4 && (s4.length = 9), n6 && (n6.length = 9);
    const i2 = new Array(3), r = Rt(p2, 2), o2 = new x2(0, 1);
    let a2 = 0;
    const h2 = Rt(ei, 3);
    if (this.queryControlPoints(h2), t2) {
      if (i2[0] = new p2(h2[0].y).sub(e5).mul(this.m_weights[0]), i2[1] = new p2(h2[1].y).sub(e5).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].y).sub(e5).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = js2(i2[2], i2[1], i2[0], o2, false, r), s4) for (let m2 = 0; m2 < a2; m2++) s4[m2] = this.getCoordX(r[m2].value());
    } else if (i2[0] = new p2(h2[0].x).sub(e5).mul(this.m_weights[0]), i2[1] = new p2(h2[1].x).sub(e5).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].x).sub(e5).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = js2(i2[2], i2[1], i2[0], o2, false, r), s4) for (let m2 = 0; m2 < a2; m2++) s4[m2] = this.getCoordY(r[m2].value());
    if (n6) for (let m2 = 0; m2 < a2; m2++) n6[m2] = r[m2].value();
    else s4 && wt(s4, 0, a2, Dt);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t2, e5) {
    if (this.m_YStart === this.m_YEnd) return t2 === this.m_YStart ? e5 : Number.NaN;
    if (t2 === this.m_YStart) return this.m_XStart;
    if (t2 === this.m_YEnd) return this.m_XEnd;
    const n6 = [Number.NaN, Number.NaN], i2 = this.intersectionWithAxis2D(true, t2, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t2) {
    return Te(this, t2);
  }
  isDegenerate3D(t2, e5) {
    return false;
  }
  queryLooseEnvelope(t2) {
    if (t2 instanceof n4) return t2.setCoords({ pt: this.getStartXY() }), t2.mergeNe(this.m_cp), void t2.mergeNe(this.getEndXY());
  }
  clone(t2) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t2, e5) {
    if (0 === t2) {
      const t3 = n4.constructEmpty();
      this.queryEnvelope(t3);
      const s4 = x2.constructEmpty();
      return 0 === e5 ? t3.queryIntervalX(s4) : t3.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t2, e5);
  }
  queryLooseEnvelopeOnInterval(t2, e5) {
    const s4 = Rt(ei, 3);
    this.queryControlPoints(s4);
    const n6 = [0, 0, 0];
    Xi(s4, this.m_weights, t2.vmin, t2.vmax, s4, n6), e5.setFromPoints(s4, 3);
  }
  changeEndPoints2D(t2, e5) {
    if (t2.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t2), this.setEndXY(e5), s4 ? this.m_cp.setCoordsPoint2D(t2) : n6 && this.m_cp.setCoordsPoint2D(e5), this.normalizeAfterEndpointChange();
  }
  tToLength(t2) {
    return Kn(this, t2, true);
  }
  lengthToT(t2) {
    return ci(this, t2);
  }
  calculateWeightedAreaCentroid2D(t2) {
    const e5 = pi(this), s4 = gi(this);
    return e5.x += (this.getStartX() - t2.x) * s4, e5.y += (this.getStartY() - t2.y) * s4, e5;
  }
  calculateWeightedCentroid2D() {
    const t2 = new ei();
    return this.isDegenerate(0) ? (t2.setCoords(0, 0), t2) : yi(this) ? (t2.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t2) : (t2.assign(Mi(this, 1)), t2);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t2) {
    this.m_cp.setCoordsPoint2D(t2), this.afterCompletedModification();
  }
  queryWeights(t2) {
    for (let e5 = 0; e5 < 3; ++e5) t2[e5] = this.m_weights[e5];
  }
  setWeights(t2) {
  }
  queryControlPoints(t2) {
    t2[0].assign(this.getStartXY()), t2[1].assign(this.m_cp), t2[2].assign(this.getEndXY());
  }
  setControlPointsAndWeights(t2, e5) {
    this.setCpsAndWeightsArray(t2, e5), this.afterCompletedModification();
  }
  getTangent(t2) {
    const e5 = Rt(ei, 3);
    return this.queryControlPoints(e5), ui(e5, this.m_weights, t2);
  }
  getDerivative(t2) {
    const e5 = ks(t2, 0, 1), s4 = Rt(ei, 4);
    return $n(this, 1, e5, s4), s4[1];
  }
  getCurvature(t2) {
    const e5 = Rt(ei, 4);
    $n(this, 2, t2, e5);
    const s4 = e5[1].sqrLength();
    if (0 === s4) return Number.NaN;
    e5[1].divThis(Math.sqrt(s4));
    return e5[1].crossProduct(e5[2]) / s4;
  }
  isIntersecting(t2, e5, s4) {
    return false;
  }
  isIntersectingPoint(t2, e5, s4) {
    return false;
  }
  isIntersectingPoint3D(t2, e5, s4, n6, i2 = 1) {
    return false;
  }
  isMonotoneQuickAndDirty() {
    const t2 = Rt(ei, 3);
    return this.queryControlPoints(t2), Ai(t2);
  }
  getMonotonicPartParams(t2, s4) {
    const n6 = Qn(this), i2 = n6.specialPointsCount();
    if (!s4) return n6.specialPointsCount();
    t2 < i2 && P("");
    for (let e5 = 0; e5 < i2; e5++) s4[e5] = n6.specialPoints[e5];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Mt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Mt(this.m_YStart, this.m_YStart = this.m_YEnd), this.m_weights[2] = Mt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
      for (let t2 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t2 < e5; t2++) this.m_attributes[t2 + e5] = Mt(this.m_attributes[t2], this.m_attributes[t2] = this.m_attributes[t2 + e5]);
      this.m_cachedValues = null;
    }
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t2) {
    const e5 = [t2];
    return !!Ie(this, e5) && Li(this, e5[0]);
  }
  copyIgnoreAttributes(t2) {
    const e5 = Rt(ei, 3);
    this.queryControlPoints(e5);
    const s4 = [0, 0, 0];
    this.queryWeights(s4), t2.setControlPointsAndWeights(e5, s4);
  }
  calculateArea2DHelper() {
    return gi(this);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1) + this.m_cp.norm(1);
  }
  absNormXYZ(t2) {
    return n2(0), 0;
  }
  queryEnvelopeW(t2, e5) {
    Di(this, t2, e5);
  }
  setSegmentFromCoords(t2, e5) {
    const s4 = [0, 0, 0];
    this.queryWeights(s4), this.constructWeights(t2[0], this.getControlPoint1(), t2[e5 - 1], s4[0], s4[1], s4[2]);
  }
  writeInBufferStream(t2, e5) {
    const s4 = new Float64Array(5);
    return s4[0] = this.m_cp.x, s4[1] = this.m_cp.y, s4[2] = this.m_weights[0], s4[3] = this.m_weights[1], s4[4] = this.m_weights[2], t2.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t2, e5) {
    const s4 = new Float64Array(5);
    t2.queryRange(e5, s4.length, s4, true, 1), this.m_cp.x = s4[0], this.m_cp.y = s4[1], this.m_weights[0] = s4[2], this.m_weights[1] = s4[3], this.m_weights[2] = s4[4], this.m_cachedValues = null;
  }
  snapControlPoints(t2) {
    const e5 = Rt(ei, 3);
    this.queryControlPoints(e5);
    const s4 = ei.sqrDistance(e5[1], e5[0]), n6 = ei.sqrDistance(e5[1], e5[2]);
    let i2 = e5[0].clone(), r = s4;
    s4 > n6 && (i2 = e5[2].clone(), r = n6);
    let o2 = false;
    return r <= t2 && 0 !== r && (o2 = true, this.setControlPoint1(i2)), o2;
  }
  needsSnapControlPoints(t2) {
    if (!t2) return false;
    const e5 = Rt(ei, 3);
    this.queryControlPoints(e5);
    const s4 = ei.sqrDistance(e5[1], e5[0]), n6 = ei.sqrDistance(e5[1], e5[2]);
    e5[0].clone();
    let i2 = s4;
    return s4 > n6 && (e5[2].clone(), i2 = n6), i2 <= t2 && 0 !== i2;
  }
  calculateSpecialPointsForCracking(t2, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return Ti(this);
  }
  setCoordsForIntersector(t2, e5, s4) {
    qi(this, t2, e5, s4);
  }
  copyToImpl(t2) {
    const e5 = t2;
    e5.m_cp.setCoordsPoint2D(this.m_cp), e5.m_weights[0] = this.m_weights[0], e5.m_weights[1] = this.m_weights[1], e5.m_weights[2] = this.m_weights[2], Ci(e5, xi(this));
  }
  reverseImpl() {
    this.m_weights[2] = Mt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
  }
  equalsImpl(t2) {
    const e5 = t2;
    if (!this.m_cp.equals(e5.m_cp)) return false;
    for (let s4 = 0; s4 < 3; s4++) if (this.m_weights[s4] !== e5.m_weights[s4]) return false;
    return true;
  }
  equalsImplTol(t2, e5) {
    const s4 = t2;
    if (!this.m_cp.isEqualPoint2D(s4.m_cp, e5)) return false;
    const n6 = Rt(ei, 3);
    this.queryControlPoints(n6);
    const i2 = Rt(ei, 3);
    s4.queryControlPoints(i2);
    const r = [s4.m_weights[0], s4.m_weights[1], s4.m_weights[2]];
    for (let o2 = 0; o2 < 3; o2++) {
      const t3 = new X2();
      t3.setCoordsPoint2DZ(n6[o2].mul(this.m_weights[o2]), this.m_weights[o2]);
      const s5 = new X2();
      if (s5.setCoordsPoint2DZ(i2[o2].mul(r[o2]), r[o2]), !t3.isEqual(s5, e5)) return false;
    }
    return true;
  }
  swapImpl(t2) {
    const e5 = t2;
    e5.m_cp = Mt(this.m_cp, this.m_cp = e5.m_cp), e5.m_weights = Mt(this.m_weights, this.m_weights = e5.m_weights), On(this, e5);
  }
  afterCompletedModification() {
    Un(this);
  }
  intersect(t2, e5, s4, n6, i2) {
    return Om(false, this, t2, e5, s4, n6, i2);
  }
  intersectPoint(t2, e5, s4) {
    return Si(this, t2, e5, s4);
  }
  endPointModified() {
    Un(this);
  }
  clearEndPointModified() {
  }
  setCpsAndWeights(t2, s4, n6, i2, r, o2) {
    (i2 <= 0 || o2 <= 0 || r < 0) && P("weights"), (t2.isNAN() || s4.isNAN() || n6.isNAN()) && P("NAN control points in bezier are not supported"), this.setStartXY(t2), this.m_cp.assign(s4), this.m_weights[0] = i2, this.m_weights[1] = r, this.m_weights[2] = o2, this.setEndXY(n6);
  }
  setCpsAndWeightsArray(t2, e5) {
    this.setCpsAndWeights(t2[0], t2[1], t2[2], e5[0], e5[1], e5[2]);
  }
};
on.type = a.enumRationalBezier2;
var an = class _an {
  static constructPoint2D(t2) {
    return new _an(Hs.constructDouble(t2.x), Hs.constructDouble(t2.y));
  }
  constructor(t2, e5) {
    if (void 0 === t2) return this.x = new Hs().setNAN(), void (this.y = new Hs().setNAN());
    this.x = t2.clone(), this.y = e5.clone();
  }
  assignPoint2D(t2) {
    return this.x.setDouble(t2.x), this.y.setDouble(t2.y), this;
  }
  setCoords(t2, e5) {
    return this.x.setThis(t2), this.y.setThis(e5), this;
  }
  asPoint2D() {
    return new ei(this.x.value(), this.y.value());
  }
  crossProduct(t2) {
    return this.x.mul(t2.y).sub(this.y.mul(t2.x));
  }
  leftPerpendicularThis() {
    const t2 = this.x.clone();
    this.x = this.y.clone().negate(), this.y = t2;
  }
  clone() {
    return new _an(this.x, this.y);
  }
  dotProduct(t2) {
    return this.x.mul(t2.x).add(this.y.mul(t2.y));
  }
  add(t2) {
    return new _an(this.x.add(t2.x), this.y.add(t2.y));
  }
  sub(t2) {
    return new _an(this.x.sub(t2.x), this.y.sub(t2.y));
  }
  sqrLength() {
    return this.x.sqr().addThis(this.y.sqr());
  }
  mulThis(t2) {
    return this.x.mulThis(t2), this.y.mulThis(t2), this;
  }
  mul(t2) {
    return this.clone().mulThis(t2);
  }
};
var hn = class {
  constructor(t2) {
    return t2.coefsT ? (this.m_zeroCtor = t2.zeroCtor, this.m_elements = t2.coefsT.map((t3) => t3.clone()), n2(this.m_elements.length === t2.power + 1), void this.updatePower()) : t2.coef0 ? (this.m_zeroCtor = t2.zeroCtor, void (this.m_elements = [t2.coef0.clone()])) : t2.copy ? (this.m_zeroCtor = t2.copy.m_zeroCtor, void (this.m_elements = t2.copy.m_elements.map((t3) => t3.clone()))) : (this.m_zeroCtor = t2.zeroCtor, void (this.m_elements = [new this.m_zeroCtor()]));
  }
  construct(t2, e5) {
    return this.m_elements = t2.map((t3) => t3.clone()), this.updatePower(), this;
  }
  construct0(t2) {
    return this.m_elements.length = 0, this.m_elements.push(t2.clone()), this.updatePower(), this;
  }
  assignCopy(t2) {
    return this.m_elements = t2.m_elements.map((t3) => t3.clone()), this.updatePower(), this;
  }
  assignMove(t2) {
    return this.m_elements = t2.m_elements, t2.m_elements = [], this.updatePower(), this;
  }
  power() {
    return this.m_elements.length - 1;
  }
  addElement(t2) {
    this.m_elements.push(t2.clone());
  }
  fmSubThis(t2, e5) {
    return n2(0), this;
  }
  addThis(t2) {
    const e5 = Math.min(this.power(), t2.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].addThis(t2.m_elements[n6]);
    const s4 = t2.power();
    this.m_elements.length = Math.max(this.power(), t2.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t2.m_elements[n6];
    return this.updatePower(), this;
  }
  add0(t2) {
    return this.m_elements[0].addThis(t2), this.updatePower(), this;
  }
  addNumber0(t2) {
    return n2(0), this;
  }
  sub(t2) {
    const e5 = Math.min(this.power(), t2.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].subThis(t2.m_elements[n6]);
    const s4 = t2.power();
    this.m_elements.length = Math.max(this.power(), t2.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t2.m_elements[n6].clone(), this.m_elements[n6].negateThis();
    return this.updatePower(), this;
  }
  sub0(t2) {
    return n2(0), this;
  }
  subNumber0(t2) {
    return n2(0), this;
  }
  subShifted(t2, e5) {
    const s4 = this.power(), n6 = t2.power() + e5, i2 = Math.min(this.power(), n6);
    let r = 0;
    for (let o2 = e5; o2 <= i2; ++o2) this.m_elements[o2].subThis(t2.m_elements[r]), r++;
    if (n6 <= s4) return this.updatePower(), this;
    this.m_elements.length = n6 + 1;
    for (let o2 = s4 + 1; o2 < this.m_elements.length; ++o2) this.m_elements[o2] = new this.m_zeroCtor();
    for (let o2 = i2 + 1; o2 <= n6; ++o2) this.m_elements[o2].subThis(t2.m_elements[r++]);
    return this.updatePower(), this;
  }
  subShiftedWithCoef(t2, e5, s4) {
    const n6 = this.power(), i2 = t2.power() + s4, r = Math.min(this.power(), i2);
    let o2 = 0;
    for (let a2 = s4; a2 <= r; ++a2) this.m_elements[a2].fmSubThis(t2.m_elements[o2], e5), o2++;
    if (i2 <= n6) return this.updatePower(), this;
    this.m_elements.length = i2 + 1;
    for (let a2 = n6 + 1; a2 < this.m_elements.length; ++a2) this.m_elements[a2] = new this.m_zeroCtor();
    for (let a2 = r + 1; a2 <= i2; ++a2) this.m_elements[a2].fmSubThis(t2.m_elements[o2++], e5);
    return this.updatePower(), this;
  }
  mulThis(t2) {
    if (this.constructor === t2.constructor) {
      const e5 = t2, s4 = [];
      for (let t3 = 0, n6 = this.power(); t3 <= n6; t3++) for (let i2 = 0, r = e5.power(); i2 <= r; i2++) {
        const n7 = this.m_elements[t3].clone();
        n7.mulThis(e5.m_elements[i2]), t3 + i2 < s4.length ? s4[t3 + i2].addThis(n7) : s4.push(n7);
      }
      this.m_elements = s4;
    } else for (let e5 = 0, s4 = this.power(); e5 <= s4; e5++) this.m_elements[e5].mulThis(t2);
    return this.updatePower(), this;
  }
  mulElementThis(t2) {
    for (let e5 = 0, s4 = this.power(); e5 <= s4; e5++) this.m_elements[e5].mulThis(t2);
    return this.updatePower(), this;
  }
  mulNumber0(t2) {
    return n2(0), this;
  }
  mulBigint0(t2) {
    return n2(0), this;
  }
  mulBigIntThis(t2) {
    return n2(0), this;
  }
  mulInt320(t2) {
    return n2(0), this;
  }
  div0(t2) {
    return n2(0), this;
  }
  absThis() {
    return n2(0), this;
  }
  div(t2, e5, s4) {
    if (this.power() < t2.power()) return s4.assignCopy(this), void e5.setZero();
    s4.setZero(), e5.setZero();
    const n6 = t2.getElement(t2.power()), i2 = this.clone();
    let r = i2.power();
    const o2 = i2.power() - t2.power();
    let a2 = o2;
    for (e5.m_elements = Rt(e5.m_zeroCtor, o2 + 1); ; ) {
      if (r < t2.power()) {
        s4.assignMove(i2);
        break;
      }
      if (r === i2.power()) {
        const s5 = i2.getElement(i2.power());
        s5.divThis(n6), i2.subShiftedWithCoef(t2, s5, i2.power() - t2.power()), e5.m_elements[a2] = s5.clone();
      }
      a2--, r--;
    }
    s4.updatePower(), e5.updatePower();
  }
  divThis(t2) {
    return n2(0), this;
  }
  subThis(t2) {
    const e5 = Math.min(this.power(), t2.power());
    for (let n6 = 0; n6 <= e5; ++n6) this.m_elements[n6].subThis(t2.m_elements[n6]);
    const s4 = t2.power();
    this.m_elements.length = Math.max(this.power(), t2.power()) + 1;
    for (let n6 = e5 + 1; n6 <= s4; ++n6) this.m_elements[n6] = t2.m_elements[n6].clone(), this.m_elements[n6].negateThis();
    return this.updatePower(), this;
  }
  sub0This(t2) {
    return this.m_elements[0].subThis(t2), this.updatePower(), this;
  }
  subFrom(t2, e5) {
    n2(0);
  }
  isZero() {
    return 0 === this.power() && this.m_elements[0].isZero();
  }
  negateThis() {
    for (let t2 = this.m_elements.length - 1; t2 >= 0; t2--) this.m_elements[t2].negateThis();
    return this;
  }
  getElement(t2) {
    return this.m_elements[t2].clone();
  }
  setElement(t2, e5) {
    return this.m_elements[t2] = e5.clone(), this;
  }
  evaluate(t2) {
    const e5 = this.power(), s4 = this.m_elements[e5].clone();
    for (let n6 = e5 - 1; n6 >= 0; --n6) s4.mulThis(t2), s4.addThis(this.m_elements[n6]);
    return s4;
  }
  equals(t2) {
    if (this === t2) return true;
    if (this.power() !== t2.power()) return false;
    for (let e5 = this.m_elements.length - 1; e5 >= 0; e5--) if (!this.m_elements[e5].equals(t2.m_elements[e5])) return false;
    return true;
  }
  updatePower() {
    for (let t2 = this.m_elements.length - 1; t2 > 0 && this.m_elements[t2].isZero(); t2--) this.m_elements.pop();
    return this;
  }
  setZero() {
    return this.m_elements.length = 1, this.m_elements[0] = new this.m_zeroCtor(), this.updatePower(), this;
  }
  derivative(t2) {
    if (this.power() < t2) return this.clone().setZero();
    if (0 === t2) return this.clone();
    const e5 = new this.constructor({ coefsT: this.m_elements.slice(t2), power: this.power() - t2 });
    for (let s4 = t2, n6 = this.power(); s4 <= n6; s4++) {
      let n7 = BigInt(s4);
      for (let e6 = s4 - 1, i2 = s4 - t2; e6 > i2; --e6) n7 *= BigInt(e6);
      e5.m_elements[s4 - t2].mulBigIntThis(n7);
    }
    return e5.updatePower(), e5;
  }
  derivative1This() {
    if (this.m_elements.length > 1) {
      this.m_elements = this.m_elements.slice(1);
      for (let t2 = 1, e5 = this.power(); t2 <= e5; t2++) this.m_elements[t2].mulThis(Hs.constructInt32(t2 + 1));
    } else this.m_elements.length = 0, this.m_elements.push(new this.m_zeroCtor());
    return this;
  }
  limitPrecisionThis(t2) {
    for (let e5 = this.power(); e5 >= 0; --e5) this.m_elements[e5].limitPrecisionThis(t2);
    return this.updatePower(), this;
  }
  hiBitIndex() {
    return this.m_elements.reduce((t2, e5) => {
      const s4 = e5.hiBitIndex();
      return t2 < s4 ? s4 : t2;
    }, 0);
  }
  shiftRight(t2) {
    return this.m_elements.splice(0, t2), this.updatePower(), this;
  }
  static evaluateCoefs(t2, e5, s4) {
    const n6 = t2.power();
    s4.construct0(t2.getElement(0).evaluate(e5));
    for (let i2 = 1; i2 <= n6; ++i2) s4.addElement(t2.getElement(i2).evaluate(e5));
    s4.updatePower();
  }
};
var mn = class _mn extends hn {
  constructor(t2) {
    super(void 0 === t2 ? { zeroCtor: Hs } : { ...t2, zeroCtor: Hs });
  }
  clone() {
    return new _mn({ copy: this });
  }
  absEvaluate(t2) {
    const e5 = this.power(), s4 = this.m_elements[e5].clone();
    s4.absThis();
    const n6 = t2.clone();
    n6.absThis();
    for (let i2 = e5 - 1; i2 >= 0; --i2) s4.mulThis(n6), s4.addThis(this.m_elements[i2].abs());
    return s4;
  }
};
var un = class _un extends hn {
  constructor(t2) {
    super(void 0 === t2 ? { zeroCtor: mn } : { ...t2, zeroCtor: mn });
  }
  clone() {
    return new _un({ copy: this });
  }
  constructFromMPValues(t2, e5) {
    this.m_elements.length = 0;
    for (let s4 = 0; s4 <= e5; ++s4) this.m_elements.push(new mn({ coef0: t2[s4] }));
    return this.updatePower(), this;
  }
};
function ln() {
  return { polypoly1: new un(), polypoly2: new un(), polyX2: new mn(), polyY2: new mn(), polyX2Deriv: new mn(), polyY2Deriv: new mn(), polypolyX1: new un(), polypolyY1: new un(), polypolyX1Deriv: new un(), polypolyY1Deriv: new un(), lazyPolypolyD1: new un(), lazyPolypolyD1Deriv: new un(), lazyPolyD2: new mn(), lazyPolyD2Deriv: null, polypoly11: new un(), polypoly12: new un(), tempPp: new un(), tempPp1: new un(), tempPp2: new un(), tempP: new mn(), tempP1: new mn(), tempP2: new mn() };
}
function cn(t2, e5, n6, i2, r, o2, a2, m2, u, l2, c, g2, d2, _, p3, f3, P5, y2 = false) {
  const x4 = ln();
  x4.polyX2.construct(a2, m2), x4.polyY2.construct(u, l2), x4.polypolyX1.constructFromMPValues(t2, e5), x4.polypolyY1.constructFromMPValues(n6, i2), x4.polypoly11.assignCopy(x4.polypolyX1), x4.polypoly12.assignCopy(x4.polypolyY1), c && (x4.lazyPolyD2.construct(c, g2), x4.polypoly11.mulElementThis(x4.lazyPolyD2), x4.polypoly12.mulElementThis(x4.lazyPolyD2)), r ? (x4.lazyPolypolyD1.constructFromMPValues(r, o2), x4.lazyPolypolyD1Deriv = new un({ copy: x4.lazyPolypolyD1 }), x4.lazyPolypolyD1Deriv.derivative1This(), x4.tempPp.assignCopy(x4.lazyPolypolyD1), x4.tempPp.mulElementThis(x4.polyX2), x4.polypoly11.subThis(x4.tempPp), x4.tempPp.assignCopy(x4.lazyPolypolyD1), x4.tempPp.mulElementThis(x4.polyY2), x4.polypoly12.subThis(x4.tempPp)) : (x4.polypoly11.sub0This(x4.polyX2), x4.polypoly12.sub0This(x4.polyY2)), x4.polypolyX1Deriv.assignCopy(x4.polypolyX1), x4.polypolyX1Deriv.derivative1This(), x4.polypolyY1Deriv.assignCopy(x4.polypolyY1), x4.polypolyY1Deriv.derivative1This(), r && (x4.polypolyX1Deriv.mulThis(x4.lazyPolypolyD1), x4.tempPp2.assignCopy(x4.lazyPolypolyD1Deriv), x4.tempPp2.mulThis(x4.polypolyX1), x4.polypolyX1Deriv.subThis(x4.tempPp2), x4.polypolyY1Deriv.mulThis(x4.lazyPolypolyD1), x4.tempPp2.assignCopy(x4.lazyPolypolyD1Deriv), x4.tempPp2.mulThis(x4.polypolyY1), x4.polypolyY1Deriv.subThis(x4.tempPp2)), x4.polyX2Deriv.assignCopy(x4.polyX2), x4.polyX2Deriv.derivative1This(), x4.polyY2Deriv.assignCopy(x4.polyY2), x4.polyY2Deriv.derivative1This(), c && (n2(null === x4.lazyPolyD2Deriv), x4.lazyPolyD2Deriv = new mn({ copy: x4.lazyPolyD2 }), x4.lazyPolyD2Deriv.derivative1This(), x4.polyX2Deriv.mulThis(x4.lazyPolyD2), x4.tempP1.assignCopy(x4.lazyPolyD2Deriv), x4.tempP1.mulThis(x4.polyX2), x4.polyX2Deriv.subThis(x4.tempP1), x4.polyY2Deriv.mulThis(x4.lazyPolyD2), x4.tempP1.assignCopy(x4.lazyPolyD2Deriv), x4.tempP1.mulThis(x4.polyY2), x4.polyY2Deriv.subThis(x4.tempP1)), x4.polypoly1.assignCopy(x4.polypoly11), x4.polypoly1.mulElementThis(x4.polyX2Deriv), x4.tempPp.assignCopy(x4.polypoly12), x4.tempPp.mulElementThis(x4.polyY2Deriv), x4.polypoly1.addThis(x4.tempPp), x4.polypoly2.assignCopy(x4.polypolyX1Deriv), x4.polypoly2.mulElementThis(x4.polyY2Deriv), x4.tempPp.assignCopy(x4.polypolyY1Deriv), x4.tempPp.mulElementThis(x4.polyX2Deriv), x4.polypoly2.subThis(x4.tempPp);
  let C2 = [];
  const v3 = [];
  P5 || (P5 = []), f3 || (f3 = []), vn(x4.polypoly11, x4.polypoly12, x4.tempP);
  let b2 = 57, E2 = 0.25 * Number.EPSILON;
  const S3 = [];
  let D3 = bn(x4.tempP, d2, p3, E2, b2, S3);
  if (D3 < 0) return -1;
  for (let s4 = 0; s4 < D3; s4++) {
    mn.evaluateCoefs(x4.polypoly11, Hs.constructDouble(S3[s4]), x4.tempP1);
    const t3 = [];
    let e6 = bn(x4.tempP1, d2, _, E2, b2, t3);
    if (0 !== e6) if (mn.evaluateCoefs(x4.polypoly12, Hs.constructDouble(S3[s4]), x4.tempP2), e6 < 0) {
      e6 = bn(x4.tempP2, d2, _, E2, b2, t3), e6 < 0 && b("mp_curve_proximity");
      for (let n7 = 0; n7 < e6; n7++) v3.push(Qt(t3[n7], S3[s4]));
    } else {
      const n7 = x4.tempP2.absEvaluate(Ws);
      n7.mulThis(Hs.constructDouble(1e-12));
      for (let i3 = 0; i3 < e6; i3++) {
        const e7 = x4.tempP2.evaluate(Hs.constructDouble(t3[i3]));
        e7.absThis(), e7.lt(n7) && v3.push(Qt(t3[i3], S3[s4]));
      }
    }
  }
  D3 = v3.length, vn(x4.polypoly1, x4.polypoly2, x4.tempP), b2 = 57, E2 = 0.25 * Number.EPSILON;
  const w4 = [];
  let A4 = bn(x4.tempP, d2, p3, E2, b2, w4);
  A4 < 0 && (A4 = 0);
  for (let s4 = 0; s4 < A4; s4++) {
    mn.evaluateCoefs(x4.polypoly1, Hs.constructDouble(w4[s4]), x4.tempP1);
    const t3 = [];
    let e6 = bn(x4.tempP1, d2, _, E2, b2, t3);
    if (0 !== e6) if (mn.evaluateCoefs(x4.polypoly2, Hs.constructDouble(w4[s4]), x4.tempP2), e6 < 0) {
      if (e6 = bn(x4.tempP2, d2, _, E2, b2, t3), e6 < 0) continue;
      for (let n7 = 0; n7 < e6; n7++) C2.push(Qt(t3[n7], w4[s4]));
    } else {
      const n7 = x4.tempP2.absEvaluate(Ws);
      n7.mulThis(Hs.constructDouble(1e-12));
      for (let i3 = 0; i3 < e6; i3++) {
        const e7 = x4.tempP2.evaluate(Hs.constructDouble(t3[i3]));
        e7.absThis(), e7.lt(n7) && C2.push(Qt(t3[i3], w4[s4]));
      }
    }
  }
  if (A4 = C2.length, 0 === D3 && 0 === A4) return 0;
  C2 = C2.concat(v3), C2.sort((t3, e6) => y2 ? Dt(t3.second, e6.second) : Dt(t3.first, e6.first));
  const T3 = Pt(C2, (t3, e6) => t3.first === e6.first && t3.second === e6.second);
  C2 = C2.slice(0, T3), f3.length = 0, P5.length = 0;
  for (const s4 of C2) f3.push(s4.first), P5.push(s4.second);
  return n2(f3.length === P5.length), P5.length;
}
function gn(t2, e5, s4, n6, i2, r, o2) {
  if (0 === t2.power()) return t2.isZero() ? -1 : 0;
  const a2 = t2.evaluate(Hs.constructInt32(1)).isZero();
  if (1 === t2.power()) {
    const s5 = pn(t2.getElement(1), t2.getElement(0), e5, r.at(0));
    return r[0].limitPrecisionThis(n6), 1 !== s5 ? 0 : (r[0].limitPrecisionThis(n6), 1);
  }
  if (2 === t2.power()) {
    return fn(t2.getElement(2), t2.getElement(1), t2.getElement(0), n6, e5, a2, r);
  }
  if (3 === t2.power()) {
    return Pn(t2.getElement(3), t2.getElement(2), t2.getElement(1), t2.getElement(0), n6, e5, a2, r);
  }
  if (4 === t2.power()) {
    return yn(t2.getElement(4), t2.getElement(3), t2.getElement(2), t2.getElement(1), t2.getElement(0), n6, e5, a2, r);
  }
  return An(t2, e5, s4, n6, a2, i2, r, o2);
}
function dn() {
  return { polyIntersect: new mn(), polyX1: new mn(), polyY1: new mn(), polyX1Deriv: new mn(), polyY1Deriv: new mn(), lazyPolyD1: new mn(), lazyPolyD1Deriv: new mn(), tempP: new mn(), tempP1: new mn(), tempP2: new mn(), polypoly1Proximity: new un(), polypoly2Proximity: new un() };
}
function _n(t2, e5, s4, n6, i2, r, o2, a2, h2, m2, u) {
  const l2 = dn();
  l2.polyX1.construct(t2, e5), l2.polyY1.construct(s4, n6), l2.polyX1Deriv.assignCopy(l2.polyX1), l2.polyX1Deriv.derivative1This(), l2.polyY1Deriv.assignCopy(l2.polyY1), l2.polyY1Deriv.derivative1This(), l2.polyIntersect.assignCopy(l2.polyX1), l2.polyIntersect.mulThis(l2.polyX1), l2.polyIntersect.mulElementThis(o2[0]), l2.tempP.assignCopy(l2.polyY1), l2.tempP.mulThis(l2.polyY1), l2.tempP.mulElementThis(o2[1]), l2.polyIntersect.addThis(l2.tempP), i2 ? (l2.lazyPolyD1.construct(i2, r), l2.tempP.assignCopy(l2.lazyPolyD1), l2.tempP.mulThis(l2.lazyPolyD1), l2.tempP.mulElementThis(o2[2]), l2.polyIntersect.addThis(l2.tempP)) : l2.polyIntersect.add0(o2[2]);
  {
    const i3 = o2[0].clone(), r2 = i3.clone();
    r2.sqrThis();
    const a3 = o2[1].clone(), h3 = a3.clone();
    h3.sqrThis();
    const m3 = o2[2].clone(), u2 = i3.clone();
    u2.subThis(a3), l2.polyX1.construct(t2, e5), l2.polyX1Deriv.assignCopy(l2.polyX1), l2.polyX1Deriv.derivative1This(), l2.polyY1.construct(s4, n6), l2.polyY1Deriv.assignCopy(l2.polyY1), l2.polyY1Deriv.derivative1This(), l2.tempP.assignCopy(l2.polyX1), l2.tempP.mulThis(l2.polyX1), l2.tempP.mulElementThis(h3), l2.tempP.mulElementThis(m3), l2.polypoly1Proximity.construct0(l2.tempP), l2.tempP.assignCopy(l2.polyX1), l2.tempP.mulThis(a3.mul(u2).mul(m3).ldexpThis(1)), l2.polypoly1Proximity.addElement(l2.tempP), l2.tempP.assignCopy(l2.polyX1), l2.tempP.mulThis(l2.polyX1), l2.tempP.mulElementThis(i3.mul(h3)), l2.tempP1.assignCopy(l2.polyY1), l2.tempP1.mulThis(l2.polyY1), l2.tempP1.mulElementThis(r2.mul(a3)), l2.tempP.addThis(l2.tempP1), l2.tempP.add0(u2.mul(u2).mul(m3)), l2.polypoly1Proximity.addElement(l2.tempP), l2.tempP.assignCopy(l2.polyX1), l2.tempP.mulElementThis(u2.mul(i3).mul(a3).ldexpThis(1)), l2.polypoly1Proximity.addElement(l2.tempP), l2.tempP.construct0(i3.mul(u2).mul(u2)), l2.polypoly1Proximity.addElement(l2.tempP), l2.polypoly1Proximity.updatePower(), l2.tempP.construct0(Xs), l2.polypoly2Proximity.construct0(l2.tempP), l2.tempP.assignCopy(l2.polyX1), l2.tempP.mulThis(l2.polyX1Deriv), l2.tempP1.assignCopy(l2.polyY1), l2.tempP1.mulThis(l2.polyY1Deriv), l2.tempP.addThis(l2.tempP1), l2.tempP.mulElementThis(i3.mul(a3)), l2.polypoly2Proximity.addElement(l2.tempP), l2.tempP.assignCopy(l2.polyX1Deriv), l2.tempP.mulElementThis(u2.mul(i3)), l2.polypoly2Proximity.addElement(l2.tempP), l2.polypoly2Proximity.updatePower();
  }
  const c = [], g2 = [];
  u || (u = []);
  let d2 = 2 * l2.polyIntersect.power() + 58;
  const _ = 0.5 * Number.EPSILON, p3 = bn(l2.polyIntersect, a2, h2, _, d2, g2);
  if (p3 < 0) return -1;
  vn(l2.polypoly1Proximity, l2.polypoly2Proximity, l2.tempP), d2 = 2 * l2.tempP.power() + 58;
  let f3 = bn(l2.tempP, a2, h2, _, d2, c);
  if (f3 < 0 && (f3 = 0), 0 === p3 && 0 === f3) return 0;
  const P5 = c.concat(g2);
  u.length = P5.length, Tt(u, P5, 0, 0, P5.length), Et(u);
  const y2 = Pt(u, (t3, e6) => 0 === Dt(t3, e6));
  return u.length = y2, u.length;
}
function pn(t2, e5, s4, n6) {
  return t2.isZero() ? e5.isZero() ? -1 : 0 : (n6.setThis(e5), n6.negateThis(), n6.divThis(t2), s4.isEmpty() || s4.containsCoordinate(n6.value()) ? 1 : 0);
}
function fn(t2, e5, s4, n6, i2, r, o2) {
  if (t2.isZero()) {
    if (r) return o2[0].setInt32(1), i2.containsCoordinate(1) ? 1 : 0;
    return pn(e5, s4, i2, o2[0]);
  }
  if (r) {
    let e6 = 2;
    return o2[0].setInt32(1), s4.equals(t2) ? (o2[1].setInt32(1), e6 = 1) : o2[1].setThis(s4.div(t2)), i2.containsCoordinate(o2[1].value()) || (e6 = 1), i2.containsCoordinate(o2[0].value()) || (e6--, o2[0].setThis(o2[1])), 2 === e6 && o2[0].value() > o2[1].value() && (o2[1] = Mt(o2[0], o2[0] = o2[1])), e6;
  }
  const a2 = e5.clone();
  a2.sqrThis();
  const h2 = t2.clone();
  if (h2.mulThis(s4).ldexpThis(2).negateThis().addThis(a2), h2.LZ()) return 0;
  const m2 = n6 + 2, u = Hs.sqrt(h2, m2), l2 = u.clone();
  e5.LZ() && l2.negateThis(), l2.addThis(e5).limitPrecisionThis(m2).ldexpThis(-1).negateThis();
  let c = 0;
  return o2[0].setThis(l2).divThis(Hs.constructAssign(t2, m2)).limitPrecisionThis(n6), (i2.isEmpty() || i2.containsCoordinate(o2[0].value())) && c++, u.isZero() || l2.isZero() || (o2[c].setThis(s4).divThis(l2).limitPrecisionThis(n6), (i2.isEmpty() || i2.containsCoordinate(o2[c].value())) && c++, 2 === c && o2[0].gt(o2[1]) && (o2[1] = Mt(o2[0], o2[0] = o2[1]))), c;
}
function Pn(t2, e5, n6, i2, r, o2, a2, h2) {
  if (t2.isZero()) {
    return fn(e5, n6, i2, r, o2, a2, h2);
  }
  const m2 = (t3, e6) => {
    if (t3 > 0) {
      let s4 = e6 + t3;
      for (let t4 = 1; t4 < s4; t4++) h2[t4].equals(h2[0]) && (h2[s4 - 1] = Mt(h2[t4], h2[t4] = h2[s4 - 1]), s4--);
      e6 = s4;
    }
    return wt(h2, 0, e6, (t4, e7) => t4.compare(e7)), e6;
  };
  if (i2.isZero()) {
    let s4 = 0;
    o2.containsCoordinate(0) && (h2[0].setInt32(0), s4 = 1);
    return m2(fn(t2, e5, n6, r, o2, a2, h2.slice(1)), s4);
  }
  if (a2) {
    let s4 = 0;
    o2.containsCoordinate(1) && (h2[0].setInt32(1), s4 = 1);
    const n7 = e5.add(t2), a3 = i2.negate(), u2 = t2.add(n7).add(a3).isZero();
    return m2(fn(t2, n7, a3, r, o2, u2, h2.slice(s4)), s4);
  }
  const u = new Hs(), l2 = new Hs(), c = new Hs(), g2 = e5.clone();
  if (g2.isZero()) l2.setThis(n6), l2.divThis(t2), c.setThis(i2), l2.divThis(t2);
  else {
    g2.divThis(t2).divDoubleThis(3).negateThis();
    const s4 = e5.clone();
    s4.sqrThis();
    const r2 = t2.clone();
    r2.sqrThis(), l2.setThis(t2), l2.mulThis(n6).mulDoubleThis(3).subThis(s4).divThis(r2).divDoubleThis(3), c.setThis(s4), c.mulThis(e5), c.ldexpThis(1), u.setThis(t2), u.mulThis(e5).mulThis(n6).mulDoubleThis(9), c.subThis(u), u.setThis(r2), u.mulThis(i2).mulDoubleThis(27), c.addThis(u), c.divThis(r2).divThis(t2).divDoubleThis(27);
  }
  if (l2.isZero()) {
    const t3 = c.clone();
    return t3.negateThis(), t3.isZero() ? (h2[0].setThis(g2), In(o2, r, h2, 1)) : (h2[0].setThis(Hs.cubicRoot(c, r).add(g2)), In(o2, r, h2, 1));
  }
  const d2 = c.clone();
  if (d2.sqrThis().ldexpThis(-2), u.setThis(l2.clone()), u.sqrThis().mulThis(l2).divDoubleThis(27), d2.addThis(u), d2.isZero()) return h2[0].setThis(c), h2[0].mulDoubleThis(3).divThis(l2), h2[1].setThis(h2[0]), h2[1].negateThis(), h2[1].ldexpThis(-1), h2[0].addThis(g2), h2[1].addThis(g2), In(o2, r, h2, 2);
  if (d2.GZ()) return d2.setThis(Hs.sqrt(d2, r + 8)), u.setThis(c), u.ldexpThis(-1).negateThis(), u.addThis(d2), h2[0].setThis(Hs.cubicRoot(u, r + 8)), u.setThis(c), u.ldexpThis(-1).negateThis(), u.subThis(d2), h2[0].addThis(Hs.cubicRoot(u, r + 8)), h2[0].addThis(g2), In(o2, r, h2, 1);
  u.setThis(l2), u.divDoubleThis(3).negateThis(), n2(u.GEZ());
  const _ = Hs.sqrt(u, r + 8), p3 = _.clone();
  p3.negateThis(), p3.addThis(g2), _.addThis(g2);
  const f3 = Hs.constructDouble(o2.isEmpty() ? -Number.MAX_VALUE : o2.vmin), P5 = Hs.constructDouble(o2.isEmpty() ? Number.MAX_VALUE : o2.vmax), y2 = new mn({ zeroCtor: Hs });
  y2.construct0(i2), y2.addElement(n6), y2.addElement(e5), y2.addElement(t2);
  const x4 = new mn({ copy: y2 });
  x4.derivative1This();
  let C2 = 0;
  const v3 = Rt(Hs, 4);
  v3[C2++].setThis(f3), p3.gt(f3) && p3.lt(P5) && v3[C2++].setThis(p3), _.gt(f3) && _.lt(P5) && v3[C2++].setThis(_), v3[C2++].setThis(P5);
  const b2 = 3 * r;
  let E2 = 52, S3 = Number.EPSILON;
  for (; E2 < b2; ) 2 * E2 <= b2 ? (S3 *= S3, E2 *= 2) : (S3 *= Number.EPSILON, E2 += 52);
  E2 += 2;
  let D3 = 0, w4 = false;
  for (let s4 = 1; s4 < C2; s4++) {
    if (Dn(y2, x4, v3[s4 - 1], v3[s4], S3, E2, h2[0])) {
      D3 = 1, w4 = s4 + 1 < C2;
      break;
    }
  }
  if (!D3) return 0;
  if (w4) {
    const t3 = new mn({ zeroCtor: Hs, coef0: h2[0] });
    t3.negateThis(), t3.addElement(Ws);
    const e6 = new mn({ zeroCtor: Hs }), n7 = new mn({ zeroCtor: Hs });
    y2.div(t3, e6, n7), n2(2 === e6.power()), n2(0 === n7.power());
    const i3 = fn(e6.getElement(2), e6.getElement(1), e6.getElement(0), r, o2, false, h2.slice(1));
    n2(i3 >= 0 && i3 <= 2), D3 += i3;
  }
  return In(o2, r, h2, D3);
}
function yn(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  if (t2.isZero()) return Pn(e5, s4, n6, i2, r, o2, a2, h2);
  const m2 = (t3, e6) => {
    if (t3 > 0) {
      let s5 = e6 + t3;
      for (let t4 = 1; t4 < s5; t4++) h2[t4].equals(h2[0]) && (h2[s5 - 1] = Mt(h2[t4], h2[t4] = h2[s5 - 1]), s5--);
      e6 = s5;
    }
    return wt(h2, 0, e6, (t4, e7) => t4.compare(e7)), e6;
  };
  if (i2.isZero()) {
    let i3 = 0;
    o2.containsCoordinate(0) && (h2[0].setInt32(0), i3 = 1);
    return m2(Pn(t2, e5, s4, n6, r, o2, a2, h2.slice(i3)), i3);
  }
  const u = new mn({ zeroCtor: Hs, coef0: i2 });
  if (u.addElement(n6), u.addElement(s4), u.addElement(e5), u.addElement(t2), a2) {
    let t3 = 0;
    o2.containsCoordinate(1) && (h2[0].setInt32(1), t3 = 1);
    const e6 = new mn({ zeroCtor: Hs, coef0: Hs.constructInt32(-1) });
    e6.addElement(Hs.constructInt32(1));
    const s5 = new mn({ zeroCtor: Hs }), n7 = new mn({ zeroCtor: Hs });
    u.div(e6, s5, n7);
    return m2(Pn(3 === s5.power() ? s5.getElement(3) : Xs.clone(), s5.power() >= 2 ? s5.getElement(2) : Xs.clone(), s5.power() >= 1 ? s5.getElement(1) : Xs.clone(), s5.getElement(0), r, o2, s5.evaluate(Ws).isZero(), h2.slice(t3)), t3);
  }
  if (u.getElement(0).isZero()) {
    let t3 = 0;
    for (o2.containsCoordinate(0) && (t3 = 1, h2[0].setDouble(0)); u.getElement(0).isZero() && u.power() > 0; ) u.shiftRight(1);
    const e6 = Pn(3 === u.power() ? u.getElement(3) : Xs.clone(), u.power() >= 2 ? u.getElement(2) : Xs.clone(), u.power() >= 1 ? u.getElement(1) : Xs.clone(), u.getElement(0), r, o2, false, h2.slice(t3));
    return e6 > 0 && (t3 += e6), wt(h2, 0, t3, (t4, e7) => t4.compare(e7)), t3;
  }
  let l2 = 52, c = Number.EPSILON;
  for (; l2 < r; ) 2 * l2 <= r ? (c *= c, l2 *= 2) : (c *= Number.EPSILON, l2 += 52);
  l2 += 2;
  const g2 = Tn(u), d2 = Hs.constructDouble(Math.max(Math.abs(o2.vmax), Math.abs(o2.vmin)));
  return c = (g2.lt(d2) ? g2 : d2).mul(Hs.constructDouble(c)).toDouble(), An(u, o2, c, l2, a2, false, h2, 4);
}
function xn(t2, e5) {
  let s4 = t2, n6 = e5;
  n6.power() > s4.power() && (n6 = Mt(s4, s4 = n6));
  const i2 = s4.power() - n6.power(), r = new mn({ copy: s4.getElement(s4.power()) });
  s4.mulThis(n6.getElement(n6.power()));
  for (let o2 = 0, a2 = s4.power(); o2 < a2; o2++) if (o2 >= i2) {
    const t3 = new mn({ copy: n6.getElement(o2 - i2) });
    t3.mulThis(r);
    const e6 = s4.getElement(o2).sub(t3);
    s4.setElement(o2, e6);
  }
  s4.setElement(s4.power(), s4.getElement(s4.power()).setZero()), s4.updatePower(), Cn(s4);
}
function Cn(t2) {
  let e5 = 0;
  for (; e5 < t2.power() && t2.getElement(e5).isZero(); ) e5++;
  return e5 > 0 && (t2.shiftRight(e5), true);
}
function vn(t2, e5, s4) {
  const n6 = t2.clone(), i2 = e5.clone();
  for (Cn(n6), Cn(i2); 0 !== n6.power() || 0 !== i2.power(); ) xn(n6, i2);
  s4.assignMove(n6.getElement(0));
}
function bn(t2, e5, s4, n6, i2, r) {
  r.length = 0;
  const o2 = t2.power(), a2 = Rt(Hs, 2 * o2 + 4), h2 = gn(t2, s4 || x2.unit(), n6, i2, false, a2, a2.length);
  if (h2 > 0) {
    r.length = 0;
    for (let t3 = 0; t3 < h2; t3++) {
      const e6 = a2[t3].value();
      t3 > 0 && e6 <= r.at(-1) || r.push(e6);
    }
    return r.length;
  }
  return h2;
}
function En(t2, e5, n6) {
  if (n2(n6 >= 1), 0 === t2.power()) return t2.isZero() ? -1 : 0;
  const i2 = t2.getElement(0);
  return i2.negateThis(), i2.divThis(t2.getElement(1)), e5[0].setThis(i2), 1;
}
function Sn(t2, e5, n6, i2) {
  if (t2.power() < 2) return En(t2, n6, i2);
  n2(i2 >= 1);
  let r = t2.getElement(1);
  r.mulThis(t2.getElement(1));
  const o2 = t2.getElement(0);
  if (o2.mulThis(t2.getElement(2)), o2.ldexpThis(2), r.subThis(o2), r.LZ()) return 0;
  if (r.isZero()) {
    const s4 = t2.getElement(1);
    return s4.negateThis(), s4.divThis(t2.getElement(2)), s4.ldexpThis(-1), s4.limitPrecisionThis(e5), n6[0].setThis(s4), 1;
  }
  n2(i2 >= 2), r = Hs.sqrt(r, e5 + 8);
  const a2 = t2.getElement(1);
  a2.negateThis();
  const h2 = a2.clone();
  h2.subThis(r), h2.divThis(t2.getElement(2)), h2.ldexpThis(-1), h2.limitPrecisionThis(e5);
  const m2 = a2.clone();
  return m2.addThis(r), m2.divThis(t2.getElement(2)), m2.ldexpThis(-1), m2.limitPrecisionThis(e5), h2.lt(m2) ? (n6[0].setThis(h2), n6[1].setThis(m2)) : (n6[1].setThis(h2), n6[0].setThis(m2)), 2;
}
function Dn(t2, e5, s4, n6, i2, r, o2) {
  let a2 = s4.clone(), m2 = n6.clone();
  a2.limitPrecisionThis(r), m2.limitPrecisionThis(r);
  let u = t2.evaluate(a2);
  u.limitPrecisionThis(r + 2);
  let l2 = t2.evaluate(m2);
  if (l2.limitPrecisionThis(r + 2), u.GEZ() && l2.GEZ() || u.LEZ() && l2.LEZ()) return u.absLessAbs(l2) ? (o2 = a2, u.isZero()) : (o2 = m2, l2.isZero());
  const c = l2.LZ();
  c && (l2 = Mt(u, u = l2), m2 = Mt(a2, a2 = m2));
  const g2 = c ? m2 : a2, d2 = c ? a2 : m2, _ = a2.add(m2).ldexpThis(-1);
  _.limitPrecisionThis(r);
  const p3 = m2.sub(a2);
  p3.limitPrecisionThis(r), p3.absThis();
  const f3 = p3.clone();
  let P5 = t2.evaluate(_), y2 = e5.evaluate(_);
  const x4 = new mn({ copy: t2 }), C2 = new mn({ copy: e5 });
  {
    const s5 = Math.max(t2.hiBitIndex(), e5.hiBitIndex()), n7 = Ws.clone();
    n7.ldexpThis(-(r + 2));
    for (let i3 = 64; i3 < s5; ) {
      x4.limitPrecisionThis(i3), C2.limitPrecisionThis(i3);
      const r2 = x4.evaluate(_), o3 = C2.evaluate(_), a3 = r2.sub(P5), h2 = o3.sub(y2);
      if (a3.divThis(P5).absThis().lt(n7) && (y2.isZero() || h2.divThis(y2).absThis().lt(n7))) break;
      x4.assignCopy(t2), C2.assignCopy(e5), i3 = Math.min(i3 + 64, s5);
    }
    P5.limitPrecisionThis(r + 2), y2.limitPrecisionThis(r + 2);
  }
  const v3 = 1, b2 = 4;
  let E2 = b2;
  const S3 = 2;
  let D3 = 1, w4 = 0, A4 = 0, T3 = v3;
  const I5 = 32, M2 = Hs.constructDouble(0.25 * i2), Y3 = Hs.constructDouble(0.5001);
  let X4 = 0;
  const N2 = 300;
  for (; ++X4 < N2; ) {
    if (X4 > I5 && w4 > 0 || y2.isZero() || T3 === S3 && w4 > 1 || T3 === v3 && E2 < b2) T3 = v3, D3 > 1 && D3--;
    else if (T3 = S3, A4 > 1) {
      const t4 = p3.mul(y2);
      t4.absThis(), t4.ldexpThis(-3), t4.absLessAbs(P5) && D3++;
    }
    p3.setThis(f3);
    const t3 = new Hs();
    let e6 = false;
    if (T3 === v3) do {
      if (A4 > 2) {
        const e7 = p3.clone();
        if (e7.absThis(), e7.ldexpThis(4), d2.sub(g2).ldexpThis(-1).gt(e7)) {
          if (_.equals(g2)) {
            t3.setThis(_), _.setThis(g2.add(e7)), _.limitPrecisionThis(r), f3.setThis(_.sub(t3));
            break;
          }
          if (_.equals(d2)) {
            t3.setThis(_), _.setThis(d2.sub(e7)), _.limitPrecisionThis(r), f3.setThis(_.sub(t3));
            break;
          }
        }
      }
      f3.setThis(m2.sub(a2)), f3.ldexpThis(-1), f3.limitPrecisionThis(r), t3.setThis(_), _.setThis(a2.add(f3)), _.limitPrecisionThis(r), _.lt(g2) ? _.setThis(g2) : _.gt(d2) && _.setThis(d2), e6 = a2.equals(_) || m2.equals(_);
    } while (0);
    else for (; ; ) {
      if (f3.setThis(P5.div(y2)), f3.limitPrecisionThis(r), 1 !== D3 && f3.mulDoubleThis(D3), t3.setThis(_), _.subThis(f3), _.limitPrecisionThis(r), e6 = _.equals(t3), _.lt(g2)) {
        if (D3 > 1) {
          _.setThis(t3), D3--;
          continue;
        }
        f3.setThis(t3.sub(g2)), _.setThis(g2);
      } else if (_.gt(d2)) {
        if (D3 > 1) {
          _.setThis(t3), D3--;
          continue;
        }
        f3.setThis(t3.sub(d2)), _.setThis(d2);
      }
      break;
    }
    if (e6 || f3.absLessAbs(M2)) {
      t3.equals(_) || (P5 = x4.evaluate(_), P5.limitPrecisionThis(r + 2));
      break;
    }
    P5 = x4.evaluate(_), P5.limitPrecisionThis(r + 2), y2 = C2.evaluate(_), y2.limitPrecisionThis(r + 2);
    const s5 = a2.clone(), n7 = m2.clone();
    P5.LZ() ? (u.setThis(P5), a2.setThis(_)) : (l2.setThis(P5), m2.setThis(_)), T3 === S3 && (a2.equals(s5) && m2.equals(n7) || A4 > 1 && !f3.absLessAbs(Y3.mul(p3))) ? w4++ : w4 = 0, T3 === v3 ? (E2++, A4 = 0) : (E2 = 0, A4++);
  }
  return X4 >= N2 && b("Root_finder iterations exceeded"), o2.setThis(_), true;
}
function wn(t2, e5, s4, n6, i2) {
  const r = t2.evaluate(s4);
  if (r.isZero()) return true;
  const o2 = Hs.constructDouble(0.5 * n6), a2 = s4.clone();
  a2.subThis(o2);
  const h2 = t2.evaluate(a2), m2 = s4.clone();
  m2.addThis(o2);
  const u = t2.evaluate(m2);
  if (h2.LZ() && u.GZ() || h2.GZ() && u.LZ()) return true;
  if (r.GZ() ? h2.LEZ() || u.LEZ() : h2.GEZ() || u.GEZ()) return true;
  const l2 = h2.LEZ() && u.LEZ(), c = h2.GEZ() && u.GEZ();
  let g2 = false;
  return l2 ? r.gt(h2) && r.gt(u) && (g2 = true) : c && r.lt(h2) && r.lt(u) && (g2 = true), !!g2 && r.absThis().lt(Hs.constructDouble(1e-17));
}
function An(t2, e5, n6, i2, r, o2, a2, h2) {
  n2(n6 > 0), n2(h2 >= t2.power());
  const m2 = a2, u = [];
  let l2 = [];
  const c = new mn({ zeroCtor: t2.m_zeroCtor }), g2 = new mn({ zeroCtor: t2.m_zeroCtor }), d2 = new mn({ zeroCtor: t2.m_zeroCtor }), _ = Hs.constructDouble(n6), p3 = Hs.constructDouble(e5.vmin), f3 = Hs.constructDouble(e5.vmax), P5 = p3.sub(_), y2 = f3.add(_), x4 = Tn(t2), C2 = x4.clone();
  if (C2.negateThis(), P5.lt(C2)) P5.setThis(C2.sub(_));
  else if (P5.gt(x4)) return 0;
  if (y2.gt(x4)) y2.setThis(x4.add(_));
  else if (y2.lt(C2)) return 0;
  let v3 = t2, b2 = null;
  if (r) {
    const e6 = new mn({ coef0: Hs.constructInt32(-1) });
    e6.addElement(Ws), b2 = new mn(), v3 = b2;
    const s4 = new mn(), n7 = new mn();
    for (t2.div(e6, s4, n7), b2.assignCopy(s4); v3.evaluate(Ws).isZero(); ) v3.div(e6, s4, n7), b2.assignCopy(s4);
  }
  let E2 = false;
  if (v3.power() > 0 && v3.getElement(0).isZero()) for (E2 = true, b2 || (b2 = new mn({ copy: v3 }), v3 = b2); v3.getElement(0).isZero(); ) b2.shiftRight(1);
  let S3 = i2 + 2 * v3.power() + 2, D3 = n6 / Math.pow(2, v3.power() + 2), w4 = S3;
  if (Xs.gt(P5) && Xs.lt(y2)) {
    for (let s4 = 0, Y3 = v3.power(); s4 < Y3; s4++) if (v3.getElement(s4).isZero()) {
      u.push(Xs.clone());
      break;
    }
  }
  for (let Y3 = v3.power() - 1; Y3 > 0; Y3--) if (D3 *= 2, S3 -= 2, w4 -= 2, v3.power() - Y3 != 1) if (v3.power() - Y3 != 2) {
    g2.assignMove(d2), d2.assignMove(v3.derivative(Y3 - 1));
    let t3 = [];
    for (let e6 = 0, s4 = l2.length; e6 < s4; ++e6) if (l2[e6].first.lte(l2[e6].second)) {
      const s5 = new Hs();
      if (Dn(g2, c, l2[e6].first, l2[e6].second, D3, S3, s5)) {
        u.push(s5);
        let n7 = s5.sub(_);
        n7.limitPrecisionThis(w4), t3.push(Qt(l2[e6].first, n7)), n7 = s5.add(_), n7.limitPrecisionThis(w4), t3.push(Qt(n7, l2[e6].second));
      } else t3.push(l2[e6]);
    }
    l2 = t3, t3 = [], c.assignMove(g2);
  } else {
    g2.assignMove(v3.derivative(Y3));
    const t3 = Sn(g2, S3, m2, h2);
    n2(t3 >= 0 && t3 <= 2);
    for (let e6 = 0; e6 < t3; e6++) m2[e6].gt(P5) && m2[e6].lt(y2) && !m2[e6].isZero() && u.push(m2[e6].clone());
    if (u.length > 1 && u.sort((t4, e6) => t4.compare(e6)), u.length > 0) {
      let t4 = u[0].sub(_);
      t4.limitPrecisionThis(w4), l2.push(Qt(P5.clone(), t4));
      let e6 = 1 === u.length ? y2.clone() : u[1].sub(_);
      t4 = u[0].add(_), t4.limitPrecisionThis(w4), e6.limitPrecisionThis(w4), l2.push(Qt(t4, e6)), u.length > 1 && (e6 = 2 === u.length ? y2.clone() : u[2].sub(_), e6.limitPrecisionThis(w4), t4 = u[1].add(_), t4.limitPrecisionThis(w4), l2.push(Qt(t4, e6)), u.length > 2 && (t4 = u[2].add(_), t4.limitPrecisionThis(w4), l2.push(Qt(t4, y2.clone()))));
    } else l2.push(Qt(P5.clone(), y2.clone()));
    c.assignCopy(g2), d2.assignMove(v3.derivative(Y3 - 1));
  }
  else {
    g2.assignMove(v3.derivative(Y3));
    1 === En(g2, m2, h2) && (m2[0].gt(P5) && m2[0].lt(y2) && !m2[0].isZero() && u.push(m2[0].clone()), c.assignMove(g2), d2.assignMove(v3.derivative(Y3 - 1)));
  }
  u.sort((t3, e6) => t3.compare(e6)), 0 === l2.length && (c.assignMove(v3.derivative(v3.power())), c.isZero() || l2.push(Qt(P5.clone(), y2.clone())));
  let A4 = 0, T3 = 0, I5 = 0;
  const M2 = new Hs();
  for (; ; ) {
    if (T3 < l2.length) {
      if (l2[T3].first.gt(l2[T3].second)) {
        T3++;
        continue;
      }
      let t3 = false;
      if (I5 < u.length && u[I5].lt(l2[T3].first) && (t3 = true), !t3) {
        Dn(v3, c, l2[T3].first, l2[T3].second, n6, i2, M2) && (M2.lt(p3) ? m2[A4++].setThis(p3) : M2.gt(f3) ? m2[A4++].setThis(f3) : m2[A4++].setThis(M2)), T3++;
        continue;
      }
    }
    if (!(I5 < u.length)) break;
    0 !== I5 && u[I5 - 1].equals(u[I5]) || wn(v3, c, u[I5], n6) && (M2.setThis(u[I5]), M2.lt(p3) ? M2.setThis(p3) : M2.gt(f3) && M2.setThis(f3), 0 !== A4 && m2[A4].equals(M2) || m2[A4++].setThis(M2)), I5++;
  }
  return E2 && Xs.gt(P5) && Xs.lt(y2) && (m2[A4++].setThis(Xs), wt(m2, 0, A4, (t3, e6) => t3.compare(e6))), r && Ws.gt(P5) && Ws.lt(y2) && (m2[A4++].setThis(Ws), wt(m2, 0, A4, (t3, e6) => t3.compare(e6))), A4;
}
function Tn(t2) {
  const e5 = t2.getElement(t2.power());
  e5.limitPrecisionThis(53);
  const s4 = Xs.clone();
  for (let n6 = 0, i2 = t2.power(); n6 < i2; n6++) {
    const i3 = t2.getElement(n6);
    i3.limitPrecisionThis(53), i3.divThis(e5).absThis(), i3.gt(s4) && s4.setThis(i3);
  }
  return s4.addThis(Ws), s4.mulThis(Hs.constructDouble(1 + 100 * Number.EPSILON)), s4;
}
function In(t2, e5, s4, n6) {
  let i2 = n6;
  if (!t2.isEmpty()) {
    i2 = 0;
    for (let e6 = 0; e6 < n6; ++e6) t2.containsCoordinate(s4[e6].value()) && (i2 !== e6 && s4[i2].setThis(s4[e6]), i2++);
  }
  i2 > 1 && (s4[0].gt(s4[1]) && (s4[1] = Mt(s4[0], s4[0] = s4[1])), i2 > 2 && (s4[0].gt(s4[2]) && (s4[2] = Mt(s4[0], s4[0] = s4[2])), s4[1].gt(s4[2]) && (s4[2] = Mt(s4[1], s4[1] = s4[2]))));
  for (let r = 0; r < i2; ++r) s4[r].limitPrecisionThis(e5);
  return i2;
}
var Mn = [[0.33998104358485626, 0.6521451548625461], [0.8611363115940526, 0.34785484513745385]];
var Yn = [[0.1834346424956498, 0.362683783378362], [0.525532409916329, 0.31370664587788727], [0.7966664774136267, 0.22238103445337448], [0.9602898564975363, 0.10122853629037626]];
var Xn = [[0.09501250983763744, 0.1894506104550685], [0.2816035507792589, 0.18260341504492358], [0.45801677765722737, 0.16915651939500254], [0.6178762444026438, 0.14959598881657674], [0.755404408355003, 0.12462897125553388], [0.8656312023878318, 0.09515851168249279], [0.9445750230732326, 0.062253523938647894], [0.9894009349916499, 0.027152459411754096]];
var Nn = [[0.04830766568773832, 0.0965400885147278], [0.1444719615827965, 0.09563872007927486], [0.23928736225213706, 0.09384439908080457], [0.33186860228212767, 0.09117387869576389], [0.42135127613063533, 0.08765209300440381], [0.5068999089322294, 0.08331192422694675], [0.5877157572407623, 0.07819389578707031], [0.6630442669302152, 0.0723457941088485], [0.7321821187402897, 0.06582222277636185], [0.7944837959679424, 0.058684093478535544], [0.84936761373257, 0.050998059262376175], [0.8963211557660521, 0.04283589802222668], [0.9349060759377397, 0.03427386291302143], [0.9647622555875064, 0.02539206530926206], [0.9856115115452684, 0.01627439473090567], [0.9972638618494816, 0.007018610009470096]];
var qn = [[0.024350292663424433, 0.048690957009139724], [0.07299312178779904, 0.04857546744150343], [0.12146281929612056, 0.048344762234802954], [0.16964442042399283, 0.04799938859645831], [0.21742364374000708, 0.04754016571483031], [0.2646871622087674, 0.04696818281621002], [0.31132287199021097, 0.046284796581314416], [0.3572201583376681, 0.04549162792741814], [0.4022701579639916, 0.044590558163756566], [0.4463660172534641, 0.04358372452932345], [0.48940314570705296, 0.04247351512365359], [0.5312794640198946, 0.04126256324262353], [0.571895646202634, 0.03995374113272034], [0.6111553551723933, 0.038550153178615626], [0.6489654712546573, 0.03705512854024005], [0.6852363130542333, 0.035472213256882386], [0.7198818501716109, 0.033805161837141606], [0.7528199072605319, 0.03205792835485155], [0.7839723589433414, 0.030234657072402478], [0.8132653151227975, 0.028339672614259483], [0.8406292962525803, 0.02637746971505466], [0.8659993981540928, 0.024352702568710874], [0.8893154459951141, 0.022270173808383253], [0.9105221370785028, 0.02013482315353021], [0.9295691721319396, 0.017951715775697343], [0.9464113748584028, 0.015726030476024718], [0.9610087996520538, 0.013463047896718643], [0.973326827789911, 0.011168139460131128], [0.983336253884626, 0.008846759826363947], [0.9910133714767443, 0.006504457968978363], [0.9963401167719553, 0.004147033260562468], [0.9993050417357722, 0.001783280721696433]];
var Fn = [[0.012223698960615764, 0.024446180196262518], [0.03666379096873349, 0.024431569097850044], [0.06108196960413957, 0.02440235563384958], [0.08546364050451549, 0.024358557264690626], [0.10979423112764375, 0.024300200167971867], [0.13405919946118777, 0.02422731922281525], [0.15824404271422493, 0.024139957989019287], [0.18233430598533718, 0.024038168681024052], [0.2063155909020792, 0.023922012136703457], [0.23017356422666, 0.023791557781003402], [0.2538939664226943, 0.023646883584447616], [0.2774626201779044, 0.02348807601653591], [0.3008654388776772, 0.02331522999406276], [0.32408843502441337, 0.023128448824387027], [0.3471177285976355, 0.022927844143686846], [0.369939555349859, 0.02271353585023646], [0.39254027503326744, 0.022485652032744968], [0.414906379552275, 0.022244328893799764], [0.43702450103710416, 0.02198971066846049], [0.4588814198335522, 0.021721949538052076], [0.48046407240417205, 0.02144120553920846], [0.5017595591361445, 0.02114764646822135], [0.5227551520511755, 0.02084144778075115], [0.5434383024128103, 0.02052279248696007], [0.5637966482266181, 0.020191871042130043], [0.5838180216287631, 0.01984888123283086], [0.6034904561585486, 0.019494028058706602], [0.6228021939105849, 0.019127523609950944], [0.6417416925623075, 0.01874958694054471], [0.660297632272646, 0.01836044393733134], [0.6784589224477192, 0.017960327185008687], [0.6962147083695144, 0.017549475827117706], [0.7135543776835874, 0.01712813542311138], [0.7304675667419088, 0.016696557801589205], [0.746944166797062, 0.016255000909785187], [0.7629743300440948, 0.015803728659399347], [0.7785484755064119, 0.015343010768865144], [0.7936572947621933, 0.014873122602147314], [0.8082917575079137, 0.014394345004166847], [0.8224431169556439, 0.013906964132951985], [0.8361029150609068, 0.013411271288616333], [0.8492629875779689, 0.012907562739267348], [0.8619154689395485, 0.012396139543950923], [0.8740527969580318, 0.01187730737274028], [0.8856677173453972, 0.011351376324080417], [0.8967532880491582, 0.010818660739503076], [0.9073028834017568, 0.010279479015832158], [0.9173101980809605, 0.009734153415006806], [0.9267692508789478, 0.009183009871660874], [0.9356743882779164, 0.00862637779861675], [0.9440202878302202, 0.008064589890486059], [0.9518019613412644, 0.0074979819256347285], [0.9590147578536999, 0.006926892566898814], [0.9656543664319652, 0.006351663161707189], [0.9717168187471366, 0.005772637542865698], [0.9771984914639074, 0.00519016183267633], [0.9820961084357185, 0.004604584256702955], [0.9864067427245862, 0.004016254983738642], [0.9901278184917344, 0.0034255260409102157], [0.9932571129002129, 0.0028327514714579912], [0.9957927585349812, 0.0022382884309626186], [0.997733248625514, 0.0016425030186690294], [0.9990774599773758, 0.0010458126793403489], [0.9998248879471319, 44938096029209035e-20]];
function Vn(t2, e5, s4, n6) {
  const i2 = 0.5 * (n6 - s4), r = s4 + i2, o2 = new n3(0);
  for (let a2 = 0, h2 = Math.trunc(t2 / 2); a2 < h2; ++a2) {
    let s5, n7;
    switch (t2) {
      case 4:
        s5 = Mn[a2][0], n7 = Mn[a2][1];
        break;
      case 8:
        s5 = Yn[a2][0], n7 = Yn[a2][1];
        break;
      case 16:
        s5 = Xn[a2][0], n7 = Xn[a2][1];
        break;
      case 32:
        s5 = Nn[a2][0], n7 = Nn[a2][1];
        break;
      case 64:
        s5 = qn[a2][0], n7 = qn[a2][1];
        break;
      case 128:
        s5 = Fn[a2][0], n7 = Fn[a2][1];
        break;
      default:
        throw new Error("Quadrature_integral: invalid n");
    }
    const h3 = st(-0.5, s5, r), m2 = st(i2, s5, r);
    o2.pe(e5(h3) * n7), o2.pe(e5(m2) * n7);
  }
  return o2.getResult() * i2;
}
function Ln(t2, e5, s4, n6, i2, r) {
  return kn(t2, e5, s4, r, n6, i2);
}
function Rn(t2, e5, s4, n6, i2, r) {
  let o2 = i2;
  if (n6) return r[0] = 1, o2 = 0.5 * (e5 - t2) * (s4(t2) + s4(e5)), o2;
  const a2 = r[0], h2 = (e5 - t2) / a2, m2 = t2, u = new n3(0);
  for (let l2 = 1; l2 <= r[0]; ++l2) {
    const t3 = (l2 - 0.5) * h2;
    u.add(s4(m2 + t3));
  }
  return o2 = 0.5 * (o2 + (e5 - t2) * u.getResult() / a2), r[0] *= 2, o2;
}
function zn(t2, e5, s4, n6, i2, r, o2) {
  let a2 = 0, h2 = Math.abs(i2 - s4[t2]);
  const m2 = Lt(e5, Number.NaN), u = Lt(e5, Number.NaN);
  for (let d2 = 0; d2 < e5; ++d2) {
    const e6 = Math.abs(i2 - s4[t2 + d2]);
    e6 < h2 && (a2 = d2, h2 = e6), m2[d2] = n6[t2 + d2], u[d2] = n6[t2 + d2];
  }
  let l2 = 0, c = 0, g2 = 0;
  r[0] = n6[t2 + a2], a2--;
  for (let d2 = 1; d2 < e5; d2++) {
    for (let n7 = 0; n7 < e5 - d2; n7++) {
      if (c = s4[t2 + n7] - i2, g2 = s4[t2 + n7 + d2] - i2, l2 = c - g2, 0 === l2) return false;
      const e6 = (m2[n7 + 1] - u[n7]) / l2;
      m2[n7] = c * e6, u[n7] = g2 * e6;
    }
    if (2 * (a2 + 1) < e5 - d2) {
      const t3 = a2 + 1;
      o2[0] = m2[t3];
    } else {
      const t3 = a2;
      o2[0] = u[t3], a2--;
    }
    r[0] += o2[0];
  }
  return true;
}
function kn(t2, s4, n6, i2, r, o2) {
  if (n6 < s4 && P("xTo < xFrom"), n6 === s4) return 0;
  const a2 = [0];
  let m2 = Number.MAX_VALUE;
  const u = [Number.MAX_VALUE];
  let l2 = 0;
  const c = 32, g2 = Lt(c + 1, Number.NaN), d2 = Lt(c + 1, Number.NaN), _ = [0];
  g2[0] = 1;
  let p3 = 0, f3 = 0;
  for (let e5 = 0; e5 < c; e5++) {
    if (l2 = Rn(s4, n6, i2, 0 === e5, l2, _), d2[e5] = l2, e5 + 1 >= t2) {
      zn(e5 + 1 - t2, t2, g2, d2, 0, a2, u) || b("polynomial_interpolation");
      const s5 = r * Math.abs(a2[0]) + o2, n7 = Math.abs(m2 - a2[0]);
      if (n7 <= s5 && Math.abs(u[0]) <= s5) {
        if (p3++, p3 > 1 && (n7 <= 0.1 * f3 || 0 === f3 || p3 > 2)) return a2[0];
      } else p3 = 0;
      f3 = n7, m2 = a2[0];
    }
    d2[e5 + 1] = d2[e5], g2[e5 + 1] = 0.25 * g2[e5];
  }
  return a2[0];
}
var Bn = class {
  constructor() {
    this.length = Number.NaN, this.area = Number.NaN, this.centroidX = Number.NaN, this.centroidY = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function Gn(t2, e5, n6, i2, r, o2, a2, h2) {
  for (; ; ) {
    const m2 = ei.distance(e5[0], e5[2]), u = ei.distance(e5[0], e5[1]) + ei.distance(e5[1], e5[2]);
    if (u - m2 <= r + i2 * u) return t2 + Q(m2, u, 0.5);
    const l2 = Rt(ei, 4), c = (t3) => {
      ti2(e5, n6, 1, t3, l2);
      return l2[1].length();
    };
    if (0 === a2 && h2 < 8) {
      n2(h2 < 8);
      let m3 = c(0), l3 = c(1);
      o2[0] += 2, m3 > l3 && (l3 = Mt(m3, m3 = l3), e5[2] = Mt(e5[0], e5[0] = e5[2]), n6[2] = Mt(n6[0], n6[0] = n6[2]));
      let g3 = m3 / (m3 + l3), d3 = 1, _2 = u;
      for (; g3 < 1 / 32 && _2 >= r + i2 * _2; ) {
        d3 /= 4;
        const t3 = c(d3);
        o2[0]++, g3 = m3 / (t3 + m3);
        const s4 = new ei();
        if (Ki(e5, n6, 0.5 * d3, s4), _2 = ei.distance(s4, e5[0]), _2 <= r) {
          const t4 = new ei();
          Ki(e5, n6, d3, t4), _2 += ei.distance(t4, s4);
        }
      }
      if (1 !== d3) {
        const s4 = Rt(ei, 3), m4 = [0, 0, 0];
        Yi(e5, n6, d3, e5, n6, s4, m4), t2 = Gn(t2, s4, m4, i2, r, o2, 0, h2 + 1), a2++, h2++;
        continue;
      }
    }
    let g2 = false;
    const d2 = 8;
    o2[0] += d2;
    const _ = Vn(d2, c, 0, 1), p3 = 16;
    o2[0] += p3;
    const f3 = Vn(p3, c, 0, 1);
    if (g2 = Math.abs(_ - f3) > r + i2 * u, !g2) return t2 + f3;
    if (a2 < 8 && h2 < 9) {
      const s4 = Rt(ei, 3), m3 = [0, 0, 0];
      Yi(e5, n6, 0.5, e5, n6, s4, m3), t2 = Gn(t2, s4, m3, i2, r, o2, a2 + 1, h2 + 1), a2++, h2++;
      continue;
    }
    const P5 = 32;
    o2[0] += P5;
    const y2 = Vn(P5, c, 0, 1);
    if (g2 = Math.abs(f3 - y2) > r + i2 * u, !g2) return t2 + y2;
    const x4 = 64;
    o2[0] += x4;
    const C2 = Vn(x4, c, 0, 1);
    if (g2 = Math.abs(y2 - C2) > r + i2 * u, !g2) return t2 + C2;
    const v3 = 128;
    o2[0] += v3;
    const b2 = Vn(v3, c, 0, 1);
    return g2 = Math.abs(C2 - b2) > r + i2 * u, t2 + b2;
  }
}
function Wn(t2, e5, s4, n6, i2) {
  if (s4 === e5) return 0;
  const r = Rt(ei, 3), o2 = [0, 0, 0];
  t2.queryControlPoints(r), t2.queryWeights(o2);
  const a2 = [0, 0, 0], h2 = Rt(ei, 3);
  Xi(r, o2, e5, s4, h2, a2);
  return Gn(0, h2, a2, n6, i2, [0], 0, 0);
}
var jn = class {
  constructor(t2, e5, s4) {
    this.controlPoints = St(t2, 3), this.weights = [0, 0, 0], Tt(this.weights, e5, 0, 0, 3), this.point = s4.clone();
  }
  getMaxDerivative() {
    return 3;
  }
  getValue(t2, e5) {
    if (0 === t2) {
      const t3 = new ei();
      Ki(this.controlPoints, this.weights, e5, t3);
      const s4 = Rt(ei, 4);
      ti2(this.controlPoints, this.weights, 1, e5, s4);
      return 2 * t3.sub(this.point).dotProduct(s4[1]);
    }
    if (1 === t2) {
      const t3 = new ei();
      Ki(this.controlPoints, this.weights, e5, t3);
      const s4 = Rt(ei, 4);
      ti2(this.controlPoints, this.weights, 2, e5, s4);
      return 2 * (t3.sub(this.point).dotProduct(s4[2]) + s4[1].dotProduct(s4[1]));
    }
    if (2 === t2) {
      const t3 = new ei();
      Ki(this.controlPoints, this.weights, e5, t3);
      const s4 = Rt(ei, 4);
      ti2(this.controlPoints, this.weights, 3, e5, s4);
      return 2 * (t3.sub(this.point).dotProduct(s4[3]) + 3 * s4[1].dotProduct(s4[2]));
    }
    return 0;
  }
  getError(t2) {
    return n2(0), 0;
  }
};
function Zn(t2, e5, s4, n6) {
  const i2 = Ei(0, 0, 0, 0, ei.getNAN()), r = Lt(18, Number.NaN), o2 = Rt(ei, 3);
  t2.queryControlPoints(o2), o2[2].subThis(e5), o2[1].subThis(e5), o2[0].subThis(e5);
  const a2 = [0, 0, 0];
  t2.queryWeights(a2);
  const h2 = [1, tr(a2), 1], m2 = sr(a2, s4), u = sr(a2, n6), l2 = Xs2(new jn(o2, h2, new ei(0, 0)), x2.construct(m2, u), 18, r);
  Ki(o2, h2, m2, i2.pt), i2.t = m2, i2.d = ei.distance(i2.pt, new ei(0, 0));
  const c = new ei();
  Ki(o2, h2, u, c);
  const g2 = ei.distance(c, new ei(0, 0));
  g2 < i2.d && (i2.d = g2, i2.t = u, i2.pt.assign(c));
  for (let d2 = 0; d2 < l2; d2++) {
    Ki(o2, h2, r[d2], c);
    const t3 = ei.distance(c, new ei(0, 0));
    t3 < i2.d && (i2.d = t3, i2.t = er(a2, r[d2]), i2.pt.assign(c));
  }
  return i2;
}
function Hn(t2, e5, s4, n6, i2) {
  let r = true;
  const o2 = Rt(ei, 4), a2 = Ln(5, e5, s4, n6, i2, (e6) => {
    $n(t2, 1, e6, o2);
    return (r ? t2.getCoordX(e6) - t2.getStartX() : t2.getCoordY(e6) - t2.getStartY()) * o2[1].length();
  });
  r = false;
  const h2 = Ln(5, e5, s4, n6, i2, (e6) => {
    $n(t2, 1, e6, o2);
    return (r ? t2.getCoordX(e6) - t2.getStartX() : t2.getCoordY(e6) - t2.getStartY()) * o2[1].length();
  });
  return new ei(a2, h2);
}
function Un(t2) {
  t2.m_cachedValues = null;
}
function On(t2, e5) {
  e5.m_cachedValues = Mt(t2.m_cachedValues, t2.m_cachedValues = e5.m_cachedValues);
}
function Qn(t2) {
  if (t2.m_cachedValues) return t2.m_cachedValues;
  const e5 = new Bn(), s4 = Rt(ei, 3);
  t2.queryControlPoints(s4);
  const n6 = [0, 0, 0];
  return t2.queryWeights(n6), Jn(s4, n6, e5.specialPoints), Ci(t2, e5), e5;
}
function Jn(t2, e5, s4) {
  if (0 === e5[1]) return s4.length = 0, s4.push(0), void s4.push(1);
  const n6 = Rt(p2, 8);
  n6[0].set(0);
  let i2 = 1;
  {
    const s5 = new p2(t2[1].x).subThis(t2[0].x).mulThis(e5[1]).mulThis(e5[0]), r = new p2(t2[2].x).subThis(t2[0].x).mulThis(e5[2]).mulThis(e5[0]), o2 = s5.subE(r).addThisE(new p2(t2[2].x).subThis(t2[1].x).mulThis(e5[2]).mulThis(e5[1]));
    r.subThisE(s5.mul(2));
    const a2 = Rt(p2, 2);
    let h2 = js2(o2, r, s5, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t3 = 0; t3 < h2; t3++) Fs(a2[t3].value(), 0, 1) || (n6[i2] = a2[t3], i2++);
  }
  {
    const s5 = new p2(t2[1].y).subThis(t2[0].y).mulThis(e5[1]).mulThis(e5[0]), r = new p2(t2[2].y).subThis(t2[0].y).mulThis(e5[2]).mulThis(e5[0]), o2 = s5.subE(r).addThisE(new p2(t2[2].y).subThis(t2[1].y).mulThis(e5[2]).mulThis(e5[1]));
    r.subThisE(s5.mul(2));
    const a2 = Rt(p2, 2);
    let h2 = js2(o2, r, s5, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t3 = 0; t3 < h2; t3++) Fs(a2[t3].value(), 0, 1) || (n6[i2] = a2[t3], i2++);
  }
  if (n6[i2].set(1), i2++, i2 > 2) {
    wt(n6, 0, i2, (t4, e7) => Dt(t4.value(), e7.value()));
    let t3 = 0, e6 = n6[0].value(), s5 = 1;
    for (let r = 1; r < i2; r++) n6[r].eq(n6[r - 1]) ? (e6 += n6[r].value(), s5++) : (s5 > 1 && (e6 /= s5, n6[t3].set(e6)), t3++, n6[t3] = n6[r], e6 = n6[r].value(), s5 = 1);
    t3++, i2 = t3;
  }
  n6[0].set(0), n6[i2 - 1].set(1), s4.length = i2;
  for (let r = 0; r < i2; r++) s4[r] = n6[r].value();
}
function Kn(t2, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + Kn(t2, 1, false);
  }
  if (t2.isDegenerate(0)) return 0;
  const n6 = 1 === e5, i2 = Qn(t2);
  if (n6 && !Number.isNaN(i2.length)) return i2.length;
  const r = fi(t2), o2 = r / t2.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let m2 = 1, u = i2.specialPointsCount(); m2 < u; m2++) {
    const s5 = i2.specialPoints[m2];
    if (a2 += Wn(t2, h2, Math.min(e5, s5), o2, r), e5 <= s5) break;
    h2 = s5;
  }
  return n6 && (i2.length = a2), a2;
}
function $n(t2, e5, s4, n6) {
  const i2 = Rt(ei, 3);
  t2.queryControlPoints(i2);
  const r = [0, 0, 0];
  t2.queryWeights(r), ti2(i2, r, e5, s4, n6);
}
function ti2(t2, e5, s4, n6, i2) {
  const r = [t2[0], t2[1], t2[2]], o2 = [e5[0], e5[1], e5[2]], a2 = Rt(ei, 4);
  ei2(r, o2, s4, n6, a2);
  for (let h2 = 0; h2 <= s4; h2++) i2[h2].setCoords(a2[h2].x, a2[h2].y);
}
function ei2(t2, e5, n6, i2, r) {
  n2(n6 > 0);
  const o2 = [t2[0].clone(), t2[1].clone(), t2[2].clone()];
  if (!o2[0].isZero()) {
    for (let t3 = 1; t3 < 3; ++t3) o2[t3].subThis(o2[0]);
    o2[0].setCoords(0, 0);
  }
  const a2 = si2(o2, e5, 0, i2), m2 = ii2(e5, 0, i2), u = a2.divide(m2);
  if (r[0].assign(u), 0 === n6) return;
  const l2 = [e5[1] * e5[0], e5[2] * e5[0] * 0.5, e5[1] * e5[2]], c = [t2[1].sub(t2[0]), t2[2].sub(t2[0]), t2[2].sub(t2[1])], g2 = m2 * m2, d2 = si2(c, l2, 0, i2).mul(2).divide(g2);
  if (r[1].assign(d2), 1 === n6) return;
  const _ = ii2(e5, 1, i2), p3 = 2 * m2 * _, f3 = si2(c, l2, 1, i2).mul(2).sub(d2.mul(p3)).divide(g2);
  if (r[2].assign(f3), 2 === n6) return;
  const P5 = si2(c, l2, 2, i2).mul(2), y2 = 2 * (_ * _ + m2 * ii2(e5, 2, i2)), x4 = P5.sub(f3.mul(p3).mul(2)).sub(d2.mul(y2)).divide(g2);
  r[3].assign(x4), 3 !== n6 && b("");
}
function si2(t2, e5, s4, n6) {
  if (0 === s4) {
    if (n6 <= 0.5) {
      const s5 = new ei();
      F(2, t2[0].mul(e5[0]), t2[1].mul(e5[1]), n6, s5);
      const i2 = new ei();
      F(2, t2[1].mul(e5[1]), t2[2].mul(e5[2]), n6, i2);
      const r = new ei();
      return F(2, s5, i2, n6, r), r;
    }
    {
      const s5 = new ei();
      k2(2, t2[0].mul(e5[0]), t2[1].mul(e5[1]), n6, s5);
      const i2 = new ei();
      k2(2, t2[1].mul(e5[1]), t2[2].mul(e5[2]), n6, i2);
      const r = new ei();
      return k2(2, s5, i2, n6, r), r;
    }
  }
  if (1 === s4) {
    const s5 = t2[1].mul(e5[1]), i2 = s5.sub(t2[0].mul(e5[0])).mul(1 - n6).add(t2[2].mul(e5[2]).sub(s5).mul(n6));
    return i2.mulThis(2), i2;
  }
  if (2 === s4) {
    const s5 = t2[1].mul(e5[1]), n7 = t2[2].mul(e5[2]).sub(s5).sub(s5.sub(t2[0].mul(e5[0])));
    return n7.mulThis(2), n7;
  }
  b("");
}
function ni(t2, e5, s4, n6) {
  if (n6.toDouble() <= 0.5) {
    const s5 = new Se();
    O(2, t2[0].mulE(e5[0]), t2[1].mulE(e5[1]), n6, s5);
    const i2 = new Se();
    O(2, t2[1].mulE(e5[1]), t2[2].mulE(e5[2]), n6, i2);
    const r = new Se();
    return O(2, s5, i2, n6, r), r;
  }
  {
    const s5 = new Se();
    G2(2, t2[0].mulE(e5[0]), t2[1].mulE(e5[1]), n6, s5);
    const i2 = new Se();
    G2(2, t2[1].mulE(e5[1]), t2[2].mulE(e5[2]), n6, i2);
    const r = new Se();
    return G2(2, s5, i2, n6, r), r;
  }
}
function ii2(t2, e5, s4) {
  if (0 === e5) {
    const e6 = Q(t2[0], t2[1], s4), n6 = Q(t2[1], t2[2], s4);
    return Q(e6, n6, s4);
  }
  if (1 === e5) {
    return 2 * ((1 - s4) * (t2[1] - t2[0]) + (t2[2] - t2[1]) * s4);
  }
  if (2 === e5) {
    return 2 * (t2[2] - t2[1] - (t2[1] - t2[0]));
  }
  b("");
}
function ri(t2, e5, s4) {
  if (s4.toDouble() <= 0.5) {
    const e6 = A2(t2[0], t2[1], s4), n6 = A2(t2[1], t2[2], s4);
    return A2(e6, n6, s4);
  }
  {
    const e6 = P2(t2[0], t2[1], s4), n6 = P2(t2[1], t2[2], s4);
    return P2(e6, n6, s4);
  }
}
function oi(t2, e5, s4, n6, i2) {
  const r = [Se.constructPoint2D(t2[0]), Se.constructPoint2D(t2[1]), Se.constructPoint2D(t2[2])];
  r[2].subThisE(r[0]), r[1].subThisE(r[0]), r[0].setCoords(0, 0);
  ai(r, [new p2(e5[0]), new p2(e5[1]), new p2(e5[2])], s4, n6, i2);
}
function ai(t2, e5, n6, i2, r) {
  n2(n6 > 0);
  const o2 = [t2[0].clone(), t2[1].clone(), t2[2].clone()];
  if (!o2[0].isZero()) {
    for (let t3 = 1; t3 < 3; ++t3) o2[t3].subThisE(o2[0]);
    o2[0] = Se.constructCoords(0, 0);
  }
  const a2 = ni(o2, e5, 0, i2), h2 = ri(e5, 0, i2), m2 = a2.divE(h2);
  r[0].setE(m2);
  const u = [e5[1].mulE(e5[0]), e5[2].mulE(e5[0]).mul(0.5), e5[1].mulE(e5[2])], l2 = ni([t2[1].subE(t2[0]), t2[2].subE(t2[0]), t2[2].subE(t2[1])], u, 0, i2).mul(2), c = h2.sqr(), g2 = l2.divE(c);
  r[1].setE(g2);
}
function hi(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6);
  const i2 = Lt(3, Number.NaN);
  t2.queryWeights(i2), mi(n6, i2, e5, s4);
}
function mi(t2, e5, s4, n6) {
  s4.value() < 0 && s4.set(0, s4.eps()), s4.value() > 1 && s4.set(1, s4.eps());
  const i2 = Rt(Se, 4);
  oi(t2, e5, 1, s4, i2), n6.setE(i2[1]);
}
function ui(t2, e5, s4) {
  const n6 = ks(s4, 0, 1), i2 = Rt(ei, 4);
  if (ti2(t2, e5, 3, n6, i2), i2[1].isZero()) {
    if (i2[2].isZero()) return i2[3];
    {
      const t3 = i2[2].clone();
      return 1 === n6 && t3.negateThis(), t3;
    }
  }
  return i2[1];
}
var li = class {
  constructor(t2, e5) {
    this.len = 0, this.b = t2, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t2, e5) {
    return 0 === t2 ? this.len - Kn(this.b, e5, false) : 0;
  }
  getError(t2) {
    return n2(0), 0;
  }
};
function ci(t2, e5, s4) {
  const n6 = Kn(t2, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== Xs2(new li(t2, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function gi(t2) {
  const e5 = Rt(ei, 3), s4 = [0, 0, 0];
  return t2.queryControlPoints(e5), t2.queryWeights(s4), di(e5, s4);
}
function di(t2, e5) {
  const n6 = tr(e5);
  if (1 === n6) {
    return br(t2);
  }
  if (0 === n6) return 0;
  const i2 = [new ei(0, 0), t2[1].sub(t2[0]), t2[2].sub(t2[0])], r = i2[1].crossProduct(i2[2]);
  if (n6 < 1) {
    n2(n6 > 0);
    const t3 = 1 - n6;
    let e6;
    if (t3 < 0.01) e6 = -1 / 3 + t3 * (2 / 15 + t3 * (3 / 35 + t3 * (16 / 315 + t3 * (20 / 693 + t3 * (16 / 1001 + t3 * (56 / 6435))))));
    else {
      const s4 = t3 * (1 + n6), i3 = Math.atan2(Math.sqrt(t3), Math.sqrt(1 + n6));
      e6 = n6 * (0.5 * n6 - W(s4) * i3) / s4;
    }
    return r * e6;
  }
  {
    const t3 = (n6 - 1) * (n6 + 1);
    return 0.25 * n6 / Math.pow(t3, 1.5) * (-2 * n6 * Math.sqrt(t3) * r - 4 * i2[1].y * i2[2].x * Math.atanh(Math.sqrt((n6 - 1) / (n6 + 1))) - i2[1].x * i2[2].y * Math.log(2 * n6 * (n6 - Math.sqrt(t3)) - 1));
  }
}
function _i(t2, e5) {
  const n6 = tr(e5);
  if (1 === n6) {
    const e6 = Rt(ei, 3);
    Zr(t2, e6);
    const s4 = e6[2].clone(), n7 = e6[1].clone(), i3 = new ei(), r2 = s4.y * n7.x - s4.x * n7.y;
    return i3.x = -(4 * s4.x + 5 * n7.x) * r2 / 60, i3.y = -(4 * s4.y + 5 * n7.y) * r2 / 60, i3;
  }
  if (0 === n6) return new ei(0, 0);
  n2(n6 > 0);
  const i2 = t2[1].sub(t2[0]), r = t2[2].sub(t2[0]);
  if (n6 < 1) {
    const t3 = Math.sqrt(1 - n6), e6 = Math.sqrt(1 + n6), s4 = (i2.y * r.x - i2.x * r.y) * n6 / Math.pow(t3 * e6, 5) / 12, o2 = Math.atan2(t3, e6), a2 = n6 * t3 * e6, h2 = n6 * n6, m2 = i2.mul(2 * (2 + h2)), u = r.mul(2 * h2 - 5), l2 = m2.add(u).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o2);
    return l2.add(c).mul(s4);
  }
  {
    const t3 = Math.sqrt(n6 - 1), e6 = Math.sqrt(n6 + 1), s4 = (i2.y * r.x - i2.x * r.y) * n6 / Math.pow(t3 * e6, 5) / 12, o2 = Math.atanh(t3 / e6), a2 = n6 * t3 * e6, h2 = n6 * n6, m2 = i2.mul(4).sub(r.mul(5)), u = i2.add(r).mul(2 * h2), l2 = m2.add(u).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o2);
    return l2.add(c).mul(s4);
  }
}
function pi(t2) {
  const e5 = Rt(ei, 3), s4 = [0, 0, 0];
  return t2.queryControlPoints(e5), t2.queryWeights(s4), _i(e5, s4);
}
function fi(t2) {
  return Pi(t2.calculateUpperLength2D());
}
function Pi(t2) {
  return 256 * Ss() * t2;
}
function yi(t2) {
  if (0 === t2.m_weights[1]) return true;
  const e5 = ei.distance(t2.getStartXY(), t2.getEndXY()), s4 = t2.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function xi(t2) {
  return t2.m_cachedValues;
}
function Ci(t2, e5) {
  t2.m_cachedValues = e5;
}
function vi(t2, e5, s4, n6, i2) {
  const r = Rt(ei, 3);
  t2.queryControlPoints(r);
  const o2 = [0, 0, 0];
  t2.queryWeights(o2);
  const a2 = [0];
  return 1 === bi(r, o2, e5, x2.unit(), n6, i2, 1, a2) ? a2[0] : Number.NaN;
}
function bi(t2, e5, n6, i2, r, o2, a2, h2) {
  D(x2.unit().contains(i2) && a2 > 0, ""), (o2 < 0 || Number.isNaN(o2)) && (o2 = Number.MAX_VALUE);
  const m2 = new Array(3);
  for (let s4 = 0; s4 < 3; ++s4) m2[s4] = t2[s4].sub(n6);
  const u = tr(e5), c = an.constructPoint2D(m2[0]), g2 = an.constructPoint2D(m2[1]), d2 = an.constructPoint2D(m2[2]), _ = Hs.constructDouble(u), p3 = _.clone();
  p3.ldexpThis(1);
  const f3 = c.dotProduct(g2.sub(c)).mul(_), P5 = _.mul(_.addDouble(2)), y2 = d2.sub(g2.mul(P5.ldexp(1))), x4 = g2.sqrLength().mul(_.mul(_).ldexp(1)).add(c.sqrLength().mul(_.ldexp(2).subDouble(1))).add(c.dotProduct(y2)), C2 = d2.sub(g2.mul(p3)).add(c.mul(p3.subDouble(1))), v3 = g2.mul(_).sub(c).dotProduct(C2).mulDouble(3), b2 = g2.dotProduct(d2).mul(_.subDouble(3).mul(_)).ldexp(1), E2 = g2.sqrLength().mul(_.mul(_).ldexp(2)), S3 = c.sqrLength().mul(_.ldexp(2).subDouble(3)), D3 = c.dotProduct(d2.sub(g2.mul(_.mulDouble(3).subDouble(1)).mul(_))).ldexp(1), w4 = d2.sqrLength().addThis(b2).addThis(E2).addThis(S3).addThis(D3), A4 = c.add(d2).sub(g2.mul(p3)), T3 = _.subDouble(1), I5 = d2.sub(c).dotProduct(A4).mul(T3), M2 = new ei(0, 0), Y3 = [];
  let X4 = new ei();
  Ki(m2, e5, i2.vmin, X4);
  let N2 = ei.distance(X4, M2);
  if (N2 <= o2 && Y3.push(new ei(i2.vmin, N2)), i2.vmin !== i2.vmax && (Ki(m2, e5, i2.vmax, X4), N2 = ei.distance(X4, M2), N2 <= o2 && Y3.push(new ei(i2.vmax, N2))), i2.width() > 0) {
    const t3 = m2[2].isZero(), s4 = Rt(Hs, 4), n7 = yn(I5, w4, v3, x4, f3, 58, i2, t3, s4);
    for (let r2 = 0; r2 < n7; r2++) {
      if (!i2.containsExclusiveCoordinate(s4[r2].toDouble())) continue;
      let t4 = s4[r2].toDouble();
      t4 = er(e5, t4);
      const n8 = new ei();
      Ki(m2, e5, t4, n8), N2 = ei.distance(n8, M2), N2 <= o2 && Y3.push(new ei(t4, N2));
    }
  }
  if (r) {
    n2(i2.equals(x2.unit()));
    {
      Ki(m2, e5, -1, X4, true);
      const t3 = new ei();
      Ki(m2, e5, 0, t3);
      const s4 = new su({ start: X4, end: t3 }), n7 = s4.getClosestCoordinate(M2, true);
      n7 < 1 && (X4 = s4.getCoord2D(n7), N2 = ei.distance(X4, M2), N2 <= o2 && Y3.push(new ei(n7 - 1, N2)));
    }
    {
      Ki(m2, e5, 2, X4, true);
      const t3 = new ei();
      Ki(m2, e5, i2.vmax, t3);
      const s4 = new su({ start: t3, end: X4 }), n7 = s4.getClosestCoordinate(M2, true);
      n7 > 0 && (X4 = s4.getCoord2D(n7), N2 = ei.distance(X4, M2), N2 <= o2 && Y3.push(new ei(1 + n7, N2)));
    }
  }
  if (!Y3.length) return 0;
  Y3.sort((t3, e6) => t3.compare(e6));
  let q2 = 0;
  const F3 = Y3[0].x;
  if (h2[q2++] = F3, q2 < a2) {
    const t3 = Rt2(m2, 4, false).total(), e6 = Y3[0].y;
    for (let s4 = 1, n7 = Y3.length; s4 < n7; s4++) if (Y3[s4].y > e6 + t3) {
      Y3.length = s4;
      break;
    }
    Y3.sort((t4, e7) => Dt(t4.x, e7.x)), q2 = 0, h2[q2++] = Y3[0].x;
    for (let s4 = 1, n7 = Y3.length; s4 < n7; s4++) Y3[s4].x !== h2[q2 - 1] && q2 < a2 && (h2[q2++] = Y3[s4].x);
  }
  return q2;
}
function Ei(t2, e5, s4, n6, i2) {
  return { tmin: t2, tmax: e5, t: s4, d: n6, pt: i2.clone() };
}
function Si(t2, e5, n6, i2, r) {
  const o2 = new ve();
  if (Di(t2, x2.unit(), o2), o2.inflate(i2), !o2.isIntersectingPoint2D(e5)) return 0;
  const a2 = Qn(t2);
  let h2 = 0;
  const m2 = [];
  let u = a2.specialPoints[0];
  for (let l2 = 1, c = a2.specialPoints.length; l2 < c; ++l2) {
    const n7 = a2.specialPoints[l2], i3 = Zn(t2, e5, u, n7);
    if (0 === m2.length) m2.push(i3);
    else if (i3.t === i3.tmin) n2(m2.at(-1).d <= i3.d), m2.at(-1).tmax = i3.tmax;
    else if (m2.at(-1).t === m2.at(-1).tmax) {
      n2(m2.at(-1).d >= i3.d);
      const t3 = m2.at(-1).tmin;
      m2[m2.length - 1] = i3, m2.at(-1).tmin = t3;
    } else m2.push(i3);
    u = n7;
  }
  for (const s4 of m2) if (s4.d <= i2) {
    const t3 = s4.t;
    n6 ? (n6[h2] = t3, h2++) : h2++;
  }
  return h2;
}
function Di(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6);
  const i2 = [0, 0, 0];
  t2.queryWeights(i2), wi(n6, i2, e5, s4);
}
function wi(t2, e5, s4, n6) {
  if (s4.equalsRange(0, 1)) return void n6.setFromPoints(t2, 3);
  const i2 = Rt(ei, 3), r = [0, 0, 0];
  Xi(t2, e5, s4.vmin, s4.vmax, i2, r), n6.setFromPoints(i2, 3);
}
function Ai(t2) {
  const e5 = hs(t2[0].y, t2[1].y), s4 = hs(t2[1].y, t2[2].y);
  if (e5 >= 0 && s4 >= 0 || e5 <= 0 && s4 <= 0) {
    const e6 = hs(t2[0].x, t2[1].x), s5 = hs(t2[1].x, t2[2].x);
    if (e6 >= 0 && s5 >= 0 || e6 <= 0 && s5 <= 0) return true;
  }
  return false;
}
function Ti(t2) {
  const e5 = Rt(ei, 3);
  t2.queryControlPoints(e5);
  const s4 = Ii(e5);
  return s4 && (t2.m_cp.setCoordsPoint2D(e5[1]), t2.afterCompletedModification()), s4;
}
function Ii(t2) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = hs(t2[0][s4], t2[2][s4]);
    n6 > 0 ? (hs(t2[0][s4], t2[1][s4]) < 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) < 0 && (t2[1][s4] = t2[2][s4], e5 = true)) : n6 < 0 ? (hs(t2[0][s4], t2[1][s4]) > 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) > 0 && (t2[1][s4] = t2[2][s4], e5 = true)) : t2[1][s4] !== t2[0][s4] && (t2[1][s4] = t2[0][s4], e5 = true);
  }
  return e5;
}
function Mi(t2, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new ei();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weighted_centroid"), s4 === n6 || t2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = Qn(t2), o2 = fi(t2), a2 = o2 / t2.calculateUpperLength2D();
  let h2 = s4, m2 = 0;
  for (let e5 = 1, u = r.specialPointsCount(); e5 < u; e5++) if (s4 < r.specialPoints[e5]) {
    m2 = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = m2 + 1, u = r.specialPointsCount(); e5 < u; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), m3 = Hn(t2, h2, s5, a2, o2);
    if (i2.addThis(m3), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t2.getStartXY().mul(t2.calculateLength2D()));
}
function Yi(t2, e5, n6, i2, r, o2, a2) {
  n2(n6 >= 0 && n6 <= 1 && i2 !== o2 && r !== a2), n2(e5[0] > 0 && e5[2] > 0 && e5[1] >= 0);
  const h2 = [1, tr(e5), 1], m2 = sr(e5, n6), u = St(t2, 3), l2 = Rt(X2, 3);
  Hi(u, h2, l2);
  const c = Rt(X2, 3), g2 = Rt(X2, 3);
  nr(l2, m2, i2 ? c : null, o2 ? g2 : null), ir(e5, n6, r, a2);
  const d2 = Ai(u);
  if (i2) {
    for (let t3 = 0; t3 < 3; ++t3) Ji(c[t3], i2[t3]);
    or(u, i2), d2 && Ii(i2);
  }
  if (o2) {
    for (let t3 = 0; t3 < 3; ++t3) Ji(g2[t3], o2[t3]);
    or(u, o2), d2 && Ii(o2);
  }
}
function Xi(t2, e5, n6, i2, r, o2) {
  if (n2(n6 >= 0 && i2 <= 1 && n6 <= i2), n6 === i2) {
    const s4 = new ei(), i3 = Ui(t2, e5, n6, s4);
    return rr(t2, s4), r[0].assign(s4), r[1].assign(s4), r[2].assign(s4), o2[0] = i3, o2[1] = i3, void (o2[2] = i3);
  }
  if (0 === n6 && 1 === i2) return r[0].assign(t2[0]), r[1].assign(t2[1]), r[2].assign(t2[2]), o2[0] = e5[0], o2[1] = e5[1], void (o2[2] = e5[2]);
  const a2 = Rt(X2, 3);
  {
    const s4 = [1, tr(e5), 1], r2 = sr(e5, n6), o3 = sr(e5, i2);
    Hi(t2, s4, a2), nr(a2, o3, a2, null);
    nr(a2, r2 >= o3 ? 1 : r2 / o3, null, a2);
  }
  const h2 = [0, 0, 0];
  ir(e5, i2, h2, null), ir(h2, n6 / i2, null, h2);
  const m2 = Ai(t2), u = Rt(ei, 3);
  Ji(a2[1], u[1]), Ki(t2, e5, n6, u[0]), Ki(t2, e5, i2, u[2]), or(t2, u);
  for (let s4 = 0; s4 < 3; ++s4) r[s4].assign(u[s4]), o2[s4] = h2[s4];
  m2 && Ii(r);
}
function Ni(t2, e5, s4) {
  const n6 = tr(e5), i2 = [1, n6, 1], r = 4 * n6 / (3 * (1 + n6));
  s4[0].assign(t2[0]), s4[3].assign(t2[2]), Y(t2[0], t2[1], r, s4[1]), Y(t2[2], t2[1], r, s4[2]), new mo({ cp: s4 }), new on({ points: t2, weight: n6 });
  let o2 = 0, a2 = 0.1, h2 = 0;
  for (let m2 = 0; m2 < 9; m2++, a2 += 0.1) {
    const e6 = new ei();
    Ki(t2, i2, a2, e6);
    const n7 = new ei();
    jo(s4, a2, n7);
    const r2 = ei.sqrDistance(e6, n7);
    r2 > o2 && (o2 = r2, h2 = a2);
  }
  {
    const e6 = new ei();
    Ki(t2, i2, h2, e6);
    const n7 = [0];
    la(s4, e6, x2.unit(), false, -1, 1, n7);
    const r2 = new ei();
    return jo(s4, n7[0], r2), o2 = ei.sqrDistance(e6, r2), Math.sqrt(o2);
  }
}
function qi(t2, e5, s4, n6) {
  if (e5.isEqual(t2.m_XStart, t2.m_YStart) && s4.isEqual(t2.m_XEnd, t2.m_YEnd)) return;
  const i2 = !!n6 && t2.isMonotoneQuickAndDirty(), r = new x3(), o2 = Rt(ei, 3);
  o2[0].setCoords(t2.m_XStart, t2.m_YStart), o2[2].setCoords(t2.m_XEnd, t2.m_YEnd);
  const a2 = new ei();
  a2.setSub(o2[2], o2[0]), a2.leftPerpendicularThis(), o2[1].setAdd(o2[0], a2);
  const h2 = Rt(ei, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o2, h2) ? r.transformInPlace(t2.m_cp) : Y(e5, s4, 0.5, t2.m_cp), t2.changeEndPoints2D(e5, s4), i2 && Ti(t2);
}
function Fi(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== ki(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Vi(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== Bi(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function Li(t2, e5) {
  const s4 = t2.getEndXY().sub(t2.getStartXY()), n6 = s4.length(), i2 = t2.getControlPoint1();
  i2.subThis(t2.getStartXY());
  return !(Math.abs(i2.crossProduct(s4)) / n6 > e5);
}
function Ri(t2, e5, s4, n6, i2) {
  if (i2) {
    const n7 = Hm(e5, s4);
    if (0 !== n7) {
      if (t2) {
        if (1 === n7) {
          if (e5.m_weights[0] === s4.m_weights[0] && e5.m_weights[1] === s4.m_weights[1] && e5.m_weights[2] === s4.m_weights[2]) return 2;
        } else if (e5.m_weights[0] === s4.m_weights[2] && e5.m_weights[1] === s4.m_weights[1] && e5.m_weights[2] === s4.m_weights[0]) return 2;
        return 4;
      }
      return 2;
    }
  } else if (Ae(e5, s4)) return 1;
  return 0 !== Gi(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function zi(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== Wi(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function ki(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  if (null !== r && (r.length = 0), null !== o2 && (o2.length = 0), null !== i2 && (i2.length = 0), n6.isDegenerate(0)) {
    const t3 = [0, 0], s4 = e5.intersectPoint(n6.getStartXY(), t3, a2);
    if (s4 > 0) {
      if (null !== r) for (let e6 = 0; e6 < s4; e6++) r.push(t3[e6]);
      if (null != o2) for (let t4 = 0; t4 < s4; t4++) o2.push(0);
      if (null != i2) for (let n7 = 0; n7 < s4; n7++) {
        const s5 = new ei();
        e5.queryCoord2D(t3[n7], s5), i2.push(s5);
      }
    }
    return s4;
  }
  const l2 = Oe(e5, n6);
  if (a2 = Math.max(a2, l2), e5.isDegenerateToLineHelper(l2)) {
    const t3 = new su({ start: e5.getStartXY(), end: e5.getEndXY() }), s4 = ps(t3, n6, i2, r, o2, a2, h2, u);
    if (r) for (let n7 = 0; n7 < s4; ++n7) {
      const s5 = t3.getCoord2D(r[n7]);
      r[n7] = e5.getClosestCoordinate(s5, false);
    }
    return s4;
  }
  if (Qe(e5, n6, a2)) return 0;
  const c = Rt(ei, 3);
  e5.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e5.queryWeights(g2);
  const d2 = [1, tr(g2), 1], _ = n6.getEndXY().sub(n6.getStartXY()), p3 = _.clone();
  p3.leftPerpendicularThis();
  const f3 = c[0].clone(), P5 = c[1].clone(), y2 = c[2].clone(), x4 = P5.sub(f3), C2 = y2.sub(f3), v3 = y2.sub(P5), b2 = d2[0], E2 = d2[1], S3 = d2[2], D3 = b2 * E2, w4 = b2 * S3, A4 = E2 * S3, T3 = x4.dotProduct(p3) * D3, I5 = C2.dotProduct(p3) * w4;
  let M2 = T3, Y3 = I5 - 2 * T3, X4 = v3.dotProduct(p3) * A4 + I5 - I5;
  const N2 = Lt(13, Number.NaN), q2 = Lt(13, Number.NaN);
  let F3 = qs2(X4, Y3, M2, x2.unit(), false, N2);
  F3 < 0 && (N2[0] = 0, N2[1] = 1, F3 = 2);
  let V4 = 0;
  for (let s4 = 0, B4 = V4; s4 < F3; ++s4) {
    const t3 = new ei();
    Ki(c, d2, N2[s4 + B4], t3), q2[V4] = n6.getClosestCoordinate(t3, false);
    ei.distance(t3, n6.getCoord2D(q2[V4])) <= a2 && (N2[V4] = N2[s4 + B4], V4++);
  }
  const L4 = Rt(ei, 3), R4 = Rt(ei, 3);
  if (e5.queryControlPoints(R4), R4[0].subThis(n6.getStartXY()), R4[1].subThis(n6.getStartXY()), R4[2].subThis(n6.getStartXY()), ji(R4, d2, L4, false), Math.abs(_.x) >= Math.abs(_.y)) {
    const t3 = _.y / _.x;
    X4 = L4[2].y - L4[2].x * t3, Y3 = L4[1].y - L4[1].x * t3, M2 = L4[0].y - L4[0].x * t3;
  } else {
    const t3 = _.x / _.y;
    X4 = L4[2].x - L4[2].y * t3, Y3 = L4[1].x - L4[1].y * t3, M2 = L4[0].x - L4[0].y * t3;
  }
  const z4 = e5.getEndXY().equals(n6.getStartXY()) || e5.getEndXY().equals(n6.getEndXY()), k4 = [0, 0];
  F3 = qs2(X4, Y3, M2, x2.unit(), z4, k4);
  for (let s4 = 0, B4 = V4; s4 < F3; ++s4) {
    N2[s4 + B4] = k4[s4];
    const t3 = new ei();
    Ki(c, d2, N2[s4 + B4], t3), q2[V4] = n6.getClosestCoordinate(t3, false);
    ei.distance(t3, n6.getCoord2D(q2[V4])) <= a2 && (N2[V4] = N2[s4 + B4], V4++);
  }
  n2(V4 < N2.length + 4);
  for (let s4 = 0; s4 < V4; s4++) N2[s4] = er(g2, N2[s4]);
  F3 = e5.intersectPoint(n6.getStartXY(), k4, a2);
  for (let s4 = 0; s4 < F3; s4++) N2[V4] = k4[s4], q2[V4++] = 0;
  F3 = e5.intersectPoint(n6.getEndXY(), k4, a2);
  for (let s4 = 0; s4 < F3; s4++) N2[V4] = k4[s4], q2[V4++] = 1;
  F3 = n6.intersectPoint(e5.getStartXY(), k4, a2);
  for (let s4 = 0; s4 < F3; s4++) q2[V4] = k4[s4], N2[V4++] = 0;
  F3 = n6.intersectPoint(e5.getEndXY(), k4, a2);
  for (let s4 = 0; s4 < F3; s4++) q2[V4] = k4[s4], N2[V4++] = 1;
  return 0 === V4 ? 0 : Km(t2, e5, n6, N2, q2, V4, i2, r, o2, a2, h2, m2, u);
}
function Bi(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  if (zh(s4)) {
    return ki(t2, e5, new su({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o2, a2, h2, m2);
  }
  const u = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, u))) return 0;
  const l2 = [], c = [], g2 = Rt(ei, 4);
  {
    e5.queryControlPoints(g2);
    const t3 = Rt(ei, 4), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(g2, 4, t3);
    const r2 = Rt(Hs, 3), a3 = Rt(Hs, 3), h3 = Rt(Hs, 3), m3 = [0, 0, 0];
    e5.queryWeights(m3), Zi(t3, m3, r2, a3, h3);
    const u2 = Rt(Hs, 3);
    u2[0].setDouble(s4.getSemiMinorAxis()), u2[0].sqrThis(), u2[1].setDouble(s4.getSemiMajorAxis()), u2[1].sqrThis(), u2[2].setThis(u2[0]), u2[2].mulThis(u2[1]), u2[2].negateThis();
    const d3 = _n(r2, 2, a3, 2, h3, 2, u2, true, x2.unit(), x2.unit(), l2);
    if (d3 > 0) {
      let t4 = 0;
      for (let n8 = 0; n8 < d3; n8++) {
        const i4 = new ei();
        e5.queryCoord2D(l2[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a4 = new ei();
        s4.queryCoord2D(r3, a4);
        ei.distance(i4, a4) <= o2 && (l2[t4] = l2[n8], c.push(r3), t4++);
      }
      l2.length = t4;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t3 = 0 === _ ? s4.getStartXY() : s4.getEndXY(), n7 = vi(e5, t3, x2.unit(), false, -1), i3 = new ei();
    e5.queryCoord2D(n7, i3);
    ei.distance(t3, i3) <= o2 && (l2.push(n7), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t3 = [0, 3];
    {
      const e6 = s4.getClosestCoordinate(g2[t3[_]], false), n7 = new ei();
      s4.queryCoord2D(e6, n7);
      ei.distance(g2[t3[_]], n7) <= o2 && (l2.push(d2[_]), c.push(e6));
    }
  }
  return Km(t2, e5, s4, l2, c, l2.length, n6, i2, r, o2, a2, h2, m2);
}
function Gi(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  const l2 = Rt(ei, 3);
  e5.queryControlPoints(l2);
  const c = Rt(ei, 3);
  if (n6.queryControlPoints(c), Je(l2, c, 3) < 0) return Gi(t2, n6, e5, i2, o2, r, a2, h2, m2, !u);
  const g2 = Oe(e5, n6);
  if (e5.isDegenerateToLineHelper(g2)) {
    const s4 = new su({ start: e5.getStartXY(), end: e5.getEndXY() }), l3 = ki(t2, n6, s4, i2, o2, r, a2, h2, m2, !u);
    if (r) for (let t3 = 0; t3 < l3; ++t3) {
      const n7 = s4.getCoord2D(r[t3]);
      r[t3] = e5.getClosestCoordinate(n7, false);
    }
    return l3;
  }
  if (n6.isDegenerateToLineHelper(g2)) {
    const s4 = new su({ start: n6.getStartXY(), end: n6.getEndXY() }), l3 = ki(t2, e5, s4, i2, r, o2, a2, h2, m2, u);
    if (o2) for (let t3 = 0; t3 < l3; ++t3) {
      const e6 = s4.getCoord2D(o2[t3]);
      o2[t3] = n6.getClosestCoordinate(e6, false);
    }
    return l3;
  }
  if (Qe(e5, n6, a2 = Math.max(a2, g2))) return 0;
  const d2 = Lt(3, Number.NaN);
  e5.queryWeights(d2);
  const _ = Lt(3, Number.NaN);
  n6.queryWeights(_);
  const p3 = [1, tr(d2), 1], f3 = [1, tr(_), 1], P5 = new x2(0, 1), y2 = new x2(0, 1);
  {
    const t3 = ve.constructEmpty();
    wi(l2, p3, new x2(0, 1), t3);
    const e6 = ve.constructEmpty();
    wi(c, f3, new x2(0, 1), e6);
    const s4 = Math.max(t3.maxDim(), e6.maxDim());
    if (t3.inflate(3 * a2), e6.inflate(3 * a2), !t3.intersectW(e6)) return 0;
    if (t3.maxDim() < 0.1 * s4) {
      if ($i(l2, p3, t3, P5), $i(c, f3, t3, y2), P5.isEmpty() || y2.isEmpty()) return 0;
      Xi(l2, p3, P5.vmin, P5.vmax, l2, p3), Xi(c, f3, y2.vmin, y2.vmax, c, f3);
    }
  }
  const x4 = tu(l2, 2, c, 2, a2);
  if (0 === x4) return 0;
  const C2 = [], v3 = [];
  if (-1 === x4) {
    const t3 = Rt(Hs, 3), e6 = Rt(Hs, 3), s4 = Rt(Hs, 3);
    Zi(l2, p3, t3, e6, s4);
    const n7 = Rt(Hs, 3), i3 = Rt(Hs, 3), r2 = Rt(Hs, 3);
    Zi(c, f3, n7, i3, r2);
    const o3 = [], h3 = [], m3 = cn(t3, 2, e6, 2, s4, 2, n7, 2, i3, 2, r2, 2, true, x2.unit(), x2.unit(), o3, h3);
    if (m3 > 0) for (let u2 = 0; u2 < m3; u2++) {
      const t4 = new ei();
      Ki(c, f3, h3[u2], t4);
      const e7 = new ei();
      Ki(l2, p3, o3[u2], e7);
      ei.distance(e7, t4) <= a2 && (C2.push(o3[u2]), v3.push(h3[u2]));
    }
  }
  for (let b2 = 0; b2 < 2; b2++) {
    let t3, e6, n7;
    0 === b2 ? (t3 = l2, e6 = c, n7 = f3) : (t3 = c, e6 = l2, n7 = p3);
    for (let i3 = 0; i3 < 2; i3++) {
      const r2 = 0 === i3 ? 0 : t3.length - 1, o3 = new ei(), h3 = [0], m3 = bi(e6, n7, t3[r2], x2.unit(), false, -1, 1, h3);
      n2(1 === m3), Ki(e6, n7, h3[0], o3), ei.distance(t3[r2], o3) <= a2 && (0 === b2 ? (C2.push(0 === r2 ? 0 : 1), v3.push(h3[0])) : (v3.push(0 === r2 ? 0 : 1), C2.push(h3[0])));
    }
  }
  if (0 === C2.length) return 0;
  if (!P5.equalsRange(0, 1)) for (let s4 = 0; s4 < C2.length; ++s4) C2[s4] = on.recalculateParentT(P5.vmin, P5.vmax, C2[s4]);
  if (!y2.equalsRange(0, 1)) for (let s4 = 0; s4 < v3.length; ++s4) v3[s4] = on.recalculateParentT(y2.vmin, y2.vmax, v3[s4]);
  for (let s4 = 0; s4 < C2.length; ++s4) C2[s4] = er(d2, C2[s4]);
  for (let s4 = 0; s4 < v3.length; ++s4) v3[s4] = er(_, v3[s4]);
  return Km(t2, e5, n6, C2, v3, C2.length, i2, r, o2, a2, h2, m2, u);
}
function Wi(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  if (e5.isLine()) {
    return Gr(t2, s4, new su({ start: e5.getStartXY(), end: e5.getEndXY() }), n6, r, i2, o2, a2, h2, !m2);
  }
  if (s4.isLine()) {
    return ki(t2, e5, new su({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o2, a2, h2, m2);
  }
  const u = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, u))) return 0;
  const l2 = Rt(ei, 3);
  e5.queryControlPoints(l2);
  const c = Rt(ei, 3);
  s4.queryControlPoints(c);
  const g2 = tu(l2, 2, c, 2, o2);
  if (0 === g2) return 0;
  const d2 = [], _ = [];
  if (-1 === g2) {
    const t3 = Rt(Hs, 3), n7 = Rt(Hs, 3), i3 = Rt(Hs, 3), r2 = [0, 0, 0];
    e5.queryWeights(r2), Zi(l2, r2, t3, n7, i3);
    const a3 = Rt(an, 3);
    Qr(c, a3);
    const h3 = cn(t3, 2, n7, 2, i3, 2, [a3[0].x, a3[1].x, a3[2].x], 2, [a3[0].y, a3[1].y, a3[2].y], 2, null, 0, true, x2.unit(), x2.unit(), d2, _);
    if (h3 > 0) {
      let t4 = 0;
      for (let n8 = 0; n8 < h3; n8++) {
        const i4 = new ei();
        s4.queryCoord2D(_[n8], i4);
        const r3 = new ei();
        e5.queryCoord2D(d2[n8], r3), ei.distance(r3, i4) <= o2 && (d2[t4] = d2[n8], _[t4] = _[n8], t4++);
      }
      d2.length = t4, _.length = t4;
    }
  }
  for (let p3 = 0; p3 < 2; p3++) {
    let t3;
    t3 = 0 === p3 ? l2 : c;
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t3.length - 1;
      let r2;
      const a3 = new ei();
      0 === p3 ? (r2 = wr(s4, t3[i3], x2.unit(), false), s4.queryCoord2D(r2, a3)) : (r2 = vi(e5, t3[i3], x2.unit(), false, -1), e5.queryCoord2D(r2, a3)), ei.distance(t3[i3], a3) <= o2 && (0 === p3 ? (d2.push(0 === i3 ? 0 : 1), _.push(r2)) : (_.push(0 === i3 ? 0 : 1), d2.push(r2)));
    }
  }
  return Km(t2, e5, s4, d2, _, d2.length, n6, i2, r, o2, a2, h2, m2);
}
function ji(t2, e5, s4, n6 = false) {
  const i2 = Rt(ei, 3);
  n6 ? (i2[0].setCoordsPoint2D(t2[0]), i2[1].setCoordsPoint2D(t2[1]), i2[1].subThis(i2[0]), i2[2].setCoordsPoint2D(t2[2]), i2[2].subThis(i2[0]), i2[0].setCoords(0, 0)) : (i2[0].setCoordsPoint2D(t2[0]), i2[1].setCoordsPoint2D(t2[1]), i2[2].setCoordsPoint2D(t2[2])), i2[0].mulThis(e5[0]), i2[1].mulThis(e5[1]), i2[2].mulThis(e5[2]), s4[1].setCoords(i2[1].x - i2[0].x, i2[1].y - i2[0].y), s4[2].setCoordsPoint2D(i2[2].sub(i2[1])), s4[2].subThis(s4[1]), s4[1].x *= 2, s4[1].y *= 2, s4[0].setCoordsPoint2D(i2[0]);
}
function Zi(t2, e5, s4, n6, i2) {
  const r = Hs.constructDouble(e5[0]), o2 = Hs.constructDouble(e5[1]), a2 = Hs.constructDouble(e5[2]);
  s4[0].setDouble(t2[0].x), s4[0].mulThis(r), s4[1].setDouble(t2[1].x), s4[1].mulThis(o2), s4[2].setDouble(t2[2].x), s4[2].mulThis(a2), s4[2].subThis(s4[1]), s4[1].subThis(s4[0]), s4[2].subThis(s4[1]), s4[1].ldexpThis(1), n6[0].setDouble(t2[0].y), n6[0].mulThis(r), n6[1].setDouble(t2[1].y), n6[1].mulThis(o2), n6[2].setDouble(t2[2].y), n6[2].mulThis(a2), n6[2].subThis(n6[1]), n6[1].subThis(n6[0]), n6[2].subThis(n6[1]), n6[1].ldexpThis(1), i2[0].setDouble(e5[0]), i2[1].setDouble(e5[1]), i2[2].setThis(i2[1]), i2[2].ldexpThis(1), i2[2].negateThis(), i2[2].addThis(i2[0]), i2[2].addDoubleThis(e5[2]), i2[1].subThis(i2[0]), i2[1].ldexpThis(1);
}
function Hi(t2, e5, s4) {
  for (let n6 = 0; n6 < 3; ++n6) s4[n6].setCoordsPoint2DZ(t2[n6].mul(e5[n6]), e5[n6]);
}
function Ui(t2, e5, s4, n6) {
  if (0 === s4) return n6.assign(t2[0]), e5[0];
  if (1 === s4) return n6.assign(t2[2]), e5[2];
  const i2 = [t2[0].x * e5[0], t2[1].x * e5[1], t2[2].x * e5[2]], r = [t2[0].y * e5[0], t2[1].y * e5[1], t2[2].y * e5[2]], o2 = [e5[0], e5[1], e5[2]], a2 = s4;
  let h2, m2, u;
  if (s4 <= 0.5) {
    const t3 = V(i2[0], i2[1], a2), e6 = V(i2[1], i2[2], a2);
    h2 = Q(t3, e6, a2);
    const s5 = V(r[0], r[1], a2), n7 = V(r[1], r[2], a2);
    m2 = Q(s5, n7, a2);
    const l2 = V(o2[0], o2[1], a2), c = V(o2[1], o2[2], a2);
    u = V(l2, c, a2);
  } else {
    const t3 = U2(i2[0], i2[1], a2), e6 = U2(i2[1], i2[2], a2);
    h2 = U2(t3, e6, a2);
    const s5 = U2(r[0], r[1], a2), n7 = U2(r[1], r[2], a2);
    m2 = U2(s5, n7, a2);
    const l2 = U2(o2[0], o2[1], a2), c = U2(o2[1], o2[2], a2);
    u = U2(l2, c, a2);
  }
  return h2 /= u, m2 /= u, n6.setCoords(h2, m2), rr(t2, n6), u;
}
function Oi(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6);
  const i2 = [0, 0, 0];
  t2.queryWeights(i2);
  Qi([Se.constructPoint2D(n6[0]), Se.constructPoint2D(n6[1]), Se.constructPoint2D(n6[2])], [new p2(i2[0]), new p2(i2[1]), new p2(i2[2])], e5, s4);
}
function Qi(t2, e5, s4, n6) {
  if (0 === s4.value()) return void n6.setE(t2[0]);
  if (1 === s4.value()) return void n6.setE(t2[2]);
  const i2 = [t2[0].x.mulE(e5[0]), t2[1].x.mulE(e5[1]), t2[2].x.mulE(e5[2])], r = [t2[0].y.mulE(e5[0]), t2[1].y.mulE(e5[1]), t2[2].y.mulE(e5[2])], o2 = [e5[0].clone(), e5[1].clone(), e5[2].clone()], a2 = new p2(), h2 = new p2(), m2 = new p2();
  if (s4.value() <= 0.5) {
    const t3 = A2(i2[0], i2[1], s4), e6 = A2(i2[1], i2[2], s4);
    a2.setE(A2(t3, e6, s4));
    const n7 = A2(r[0], r[1], s4), u2 = A2(r[1], r[2], s4);
    h2.setE(A2(n7, u2, s4));
    const l2 = A2(o2[0], o2[1], s4), c = A2(o2[1], o2[2], s4);
    m2.setE(A2(l2, c, s4));
  } else {
    const t3 = P2(i2[0], i2[1], s4), e6 = P2(i2[1], i2[2], s4);
    a2.setE(P2(t3, e6, s4));
    const n7 = P2(r[0], r[1], s4), u2 = P2(r[1], r[2], s4);
    h2.setE(P2(n7, u2, s4));
    const l2 = P2(o2[0], o2[1], s4), c = P2(o2[1], o2[2], s4);
    m2.setE(P2(l2, c, s4));
  }
  a2.divThisE(m2), h2.divThisE(m2);
  const u = new ei(a2.value(), h2.value());
  rr([t2[0].value(), t2[1].value(), t2[2].value()], u), n6.x.set(u.x, a2.eps()), n6.y.set(u.y, h2.eps());
}
function Ji(t2, e5) {
  return e5.setCoords(t2.x / t2.z, t2.y / t2.z), t2.z;
}
function Ki(t2, e5, s4, n6, i2) {
  if (i2) {
    if (s4 < 0) {
      return void rs2(new su({ start: t2[0], end: t2[0].add(ui(t2, e5, 0).getUnitVector()) }), s4, n6);
    }
    if (s4 > 1) {
      return void rs2(new su({ start: t2[2], end: t2[2].add(ui(t2, e5, 1).getUnitVector()) }), s4 - 1, n6);
    }
  }
  Ui(t2, e5, s4, n6);
}
function $i(t2, e5, s4, n6) {
  n6.setEmpty();
  const i2 = [];
  i2.push(new x2(0, 1));
  const r = 0.5 * Math.max(s4.width(), s4.height());
  for (; i2.length; ) {
    const o2 = i2.at(-1);
    i2.pop();
    const a2 = new ve();
    if (wi(t2, e5, o2, a2), a2.isIntersectingW(s4)) {
      const t3 = Math.max(a2.width(), a2.height());
      if (s4.containsW(a2) || t3 <= r || o2.width() < 1e-12) n6.merge(o2);
      else {
        const t4 = o2.getCenter();
        i2.push(x2.construct(o2.vmin, t4)), i2.push(x2.construct(t4, o2.vmax));
      }
    }
  }
}
function tr(t2) {
  return t2[1] / Math.sqrt(t2[0] * t2[2]);
}
function er(t2, e5) {
  const s4 = Math.sqrt(t2[2] / t2[0]);
  return e5 / Q(s4, 1, e5);
}
function sr(t2, e5) {
  const s4 = Math.sqrt(t2[0] / t2[2]);
  return e5 / Q(s4, 1, e5);
}
function nr(t2, e5, n6, i2) {
  n2(e5 >= 0 && e5 <= 1);
  new X2().setCoordsPoint3D(t2[0]);
  new X2().setCoordsPoint3D(t2[1]);
  new X2().setCoordsPoint3D(t2[2]);
  const r = new X2(), o2 = new X2(), a2 = new X2();
  L2(3, t2[0], t2[1], e5, r), L2(3, t2[1], t2[2], e5, o2), L2(3, r, o2, e5, a2);
  const h2 = t2[2].clone();
  n6 && (n6[0].assign(t2[0]), n6[1].assign(r), n6[2].assign(a2)), i2 && (i2[0].assign(a2), i2[1].assign(o2), i2[2].assign(h2));
}
function ir(t2, e5, n6, i2) {
  const r = [t2[0], t2[1], t2[2]];
  n2(e5 >= 0 && e5 <= 1 && n6 !== i2);
  const o2 = Q(r[0], r[1], e5), a2 = Q(r[1], r[2], e5), h2 = Q(o2, a2, e5);
  n6 && (n6[0] = r[0], n6[1] = o2, n6[2] = h2), i2 && (i2[0] = h2, i2[1] = a2, i2[2] = r[2]);
}
function rr(t2, e5) {
  const s4 = x2.constructEmpty();
  s4.vmin = s4.vmax = t2[0].x, s4.mergeNeCoordinate(t2[1].x), s4.mergeNeCoordinate(t2[2].x), e5.x = ks(e5.x, s4.vmin, s4.vmax), s4.vmin = s4.vmax = t2[0].y, s4.mergeNeCoordinate(t2[1].y), s4.mergeNeCoordinate(t2[2].y), e5.y = ks(e5.y, s4.vmin, s4.vmax);
}
function or(t2, e5) {
  const s4 = new x2();
  s4.vmin = s4.vmax = t2[0].x, s4.mergeNeCoordinate(t2[1].x), s4.mergeNeCoordinate(t2[2].x), e5[0].x = ks(e5[0].x, s4.vmin, s4.vmax), e5[1].x = ks(e5[1].x, s4.vmin, s4.vmax), e5[2].x = ks(e5[2].x, s4.vmin, s4.vmax), s4.vmin = s4.vmax = t2[0].y, s4.mergeNeCoordinate(t2[1].y), s4.mergeNeCoordinate(t2[2].y), e5[0].y = ks(e5[0].y, s4.vmin, s4.vmax), e5[1].y = ks(e5[1].y, s4.vmin, s4.vmax), e5[2].y = ks(e5[2].y, s4.vmin, s4.vmax);
}
var ar = class {
  constructor() {
    this.area = Number.NaN, this.centroid_x = Number.NaN, this.centroid_y = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
var hr = class {
  constructor(t2, e5) {
    this.b = t2, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t2, e5) {
    return 0 === t2 ? this.len - dr(this.b, e5, false) : 0;
  }
  getError(t2) {
    return n2(0), 0;
  }
};
function mr(t2, e5, s4, n6, i2) {
  let r = true;
  const o2 = Rt(ei, 3);
  t2.queryControlPoints(o2);
  let a2 = r ? 0 : 1, h2 = o2[1][a2] - o2[0][a2], m2 = o2[2][a2] - o2[0][a2];
  const u = Ln(5, e5, s4, n6, i2, (t3) => {
    let e6;
    if (t3 <= 0.5) {
      const s5 = V(0, h2, t3), n7 = V(h2, m2, t3);
      e6 = V(s5, n7, t3);
    } else {
      const s5 = U2(0, h2, t3), n7 = U2(h2, m2, t3);
      e6 = U2(s5, n7, t3);
    }
    return e6 * yr(o2, 1, t3).length();
  });
  r = false, a2 = r ? 0 : 1, h2 = o2[1][a2] - o2[0][a2], m2 = o2[2][a2] - o2[0][a2];
  const l2 = Ln(5, e5, s4, n6, i2, (t3) => {
    let e6;
    if (t3 <= 0.5) {
      const s5 = V(0, h2, t3), n7 = V(h2, m2, t3);
      e6 = V(s5, n7, t3);
    } else {
      const s5 = U2(0, h2, t3), n7 = U2(h2, m2, t3);
      e6 = U2(s5, n7, t3);
    }
    return e6 * yr(o2, 1, t3).length();
  });
  return new ei(u, l2);
}
function ur(t2) {
  t2.m_cachedValues = null;
}
function lr(t2, e5) {
  e5.m_cachedValues = Mt(t2.m_cachedValues, t2.m_cachedValues = e5.m_cachedValues);
}
function cr(t2) {
  if (t2.m_cachedValues) return t2.m_cachedValues;
  const e5 = new ar();
  return gr(t2, e5.specialPoints), Dr(t2, e5), e5;
}
function gr(t2, e5) {
  const s4 = Rt(ei, 3);
  t2.queryControlPoints(s4);
  const n6 = Rt(p2, 8);
  n6[0].set(0);
  let i2 = 1;
  {
    const t3 = Rt(p2, 3);
    Ur(s4, t3, false);
    const e6 = Rt(p2, 2), r = new x2(0, 1);
    let o2 = Ws2(t3[2].mul(2), t3[1], r, e6[0]);
    o2 < 0 && (o2 = 0);
    for (let s5 = 0; s5 < o2; s5++) Fs(e6[s5].value(), 0, 1) || (n6[i2] = e6[s5], i2++);
  }
  {
    const t3 = Rt(p2, 3);
    Or(s4, t3, false);
    const e6 = Rt(p2, 2), r = new x2(0, 1);
    let o2 = Ws2(t3[2].mul(2), t3[1], r, e6[0]);
    o2 < 0 && (o2 = 0);
    for (let s5 = 0; s5 < o2; s5++) Fs(e6[s5].value(), 0, 1) || (n6[i2] = e6[s5], i2++);
  }
  if (n6[i2].set(1), i2++, i2 > 2) {
    wt(n6, 0, i2, (t4, e7) => t4.value() - e7.value());
    let t3 = 0, e6 = n6[0].value(), s5 = 1;
    for (let r = 1; r < i2; r++) n6[r].eq(n6[r - 1]) ? (e6 += n6[r].value(), s5++) : (s5 > 1 && (e6 /= s5, n6[t3].set(e6)), t3++, n6[t3] = n6[r], e6 = n6[r].value(), s5 = 1);
    t3++, i2 = t3;
  }
  n6[0].set(0), n6[i2 - 1].set(1), e5.length = i2;
  for (let r = 0; r < i2; r++) e5[r] = n6[r].value();
}
function dr(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  return t2.queryControlPoints(n6), _r(n6, e5, s4);
}
function _r(t2, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + _r(t2, 1, false);
  }
  if (1 === e5) return pr(t2);
  const n6 = Rt(ei, 3);
  return Fr(t2, e5, n6, null), pr(n6);
}
function pr(t2) {
  if (t2[0].equals(t2[1])) return ei.distance(t2[2], t2[0]);
  if (t2[1].equals(t2[2])) return ei.distance(t2[0], t2[2]);
  const e5 = ei.distance(t2[0], t2[1]) + ei.distance(t2[2], t2[1]), s4 = ei.distance(t2[0], t2[2]);
  if (e5 - s4 <= e5 * Number.EPSILON) return s4;
  const n6 = 1, i2 = Rt(ei, 3);
  Zr(t2, i2, true);
  const r = 4 * ($(i2[2].x) + $(i2[2].y)), o2 = 2 * (i2[2].x * i2[1].x + i2[2].y * i2[1].y), a2 = $(i2[1].x) + $(i2[1].y);
  if (1e-14 * (Math.abs(o2) + Math.abs(a2)) >= Math.abs(r)) {
    if (1e-14 * Math.abs(a2) >= Math.abs(o2)) {
      return Math.sqrt(a2) * n6;
    }
    return 2 / (3 * o2) * (Math.pow(o2 * n6 + a2, 1.5) - Math.pow(a2, 1.5));
  }
  const h2 = o2 / r, m2 = a2 / r, u = m2 - h2 * h2, l2 = n6 + h2;
  if (0 === u) {
    if (h2 >= 0 && l2 >= 0 || h2 <= 0 && l2 <= 0) {
      return Math.abs(0.5 * Math.sqrt(r) * (l2 * l2 - h2 * h2));
    }
    return 0.5 * Math.sqrt(r) * (l2 * l2 + h2 * h2);
  }
  const c = Math.sqrt(u + l2 * l2), g2 = Math.sqrt(m2);
  return 0.5 * Math.sqrt(r) * (l2 * c - h2 * g2 + u * Math.log(Math.abs((l2 + c) / (h2 + g2))));
}
function fr(t2, e5) {
  const s4 = ks(e5, 0, 1);
  let n6 = yr(t2, 1, s4);
  return n6.isZero() && (n6 = yr(t2, 2, s4)), n6;
}
function Pr(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  return t2.queryControlPoints(n6), yr(n6, e5, s4);
}
function yr(t2, e5, s4) {
  if (1 === e5) {
    const e6 = t2[1].sub(t2[0]).mul(1 - s4).add(t2[2].sub(t2[1]).mul(s4));
    return e6.mulThis(2), e6;
  }
  return 2 === e5 ? t2[2].sub(t2[1]).sub(t2[1].sub(t2[0]).mul(2)) : ei.construct(0, 0);
}
function xr(t2, e5, s4) {
  {
    const e6 = Se.constructPoint2D(t2[1]).subE(Se.constructPoint2D(t2[0])), n6 = new p2(1).subE(s4), i2 = Se.constructPoint2D(t2[2]).subE(Se.constructPoint2D(t2[1])), r = e6.mulE(n6).addE(i2.mulE(s4));
    return r.mulThisE(new p2(2)), r;
  }
}
function Cr(t2, e5, s4) {
  const n6 = dr(t2, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== Xs2(new hr(t2, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function vr(t2) {
  const e5 = Rt(ei, 3);
  return t2.queryControlPoints(e5), br(e5);
}
function br(t2) {
  return -t2[1].sub(t2[0]).crossProduct(t2[2].sub(t2[0])) / 3;
}
function Er(t2) {
  const e5 = ei.distance(t2.getStartXY(), t2.getEndXY()), s4 = t2.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function Sr(t2) {
  return t2.m_cachedValues;
}
function Dr(t2, e5) {
  t2.m_cachedValues = e5;
}
function wr(t2, e5, s4, n6, i2) {
  D(x2.unit().contains(s4), "QuadraticBezierHelper::getClosestCoordinateSegment");
  const r = Rt(ei, 3);
  t2.queryControlPoints(r);
  let o2 = Number.MAX_VALUE;
  const a2 = [0], h2 = Ar(r, e5, a2);
  if (s4.containsCoordinate(a2[0])) o2 = ei.distance(e5, h2);
  else {
    a2[0] = s4.vmin, Jr(r, a2[0], h2), o2 = ei.distance(h2, e5);
    const t3 = new ei();
    Jr(r, s4.vmax, t3);
    const n7 = ei.distance(t3, e5);
    o2 > n7 && (h2.setCoordsPoint2D(t3), a2[0] = s4.vmax, o2 = n7);
  }
  if (!n6) return a2[0];
  if (s4.vmin <= 0) {
    const n7 = new ei();
    t2.queryCoord2DExtended(-1, n7, true);
    const i3 = new ei();
    t2.queryCoord2D(s4.vmin, i3);
    const r2 = new su({ start: n7, end: i3 }), m2 = r2.getClosestCoordinate(e5, true);
    if (m2 < 1) {
      const t3 = r2.getCoord2D(m2), s5 = ei.distance(t3, e5);
      s5 < o2 && (o2 = s5, a2[0] = m2 - 1, h2.assign(t3));
    }
  }
  if (s4.vmin >= 1) {
    const n7 = new ei();
    t2.queryCoord2DExtended(2, n7, true);
    const i3 = new ei();
    t2.queryCoord2D(s4.vmax, i3);
    const r2 = new su({ start: i3, end: n7 }), m2 = r2.getClosestCoordinate(e5, true);
    if (m2 > 0) {
      const t3 = r2.getCoord2D(m2), s5 = ei.distance(t3, e5);
      s5 < o2 && (o2 = s5, a2[0] = 1 + m2, h2.assign(t3));
    }
  }
  return a2[0];
}
function Ar(t2, e5, s4) {
  const n6 = t2[2].sub(t2[1]).sub(t2[1].sub(t2[0])), i2 = t2[1].sub(t2[0]), r = t2[0].sub(e5), o2 = r.dotProduct(i2), a2 = r.dotProduct(n6) + 2 * i2.dotProduct(i2), h2 = 3 * i2.dotProduct(n6), m2 = n6.dotProduct(n6), u = Lt(3, Number.NaN), l2 = Fs2(m2, h2, a2, o2, x2.unit(), false, u), c = t2[0].clone();
  let g2 = 0, d2 = ei.sqrDistance(t2[0], e5), _ = ei.sqrDistance(t2[2], e5);
  _ < d2 && (g2 = 1, c.assign(t2[2]), d2 = _);
  for (let p3 = 0; p3 < l2; p3++) {
    const s5 = new ei();
    Jr(t2, u[p3], s5), _ = ei.sqrDistance(s5, e5), _ < d2 && (d2 = _, c.assign(s5), g2 = u[p3]);
  }
  return s4 && (s4[0] = g2), c;
}
function Tr(t2, e5, s4, n6, i2, r) {
  const o2 = new ve();
  if (Ir(t2, x2.unit(), o2), o2.inflate(i2), !o2.isIntersectingPoint2D(e5)) return 0;
  const a2 = new ei(), h2 = wr(t2, e5, x2.unit(), false);
  t2.queryCoord2D(h2, a2);
  return ei.distance(a2, e5) <= i2 ? (n6 && (n6[0] = h2), 1) : 0;
}
function Ir(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6), Mr(n6, e5, s4);
}
function Mr(t2, e5, s4) {
  if (e5.equalsRange(0, 1)) return void s4.setFromPoints(t2, 3);
  const n6 = Rt(ei, 3);
  Vr(t2, e5.vmin, e5.vmax, n6), s4.setFromPoints(n6, 3);
}
function Yr(t2, e5, s4) {
  s4.setEmpty();
  const n6 = [];
  n6.push(new x2(0, 1));
  const i2 = 0.5 * Math.max(e5.width(), e5.height());
  for (; n6.length; ) {
    const r = n6.at(-1);
    n6.pop();
    const o2 = new ve();
    if (Mr(t2, r, o2), o2.isIntersectingW(e5)) {
      const t3 = Math.max(o2.width(), o2.height());
      if (e5.containsW(o2) || t3 <= i2 || r.width() < 1e-12) s4.merge(r);
      else {
        const t4 = r.getCenter();
        n6.push(x2.construct(r.vmin, t4)), n6.push(x2.construct(t4, r.vmax));
      }
    }
  }
}
function Xr(t2) {
  const e5 = Rt(ei, 3);
  t2.queryControlPoints(e5);
  const s4 = Nr(e5);
  return s4 && (t2.m_cp.setCoordsPoint2D(e5[1]), t2.afterCompletedModification()), s4;
}
function Nr(t2) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = hs(t2[0][s4], t2[2][s4]);
    n6 > 0 ? (hs(t2[0][s4], t2[1][s4]) < 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) < 0 && (t2[1][s4] = t2[2][s4], e5 = true)) : n6 < 0 ? (hs(t2[0][s4], t2[1][s4]) > 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) > 0 && (t2[1][s4] = t2[2][s4], e5 = true)) : t2[1][s4] !== t2[0][s4] && (t2[1][s4] = t2[0][s4], e5 = true);
  }
  return e5;
}
function qr(t2, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new ei();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weighted_centroid"), s4 === n6 || t2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = cr(t2), o2 = Ue(t2), a2 = Math.min(o2 / t2.calculateUpperLength2D(), 1e-7);
  let h2 = s4, m2 = 0;
  for (let e5 = 1, u = r.specialPointsCount(); e5 < u; e5++) if (s4 < r.specialPoints[e5]) {
    m2 = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = m2 + 1, u = r.specialPointsCount(); e5 < u; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), m3 = mr(t2, h2, s5, a2, o2);
    if (i2.addThis(m3), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t2.getStartXY().mul(t2.calculateLength2D()));
}
function Fr(t2, e5, s4, n6) {
  new ei().setCoordsPoint2D(t2[0]);
  new ei().setCoordsPoint2D(t2[1]);
  new ei().setCoordsPoint2D(t2[2]);
  const i2 = new ei(), r = new ei(), o2 = new ei();
  if (Y(t2[0], t2[1], e5, i2), Y(t2[1], t2[2], e5, r), Y(i2, r, e5, o2), s4 && (s4[0].assign(t2[0]), s4[1].assign(i2), s4[2].assign(o2)), n6) {
    const e6 = t2[2];
    n6[0].assign(o2), n6[1].assign(r), n6[2].assign(e6);
  }
}
function Vr(t2, e5, s4, n6) {
  if (e5 === s4) {
    const s5 = new ei();
    return Jr(t2, e5, s5), n6[0] = s5, n6[1] = s5, void (n6[2] = s5);
  }
  const i2 = Rt(ei, 3);
  Fr(t2, s4, i2, null), Fr(i2, e5 / s4, null, i2), Jr(t2, e5, i2[0]), Jr(t2, s4, i2[2]), n6[0].setCoordsPoint2D(i2[0]), n6[1].setCoordsPoint2D(i2[1]), n6[2].setCoordsPoint2D(i2[2]);
}
function Lr(t2, e5, s4, n6) {
  if (e5.isEqual(t2.m_XStart, t2.m_YStart) && s4.isEqual(t2.m_XEnd, t2.m_YEnd)) return;
  const i2 = !!n6 && t2.isMonotoneQuickAndDirty(), r = new x3(), o2 = Rt(ei, 3);
  o2[0].setCoords(t2.m_XStart, t2.m_YStart), o2[2].setCoords(t2.m_XEnd, t2.m_YEnd);
  const a2 = new ei();
  a2.setSub(o2[2], o2[0]), a2.leftPerpendicularThis(), o2[1].setAdd(o2[0], a2);
  const h2 = Rt(ei, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o2, h2) ? r.transformInPlace(t2.m_cp) : Y(e5, s4, 0.5, t2.m_cp), t2.changeEndPoints2D(e5, s4), i2 && Xr(t2);
}
function Rr(t2) {
  return t2.getStartXY().norm(1) + t2.getEndXY().norm(1) + t2.m_cp.norm(1);
}
function zr(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== Gr(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function kr(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== Wr(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function Br(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== jr(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function Gr(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  if (null != r && (r.length = 0), null !== o2 && (o2.length = 0), null !== i2 && (i2.length = 0), n6.isDegenerate(0)) {
    const t3 = [0, 0], s4 = e5.intersectPoint(n6.getStartXY(), t3, a2);
    if (s4 > 0) {
      if (null !== r) for (let e6 = 0; e6 < s4; e6++) r.push(t3[e6]);
      if (null !== o2) for (let t4 = 0; t4 < s4; t4++) o2.push(0);
      if (null !== i2) for (let n7 = 0; n7 < s4; n7++) {
        const s5 = new ei();
        e5.queryCoord2D(t3[n7], s5), i2.push(s5);
      }
    }
    return s4;
  }
  const l2 = Oe(e5, n6);
  if (a2 = Math.max(a2, l2), e5.isDegenerateToLineHelper(l2)) {
    const t3 = new su({ start: e5.getStartXY(), end: e5.getEndXY() }), s4 = ps(t3, n6, i2, r, o2, a2, h2, u);
    if (r) for (let n7 = 0; n7 < s4; ++n7) {
      const s5 = t3.getCoord2D(r[n7]);
      r[n7] = e5.getClosestCoordinate(s5, false);
    }
    return s4;
  }
  if (Qe(e5, n6, a2)) return 0;
  const c = an.constructPoint2D(n6.getStartXY()), g2 = an.constructPoint2D(n6.getEndXY()).sub(c), d2 = g2.clone();
  d2.leftPerpendicularThis();
  const _ = an.constructPoint2D(e5.m_cp).sub(an.constructPoint2D(e5.getStartXY())), p3 = an.constructPoint2D(e5.getEndXY()).sub(an.constructPoint2D(e5.m_cp));
  let f3 = _.dotProduct(d2).toDouble(), P5 = p3.sub(_).dotProduct(d2).toDouble();
  const y2 = Lt(12, Number.NaN), x4 = Lt(12, Number.NaN);
  let C2 = Ns(P5, f3, x2.unit(), y2);
  C2 < 0 && (y2[0] = 0, y2[1] = 1, C2 = 2);
  let v3, b2 = 0;
  for (let s4 = 0, w4 = b2; s4 < C2; ++s4) {
    const t3 = e5.getCoord2D(y2[s4 + w4]);
    x4[b2] = n6.getClosestCoordinate(t3, false), ei.distance(t3, n6.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[s4 + w4], b2++);
  }
  const E2 = Rt(ei, 3);
  e5.queryControlPoints(E2);
  {
    const t3 = Rt(an, 3);
    if (Qr(E2, t3, false), t3[0] = t3[0].sub(c), g2.x.abs().gte(g2.y.abs())) {
      const e6 = g2.y.div(g2.x);
      P5 = t3[2].y.sub(t3[2].x.mul(e6)).toDouble(), f3 = t3[1].y.sub(t3[1].x.mul(e6)).toDouble(), v3 = t3[0].y.sub(t3[0].x.mul(e6)).toDouble();
    } else {
      const e6 = g2.x.div(g2.y);
      P5 = t3[2].x.sub(t3[2].y.mul(e6)).toDouble(), f3 = t3[1].x.sub(t3[1].y.mul(e6)).toDouble(), v3 = t3[0].x.sub(t3[0].y.mul(e6)).toDouble();
    }
  }
  const S3 = e5.getEndXY().equals(n6.getStartXY()) || e5.getEndXY().equals(n6.getEndXY()), D3 = [0, 0];
  C2 = qs2(P5, f3, v3, x2.unit(), S3, D3);
  for (let s4 = 0, w4 = b2; s4 < C2; ++s4) {
    y2[s4 + w4] = D3[s4];
    const t3 = e5.getCoord2D(y2[s4 + w4]);
    x4[b2] = n6.getClosestCoordinate(t3, false), ei.distance(t3, n6.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[s4 + w4], b2++);
  }
  n2(b2 < y2.length + 4), C2 = e5.intersectPoint(n6.getStartXY(), D3, a2);
  for (let s4 = 0; s4 < C2; s4++) y2[b2] = D3[s4], x4[b2++] = 0;
  C2 = e5.intersectPoint(n6.getEndXY(), D3, a2);
  for (let s4 = 0; s4 < C2; s4++) y2[b2] = D3[s4], x4[b2++] = 1;
  C2 = n6.intersectPoint(e5.getStartXY(), D3, a2);
  for (let s4 = 0; s4 < C2; s4++) x4[b2] = D3[s4], y2[b2++] = 0;
  C2 = n6.intersectPoint(e5.getEndXY(), D3, a2);
  for (let s4 = 0; s4 < C2; s4++) x4[b2] = D3[s4], y2[b2++] = 0;
  return 0 === b2 ? 0 : Km(t2, e5, n6, y2, x4, b2, i2, r, o2, a2, h2, m2, u);
}
function Wr(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  if (zh(s4)) {
    return Gr(t2, e5, new su({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o2, a2, h2, m2);
  }
  const u = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, u))) return 0;
  const l2 = [], c = [], g2 = Rt(ei, 3);
  {
    e5.queryControlPoints(g2);
    const t3 = Rt(ei, 3), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(g2, 3, t3);
    const r2 = Rt(an, 3);
    Qr(t3, r2);
    const a3 = [r2[0].x, r2[1].x, r2[2].x], h3 = [r2[0].y, r2[1].y, r2[2].y], m3 = Rt(Hs, 3);
    m3[0].setDouble(s4.getSemiMinorAxis()), m3[0].sqrThis(), m3[1].setDouble(s4.getSemiMajorAxis()), m3[1].sqrThis(), m3[2] = m3[0], m3[2].mul(m3[1]), m3[2].negate();
    const u2 = _n(a3, 2, h3, 2, null, 0, m3, true, x2.unit(), x2.unit(), l2);
    if (u2 > 0) {
      let t4 = 0;
      for (let n8 = 0; n8 < u2; n8++) {
        const i4 = new ei();
        e5.queryCoord2D(l2[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a4 = new ei();
        s4.queryCoord2D(r3, a4), ei.distance(i4, a4) <= o2 && (l2[t4] = l2[n8], c.push(r3), t4++);
      }
      l2.length = t4;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t3 = 0 === _ ? s4.getStartXY() : s4.getEndXY(), e6 = [0];
    Ar(g2, t3, e6);
    const n7 = new ei();
    Jr(g2, e6[0], n7), ei.distance(t3, n7) <= o2 && (l2.push(e6[0]), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t3 = [0, 2];
    {
      const e6 = s4.getClosestCoordinate(g2[t3[_]], false), n7 = new ei();
      s4.queryCoord2D(e6, n7), ei.distance(g2[t3[_]], n7) <= o2 && (l2.push(d2[_]), c.push(e6));
    }
  }
  return Km(t2, e5, s4, l2, c, l2.length, n6, i2, r, o2, a2, h2, m2);
}
function jr(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  const u = Rt(ei, 3);
  e5.queryControlPoints(u);
  const l2 = Rt(ei, 3);
  if (s4.queryControlPoints(l2), Je(u, l2, 3) < 0) return jr(t2, s4, e5, n6, r, i2, o2, a2, h2, !m2);
  const c = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, c))) return 0;
  if (ao(e5, s4, n6, i2, r, o2, a2, h2, m2)) return 2;
  const g2 = new x2(0, 1), d2 = new x2(0, 1);
  {
    const t3 = new ve();
    Mr(u, x2.unit(), t3);
    const e6 = new ve();
    Mr(l2, x2.unit(), e6);
    const s5 = Math.max(t3.maxDim(), e6.maxDim());
    if (t3.inflate(3 * o2), e6.inflate(3 * o2), !t3.intersectW(e6)) return 0;
    if (t3.maxDim() < 0.1 * s5) {
      if (Yr(u, t3, g2), Yr(l2, t3, d2), g2.isEmpty() || d2.isEmpty()) return 0;
      Vr(u, g2.vmin, g2.vmax, u), Vr(l2, d2.vmin, d2.vmax, l2);
    }
  }
  const _ = tu(u, 2, l2, 2, o2);
  if (0 === _) return 0;
  const p3 = [], f3 = [];
  if (-1 === _) {
    const t3 = Rt(an, 3);
    Qr(u, t3);
    const e6 = [t3[0].x, t3[1].x, t3[2].x], s5 = [t3[0].y, t3[1].y, t3[2].y], n7 = Rt(an, 3);
    Qr(l2, n7);
    const i3 = cn(e6, 2, s5, 2, null, 0, [n7[0].x, n7[1].x, n7[2].x], 2, [n7[0].y, n7[1].y, n7[2].y], 2, null, 0, true, x2.unit(), x2.unit(), p3, f3, m2);
    if (i3 > 0) {
      let t4 = 0;
      for (let e7 = 0; e7 < i3; e7++) {
        const s6 = new ei(), n8 = new ei();
        Jr(l2, f3[e7], n8), Jr(u, p3[e7], s6), ei.distance(s6, n8) <= o2 && (p3[t4] = p3[e7], f3[t4] = f3[e7], t4++);
      }
      p3.length = t4, f3.length = t4;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    const t3 = 0 === P5 ? u : l2, e6 = 0 === P5 ? l2 : u;
    for (let s5 = 0; s5 < 2; s5++) {
      const n7 = 0 === s5 ? 0 : 2, i3 = [0];
      Ar(e6, t3[n7], i3);
      const r2 = new ei();
      Jr(e6, i3[0], r2), ei.distance(t3[n7], r2) <= o2 && (0 === P5 ? (p3.push(0 === n7 ? 0 : 1), f3.push(i3[0])) : (f3.push(0 === n7 ? 0 : 1), p3.push(i3[0])));
    }
  }
  if (0 === p3.length) return 0;
  if (!g2.equalsRange(0, 1)) for (let P5 = 0; P5 < p3.length; ++P5) p3[P5] = nn.recalculateParentT(g2.vmin, g2.vmax, p3[P5]);
  if (!d2.equalsRange(0, 1)) for (let P5 = 0; P5 < f3.length; ++P5) f3[P5] = nn.recalculateParentT(d2.vmin, d2.vmax, f3[P5]);
  return Km(t2, e5, s4, p3, f3, p3.length, n6, i2, r, o2, a2, h2, m2);
}
function Zr(t2, e5, s4 = false) {
  const n6 = t2[1].sub(t2[0]);
  e5[1].assign(n6.mul(2)), e5[2].assign(t2[2].sub(t2[1]).sub(n6)), s4 ? e5[0].setCoords(0, 0) : e5[0].assign(t2[0]);
}
function Hr(t2, e5, s4 = false) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6), Zr(n6, e5, s4);
}
function Ur(t2, e5, s4 = false) {
  const n6 = 0, i2 = new p2(t2[1][n6]).subE(new p2(t2[0][n6]));
  e5[1] = i2.mul(2), e5[2] = new p2(t2[2][n6]).subE(new p2(t2[1][n6])).subE(i2), s4 ? e5[0].set(0) : e5[0].set(t2[0][n6]);
}
function Or(t2, e5, s4 = false) {
  const n6 = 1, i2 = new p2(t2[1][n6]).subE(new p2(t2[0][n6]));
  e5[1] = i2.mul(2), e5[2] = new p2(t2[2][n6]).subE(new p2(t2[1][n6])).subE(i2), s4 ? e5[0].set(0) : e5[0].set(t2[0][n6]);
}
function Qr(t2, e5, s4 = false) {
  const n6 = an.constructPoint2D(t2[1]), i2 = n6.sub(an.constructPoint2D(t2[0]));
  e5[1] = i2.mul(Hs.constructInt32(2)), e5[2] = an.constructPoint2D(t2[2]).sub(n6).sub(i2), e5[0] = s4 ? new an(Xs, Xs) : an.constructPoint2D(t2[0]);
}
function Jr(t2, e5, s4, n6) {
  if (n6) {
    if (e5 < 0) {
      return void rs2(new su({ start: t2[0], end: t2[0].add(fr(t2, 0).getUnitVector()) }), e5, s4);
    }
    if (e5 > 1) {
      return void rs2(new su({ start: t2[2], end: t2[2].add(fr(t2, 1).getUnitVector()) }), e5 - 1, s4);
    }
  }
  if (e5 <= 0.5) {
    const n7 = t2[1].clone(), i2 = new ei();
    F(2, t2[0], n7, e5, i2);
    const r = new ei();
    F(2, n7, t2[2], e5, r);
    const o2 = new ei();
    F(2, i2, r, e5, o2), s4.assign(o2);
  } else {
    const n7 = t2[1].clone(), i2 = new ei();
    k2(2, t2[0], n7, e5, i2);
    const r = new ei();
    k2(2, n7, t2[2], e5, r);
    const o2 = new ei();
    k2(2, i2, r, e5, o2), s4.assign(o2);
  }
}
function Kr(t2, e5, s4) {
  const n6 = Rt(ei, 3);
  t2.queryControlPoints(n6), $r(n6, e5, s4);
}
function $r(t2, e5, s4) {
  if (e5.value() <= 0.5) {
    const n6 = Se.constructPoint2D(t2[1]), i2 = new Se();
    O(2, Se.constructPoint2D(t2[0]), n6, e5, i2);
    const r = new Se();
    O(2, n6, Se.constructPoint2D(t2[2]), e5, r);
    const o2 = new Se();
    O(2, i2, r, e5, o2), s4.setE(o2);
  } else {
    const n6 = Se.constructPoint2D(t2[1]), i2 = new Se();
    G2(2, Se.constructPoint2D(t2[0]), n6, e5, i2);
    const r = new Se();
    G2(2, n6, Se.constructPoint2D(t2[2]), e5, r);
    const o2 = new Se();
    G2(2, i2, r, e5, o2), s4.setE(o2);
  }
}
function to(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), eo(n6, e5, s4);
}
function eo(t2, e5, s4) {
  e5.value() < 0 && e5.set(0, e5.eps()), e5.value() > 1 && e5.set(1, e5.eps()), s4.setE(xr(t2, 1, e5));
}
function io(t2, e5) {
  e5[0].assign(t2[0]), e5[3].assign(t2[2]), Y(t2[0], t2[1], 2 / 3, e5[1]), Y(t2[1], t2[2], 1 / 3, e5[2]);
}
function ro(t2, e5) {
  const s4 = Rt(ei, 3);
  t2.queryControlPoints(s4);
  const n6 = ei.sqrDistance(s4[1], s4[0]), i2 = ei.sqrDistance(s4[1], s4[2]);
  let r = s4[0].clone(), o2 = n6;
  n6 > i2 && (r = s4[2].clone(), o2 = i2);
  let a2 = false;
  return o2 <= e5 && 0 !== o2 && (a2 = true, t2.setControlPoint1(r)), a2;
}
function oo(t2, e5) {
  if (!e5) return false;
  const s4 = Rt(ei, 3);
  t2.queryControlPoints(s4);
  const n6 = ei.sqrDistance(s4[1], s4[0]), i2 = ei.sqrDistance(s4[1], s4[2]);
  s4[0].clone();
  let r = n6;
  return n6 > i2 && (s4[2].clone(), r = i2), r <= e5 && 0 !== r;
}
function ao(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  const m2 = Rt(ei, 3);
  t2.queryControlPoints(m2);
  const u = Rt(ei, 3);
  if (e5.queryControlPoints(u), m2[0].equals(u[0])) {
    if (m2[1].equals(u[1]) && m2[2].equals(u[2])) return s4 && (s4.length = 0, s4.push(m2[0]), s4.push(m2[2])), n6 && (n6.length = 0, n6.push(0), n6.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!m2[0].equals(u[2])) return false;
  }
  return !!(m2[0].equals(u[2]) && m2[1].equals(u[1]) && m2[2].equals(u[0])) && (n6 && (n6.length = 0, n6.push(0), n6.push(1), h2 && (n6[1] = Mt(n6[0], n6[0] = n6[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Mt(i2[0], i2[0] = i2[1]))), s4 && (s4.length = 0, s4.push(m2[0]), s4.push(m2[2]), h2 && (s4[1] = Mt(s4[0], s4[0] = s4[1]))), true);
}
var ho = B3;
var mo = class _mo extends ns {
  constructor(t2) {
    t2 && t2.cp ? (super({ start: t2.cp[0], end: t2.cp[3], vd: t2.vd }), this.m_cp = Rt(ei, 2), this.m_cp[0].assign(t2.cp[1]), this.m_cp[1].assign(t2.cp[2])) : void 0 === t2 || Ot(t2, "vd") ? (super({ vd: t2 == null ? void 0 : t2.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = Rt(ei, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)) : t2.from ? (super({ start: t2.from, end: t2.to, vd: t2.vd }), this.m_cp = Rt(ei, 2), this.m_cp[0].assign(t2.cp1), this.m_cp[1].assign(t2.cp2)) : (super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0, vd: t2.vd }), b("unrecognized constructor params"), this.m_cp = Rt(ei, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)), this.m_cachedValues = 0;
  }
  getBoundary() {
    return Va(this);
  }
  construct(t2, e5, s4, n6) {
    this.m_XStart = t2.x, this.m_YStart = t2.y, this.m_XEnd = n6.x, this.m_YEnd = n6.y, this.m_cp[0].assign(e5), this.m_cp[1].assign(s4), this.afterCompletedModification();
  }
  constructPoints(t2) {
    this.m_XStart = t2[0].x, this.m_YStart = t2[0].y, this.m_XEnd = t2[3].x, this.m_YEnd = t2[3].y, this.m_cp[0].assign(t2[1]), this.m_cp[1].assign(t2[2]), this.afterCompletedModification();
  }
  constructFromQuadratic(t2) {
    const e5 = Rt(ei, 4);
    io(t2, e5), this.constructPoints(e5);
  }
  constructFromQuadraticSegment(t2) {
    this.dropAllAttributes(), this.assignVertexDescription(t2.getDescription()), this.m_XStart = t2.getStartX(), this.m_YStart = t2.getStartY(), this.m_XEnd = t2.getEndX(), this.m_YEnd = t2.getEndY(), L2(2, t2.getStartXY(), t2.getControlPoint1(), 2 / 3, this.m_cp[0]), L2(2, t2.getControlPoint1(), t2.getEndXY(), 1 / 3, this.m_cp[1]), this.afterCompletedModification(), Ze(this, t2);
  }
  getGeometryType() {
    return a.enumBezier;
  }
  queryEnvelope(t2) {
    if (2 !== t2.m_EnvelopeType) return void n2(0);
    if (t2.setCoords(this.getStartXY()), t2.mergeNe(this.getEndXY()), t2.contains(this.m_cp[0]) && t2.contains(this.m_cp[1])) return;
    const e5 = So(this);
    if (null !== e5) {
      const s4 = new ei();
      for (const n7 of e5.specialPoints) this.queryCoord2D(n7, s4), t2.mergeNe(s4);
      return;
    }
    const n6 = Rt(p2, 8), i2 = Rt(ei, 4);
    this.queryControlPoints(i2);
    const r = Pa(i2, n6), o2 = new ei();
    for (let s4 = 1; s4 < r - 1; s4++) this.queryCoord2D(n6[s4].value(), o2), t2.mergeNe(o2);
  }
  applyTransformation(t2) {
    if (1 === t2.m_TransformationType) {
      const e5 = Rt(ei, 4);
      return this.queryControlPoints(e5), t2.transformPoints2D(e5, 4, e5), this.setStartXY(e5[0]), this.m_cp[0].assign(e5[1]), this.m_cp[1].assign(e5[2]), this.setEndXY(e5[3]), void wo(this);
    }
    n2(0);
  }
  createInstance() {
    return new _mo({ vd: this.m_description });
  }
  calculateLength2D() {
    return Co(this, 1, false);
  }
  calculateLowerLength2D() {
    return ei.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return ei.distance(this.getStartXY(), this.m_cp[0]) + ei.distance(this.m_cp[0], this.m_cp[1]) + ei.distance(this.getEndXY(), this.m_cp[1]);
  }
  queryCoord2D(t2, e5) {
    return this.queryCoord2DExtends(t2, e5, true);
  }
  queryCoord2DExtends(t2, e5, s4) {
    const n6 = Rt(ei, 4);
    this.queryControlPoints(n6), jo(n6, t2, e5, s4);
  }
  queryCoord2DE(t2, e5) {
    Ho(this, t2, e5);
  }
  getCoordX(t2) {
    if (t2 < 0 || t2 > 1) {
      const e6 = new ei();
      return this.queryCoord2DExtends(t2, e6, true), e6.x;
    }
    const e5 = Q(this.getStartX(), this.m_cp[0].x, t2), s4 = Q(this.m_cp[0].x, this.m_cp[1].x, t2), n6 = Q(this.m_cp[1].x, this.getEndX(), t2), i2 = Q(e5, s4, t2), r = Q(s4, n6, t2);
    return Q(i2, r, t2);
  }
  getCoordY(t2) {
    if (t2 < 0 || t2 > 1) {
      const e6 = new ei();
      return this.queryCoord2DExtends(t2, e6, true), e6.y;
    }
    const e5 = Q(this.getStartY(), this.m_cp[0].y, t2), s4 = Q(this.m_cp[0].y, this.m_cp[1].y, t2), n6 = Q(this.m_cp[1].y, this.getEndY(), t2), i2 = Q(e5, s4, t2), r = Q(s4, n6, t2);
    return Q(i2, r, t2);
  }
  cut(t2, e5, s4) {
    const n6 = new nu();
    return this.queryCut(t2, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t2, e5, s4, n6) {
    const i2 = s4.createCubicBezier();
    if (this.cutBezierIgnoreAttributes(t2, e5, i2), n6) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e6 = 1; e6 < r; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = ho.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t2, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t3 = 1; t3 < r; t3++) {
        const s5 = this.m_description.getSemantics(t3), n7 = ho.getComponentCount(s5);
        for (let t4 = 0; t4 < n7; t4++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t4);
          i2.setEndAttribute(s5, t4, n8);
        }
      }
    }
  }
  queryDerivative(t2, e5) {
    Oo(this, t2, e5);
  }
  cutBezierIgnoreAttributes(t2, s4, n6) {
    (t2 < 0 || s4 > 1 || t2 > s4) && P("Cubic_bezier.cut_bezier_ignore_attributes");
    const i2 = Rt(ei, 4);
    this.queryControlPoints(i2);
    const r = Rt(ei, 4);
    Wo(i2, t2, s4, r), n6.setControlPoints(r);
  }
  splitBezierIgnoreAttributes(t2, s4, n6) {
    this === s4 && this === n6 && P("Cubic_bezier.split_bezier_ignore_attributes");
    const i2 = Rt(ei, 4);
    this.queryControlPoints(i2);
    const r = Rt(ei, 4), o2 = Rt(ei, 4);
    Go(i2, t2, r, o2), s4 && s4.setControlPoints(r), n6 && n6.setControlPoints(o2);
  }
  getAttributeAsDbl(t2, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t2) : this.getCoordY(t2);
    if (0 === t2) return this.getStartAttributeAsDbl(e5, s4);
    if (1 === t2) return this.getEndAttributeAsDbl(e5, s4);
    const n6 = this.getStartAttributeAsDbl(e5, s4), i2 = this.getEndAttributeAsDbl(e5, s4), r = this.calculateLength2D(), o2 = r > 0 ? this.tToLength(t2) / r : 0, a2 = ho.getInterpolation(e5);
    return pt(a2, n6, i2, o2, ho.getDefaultValue(e5));
  }
  getClosestCoordinate(t2, e5) {
    const s4 = [Number.NaN];
    return ca(this, t2, x2.unit(), e5, -1, 1, s4), s4[0];
  }
  getClosestCoordinateOnInterval(t2, e5, s4 = -1) {
    const n6 = [Number.NaN];
    return 0 === ca(this, t2, e5, false, s4, 1, n6) ? Number.NaN : n6[0];
  }
  getYMonotonicParts(t2, e5 = false) {
    return this.getMonotonicParts(t2, e5);
  }
  getMonotonicParts(t2, n6) {
    t2.length < 2 && P("");
    const i2 = Eo(this);
    if (2 === i2.specialPointsCount() && this.isMonotoneQuickAndDirty()) return 0;
    let r = 0;
    n2(t2.length >= i2.specialPointsCount() - 1);
    for (let e5 = 1, s4 = i2.specialPointsCount(); e5 < s4; ++e5) this.queryCut(i2.specialPoints[e5 - 1], i2.specialPoints[e5], t2[r], n6), r++;
    for (let e5 = 0; e5 < r; ++e5) {
      Ro(t2[e5].get());
    }
    return r;
  }
  intersectionWithAxis2D(t2, e5, s4, n6) {
    const i2 = Rt(ei, 4);
    return this.queryControlPoints(i2), ya(i2, t2, e5, s4, n6);
  }
  intersectionOfYMonotonicWithAxisX(t2, e5) {
    if (this.m_YStart === this.m_YEnd) return t2 === this.m_YStart ? e5 : Number.NaN;
    if (t2 === this.m_YStart) return this.m_XStart;
    if (t2 === this.m_YEnd) return this.m_XEnd;
    const n6 = [0, 0], i2 = this.intersectionWithAxis2D(true, t2, n6, null);
    return n2(2 !== i2), -1 === i2 ? e5 : n6[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t2) {
    return Te(this, t2);
  }
  isDegenerate3D(t2, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t2) {
    if (2 === t2.m_EnvelopeType) return t2.setCoords({ pt: this.getStartXY() }), t2.mergeNe(this.m_cp[0]), t2.mergeNe(this.m_cp[1]), void t2.mergeNe(this.getEndXY());
    n2(0);
  }
  clone(t2) {
    const e5 = this.createInstance();
    return this.copyTo(e5), e5;
  }
  queryInterval(t2, e5) {
    if (0 === t2) {
      const t3 = n4.constructEmpty();
      this.queryEnvelope(t3);
      const s4 = x2.constructEmpty();
      return 0 === e5 ? t3.queryIntervalX(s4) : t3.queryIntervalY(s4), s4;
    }
    return super.queryInterval(t2, e5);
  }
  queryLooseEnvelopeOnInterval(t2, e5) {
    const s4 = Rt(ei, 4);
    this.queryControlPoints(s4), Wo(s4, t2.vmin, t2.vmax, s4), e5.setFromPoints(s4, 4);
  }
  changeEndPoints2D(t2, e5) {
    if (t2.isEqual(this.m_XStart, this.m_YStart) && e5.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s4 = this.m_cp[0].isEqual(this.m_XStart, this.m_YStart), n6 = this.m_cp[0].isEqual(this.m_XEnd, this.m_YEnd), i2 = this.m_cp[1].isEqual(this.m_XStart, this.m_YStart), r = this.m_cp[1].isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t2), this.setEndXY(e5), s4 ? this.m_cp[0].setCoordsPoint2D(t2) : n6 && this.m_cp[0].setCoordsPoint2D(e5), r ? this.m_cp[1].setCoordsPoint2D(e5) : i2 && this.m_cp[1].setCoordsPoint2D(t2), this.normalizeAfterEndpointChange();
  }
  tToLength(t2) {
    return Co(this, t2, true);
  }
  lengthToT(t2) {
    return vo(this, t2);
  }
  calculateWeightedAreaCentroid2D(t2) {
    const e5 = Rt(ei, 4);
    _o(this, e5);
    const s4 = e5[3], n6 = e5[2], i2 = e5[1], r = new ei();
    r.x = (5 * s4.x * s4.x * (7 * n6.y + 16 * i2.y) + s4.x * (-35 * s4.y * n6.x + 40 * n6.x * n6.y - 80 * s4.y * i2.x + 140 * n6.x * i2.y + 112 * i2.x * i2.y) - 2 * (s4.y * (20 * n6.x * n6.x + 70 * n6.x * i2.x + 56 * i2.x * i2.x) - 7 * (4 * n6.x + 5 * i2.x) * (-n6.y * i2.x + n6.x * i2.y))) / 840, r.y = (-5 * s4.y * s4.y * (7 * n6.x + 16 * i2.x) + s4.y * (5 * s4.x * (7 * n6.y + 16 * i2.y) - 4 * (10 * n6.x * n6.y + 35 * n6.y * i2.x + 28 * i2.x * i2.y)) + 2 * (-7 * (4 * n6.y + 5 * i2.y) * (n6.y * i2.x - n6.x * i2.y) + s4.x * (20 * n6.y * n6.y + 70 * n6.y * i2.y + 56 * i2.y * i2.y))) / 840;
    const o2 = Lo(this);
    return r.x += (e5[0].x - t2.x) * o2, r.y += (e5[0].y - t2.y) * o2, r;
  }
  calculateWeightedCentroid2D() {
    const t2 = new ei();
    return this.isDegenerate(0) ? (t2.setCoords(0, 0), t2) : go(this) ? (t2.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t2) : (t2.assign(bo(this, 1)), t2);
  }
  getControlPoint1() {
    return this.m_cp[0].clone();
  }
  setControlPoint1(t2) {
    this.m_cp[0].setCoordsPoint2D(t2), this.afterCompletedModification();
  }
  getControlPoint2() {
    return this.m_cp[1].clone();
  }
  setControlPoint2(t2) {
    this.m_cp[1].setCoordsPoint2D(t2), this.afterCompletedModification();
  }
  queryControlPoints(t2) {
    t2[0].assign(this.getStartXY()), t2[1].assign(this.m_cp[0]), t2[2].assign(this.m_cp[1]), t2[3].assign(this.getEndXY());
  }
  setControlPoints(t2) {
    for (let s4 = 0; s4 < 4; s4++) t2[s4].isNAN() && P("NAN control points in bezier are not supported");
    this.m_XStart = t2[0].x, this.m_YStart = t2[0].y, this.m_cp[0].setCoordsPoint2D(t2[1]), this.m_cp[1].setCoordsPoint2D(t2[2]), this.m_XEnd = t2[3].x, this.m_YEnd = t2[3].y, this.afterCompletedModification();
  }
  getTangent(t2) {
    const e5 = Rt(ei, 4);
    return this.queryControlPoints(e5), Uo(e5, t2);
  }
  getDerivative(t2) {
    const e5 = Rt(ei, 4);
    return this.queryControlPoints(e5), qo(e5, 1, t2);
  }
  getCurvature(t2) {
    const e5 = Vo(this, 1, t2), s4 = Vo(this, 2, t2), n6 = e5.sqrLength();
    if (0 === n6) return Number.NaN;
    e5.divThis(Math.sqrt(n6));
    return e5.crossProduct(s4) / n6;
  }
  isIntersectingPoint(t2, e5, s4) {
    if (s4 && (t2.equals(this.getStartXY()) || t2.equals(this.getEndXY()))) return false;
    const n6 = new n4();
    if (this.queryLooseEnvelope(n6), n6.inflateCoords(e5, e5), !n6.contains(t2)) return false;
    const i2 = this.getClosestCoordinate(t2, false), r = new ei();
    this.queryCoord2D(i2, r);
    return ei.distance(r, t2) <= e5;
  }
  isIntersectingPoint3D(t2, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  isMonotoneQuickAndDirty() {
    const t2 = Rt(ei, 4);
    return this.queryControlPoints(t2), ko(t2);
  }
  getMonotonicPartParams(t2, n6) {
    const i2 = Eo(this), r = i2.specialPointsCount();
    if (n2($e.s_maxMonotonicPartParams >= r), !n6) return i2.specialPointsCount();
    t2 < r && P("");
    for (let e5 = 0; e5 < r; e5++) n6[e5] = i2.specialPoints[e5];
    return r;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Mt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Mt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t2 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t2 < e5; t2++) this.m_attributes[t2 + e5] = Mt(this.m_attributes[t2], this.m_attributes[t2] = this.m_attributes[t2 + e5]);
      this.m_cp[1] = Mt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]), this.m_cachedValues = null;
    }
  }
  findMinDeriv() {
    const t2 = new p2();
    return Yo(this, t2), t2.value();
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t2) {
    const e5 = this.getEndXY().sub(this.getStartXY()), s4 = e5.length(), n6 = 0.1 * t2;
    let i2 = this.getControlPoint1();
    i2.subThis(this.getStartXY());
    let r = Math.abs(i2.crossProduct(e5)) / s4;
    return !(r > n6) && (i2 = this.getControlPoint2(), i2.subThis(this.getStartXY()), r = Math.abs(i2.crossProduct(e5)) / s4, !(r > n6));
  }
  copyIgnoreAttributes(t2) {
    const e5 = Rt(ei, 4);
    this.queryControlPoints(e5), t2.setControlPoints(e5);
  }
  calculateArea2DHelper() {
    return Lo(this);
  }
  absNorm() {
    return ga(this);
  }
  queryEnvelopeW(t2, e5) {
    ha(this, t2, e5);
  }
  setSegmentFromCoords(t2, e5) {
    _a(this, t2, e5);
  }
  writeInBufferStream(t2, e5) {
    const s4 = new Float64Array(4);
    return this.writeInBuffer_(s4), t2.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  writeInBuffer_(t2) {
    return t2[0] = this.m_cp[0].x, t2[1] = this.m_cp[0].y, t2[2] = this.m_cp[1].x, t2[3] = this.m_cp[1].y, 4;
  }
  readFromBufferStream(t2, e5) {
    const s4 = new Float64Array(4);
    t2.queryRange(e5, s4.length, s4, true, 1), this.readFromBuffer_(s4);
  }
  readFromBuffer_(t2) {
    this.m_cp = Rt(ei, 2), this.m_cp[0].x = t2[0], this.m_cp[0].y = t2[1], this.m_cp[1].x = t2[2], this.m_cp[1].y = t2[3], this.m_cachedValues = null;
  }
  snapControlPoints(t2) {
    const e5 = Rt(ei, 4);
    this.queryControlPoints(e5);
    const s4 = (e6, s5, n7) => {
      let i3 = false;
      if (ei.sqrDistance(e6, n7) <= t2) {
        i3 = !e6.equals(n7), e6.setCoordsPoint2D(n7);
        ei.sqrDistance(s5, n7) <= t2 && (i3 || (i3 = !s5.equals(n7)), s5.setCoordsPoint2D(n7));
      }
      return i3;
    }, n6 = s4(e5[1], e5[2], e5[0]), i2 = s4(e5[2], e5[1], e5[3]);
    return (n6 || i2) && this.setControlPoints(e5), n6 || i2;
  }
  needsSnapControlPoints(t2) {
    if (!t2) return false;
    const e5 = Rt(ei, 4);
    this.queryControlPoints(e5);
    const s4 = (e6, s5, n7) => {
      let i3 = false;
      if (ei.sqrDistance(e6, n7) <= t2) {
        i3 = !e6.equals(n7), e6.setCoordsPoint2D(n7);
        ei.sqrDistance(s5, n7) <= t2 && (i3 || (i3 = !s5.equals(n7)), s5.setCoordsPoint2D(n7));
      }
      return i3;
    }, n6 = s4(e5[1], e5[2], e5[0]), i2 = s4(e5[2], e5[1], e5[3]);
    return n6 || i2;
  }
  calculateSpecialPointsForCracking(t2, e5) {
    return Ca(this, t2, e5);
  }
  ensureXYMonotone() {
    return Ro(this);
  }
  setCoordsForIntersector(t2, e5, s4) {
    To(this, t2, e5, s4);
  }
  copyToImpl(t2) {
    const e5 = t2;
    e5.m_cp[0].assign(this.m_cp[0]), e5.m_cp[1].assign(this.m_cp[1]), Do(e5, So(this));
  }
  reverseImpl() {
    this.m_cp[1] = Mt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]);
  }
  equalsImpl(t2) {
    const e5 = t2, s4 = 0, n6 = 1;
    return !!this.m_cp[0].equals(e5.m_cp[s4]) && !!this.m_cp[1].equals(e5.m_cp[n6]);
  }
  equalsImplTol(t2, e5) {
    const s4 = t2, n6 = 0, i2 = 1;
    return !!this.m_cp[0].isEqualPoint2D(s4.m_cp[n6], e5) && !!this.m_cp[1].isEqualPoint2D(s4.m_cp[i2], e5);
  }
  swapImpl(t2) {
    const e5 = t2;
    e5.m_cp[0] = Mt(this.m_cp[0], this.m_cp[0] = e5.m_cp[0]), e5.m_cp[1] = Mt(this.m_cp[1], this.m_cp[1] = e5.m_cp[1]), Ao(this, e5);
  }
  afterCompletedModification() {
    wo(this);
  }
  isIntersecting(t2, e5, s4) {
    return 0 !== jm(false, this, t2, e5, s4);
  }
  intersect(t2, e5, s4, n6, i2) {
    return Om(false, this, t2, e5, s4, n6, i2);
  }
  intersectPoint(t2, e5, s4) {
    return aa(this, t2, e5, s4);
  }
  endPointModified() {
    wo(this);
  }
  clearEndPointModified() {
  }
};
mo.type = a.enumBezier;
var uo = class {
  constructor() {
    this.length = Number.NaN, this.specialPoints = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function lo(t2) {
  return co(t2.calculateUpperLength2D());
}
function co(t2) {
  return 256 * Ss() * t2;
}
function go(t2) {
  const e5 = ei.distance(t2.getStartXY(), t2.getEndXY()), s4 = t2.calculateUpperLength2D();
  return s4 - e5 <= 8 * Number.EPSILON * s4;
}
function _o(t2, e5, s4 = false) {
  e5[1].setCoords(t2.m_cp[0].x - t2.getStartX(), t2.m_cp[0].y - t2.getStartY()), e5[1].mulThis(3), e5[2].setCoords(t2.m_cp[1].x - t2.m_cp[0].x, t2.m_cp[1].y - t2.m_cp[0].y), e5[2].mulThis(3), e5[3] = t2.getEndXY().sub(t2.getStartXY()), e5[3].subThis(e5[2]), e5[2].subThis(e5[1]), s4 ? e5[0].setCoords(0, 0) : e5[0] = t2.getStartXY();
}
function po(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), Po(n6, e5, s4);
}
function fo(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), yo(n6, e5, s4);
}
function Po(t2, e5, s4) {
  let n6 = t2[1].x;
  n6 -= t2[0].x, n6 *= 3;
  let i2 = t2[2].x;
  i2 -= t2[1].x, i2 *= 3;
  let r = t2[3].x;
  r -= t2[0].x, r -= i2, i2 -= n6, e5[3].setWithEps(r), e5[2].setWithEps(i2), e5[1].setWithEps(n6), s4 ? e5[0].set(0) : e5[0].set(t2[0].x);
}
function yo(t2, e5, s4) {
  let n6 = t2[1].y;
  n6 -= t2[0].y, n6 *= 3;
  let i2 = t2[2].y;
  i2 -= t2[1].y, i2 *= 3;
  let r = t2[3].y;
  r -= t2[0].y, r -= i2, i2 -= n6, e5[3].setWithEps(r), e5[2].setWithEps(i2), e5[1].setWithEps(n6), s4 ? e5[0].set(0) : e5[0].set(t2[0].y);
}
function xo(t2, e5, s4 = false) {
  const n6 = Rt(an, 4);
  n6[0].assignPoint2D(t2[0]), n6[1].assignPoint2D(t2[1]), n6[2].assignPoint2D(t2[2]), n6[3].assignPoint2D(t2[3]), e5[1].setCoords(n6[1].x.sub(n6[0].x), n6[1].y.sub(n6[0].y)), e5[1].mulThis(Hs.constructInt32(3)), e5[2].setCoords(n6[2].x.sub(n6[1].x), n6[2].y.sub(n6[1].y)), e5[2].mulThis(Hs.constructInt32(3)), e5[3] = n6[3].sub(n6[0]), e5[3] = e5[3].sub(e5[2]), e5[2] = e5[2].sub(e5[1]), s4 ? e5[0].setCoords(Xs, Xs) : e5[0] = n6[0].clone();
}
function Co(t2, e5, s4) {
  if (s4) {
    if (e5 < 0) return e5;
    if (e5 > 1) return e5 - 1 + Co(t2, 1, false);
  }
  if (t2.isDegenerate(0)) return 0;
  const n6 = 1 === e5, i2 = Eo(t2);
  if (n6 && !Number.isNaN(i2.length) && !Number.isNaN(i2.length)) return i2.length;
  const r = lo(t2), o2 = r / t2.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let m2 = 1, u = i2.specialPointsCount(); m2 < u; m2++) {
    const s5 = i2.specialPoints[m2];
    if (a2 += Ea(t2, h2, Math.min(e5, s5), o2, r), e5 <= s5) break;
    h2 = s5;
  }
  return n6 && (i2.length = a2), a2;
}
function vo(t2, e5, s4) {
  const n6 = Co(t2, 1, false);
  if (e5 <= 0) return e5;
  if (e5 >= n6) return e5 - n6 + 1;
  const i2 = [0];
  return 1 !== Xs2(new va(t2, e5), x2.unit(), 1, i2) && b(""), i2[0];
}
function bo(t2, s4, n6) {
  void 0 === n6 && (n6 = s4, s4 = 0);
  const i2 = new ei();
  if (s4 < 0 || n6 > 1) return i2.setNAN(), i2;
  if (s4 > n6 && P("calculate_sub_weightedCentroid"), s4 === n6 || t2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = Eo(t2), o2 = lo(t2), a2 = o2 / t2.calculateUpperLength2D();
  let h2 = s4, m2 = 0;
  for (let e5 = 1, u = r.specialPointsCount(); e5 < u; e5++) if (s4 < r.specialPoints[e5]) {
    m2 = e5 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let e5 = m2 + 1, u = r.specialPointsCount(); e5 < u; e5++) {
    const s5 = Math.min(r.specialPoints[e5], n6), m3 = Sa(t2, h2, s5, a2, o2);
    if (i2.addThis(m3), h2 = s5, n6 <= r.specialPoints[e5]) break;
  }
  return i2.add(t2.getStartXY().mul(t2.calculateLength2D()));
}
function Eo(t2) {
  if (t2.m_cachedValues) return t2.m_cachedValues;
  const e5 = new uo(), s4 = Rt(p2, 8), n6 = Rt(ei, 4);
  t2.queryControlPoints(n6);
  const i2 = Pa(n6, s4);
  e5.specialPoints = [];
  for (let r = 0; r < i2; r++) e5.specialPoints.push(s4[r].value());
  return Do(t2, e5), e5;
}
function So(t2) {
  let e5 = null;
  return e5 = t2.m_cachedValues, e5;
}
function Do(t2, e5) {
  t2.m_cachedValues = e5;
}
function wo(t2) {
  t2.m_cachedValues = null;
}
function Ao(t2, e5) {
  e5.m_cachedValues = Mt(t2.m_cachedValues, t2.m_cachedValues = e5.m_cachedValues);
}
function To(t2, e5, s4, n6) {
  if (e5.isEqual(t2.m_XStart, t2.m_YStart) && s4.isEqual(t2.m_XEnd, t2.m_YEnd)) return;
  const i2 = !!n6 && t2.isMonotoneQuickAndDirty(), r = new x3(), o2 = Rt(ei, 3);
  o2[0].setCoords(t2.m_XStart, t2.m_YStart), o2[2].setCoords(t2.m_XEnd, t2.m_YEnd);
  const a2 = new ei();
  a2.setSub(o2[2], o2[0]), a2.leftPerpendicularThis(), o2[1].setAdd(o2[0], a2);
  const h2 = Rt(ei, 3);
  h2[0].setCoordsPoint2D(e5), h2[2].setCoordsPoint2D(s4), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o2, h2) ? r.transformPoints2D(t2.m_cp, 2, t2.m_cp) : (Y(e5, s4, 1 / 3, t2.m_cp[0]), Y(e5, s4, 2 / 3, t2.m_cp[1])), t2.changeEndPoints2D(e5, s4), i2 && Ro(t2);
}
function Io(t2, e5, s4, n6, i2) {
  return { tmin: t2, tmax: e5, t: s4, d: n6, pt: i2.clone() };
}
function Mo(t2, e5, s4, n6) {
  const i2 = Lt(18, Number.NaN), r = Rt(ei, 4);
  t2.queryControlPoints(r);
  const o2 = Xs2(new ua(r, e5), x2.construct(s4, n6), 18, i2), a2 = new ei();
  t2.queryCoord2D(s4, a2);
  let h2 = s4, m2 = ei.distance(a2, e5);
  const u = new ei();
  t2.queryCoord2D(n6, u);
  const l2 = ei.distance(u, e5);
  l2 < m2 && (m2 = l2, h2 = n6, a2.assign(u));
  for (let c = 0; c < o2; c++) {
    t2.queryCoord2D(i2[c], u);
    const s5 = ei.distance(u, e5);
    s5 < m2 && (m2 = s5, h2 = i2[c], a2.assign(u));
  }
  return Io(s4, n6, h2, m2, a2);
}
function Yo(t2, e5) {
  const n6 = Rt(p2, 4);
  po(t2, n6, true);
  const i2 = Rt(p2, 4);
  fo(t2, i2, true);
  const r = n6[3].clone(), o2 = n6[2].clone(), a2 = n6[1].clone(), h2 = i2[3].clone(), m2 = i2[2].clone(), u = i2[1].clone(), l2 = o2.mulE(a2).addE(m2.mulE(u)).mul(4), c = o2.mulE(o2).mul(8).addE(r.mulE(a2).mul(12)).addE(m2.mulE(m2).mul(8).addE(h2.mulE(u).mul(12))), g2 = r.mulE(o2).addE(h2.mulE(m2)).mul(36), d2 = r.mulE(r).addE(h2.mulE(h2)).mul(36), _ = Rt(p2, 3), p3 = Zs(d2, g2, c, l2, new x2(0, 1), false, _);
  if (n2(p3 <= 3), p3 > 0) {
    const s4 = Vo(t2, 1, 0).sqrLength(), n7 = Vo(t2, 1, 1).sqrLength();
    let i3 = s4;
    e5.set(0), i3 < n7 && (i3 = n7, e5.set(1));
    for (let r2 = 0; r2 < p3; r2++) {
      const s5 = Vo(t2, 1, _[r2].value()).sqrLength();
      s5 < i3 && (i3 = s5, e5 = _[r2]);
    }
  }
}
function Xo(t2, e5, s4, n6) {
  if (1 === e5) {
    const e6 = 1 - s4, i2 = e6 * e6, r = s4 * s4, o2 = t2[1].sub(t2[0]), a2 = t2[2].sub(t2[1]), h2 = t2[3].sub(t2[2]), m2 = o2.mul(i2).add(a2.mul(2 * e6 * s4)).add(h2.mul(r));
    n6.assign(m2.mul(3));
  } else if (2 === e5) {
    const e6 = 1 - s4, i2 = t2[2].sub(t2[1]).sub(t2[1].sub(t2[0])), r = t2[3].sub(t2[2]).sub(t2[2].sub(t2[1])), o2 = i2.mul(e6).add(r.mul(s4));
    n6.assign(o2.mul(6));
  } else if (3 === e5) {
    const e6 = t2[2].sub(t2[1]), s5 = t2[3].sub(e6.mul(3)).sub(t2[0]);
    n6.assign(s5.mul(6));
  } else n6.setCoords(0, 0);
}
function No(t2, e5, s4, n6) {
  {
    const e6 = w2.subE(s4), i2 = e6.sqr(), r = s4.sqr(), o2 = t2[1].subE(t2[0]).mulE(i2).addE(t2[2].subE(t2[1]).mulE(new p2(2).mulE(e6).mulE(s4))).addE(t2[3].subE(t2[2]).mulE(r));
    n6.setE(o2.mulE(new p2(3)));
  }
}
function qo(t2, e5, s4) {
  const n6 = new ei();
  return Xo(t2, e5, s4, n6), n6;
}
function Fo(t2, e5, s4) {
  const n6 = [Se.constructPoint2D(t2[0]), Se.constructPoint2D(t2[1]), Se.constructPoint2D(t2[2]), Se.constructPoint2D(t2[3])], i2 = new Se();
  return No(n6, e5, s4, i2), i2;
}
function Vo(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  return t2.queryControlPoints(n6), qo(n6, e5, s4);
}
function Lo(t2) {
  const e5 = t2.m_cp[0].sub(t2.getStartXY()), s4 = t2.m_cp[1].sub(t2.m_cp[0]), n6 = t2.getEndXY().sub(t2.getStartXY());
  e5.mulThis(3), s4.mulThis(3), n6.subThis(s4), s4.subThis(e5);
  return (3 * n6.x * (2 * s4.y + 5 * e5.y) - 3 * n6.y * (2 * s4.x + 5 * e5.x) + 10 * (s4.x * e5.y - s4.y * e5.x)) / 60;
}
function Ro(t2) {
  const e5 = Rt(ei, 4);
  t2.queryControlPoints(e5);
  const s4 = zo(e5);
  return s4 && (t2.m_cp[0].setCoordsPoint2D(e5[1]), t2.m_cp[1].setCoordsPoint2D(e5[2]), t2.afterCompletedModification()), s4;
}
function zo(t2) {
  let e5 = false;
  for (let s4 = 0; s4 < 2; s4++) {
    const n6 = hs(t2[0][s4], t2[3][s4]);
    n6 > 0 ? (hs(t2[0][s4], t2[1][s4]) < 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[3][s4]) < 0 && (t2[1][s4] = t2[3][s4], e5 = true), hs(t2[0][s4], t2[2][s4]) < 0 && (t2[2][s4] = t2[0][s4], e5 = true), hs(t2[2][s4], t2[3][s4]) < 0 && (t2[2][s4] = t2[3][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) < 0 && (t2[2][s4] = t2[1][s4], e5 = true)) : n6 < 0 ? (hs(t2[0][s4], t2[1][s4]) > 0 && (t2[1][s4] = t2[0][s4], e5 = true), hs(t2[1][s4], t2[3][s4]) > 0 && (t2[1][s4] = t2[3][s4], e5 = true), hs(t2[0][s4], t2[2][s4]) > 0 && (t2[2][s4] = t2[0][s4], e5 = true), hs(t2[2][s4], t2[3][s4]) > 0 && (t2[2][s4] = t2[3][s4], e5 = true), hs(t2[1][s4], t2[2][s4]) > 0 && (t2[2][s4] = t2[1][s4], e5 = true)) : t2[1][s4] === t2[0][s4] && t2[2][s4] === t2[0][s4] || (t2[1][s4] = t2[0][s4], t2[2][s4] = t2[0][s4], e5 = true);
  }
  return e5;
}
function ko(t2) {
  const e5 = hs(t2[0].y, t2[1].y), s4 = hs(t2[1].y, t2[2].y), n6 = hs(t2[2].y, t2[3].y);
  if (e5 >= 0 && s4 >= 0 && n6 >= 0 || e5 <= 0 && s4 <= 0 && n6 <= 0) {
    const e6 = hs(t2[0].x, t2[1].x), s5 = hs(t2[1].x, t2[2].x), n7 = hs(t2[2].x, t2[3].x);
    if (e6 >= 0 && s5 >= 0 && n7 >= 0 || e6 <= 0 && s5 <= 0 && n7 <= 0) return true;
  }
  return false;
}
function Bo(t2, e5, s4) {
  const n6 = new ei(), i2 = new ei(), r = new ei(), o2 = new ei(), a2 = new ei();
  e5 <= 0.5 ? (F(2, t2[0], t2[1], e5, n6), F(2, t2[1], t2[2], e5, i2), F(2, t2[2], t2[3], e5, r), F(2, n6, i2, e5, o2), F(2, i2, r, e5, a2), F(2, o2, a2, e5, s4)) : (k2(2, t2[0], t2[1], e5, n6), k2(2, t2[1], t2[2], e5, i2), k2(2, t2[2], t2[3], e5, r), k2(2, n6, i2, e5, o2), k2(2, i2, r, e5, a2), k2(2, o2, a2, e5, s4));
}
function Go(t2, e5, n6, i2) {
  n2(e5 >= 0 && e5 <= 1);
  const r = new ei(), o2 = new ei(), a2 = new ei(), h2 = new ei(), m2 = new ei(), u = new ei();
  e5 <= 0.5 ? (F(2, t2[0], t2[1], e5, r), F(2, t2[1], t2[2], e5, o2), F(2, t2[2], t2[3], e5, a2), F(2, r, o2, e5, h2), F(2, o2, a2, e5, m2), F(2, h2, m2, e5, u)) : (k2(2, t2[0], t2[1], e5, r), k2(2, t2[1], t2[2], e5, o2), k2(2, t2[2], t2[3], e5, a2), k2(2, r, o2, e5, h2), k2(2, o2, a2, e5, m2), k2(2, h2, m2, e5, u));
  const l2 = t2[3].clone();
  n6 && (n6[0].assign(t2[0]), n6[1].assign(r), n6[2].assign(h2), n6[3].assign(u)), i2 && (i2[0].assign(u), i2[1].assign(m2), i2[2].assign(a2), i2[3].assign(l2));
}
function Wo(t2, e5, n6, i2) {
  if (n2(e5 >= 0 && n6 <= 1 && e5 <= n6), e5 === n6) {
    const s4 = new ei();
    return jo(t2, e5, s4), i2[0].assign(s4), i2[1].assign(s4), i2[2].assign(s4), void i2[3].assign(s4);
  }
  if (0 === e5 && 1 === n6) {
    for (let e6 = 0; e6 < 4; ++e6) i2[e6].assign(t2[e6]);
    return;
  }
  const r = Rt(ei, 4);
  Go(t2, n6, r, null), Go(r, n6 > 0 ? e5 / n6 : 0, null, r), jo(t2, e5, r[0]), jo(t2, n6, r[3]), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]), i2[2].setCoordsPoint2D(r[2]), i2[3].setCoordsPoint2D(r[3]);
}
function jo(t2, e5, s4, n6) {
  if (n6) {
    if (e5 < 0) {
      return void rs2(new su({ start: t2[0], end: t2[0].add(Uo(t2, 0).getUnitVector()) }), e5, s4);
    }
    if (e5 > 1) {
      return void rs2(new su({ start: t2[3], end: t2[3].add(Uo(t2, 1).getUnitVector()) }), e5 - 1, s4);
    }
  }
  if (e5 <= 0.5) {
    const n7 = new ei();
    F(2, t2[0], t2[1], e5, n7);
    const i2 = new ei();
    F(2, t2[1], t2[2], e5, i2);
    const r = new ei();
    F(2, t2[2], t2[3], e5, r);
    const o2 = new ei();
    F(2, n7, i2, e5, o2);
    const a2 = new ei();
    F(2, i2, r, e5, a2), F(2, o2, a2, e5, s4);
  } else {
    const n7 = new ei();
    k2(2, t2[0], t2[1], e5, n7);
    const i2 = new ei();
    k2(2, t2[1], t2[2], e5, i2);
    const r = new ei();
    k2(2, t2[2], t2[3], e5, r);
    const o2 = new ei();
    k2(2, n7, i2, e5, o2);
    const a2 = new ei();
    k2(2, i2, r, e5, a2), k2(2, o2, a2, e5, s4);
  }
}
function Zo(t2, e5, s4) {
  if (e5.value() <= 0.5) {
    const n6 = new Se();
    O(2, Se.constructPoint2D(t2[0]), Se.constructPoint2D(t2[1]), e5, n6);
    const i2 = new Se();
    O(2, Se.constructPoint2D(t2[1]), Se.constructPoint2D(t2[2]), e5, i2);
    const r = new Se();
    O(2, Se.constructPoint2D(t2[2]), Se.constructPoint2D(t2[3]), e5, r);
    const o2 = new Se();
    O(2, n6, i2, e5, o2);
    const a2 = new Se();
    O(2, i2, r, e5, a2), O(2, o2, a2, e5, s4);
  } else {
    const n6 = new Se();
    G2(2, Se.constructPoint2D(t2[0]), Se.constructPoint2D(t2[1]), e5, n6);
    const i2 = new Se();
    G2(2, Se.constructPoint2D(t2[1]), Se.constructPoint2D(t2[2]), e5, i2);
    const r = new Se();
    G2(2, Se.constructPoint2D(t2[2]), Se.constructPoint2D(t2[3]), e5, r);
    const o2 = new Se();
    G2(2, n6, i2, e5, o2);
    const a2 = new Se();
    G2(2, i2, r, e5, a2), G2(2, o2, a2, e5, s4);
  }
}
function Ho(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), Zo(n6, e5, s4);
}
function Uo(t2, e5) {
  const s4 = ks(e5, 0, 1);
  let n6 = qo(t2, 1, s4);
  return n6.isZero() && (n6 = qo(t2, 2, s4), n6.isZero() ? n6 = qo(t2, 3, s4) : 1 === s4 && n6.negateThis()), n6;
}
function Oo(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), Qo(n6, e5, s4);
}
function Qo(t2, e5, s4) {
  e5.value() < 0 && e5.set(0, e5.eps()), e5.value() > 1 && e5.set(1, e5.eps()), s4.setE(Fo(t2, 1, e5));
}
function Jo(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== sa(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Ko(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== na(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function $o(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== ia(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function ta(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== ra(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function ea(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return t2 ? 4 : 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== oa(t2, e5, s4, null, null, null, n6, i2 ?? false, true, false) ? 4 : 0;
}
function sa(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  if (null !== i2 && (i2.length = 0), null != r && (r.length = 0), null !== n6 && (n6.length = 0), s4.isDegenerate(0)) {
    const t3 = [0, 0, 0], a3 = e5.intersectPoint(s4.getStartXY(), t3, o2);
    if (a3 > 0) {
      if (null !== i2) for (let e6 = 0; e6 < a3; e6++) i2.push(t3[e6]);
      if (null !== r) for (let t4 = 0; t4 < a3; t4++) r.push(0);
      if (null != n6) for (let s5 = 0; s5 < a3; s5++) {
        const i3 = new ei();
        e5.queryCoord2D(t3[s5], i3), n6.push(i3);
      }
    }
    return a3;
  }
  const u = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, u))) return 0;
  const l2 = Rt(ei, 4);
  _o(e5, l2);
  const c = s4.getEndXY();
  c.subThis(s4.getStartXY());
  const g2 = c.clone();
  g2.leftPerpendicularThis();
  let d2 = 3 * l2[3].dotProduct(g2), _ = 2 * l2[2].dotProduct(g2), p3 = l2[1].dotProduct(g2);
  const f3 = Lt(15, Number.NaN), P5 = Lt(15, Number.NaN);
  let y2 = qs2(d2, _, p3, x2.unit(), false, f3);
  y2 < 0 && (f3[0] = 0, f3[1] = 1, y2 = 2);
  let x4, C2 = 0;
  for (let E2 = 0, S3 = C2; E2 < y2; ++E2) {
    const t3 = e5.getCoord2D(f3[E2 + S3]);
    P5[C2] = s4.getClosestCoordinate(t3, false), ei.distance(t3, s4.getCoord2D(P5[C2])) <= o2 && (f3[C2] = f3[E2 + S3], C2++);
  }
  if (l2[0].subThis(s4.getStartXY()), Math.abs(c.x) >= Math.abs(c.y)) {
    const t3 = c.y / c.x;
    d2 = l2[3].y - l2[3].x * t3, _ = l2[2].y - l2[2].x * t3, p3 = l2[1].y - l2[1].x * t3, x4 = l2[0].y - l2[0].x * t3;
  } else {
    const t3 = c.x / c.y;
    d2 = l2[3].x - l2[3].y * t3, _ = l2[2].x - l2[2].y * t3, p3 = l2[1].x - l2[1].y * t3, x4 = l2[0].x - l2[0].y * t3;
  }
  const v3 = e5.getEndXY().equals(s4.getStartXY()) || e5.getEndXY().equals(s4.getEndXY()), b2 = [0, 0, 0];
  y2 = Fs2(d2, _, p3, x4, x2.unit(), v3, b2);
  for (let E2 = 0, S3 = C2; E2 < y2; ++E2) {
    f3[E2 + S3] = b2[E2];
    const t3 = e5.getCoord2D(f3[E2 + S3]);
    P5[C2] = s4.getClosestCoordinate(t3, false);
    ei.distance(t3, s4.getCoord2D(P5[C2])) <= o2 && (f3[C2] = f3[E2 + S3], C2++);
  }
  y2 = e5.intersectPoint(s4.getStartXY(), b2, o2);
  for (let E2 = 0; E2 < y2; E2++) f3[C2] = b2[E2], P5[C2++] = 0;
  y2 = e5.intersectPoint(s4.getEndXY(), b2, o2);
  for (let E2 = 0; E2 < y2; E2++) f3[C2] = b2[E2], P5[C2++] = 1;
  return 0 !== s4.intersectPoint(e5.getStartXY(), b2, o2) && (P5[C2] = b2[0], f3[C2++] = 0), 0 !== s4.intersectPoint(e5.getEndXY(), b2, o2) && (P5[C2] = b2[0], f3[C2++] = 1), 0 === C2 ? 0 : Km(t2, e5, s4, f3, P5, C2, n6, i2, r, o2, a2, h2, m2);
}
function na(t2, e5, s4, n6, i2, r, o2, a2, h2, m2) {
  if (zh(s4)) {
    return sa(t2, e5, new su({ start: s4.getStartXY(), end: s4.getEndXY() }), n6, i2, r, o2, a2, h2, m2);
  }
  const u = Oe(e5, s4);
  if (Qe(e5, s4, o2 = Math.max(o2, u))) return 0;
  const l2 = [], c = [], g2 = [], d2 = Rt(ei, 4);
  {
    e5.queryControlPoints(d2);
    const t3 = Rt(ei, 4), n7 = new x3();
    s4.canonicToWorldTransformation(n7);
    const i3 = new x3();
    i3.setInvert(n7), i3.transformPoints2D(d2, 4, t3);
    const r2 = Rt(an, 4);
    xo(t3, r2);
    const a3 = [r2[0].x, r2[1].x, r2[2].x, r2[3].x], h3 = [r2[0].y, r2[1].y, r2[2].y, r2[3].y], m3 = Rt(Hs, 3);
    m3[0].setDouble(s4.getSemiMinorAxis()), m3[0].sqrThis(), m3[1].setDouble(s4.getSemiMajorAxis()), m3[1].sqrThis(), m3[2].setThis(m3[0]), m3[2].mulThis(m3[1]), m3[2].negateThis();
    const u2 = _n(a3, 3, h3, 3, null, 0, m3, true, x2.unit(), x2.unit(), c);
    if (u2 > 0) {
      let t4 = 0;
      for (let n8 = 0; n8 < u2; n8++) {
        const i4 = new ei();
        e5.queryCoord2D(c[n8], i4);
        const r3 = s4.getClosestCoordinate(i4, false), a4 = new ei();
        s4.queryCoord2D(r3, a4);
        ei.distance(i4, a4) <= o2 && (l2.push(i4.clone()), c[t4] = c[n8], g2.push(r3), t4++);
      }
      c.length = t4, l2.length = t4;
    }
  }
  const _ = [0, 1];
  for (let p3 = 0; p3 < 2; p3++) {
    const t3 = 0 === p3 ? s4.getStartXY() : s4.getEndXY(), e6 = [0];
    la(d2, t3, x2.unit(), false, -1, 1, e6);
    const n7 = new ei();
    jo(d2, e6[0], n7);
    ei.distance(t3, n7) <= o2 && (c.push(e6[0]), g2.push(_[p3]), l2.push(n7.clone()));
  }
  for (let p3 = 0; p3 < 2; p3++) {
    const t3 = [0, 3];
    {
      const e6 = s4.getClosestCoordinate(d2[t3[p3]], false), n7 = new ei();
      s4.queryCoord2D(e6, n7);
      ei.distance(d2[t3[p3]], n7) <= o2 && (c.push(_[p3]), g2.push(e6), l2.push(n7.clone()));
    }
  }
  return Km(t2, e5, s4, c, g2, c.length, n6, i2, r, o2, a2, h2, m2);
}
function ia(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  const l2 = Rt(ei, 4);
  e5.queryControlPoints(l2);
  const c = Rt(ei, 4);
  if (n6.queryControlPoints(c), Je(l2, c, 4) < 0) return ia(t2, n6, e5, i2, o2, r, a2, h2, m2, !u);
  const g2 = Oe(e5, n6);
  if (Qe(e5, n6, a2 = Math.max(a2, g2))) return 0;
  if (Da(e5, n6, i2, r, o2, a2, h2, m2, u)) return 2;
  const d2 = new x2(0, 1), _ = new x2(0, 1);
  {
    const t3 = new ve();
    ma(l2, new x2(0, 1), t3);
    const e6 = new ve();
    ma(c, new x2(0, 1), e6);
    const s4 = Math.max(t3.maxDim(), e6.maxDim());
    if (t3.inflate(3 * a2), e6.inflate(3 * a2), !t3.intersectW(e6)) return 0;
    if (t3.maxDim() < 0.1 * s4) {
      if (xa(l2, t3, d2), xa(c, t3, _), d2.isEmpty() || _.isEmpty()) return 0;
      Wo(l2, d2.vmin, d2.vmax, l2), Wo(c, _.vmin, _.vmax, c);
    }
  }
  const p3 = tu(l2, 3, c, 3, a2);
  if (0 === p3) return 0;
  const f3 = [], P5 = [], y2 = [];
  let x4 = false;
  if (-1 === p3) {
    const t3 = Rt(an, 4);
    xo(l2, t3);
    const e6 = [t3[0].x, t3[1].x, t3[2].x, t3[3].x], s4 = [t3[0].y, t3[1].y, t3[2].y, t3[3].y], n7 = Rt(an, 4);
    xo(c, n7);
    const i3 = [], r2 = [], o3 = cn(e6, 3, s4, 3, null, 0, [n7[0].x, n7[1].x, n7[2].x, n7[3].x], 3, [n7[0].y, n7[1].y, n7[2].y, n7[3].y], 3, null, 0, true, x2.unit(), x2.unit(), i3, r2);
    if (o3 > 0) for (let h3 = 0; h3 < o3; h3++) {
      const t4 = new ei();
      jo(c, r2[h3], t4);
      const e7 = new ei();
      jo(l2, i3[h3], e7);
      ei.distance(e7, t4) <= a2 && (f3.push(e7.clone()), y2.push(r2[h3]), P5.push(i3[h3]));
    }
    else -1 === o3 && (x4 = true);
  }
  for (let s4 = 0; s4 < 2; s4++) {
    const t3 = 0 === s4 ? l2 : c, e6 = 0 === s4 ? c : l2;
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : 3, r2 = [0];
      la(e6, t3[i3], x2.unit(), false, -1, 1, r2);
      const o3 = new ei();
      jo(e6, r2[0], o3);
      ei.distance(t3[i3], o3) <= a2 && (0 === s4 ? (P5.push(0 === i3 ? 0 : 1), y2.push(r2[0])) : (y2.push(0 === i3 ? 0 : 1), P5.push(r2[0])), f3.push(o3.clone()));
    }
  }
  if (0 === P5.length && x4) {
    const t3 = e5.calculateUpperLength2D() > n6.calculateUpperLength2D();
    {
      const i3 = [0, 0];
      if (2 === pa(t3 ? e5 : n6, i3, true) && (n2(x2.unit().containsCoordinate(i3[0])), !x2.unit().containsCoordinate(i3[1]))) {
        const e6 = new ei();
        jo(t3 ? l2 : c, i3[0], e6);
        const s4 = [0, 0];
        1 === la(t3 ? c : l2, e6, x2.unit(), false, -1, 2, s4) && (f3.push(e6.clone()), P5.push(t3 ? i3[0] : s4[0]), y2.push(t3 ? s4[0] : i3[0]));
      }
    }
  }
  if (0 === P5.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let s4 = 0; s4 < P5.length; ++s4) P5[s4] = mo.recalculateParentT(d2.vmin, d2.vmax, P5[s4]);
  if (!_.equalsRange(0, 1)) for (let s4 = 0; s4 < y2.length; ++s4) y2[s4] = mo.recalculateParentT(_.vmin, _.vmax, y2[s4]);
  return Km(t2, e5, n6, P5, y2, P5.length, i2, r, o2, a2, h2, m2, u);
}
function ra(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  const l2 = Oe(e5, n6);
  if (n6.isDegenerateToLineHelper(l2)) {
    const s4 = new su({ start: n6.getStartXY(), end: n6.getEndXY() }), l3 = sa(t2, e5, s4, i2, r, o2, a2, h2, m2, u);
    if (o2) for (let t3 = 0; t3 < l3; ++t3) {
      const e6 = s4.getCoord2D(o2[t3]);
      o2[t3] = n6.getClosestCoordinate(e6, false);
    }
    return l3;
  }
  if (Qe(e5, n6, a2 = Math.max(a2, l2))) return 0;
  const c = Rt(ei, 4);
  e5.queryControlPoints(c);
  const g2 = Rt(ei, 3);
  n6.queryControlPoints(g2);
  const d2 = new x2(0, 1), _ = new x2(0, 1), p3 = [0, 0, 0];
  n6.queryWeights(p3);
  const f3 = [1, tr(p3), 1];
  {
    const t3 = new ve();
    ma(c, new x2(0, 1), t3);
    const e6 = new ve();
    wi(g2, f3, new x2(0, 1), e6);
    const s4 = Math.max(t3.maxDim(), e6.maxDim());
    if (t3.inflate(3 * a2), e6.inflate(3 * a2), !t3.intersectW(e6)) return 0;
    if (t3.maxDim() < 0.1 * s4) {
      if (xa(c, t3, d2), $i(g2, f3, t3, _), d2.isEmpty() || _.isEmpty()) return 0;
      Wo(c, d2.vmin, d2.vmax, c), Xi(g2, f3, _.vmin, _.vmax, g2, f3);
    }
  }
  const P5 = tu(c, 3, g2, 2, a2);
  if (0 === P5) return 0;
  const y2 = [], x4 = [], C2 = [];
  if (-1 === P5) {
    const t3 = Rt(an, 4);
    xo(c, t3);
    const e6 = [t3[0].x, t3[1].x, t3[2].x, t3[3].x], s4 = [t3[0].y, t3[1].y, t3[2].y, t3[3].y], n7 = Rt(Hs, 3), i3 = Rt(Hs, 3), r2 = Rt(Hs, 3);
    Zi(g2, f3, n7, i3, r2);
    const o3 = [], h3 = [], m3 = cn(n7, 2, i3, 2, r2, 2, e6, 3, s4, 3, null, 0, true, x2.unit(), x2.unit(), h3, o3);
    if (m3 > 0) for (let u2 = 0; u2 < m3; u2++) {
      const t4 = new ei();
      jo(c, o3[u2], t4);
      const e7 = new ei();
      Ki(g2, f3, h3[u2], e7);
      ei.distance(t4, e7) <= a2 && (y2.push(t4.clone()), x4.push(o3[u2]), C2.push(h3[u2]));
    }
  }
  for (let v3 = 0; v3 < 2; v3++) {
    let t3, e6;
    0 === v3 ? (t3 = c, e6 = g2) : (e6 = c, t3 = g2);
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t3.length - 1, r2 = [0], o3 = new ei();
      if (0 === v3) {
        const n8 = bi(e6, f3, t3[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), Ki(e6, f3, r2[0], o3);
      } else {
        const n8 = la(e6, t3[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), jo(e6, r2[0], o3);
      }
      ei.distance(t3[i3], o3) <= a2 && (0 === v3 ? (x4.push(0 === i3 ? 0 : 1), C2.push(r2[0])) : (C2.push(0 === i3 ? 0 : 1), x4.push(r2[0])), y2.push(o3.clone()));
    }
  }
  if (0 === x4.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let s4 = 0; s4 < x4.length; ++s4) x4[s4] = mo.recalculateParentT(d2.vmin, d2.vmax, x4[s4]);
  if (!_.equalsRange(0, 1)) for (let s4 = 0; s4 < C2.length; ++s4) C2[s4] = on.recalculateParentT(_.vmin, _.vmax, C2[s4]);
  for (let s4 = 0; s4 < C2.length; ++s4) C2[s4] = er(p3, C2[s4]);
  return Km(t2, e5, n6, x4, C2, x4.length, i2, r, o2, a2, h2, m2, u);
}
function oa(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  const l2 = Oe(e5, n6);
  if (Qe(e5, n6, a2 = Math.max(a2, l2))) return 0;
  const c = Rt(ei, 4);
  e5.queryControlPoints(c);
  const g2 = Rt(ei, 3);
  n6.queryControlPoints(g2);
  const d2 = tu(c, 3, g2, 2, a2);
  if (0 === d2) return 0;
  const _ = [], p3 = [], f3 = [];
  if (-1 === d2) {
    const t3 = Rt(an, 4);
    xo(c, t3);
    const s4 = [t3[0].x, t3[1].x, t3[2].x, t3[3].x], i3 = [t3[0].y, t3[1].y, t3[2].y, t3[3].y], r2 = Rt(an, 3);
    Qr(g2, r2);
    const o3 = cn([r2[0].x, r2[1].x, r2[2].x], 2, [r2[0].y, r2[1].y, r2[2].y], 2, null, 0, s4, 3, i3, 3, null, 0, true, x2.unit(), x2.unit(), f3, p3);
    if (o3 > 0) {
      let t4 = 0;
      for (let s5 = 0; s5 < o3; s5++) {
        const i4 = new ei();
        e5.queryCoord2D(p3[s5], i4);
        const r3 = new ei();
        n6.queryCoord2D(f3[s5], r3);
        ei.distance(i4, r3) <= a2 && (_.push(i4.clone()), p3[t4] = p3[s5], f3[t4] = f3[s5], t4++);
      }
      p3.length = t4, _.length = t4;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    let t3, e6;
    0 === P5 ? (t3 = c, e6 = g2) : (e6 = c, t3 = g2);
    for (let n7 = 0; n7 < 2; n7++) {
      const i3 = 0 === n7 ? 0 : t3.length - 1, r2 = [0], o3 = new ei();
      if (0 === P5) Ar(e6, t3[i3], r2), Jr(e6, r2[0], o3);
      else {
        const n8 = la(e6, t3[i3], x2.unit(), false, -1, 1, r2);
        n2(1 === n8), jo(e6, r2[0], o3);
      }
      ei.distance(t3[i3], o3) <= a2 && (0 === P5 ? (p3.push(0 === i3 ? 0 : 1), f3.push(r2[0])) : (f3.push(0 === i3 ? 0 : 1), p3.push(r2[0])), _.push(o3.clone()));
    }
  }
  return Km(t2, e5, n6, p3, f3, p3.length, i2, r, o2, a2, h2, m2, u);
}
function aa(t2, e5, i2, r, o2) {
  const a2 = new ve();
  if (ha(t2, x2.unit(), a2), a2.inflate(r), !a2.isIntersectingPoint2D(e5)) return 0;
  const h2 = Eo(t2);
  let m2 = 0, u = h2.specialPoints[0];
  const l2 = [];
  for (let n6 = 1, c = h2.specialPoints.length; n6 < c; ++n6) {
    const i3 = h2.specialPoints[n6], r2 = Mo(t2, e5, u, i3);
    if (0 === l2.length) l2.push(r2);
    else if (r2.t === r2.tmin) n2(l2.at(-1).d <= r2.d), l2.at(-1).tmax = r2.tmax;
    else if (l2.at(-1).t === l2.at(-1).tmax) {
      n2(l2.at(-1).d >= r2.d);
      const t3 = l2.at(-1).tmin;
      l2[l2.length - 1] = r2, l2.at(-1).tmin = t3;
    } else l2.push(r2);
    u = i3;
  }
  for (const s4 of l2) if (s4.d <= r) {
    const t3 = s4.t;
    i2 ? (m2 >= i2.length && A(""), i2[m2] = t3, m2++) : m2++;
  }
  return m2;
}
function ha(t2, e5, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), ma(n6, e5, s4);
}
function ma(t2, e5, s4) {
  if (e5.equalsRange(0, 1)) return void s4.setFromPoints(t2, 4);
  const n6 = Rt(ei, 4);
  Wo(t2, e5.vmin, e5.vmax, n6), s4.setFromPoints(n6, 4);
}
var ua = class {
  constructor(t2, e5) {
    this.controlPoints = t2, this.point = e5.clone();
  }
  getMaxDerivative() {
    return 6;
  }
  getValue(t2, e5) {
    switch (t2) {
      case 0: {
        const t3 = new ei();
        jo(this.controlPoints, e5, t3);
        const s4 = qo(this.controlPoints, 1, e5);
        return 2 * t3.sub(this.point).dotProduct(s4);
      }
      case 1: {
        const t3 = new ei();
        jo(this.controlPoints, e5, t3);
        const s4 = qo(this.controlPoints, 1, e5), n6 = qo(this.controlPoints, 2, e5);
        return 2 * (t3.sub(this.point).dotProduct(n6) + s4.dotProduct(s4));
      }
      case 2: {
        const t3 = new ei();
        jo(this.controlPoints, e5, t3);
        const s4 = qo(this.controlPoints, 1, e5), n6 = qo(this.controlPoints, 2, e5), i2 = qo(this.controlPoints, 3, e5);
        return 2 * (t3.sub(this.point).dotProduct(i2) + 3 * s4.dotProduct(n6));
      }
      case 3: {
        const t3 = qo(this.controlPoints, 1, e5), s4 = qo(this.controlPoints, 2, e5), n6 = qo(this.controlPoints, 3, e5);
        return 2 * (4 * t3.dotProduct(n6) + 3 * s4.sqrLength());
      }
      case 4: {
        const t3 = qo(this.controlPoints, 2, e5), s4 = qo(this.controlPoints, 3, e5);
        return 2 * (10 * t3.dotProduct(s4));
      }
      case 5: {
        const t3 = qo(this.controlPoints, 3, e5);
        return 2 * (10 * t3.dotProduct(t3));
      }
      default:
        return 0;
    }
  }
  getError(t2) {
    return 0;
  }
};
function la(t2, e5, n6, i2, r, o2, a2) {
  D(x2.unit().contains(n6) && o2 > 0, "getClosestCoordinate"), (r < 0 || Number.isNaN(r)) && (r = Number.MAX_VALUE);
  const h2 = [], m2 = new ei();
  jo(t2, n6.vmin, m2);
  let u = ei.distance(m2, e5);
  if (u <= r && h2.push(new ei(n6.vmin, u)), n6.vmin !== n6.vmax && (jo(t2, n6.vmax, m2), u = ei.distance(m2, e5), u <= r && h2.push(new ei(n6.vmax, u))), n6.width() > 0) {
    const s4 = Lt(18, Number.NaN), i3 = Xs2(new ua(t2, e5), n6, 18, s4);
    for (let n7 = 0; n7 < i3; n7++) jo(t2, s4[n7], m2), u = ei.distance(m2, e5), u > r || h2.push(new ei(s4[n7], u));
  }
  if (i2) {
    n2(n6.equals(x2.unit()));
    {
      jo(t2, -1, m2, true);
      const s4 = new ei();
      jo(t2, 0, s4);
      const n7 = new su({ start: m2, end: s4 }), i3 = n7.getClosestCoordinate(e5, true);
      i3 < 1 && (m2.assign(n7.getCoord2D(i3)), u = ei.distance(m2, e5), u <= r && h2.push(new ei(i3 - 1, u)));
    }
    {
      jo(t2, 2, m2, true);
      const s4 = new ei();
      jo(t2, n6.vmax, s4);
      const i3 = new su({ start: s4, end: m2 }), o3 = i3.getClosestCoordinate(e5, true);
      o3 > 0 && (m2.assign(i3.getCoord2D(o3)), u = ei.distance(m2, e5), u <= r && h2.push(new ei(1 + o3, u)));
    }
  }
  if (!h2.length) return 0;
  h2.sort((t3, e6) => t3.compare(e6));
  let c = 0;
  const g2 = h2[0].x;
  if (a2[c++] = g2, c < o2) {
    const e6 = Rt2(t2, 4, false).total(), s4 = h2[0].y;
    for (let t3 = 1, n7 = h2.length; t3 < n7; t3++) if (h2[t3].y > s4 + e6) {
      h2.length = t3;
      break;
    }
    h2.sort((t3, e7) => Dt(t3.x, e7.x)), c = 0, a2[c++] = h2[0].x;
    for (let t3 = 1, n7 = h2.length; t3 < n7; t3++) h2[t3].x !== a2[c - 1] && c < o2 && (a2[c++] = h2[t3].x);
  }
  return c;
}
function ca(t2, e5, s4, n6, i2, r, o2) {
  const a2 = Rt(ei, 4);
  return t2.queryControlPoints(a2), la(a2, e5, s4, n6, i2, r, o2);
}
function ga(t2) {
  return t2.getStartXY().norm(1) + t2.getEndXY().norm(1) + t2.m_cp[0].norm(1) + t2.m_cp[1].norm(1);
}
function da(t2) {
  return t2[0].norm(1) + t2[1].norm(1) + t2[2].norm(1) + t2[3].norm(1);
}
function _a(t2, e5, n6) {
  if (n2(n6 >= 2), 2 === n6) {
    const s4 = new ei();
    Y(e5[0], e5[n6 - 1], 1 / 3, s4);
    const i3 = new ei();
    return Y(e5[0], e5[n6 - 1], 2 / 3, i3), void t2.construct(e5[0], s4, i3, e5[n6 - 1]);
  }
  const i2 = e5[0], r = e5[n6 - 1], o2 = [0, 0], a2 = ca(t2, i2, x2.unit(), false, Number.NaN, 2, o2), h2 = [0, 0], m2 = ca(t2, r, x2.unit(), false, Number.NaN, 2, h2), u = [];
  for (let s4 = 0; s4 < a2; s4++) for (let a3 = 0; a3 < m2; a3++) {
    const m3 = o2[s4], l3 = h2[a3], c2 = (s5, o3) => {
      const a4 = Lt(n6 - 2, Number.NaN), h3 = () => {
        let t3 = 0;
        for (let s6 = 1, i3 = n6 - 1; s6 < i3; s6++) {
          t3 += ei.distance(e5[s6 - 1], e5[s6]);
          const n7 = t3;
          a4[s6 - 1] = n7;
        }
        t3 += ei.distance(e5[n6 - 2], e5[n6 - 1]);
        for (let e6 = 1, s6 = n6 - 1; e6 < s6; e6++) a4[e6 - 1] /= t3;
      };
      let u2 = false, c3 = false;
      {
        const e6 = new nu();
        m3 <= l3 ? (t2.queryCut(m3, l3, e6, true), s5.assign(e6.get().getControlPoint1()), o3.assign(e6.get().getControlPoint2())) : (t2.queryCut(l3, m3, e6, true), s5.assign(e6.get().getControlPoint2()), o3.assign(e6.get().getControlPoint1())), i2.equals(s5) && (u2 = true), r.equals(o3) && (c3 = true);
      }
      h3();
      let g4 = Number.MAX_VALUE;
      const d4 = s5.clone(), _2 = o3.clone();
      for (let t3 = 0; t3 < 5; t3++) {
        g4 = wa(true, false, i2, d4, _2, r, u2, c3, a4, n6 - 2, e5, n6);
      }
      for (let t3 = 0; t3 < 30; t3++) {
        const t4 = d4.clone();
        _2.clone();
        const s6 = wa(true, true, i2, d4, _2, r, u2, c3, a4, n6 - 2, e5, n6);
        if (g4 <= s6 && t4.equals(d4) && t4.equals(_2)) break;
        g4 = s6;
      }
      h3();
      let p3 = false, f3 = Number.EPSILON;
      const P5 = s5.clone(), y2 = o3.clone();
      for (let t3 = 0; t3 < 30; t3++) {
        const t4 = P5.clone();
        y2.clone();
        const s6 = wa(p3, true, i2, P5, y2, r, u2, c3, a4, n6 - 2, e5, n6);
        if (f3 <= s6 && t4.equals(P5) && t4.equals(y2)) break;
        p3 = true, f3 = s6;
      }
      return f3 < g4 ? (s5.assign(P5), o3.assign(y2)) : (s5.assign(d4), o3.assign(_2), f3 = g4), f3;
    }, g3 = new ei(), d3 = new ei(), _ = [c2(g3, d3), ei.distance(i2, g3) + ei.distance(g3, d3) + ei.distance(d3, r), g3.x, g3.y, d3.x, d3.y];
    u.splice(u.length, 0, ..._);
  }
  let l2 = u[0], c = u[1], g2 = 0;
  for (let s4 = 6; s4 < u.length; s4 += 6) u[s4] < l2 && (l2 = u[s4], c = u[s4 + 1], g2 = s4);
  let d2 = g2;
  for (let s4 = 0; s4 < u.length; s4 += 6) s4 !== g2 && u[s4 + 1] < c && Math.abs(l2 - u[s4]) < 10 * l2 && (c = u[s4 + 1], d2 = s4);
  t2.construct(i2, new ei(u[d2 + 2], u[d2 + 3]), new ei(u[d2 + 4], u[d2 + 5]), r);
}
function pa(t2, e5, s4 = false) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6);
  const i2 = Rt(an, 4);
  let r, o2, a2;
  xo(n6, i2, true);
  const h2 = i2[3].x.isZero(), m2 = i2[3].y.isZero();
  if (h2 || m2) if (h2 && !m2) {
    if (i2[2].x.isZero()) return 0;
    r = i2[1].x.div(i2[2].x).negate(), o2 = i2[2].y.div(i2[3].y), a2 = i2[1].y.div(i2[3].y);
  } else {
    if (h2 || !m2) return 0;
    if (i2[2].y.isZero()) return 0;
    r = i2[1].y.div(i2[2].y).negate(), o2 = i2[2].x.div(i2[3].x), a2 = i2[1].x.div(i2[3].x);
  }
  else {
    i2[2].x.divThis(i2[3].x), i2[1].x.divThis(i2[3].x), i2[2].y.divThis(i2[3].y), i2[1].y.divThis(i2[3].y);
    const t3 = i2[2].x.sub(i2[2].y);
    if (t3.isZero()) return 0;
    r = i2[1].x.sub(i2[1].y).div(t3).negate(), o2 = i2[2].x.clone(), a2 = i2[1].x.clone();
  }
  if (!s4 && r.abs().value() > 2) return 0;
  const u = [0, 0], l2 = t2.getStartXY().equals(t2.getEndXY()), c = qs2(1, -r.toDouble(), r.add(o2).mul(r).add(a2).toDouble(), x2.unit(), l2, u);
  if (0 === c) return 0;
  if (u[0] >= 0 && u[0] <= 1) {
    const t3 = r.toDouble() - u[0];
    if (s4 || t3 >= 0 && t3 <= 1) return e5[0] = u[0], e5[1] = t3, e5[0] > e5[1] && (e5[1] = Mt(e5[0], e5[0] = e5[1])), 2;
  }
  if (2 === c && u[1] >= 0 && u[1] <= 1) {
    const t3 = r.toDouble() - u[1];
    if (s4 || t3 >= 0 && t3 <= 1) return e5[0] = u[1], e5[1] = t3, e5[0] > e5[1] && (e5[1] = Mt(e5[0], e5[0] = e5[1])), 2;
  }
  return 0;
}
function fa(t2, e5, s4) {
  const n6 = t2[1].mulE(e5[2]).subThisE(t2[2].mulE(e5[1])), i2 = t2[1].mulE(e5[3]).subThisE(t2[3].mulE(e5[1])).mulThis(3), r = t2[2].mulE(e5[3]).subThisE(t2[3].mulE(e5[2])).mulThis(3), o2 = Rt(p2, 2);
  let a2 = js2(r, i2, n6, new x2(0, 1), false, o2);
  a2 < 0 && (a2 = 0);
  let h2 = 0;
  for (let m2 = 0; m2 < a2; m2++) Fs(o2[m2].value(), 0, 1) || (s4[h2].setE(o2[m2]), h2++);
  return h2;
}
function Pa(t2, e5) {
  e5[0].set(0);
  let n6 = 1;
  const i2 = Rt(p2, 4);
  Po(t2, i2, true);
  const r = Rt(p2, 4);
  yo(t2, r, true);
  {
    const t3 = i2[3].mul(3), s4 = i2[2].mul(2), r2 = i2[1].clone(), o2 = Rt(p2, 2);
    let a2 = js2(t3, s4, r2, new x2(0, 1), false, o2);
    a2 < 0 && (a2 = 0);
    for (let i3 = 0; i3 < a2; i3++) Fs(o2[i3].value(), 0, 1) || (e5[n6] = o2[i3], n6++);
  }
  {
    const t3 = r[3].mul(3), s4 = r[2].mul(2), i3 = r[1].clone(), o2 = Rt(p2, 2);
    let a2 = js2(t3, s4, i3, new x2(0, 1), false, o2);
    a2 < 0 && (a2 = 0);
    for (let r2 = 0; r2 < a2; r2++) Fs(o2[r2].value(), 0, 1) || (e5[n6] = o2[r2], n6++);
  }
  if (n6 += fa(i2, r, e5.slice(n6)), e5[n6].set(1), n6++, n6 > 2) {
    wt(e5, 0, n6, (t3, e6) => {
      const s5 = t3.value(), n7 = e6.value();
      return s5 < n7 ? -1 : s5 > n7 ? 1 : 0;
    });
    let s4 = 0;
    const i3 = e5[0].clone();
    let r2 = 0;
    const o2 = da(t2) * Ss(), a2 = new ei();
    Bo(t2, e5[0].value(), a2);
    for (let h2 = 1; h2 < n6; h2++) {
      const n7 = new ei();
      if (Bo(t2, e5[h2].value(), n7), e5[h2].eq(i3) || n7.isEqualPoint2D(a2, o2)) {
        if (0 !== s4) {
          if (0 === e5[h2].eps()) i3.setE(e5[h2]), r2 = 0;
          else if (0 !== r2) {
            const t3 = $(1 / e5[h2].eps()), s5 = 1 / r2, n8 = t3 + s5;
            i3.set((e5[h2].value() * t3 + i3.value() * s5) / n8), r2 = 1 / n8, i3.setError(Math.sqrt(r2));
          }
          e5[s4].setE(i3), Bo(t2, i3.value(), a2);
        }
      } else s4++, e5[s4].setE(e5[h2]), i3.setE(e5[h2]), Bo(t2, i3.value(), a2), r2 = $(e5[h2].eps());
    }
    s4++, n6 = s4;
  }
  return 1 === n6 && (n6 = 2, e5[1].set(1)), n2(0 === e5[0].value()), n2(1 === e5[n6 - 1].value()), n6;
}
function ya(t2, e5, s4, n6, i2) {
  const r = Rt(p2, 4), o2 = Rt(p2, 3), a2 = new x2(0, 1);
  let h2 = 0;
  if (e5) {
    if (yo(t2, r, false), h2 = Zs(r[3], r[2], r[1], r[0].sub(s4), a2, false, o2), n6) for (let m2 = 0; m2 < h2; m2++) {
      const e6 = new ei();
      jo(t2, o2[m2].value(), e6), n6[m2] = e6.x;
    }
  } else if (Po(t2, r, false), h2 = Zs(r[3], r[2], r[1], r[0].sub(s4), a2, false, o2), n6) for (let m2 = 0; m2 < h2; m2++) {
    const e6 = new ei();
    jo(t2, o2[m2].value(), e6), n6[m2] = e6.y;
  }
  if (i2) for (let m2 = 0; m2 < h2; m2++) i2[m2] = o2[m2].value();
  else n6 && wt(n6, 0, h2, Dt);
  return h2;
}
function xa(t2, e5, s4) {
  s4.setEmpty();
  const n6 = [];
  n6.push(new x2(0, 1));
  const i2 = 0.5 * Math.max(e5.width(), e5.height());
  for (; n6.length; ) {
    const r = n6.at(-1);
    n6.pop();
    const o2 = new ve();
    if (ma(t2, r, o2), o2.isIntersectingW(e5)) {
      const t3 = Math.max(o2.width(), o2.height());
      if (e5.containsW(o2) || t3 <= i2 || r.width() < 1e-12) s4.merge(r);
      else {
        const t4 = r.getCenter();
        n6.push(x2.construct(r.vmin, t4)), n6.push(x2.construct(t4, r.vmax));
      }
    }
  }
}
function Ca(t2, e5, s4) {
  s4.length = 0;
  {
    const e6 = new p2();
    Yo(t2, e6);
    const n7 = new Se();
    if (Oo(t2, e6, n7), n7.isZero()) return e6.isZero() || e6.eq(new p2(1)) ? 0 : (s4.push(e6.value()), 1);
  }
  const n6 = Rt(p2, 4);
  po(t2, n6, true);
  const i2 = Rt(p2, 4);
  fo(t2, i2, true);
  const r = Rt(p2, 6), o2 = n6[3].negate().mulE(i2[1]).addE(n6[2].mulE(i2[2]).mul(2)).addE(n6[1].mulE(i2[3])), a2 = n6[3].negate().mulE(i2[1]).subE(n6[2].mulE(i2[2]).mul(2)).addE(n6[1].mulE(i2[3])), h2 = n6[2].mulE(n6[2]).subE(i2[2].mulE(i2[2]));
  r[0] = i2[1].mulE(i2[1]).mulE(o2).addE(n6[1].mulE(n6[1]).mulE(a2)).addE(n6[1].mulE(i2[1]).mulE(h2).mul(2)).mul(6), r[1] = n6[2].mulE(i2[1]).subE(n6[1].mulE(i2[2])).mulE(n6[2].mulE(n6[2]).addE(n6[1].mulE(n6[3]).mul(2)).addE(i2[2].mulE(i2[2])).addE(i2[1].mulE(i2[3]).mul(2))).mul(24);
  const m2 = n6[1].mulE(i2[2]).mulE(i2[2]).mulE(i2[3]), u = n6[2].mulE(n6[2]).mulE(n6[3]).mulE(i2[1]).subE(m2).mul(156), l2 = n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3])), c = n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3])), g2 = n6[1].mulE(n6[3]).mulE(c).addE(i2[1].mulE(i2[3]).mulE(l2)).mul(72), d2 = i2[1].mulE(i2[3]).subE(n6[1].mulE(n6[3])), _ = n6[2].mulE(i2[2]).mulE(d2).mul(120), p3 = n6[1].mulE(n6[2]).mulE(n6[2]).mulE(i2[3]), f3 = n6[3].mulE(i2[1]).mulE(i2[2]).mulE(i2[2]).subE(p3).mul(36);
  r[2] = u.addE(g2).addE(_).addE(f3);
  const P5 = n6[2].mulE(n6[3]).mulE(n6[3]).mulE(i2[1]).subE(n6[1].mulE(i2[2]).mulE(i2[3]).mulE(i2[3])).mul(360), y2 = n6[2].mulE(i2[2]).mulE(n6[2].mulE(n6[3]).subE(i2[2].mulE(i2[3]))).addE(n6[3].mulE(i2[2]).mulE(i2[2]).mulE(i2[2])).subE(n6[2].mulE(n6[2]).mulE(n6[2]).mulE(i2[3])).mul(24), x4 = n6[2].mulE(i2[1]).mulE(i2[3]).mulE(i2[3]).subE(n6[1].mulE(n6[3]).mulE(n6[3]).mulE(i2[2])).mul(72), C2 = n6[3].mulE(i2[3]).mulE(i2[1].mulE(i2[2]).subE(n6[1].mulE(n6[2]))).mul(288);
  r[3] = P5.addE(y2).addE(x4).addE(C2), r[4] = i2[3].mulE(i2[3]).addE(n6[3].mulE(n6[3])).mulE(n6[3].mulE(i2[1]).subE(n6[1].mulE(i2[3]))).mul(270).addE(n6[3].mulE(i2[2]).subE(n6[2].mulE(i2[3]))).mulE(n6[2].mulE(n6[3]).addE(i2[2].mulE(i2[3]))).mul(180), r[5] = n6[3].mulE(i2[2]).subE(n6[2].mulE(i2[3])).mulE(n6[3].mulE(n6[3]).addE(i2[3].mulE(i2[3]))).mul(216);
  const v3 = Rt(p2, 5), b2 = Hs2(r, 5, new x2(0, 1), false, v3, 5);
  if (b2 > 0) {
    let n7 = Math.abs(t2.getCurvature(0)), i3 = 0;
    const r2 = Math.abs(t2.getCurvature(1));
    (r2 > n7 || !Number.isFinite(r2)) && (i3 = 1);
    for (let e6 = 0; e6 < b2; e6++) {
      const s5 = Math.abs(t2.getCurvature(v3[e6].value()));
      t2.getCoord2D(v3[e6].value()), (s5 > n7 || !Number.isFinite(s5)) && (n7 = s5, i3 = v3[e6].value());
    }
    if ((!Number.isFinite(n7) || 1 / n7 < e5) && !Fs(i3, 0, 1)) {
      const e6 = t2.getCoord2D(i3);
      if (!e6.equals(t2.getStartXY()) && !e6.equals(t2.getEndXY())) return s4.push(i3), 1;
    }
  }
  return 0;
}
var va = class {
  constructor(t2, e5) {
    this.b = t2, this.len = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t2, e5) {
    return 0 === t2 ? this.len - Co(this.b, e5, false) : 0;
  }
  getError(t2) {
    return 0;
  }
};
function ba(t2, e5, n6, i2, r, o2, a2) {
  for (; ; ) {
    const h2 = ei.distance(e5[0], e5[3]), m2 = ei.distance(e5[0], e5[1]) + ei.distance(e5[1], e5[2]) + ei.distance(e5[2], e5[3]);
    if (m2 - h2 <= i2 + n6 * m2) return t2 + Q(h2, m2, 0.5);
    const u = (t3) => qo(e5, 1, t3).length();
    if (0 === o2) {
      n2(a2 < 8);
      let h3 = u(0), l3 = u(1);
      r[0] += 2, h3 > l3 && (l3 = Mt(h3, h3 = l3), e5[3] = Mt(e5[0], e5[0] = e5[3]), e5[2] = Mt(e5[1], e5[1] = e5[2]));
      let c2 = h3 / (h3 + l3), g3 = 1, d3 = m2;
      for (; c2 < 1 / 32 && d3 >= 32 * (i2 + n6 * d3); ) {
        g3 /= 4;
        const t3 = u(g3);
        r[0]++, c2 = h3 / (t3 + h3);
        const s4 = new ei();
        if (jo(e5, 0.5 * g3, s4), d3 = ei.distance(s4, e5[0]), d3 <= i2) {
          const t4 = new ei();
          jo(e5, g3, t4), d3 += ei.distance(t4, s4);
        }
      }
      if (1 !== g3) {
        const s4 = Rt(ei, 4);
        Go(e5, g3, e5, s4), t2 = ba(t2, s4, n6, i2, r, 0, a2 + 1), o2++, a2++;
        continue;
      }
    }
    const l2 = 8;
    r[0] += l2;
    const c = Vn(l2, u, 0, 1), g2 = 16;
    r[0] += g2;
    const d2 = Vn(g2, u, 0, 1);
    let _ = Math.abs(c - d2) > i2 + n6 * m2;
    if (!_) return t2 + d2;
    if (o2 < 3) {
      const s4 = Rt(ei, 4);
      Go(e5, 0.5, e5, s4), t2 = ba(t2, s4, n6, i2, r, o2 + 1, a2 + 1), o2++, a2++;
      continue;
    }
    const p3 = 32;
    r[0] += p3;
    const f3 = Vn(p3, u, 0, 1);
    if (_ = Math.abs(d2 - f3) > i2 + n6 * m2, !_) return t2 + f3;
    const P5 = 64;
    r[0] += P5;
    const y2 = Vn(P5, u, 0, 1);
    if (_ = Math.abs(f3 - y2) > i2 + n6 * m2, !_) return t2 + y2;
    const x4 = 128;
    r[0] += x4;
    const C2 = Vn(x4, u, 0, 1);
    return _ = Math.abs(y2 - C2) > i2 + n6 * m2, t2 + C2;
  }
}
function Ea(t2, e5, s4, n6, i2) {
  if (s4 === e5) return 0;
  const r = Rt(ei, 4);
  t2.queryControlPoints(r);
  const o2 = Rt(ei, 4);
  Wo(r, e5, s4, o2);
  return ba(0, o2, n6, i2, [0], 0, 0);
}
function Sa(t2, e5, s4, n6, i2) {
  let r = true;
  const o2 = Ln(5, e5, s4, n6, i2, (e6) => {
    const s5 = Vo(t2, 1, e6);
    return (r ? t2.getCoordX(e6) - t2.getStartX() : t2.getCoordY(e6) - t2.getStartY()) * s5.length();
  });
  r = false;
  const a2 = Ln(5, e5, s4, n6, i2, (e6) => {
    const s5 = Vo(t2, 1, e6);
    return (r ? t2.getCoordX(e6) - t2.getStartX() : t2.getCoordY(e6) - t2.getStartY()) * s5.length();
  });
  return new ei(o2, a2);
}
function Da(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  const m2 = Rt(ei, 4);
  t2.queryControlPoints(m2);
  const u = Rt(ei, 4);
  if (e5.queryControlPoints(u), m2[0].equals(u[0])) {
    if (m2[1].equals(u[1]) && m2[2].equals(u[2]) && m2[3].equals(u[3])) return s4 && (s4.length = 0, s4.push(m2[0]), s4.push(m2[3])), n6 && (n6.length = 0, n6.push(0), n6.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!m2[0].equals(u[3])) return false;
  }
  return !!(m2[0].equals(u[3]) && m2[1].equals(u[2]) && m2[2].equals(u[1]) && m2[3].equals(u[0])) && (n6 && (n6.length = 0, n6.push(0), n6.push(1), h2 && (n6[1] = Mt(n6[0], n6[0] = n6[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Mt(i2[0], i2[0] = i2[1]))), s4 && (s4.length = 0, s4.push(m2[0]), s4.push(m2[3]), h2 && (s4[1] = Mt(s4[0], s4[0] = s4[1]))), true);
}
function wa(t2, e5, s4, n6, i2, r, o2, a2, h2, m2, u, l2) {
  let c = 0, g2 = 0, d2 = 0, _ = 0, p3 = 0, f3 = 0, P5 = 0;
  for (let x4 = 1, C2 = l2 - 1; x4 < C2; x4++) {
    let e6, o3, a3, m3, l3, y3, C3 = -1, v3 = h2[x4 - 1];
    t2 && (x4 > 2 ? (v3 = ks(2 * h2[x4 - 2] - h2[x4 - 3], 0, 1), h2[x4 - 1] = v3) : 2 === x4 && v3 <= h2[0] && (v3 = h2[0]));
    for (let c2 = 0; c2 < 11 && (e6 = h2[x4 - 1], o3 = e6 * e6, a3 = o3 * e6, m3 = 1 - e6, l3 = m3 * m3, y3 = l3 * m3, t2) && !(Math.abs(e6 - C3) < 1e-12) && 10 !== c2; c2++) {
      const t3 = s4.x - 2 * n6.x + i2.x, a4 = s4.x - 3 * n6.x + 3 * i2.x - r.x, m4 = s4.y - 2 * n6.y + i2.y, c3 = s4.y - 3 * n6.y + 3 * i2.y - r.y, g3 = s4.x - n6.x - 2 * t3 * e6 + a4 * o3, d3 = -u[x4].x + s4.x * y3 + e6 * (3 * n6.x * l3 + e6 * (3 * i2.x - 3 * i2.x * e6 + r.x * e6)), _2 = s4.y - n6.y - 2 * m4 * e6 + c3 * o3, p4 = -u[x4].y + s4.y * y3 + e6 * (3 * n6.y * l3 + e6 * (3 * i2.y - 3 * i2.y * e6 + r.y * e6));
      C3 = e6;
      const f4 = e6 - -6 * (g3 * d3 + _2 * p4) / (6 * (3 * $(g3) - (-2 * t3 + 2 * a4 * e6) * d3) + 6 * (3 * $(_2) - (-2 * m4 + 2 * c3 * e6) * p4));
      h2[x4 - 1] = ks(f4, x4 > 1 ? h2[x4 - 2] : 0, 1);
    }
    c += 3 * o3 * l3 * l3, g2 += 3 * a3 * y3, d2 += 3 * o3 * o3 * l3;
    const b2 = -(y3 * s4.x + a3 * r.x - u[x4].x);
    _ += b2 * e6 * l3, p3 += b2 * o3 * m3;
    const E2 = -(y3 * s4.y + a3 * r.y - u[x4].y);
    f3 += E2 * e6 * l3, P5 += E2 * o3 * m3;
  }
  if (e5) {
    const t3 = c * d2 - g2 * g2;
    Math.abs(t3) >= 1e-12 * (Math.abs(c * d2) + Math.abs(g2 * g2)) + 1e-10 ? (o2 || (n6.x = (_ * d2 - p3 * g2) / t3, n6.y = (f3 * d2 - P5 * g2) / t3), a2 || (i2.x = (c * p3 - g2 * _) / t3, i2.y = (c * P5 - g2 * f3) / t3)) : (Y(s4, r, 0.3, n6), Y(s4, r, 0.6, i2));
  }
  let y2 = 0;
  for (let x4 = 1, C2 = l2 - 1; x4 < C2; x4++) {
    const t3 = h2[x4 - 1], e6 = 1 - t3, o3 = s4.mul(H(e6)), a3 = n6.mul(3 * t3 * e6 * e6), m3 = i2.mul(3 * t3 * t3 * e6), l3 = r.mul(H(t3));
    y2 += o3.add(a3).add(m3).add(l3).sub(u[x4]).sqrLength();
  }
  return y2;
}
function Aa(t2, e5, s4, n6) {
  const i2 = t2.getPathStart(e5), r = t2.getPathEnd(e5);
  if (r - i2 < 3) return;
  const o2 = 2 * i2, a2 = ei.getNAN();
  s4.queryPoint2D(o2, a2);
  const h2 = a2.x, m2 = a2.y, u = ei.getNAN();
  s4.queryPoint2D(o2 + 2, u);
  const l2 = ei.getNAN();
  for (let c = o2 + 4, g2 = 2 * r; c < g2; c += 2) s4.queryPoint2D(c, l2), n6.pe((l2.x - a2.x) * (u.y - m2)), a2.setCoordsPoint2D(u), u.setCoordsPoint2D(l2);
  n6.pe((h2 - a2.x) * (u.y - m2));
}
function Ta(t2, e5, s4) {
  for (; e5.hasNextSegment(); ) {
    const t3 = e5.nextCurve();
    if (null === t3) break;
    s4.pe(2 * t3.calculateArea2DHelper());
  }
}
var Ia = B3;
var Ma = class {
  static toSegType(t2) {
    let e5 = 0;
    switch (t2) {
      case a.enumLine:
        e5 = 1;
        break;
      case a.enumBezier:
        e5 = 2;
        break;
      case a.enumEllipticArc:
        e5 = 4;
        break;
      case a.enumRationalBezier2:
        e5 = 8;
        break;
      case a.enumBezier2:
        e5 = 16;
        break;
      default:
        b("");
    }
    return e5;
  }
  constructor() {
    this.m_segmentFlags = null, this.m_segmentParamIndex = null, this.m_segmentParams = null, this.m_curveCount = 0, this.m_bezierCount = 0, this.m_arcCount = 0, this.m_rbezier2Count = 0, this.m_bezier2Count = 0, this.m_curveParamWritePoint = 0;
  }
  assignCopy(t2) {
    return this.m_segmentFlags = t2.m_segmentFlags, this.m_segmentParamIndex = t2.m_segmentParamIndex, this.m_segmentParams = t2.m_segmentParams, this.m_curveCount = t2.m_curveCount, this.m_bezierCount = t2.m_bezierCount, this.m_arcCount = t2.m_arcCount, this.m_rbezier2Count = t2.m_rbezier2Count, this.m_bezier2Count = t2.m_bezier2Count, this.m_curveParamWritePoint = t2.m_curveParamWritePoint, this;
  }
};
var Ya = class _Ya extends xe {
  constructor(t2) {
    super(t2), this.m_cachedRingAreas2D = null, this.m_paths = null, this.m_pathFlags = null, this.m_curveData = null, t2.move ? (this.m_bPolygon = t2.move.m_bPolygon, this.m_cachedLength2D = t2.move.m_cachedLength2D, this.m_cachedArea2D = t2.move.m_cachedArea2D, this.m_currentPathIndex = t2.move.m_currentPathIndex, this.m_cachedRingAreas2D = t2.move.m_cachedRingAreas2D, this.m_paths = t2.move.m_paths, this.m_pathFlags = t2.move.m_pathFlags, this.m_curveData = t2.move.m_curveData, t2.move.m_curveData = null, t2.move.setEmpty()) : (this.m_bPolygon = t2.bPolygon, this.m_cachedLength2D = 0, this.m_cachedArea2D = 0, this.m_currentPathIndex = 0);
  }
  getGeometryType() {
    return this.m_bPolygon ? a.enumPolygon : a.enumPolyline;
  }
  getDimension() {
    return this.m_bPolygon ? 2 : 1;
  }
  changeRingStartPoint(t2) {
    n2(this.m_bPolygon);
    const n6 = this.getPathIndexFromPointIndex(t2), i2 = this.getPathStart(n6);
    if (i2 === t2) return;
    const r = this.getPathEnd(n6);
    (t2 >= r || t2 < i2) && P("change_ring_start_point");
    for (let e5 = 0, s4 = this.m_description.getAttributeCount(); e5 < s4; e5++) {
      const s5 = this.m_description.getSemantics(e5), n7 = Ia.getComponentCount(s5);
      this.m_vertexAttributes.get(e5).rotate(i2 * n7, t2 * n7, r * n7);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.rotate(i2, t2, r), this.m_curveData.m_segmentParamIndex.rotate(i2, t2, r));
  }
  setFillRule(t2) {
    this.m_bFillRule = 1 === t2;
  }
  getFillRule() {
    return this.m_bFillRule ? 1 : 0;
  }
  isExteriorRingOGC(t2) {
    return !!this.m_bPolygon && (this.updateOGCFlagsProtected(), !!(8 & this.m_pathFlags.read(t2)));
  }
  isExteriorRing(t2) {
    return this.calculateRingArea2D(t2) > 0;
  }
  calculateRingArea2D(t2) {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedRingAreas2D.read(t2)) : 0;
  }
  updateRingAreas2DProtected() {
    if (!this.hasDirtyFlag(1024)) return;
    const t2 = this.getPathCount();
    if (0 === t2) return this.hasDirtyFlag(1024) && (this.m_cachedArea2D = 0), void this.setDirtyFlagProtected(1024, false);
    const e5 = new nt(t2), s4 = new n3(0), n6 = new n3(0);
    if (0 !== this.m_pointCount) {
      const i2 = this.getAttributeStreamRef(0);
      if (this.hasNonLinearSegments()) {
        const t3 = new Ds({ parent: this });
        for (t3.stripAttributes(); t3.nextPath(); ) {
          n6.reset();
          const r = t3.getPathIndex();
          Aa(this, r, i2, n6), Ta(this, t3, n6);
          const o2 = 0.5 * n6.getResult();
          s4.add(o2), e5.write(r, o2);
        }
      } else for (let r = 0; r < t2; r++) {
        n6.reset(), Aa(this, r, i2, n6);
        const t3 = 0.5 * n6.getResult();
        s4.add(t3), e5.write(r, t3);
      }
    }
    this.hasDirtyFlag(1024) && (this.m_cachedArea2D = s4.getResult(), this.m_cachedRingAreas2D = e5, this.setDirtyFlagProtected(1024, false));
  }
  getOGCPolygonCount() {
    if (!this.m_bPolygon) return 0;
    this.updateOGCFlagsProtected();
    let t2 = 0;
    const e5 = this.getPathCount();
    for (let s4 = 0; s4 < e5; s4++) 8 & this.m_pathFlags.read(s4) && t2++;
    return t2;
  }
  getHashCodeImpl() {
    return n2(0), 0;
  }
  equalsImpl(t2) {
    const e5 = t2, s4 = this.getPathCount();
    if (s4 !== e5.getPathCount()) return false;
    const n6 = this.hasNonLinearSegments();
    if (n6 !== e5.hasNonLinearSegments()) return false;
    if (n6) {
      if (this.m_curveData.m_curveCount !== e5.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== e5.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(e5.m_paths, 0, s4 + 1)) return false;
    if (this.m_bFillRule !== e5.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(e5.m_pathFlags, 0, s4)) return false;
    if (this.hasNonLinearSegments()) {
      if (!this.m_curveData.m_segmentFlags.equals(e5.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
      for (let t3 = 0, s5 = this.getPointCount(); t3 < s5; t3++) {
        const s6 = this.m_curveData.m_segmentFlags.read(t3);
        if (!_Ya.isNonLinearSegmentFlag(s6)) continue;
        const n7 = this.m_curveData.m_segmentParamIndex.read(t3), i2 = e5.m_curveData.m_segmentParamIndex.read(t3), r = Ys2(s6);
        for (let t4 = 0; t4 < r; t4++) {
          const s7 = this.m_curveData.m_segmentParams.read(n7 + t4), r2 = e5.m_curveData.m_segmentParams.read(i2 + t4);
          if (!rs(s7, r2)) return false;
        }
      }
    }
    return true;
  }
  equalsImplTol(t2, e5) {
    const s4 = t2, n6 = this.getPathCount();
    if (n6 !== s4.getPathCount()) return false;
    const i2 = this.hasNonLinearSegments();
    if (i2 !== s4.hasNonLinearSegments()) return false;
    if (i2) {
      if (this.m_curveData.m_curveCount !== s4.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== s4.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(s4.m_paths, 0, n6 + 1)) return false;
    if (this.m_bFillRule !== s4.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(s4.m_pathFlags, 0, n6)) return false;
    if (!i2) return true;
    if (!this.m_curveData.m_segmentFlags.equals(s4.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
    const r = this.querySegmentIterator(), o2 = s4.querySegmentIterator();
    for (; r.nextPath(); ) {
      if (!o2.nextPath()) return false;
      for (; r.hasNextSegment(); ) {
        const t3 = r.nextCurve(), s5 = o2.nextCurve();
        if (!(t3 && s5 && t3.equals(s5, e5))) {
          if (!t3 && !s5) break;
          return false;
        }
      }
    }
    return true;
  }
  reserveImplImpl(t2, e5) {
    this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(t2, 1), this.m_curveData.m_segmentParamIndex.resize(t2, -1), this.checkCompactSegmentParams());
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
    this.m_paths || (this.m_paths = J(1, 0), this.m_pathFlags = K(1, 0)), this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount, 1), this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount, -1), this.checkCompactSegmentParams());
  }
  copyToImpl(t2, e5) {
    const s4 = t2;
    s4.m_bPathStarted = false, s4.m_bFillRule = this.m_bFillRule, this.m_paths ? s4.m_paths = e5 ? this.m_paths : this.m_paths.clone() : s4.m_paths = null, this.m_pathFlags ? s4.m_pathFlags = e5 ? this.m_pathFlags : this.m_pathFlags.clone() : s4.m_pathFlags = null, this.m_curveData && (s4.m_curveData || (s4.m_curveData = new Ma()), s4.m_curveData.assignCopy(this.m_curveData), s4.m_curveData.m_curveCount = 0, s4.updateCurveCounter(this.m_curveData.m_curveCount), e5 || (this.m_curveData.m_segmentParamIndex ? s4.m_curveData.m_segmentParamIndex = this.m_curveData.m_segmentParamIndex.clone() : s4.m_curveData.m_segmentParamIndex = null, this.m_curveData.m_segmentFlags ? s4.m_curveData.m_segmentFlags = this.m_curveData.m_segmentFlags.clone() : s4.m_curveData.m_segmentFlags = null, this.m_curveData.m_segmentParams ? s4.m_curveData.m_segmentParams = this.m_curveData.m_segmentParams.clone() : s4.m_curveData.m_segmentParams = null)), s4.hasDirtyFlag(512) || (s4.m_cachedLength2D = this.m_cachedLength2D), s4.m_cachedRingAreas2D = null, s4.hasDirtyFlag(1024) || (s4.m_cachedArea2D = this.m_cachedArea2D, null !== this.m_cachedRingAreas2D && (s4.m_cachedRingAreas2D = e5 ? this.m_cachedRingAreas2D : this.m_cachedRingAreas2D.clone()));
  }
  calculateArea2D() {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedArea2D) : 0;
  }
  calculateLength2D() {
    if (!this.hasDirtyFlag(512)) return this.m_cachedLength2D;
    const t2 = this.querySegmentIterator(), e5 = new n3(0);
    for (; t2.nextPath(); ) for (; t2.hasNextSegment(); ) e5.add(t2.nextSegment().calculateLength2D());
    return this.hasDirtyFlag(512) && (this.m_cachedLength2D = e5.getResult()), this.setDirtyFlagProtected(512, false), e5.getResult();
  }
  calculatePathLength2D(t2) {
    const e5 = this.querySegmentIteratorAtVertex(this.getPathStart(t2)), s4 = new n3(0);
    for (; e5.hasNextSegment(); ) s4.add(e5.nextSegment().calculateLength2D());
    return s4.getResult();
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  calculatePathLength3D(t2, e5) {
    return n2(0), 0;
  }
  copyTo(t2) {
    h(t2.getGeometryType()) || P(""), this !== t2 && super.copyTo(t2);
  }
  swap(t2) {
    n2(0);
  }
  hasNonLinearSegments() {
    return 0 !== this.getCurveCount();
  }
  getSegmentCount() {
    let t2 = this.getPointCount();
    if (!this.m_bPolygon) {
      t2 -= this.getPathCount();
      for (let e5 = 0, s4 = this.getPathCount(); e5 < s4; e5++) this.isClosedPath(e5) && t2++;
    }
    return t2;
  }
  getSegmentCountPath(t2) {
    let e5 = this.getPathSize(t2);
    return !this.isClosedPath(t2) && e5 > 0 && e5--, e5;
  }
  add(t2, s4) {
    this === t2 && P("Multi_path_impl::add");
    for (let e5 = 0, n6 = t2.getPathCount(); e5 < n6; e5++) this.addPath(t2, e5, !s4);
  }
  addPath(t2, e5, s4) {
    this.insertPath(-1, t2, e5, s4);
  }
  addPathPoint2D(t2, e5, s4) {
    this.insertPath2D(-1, t2, 0, e5, s4);
  }
  addPathMultiPoint(t2, e5, s4, n6) {
    s4 < 0 && (s4 = t2.getPointCount() - e5), this.insertPointsFromMultipoint(-1, 0, t2, e5, s4, n6);
  }
  addSegmentsFromPath(t2, s4, i2, r, o2) {
    if (this === t2 && P("Multi_path_impl.add_segments_from_path"), o2 || 0 !== this.getPathCount() || (o2 = true), s4 < 0 && (s4 = t2.getPathCount() - 1), (s4 >= t2.getPathCount() || i2 < 0 || r < 0 || i2 + r > t2.getSegmentCountPath(s4)) && A("add_segments_from_path"), 0 === r) return;
    const a2 = t2.getPathStart(s4), h2 = t2.isClosedPath(s4) && i2 + r === t2.getSegmentCountPath(s4);
    this.m_bPathStarted = false, this.mergeVertexDescription(t2.getDescription());
    let m2 = r;
    const u = a2 + i2;
    let l2 = u + 1;
    o2 && (m2++, l2--), !o2 && t2.hasNonLinearSegments() && 1 !== t2.m_curveData.m_segmentFlags.read(u) && (t2.getXY(u).equals(this.getXY(this.m_pointCount - 1)) || P("add_segments_from_path: start point mismatch"));
    const c = this.m_pointCount;
    if (this.resizeImpl(this.m_pointCount + m2), this.verifyAllStreamsAfterSizeChange(), o2) {
      if (0 === m2) return;
      this.m_paths.add(this.m_pointCount);
      let e5 = t2.m_pathFlags.read(s4);
      this.m_bPolygon && (e5 |= 1), this.m_pathFlags.write(this.m_pathFlags.size() - 1, e5), this.m_pathFlags.add(0);
    } else this.m_paths.write(this.m_pathFlags.size() - 1, this.m_pointCount);
    const g2 = h2 ? m2 - 1 : m2;
    for (let e5 = 0, n6 = this.m_description.getAttributeCount(); e5 < n6; e5++) {
      const s5 = this.m_description.getSemantics(e5), n7 = Ia.getComponentCount(s5), i3 = t2.m_description.getAttributeIndex(s5);
      if (g2 > 0) {
        if (i3 < 0 || !t2.m_vertexAttributes.get(i3)) {
          const t3 = Ia.getDefaultValue(s5);
          this.m_vertexAttributes.get(e5).insertRange(n7 * c, t3, g2 * n7, n7 * c), h2 && this.m_vertexAttributes.get(e5).insertRange(n7 * c + g2 * n7, t3, n7, n7 * c);
          continue;
        }
        this.m_vertexAttributes.get(e5).insertRangeFromStream(n7 * c, t2.m_vertexAttributes.get(i3), n7 * l2, g2 * n7, true, n7, n7 * c);
      }
      h2 && this.m_vertexAttributes.get(e5).insertRangeFromStream(n7 * (c + g2), t2.m_vertexAttributes.get(i3), n7 * a2, n7, true, n7, n7 * (c + g2));
    }
    if (this.hasNonLinearSegments() && this.initSegmentData(0), t2.hasNonLinearSegments()) {
      let e5 = 0;
      for (let s5 = 0, n6 = u; s5 < r; s5++) {
        e5 += Ys2(t2.m_curveData.m_segmentFlags.read(n6)), n6++;
      }
      if (e5 > 0) {
        this.initSegmentData(e5);
        let s5 = u, n6 = c - (o2 ? 0 : 1), i3 = 0;
        for (let e6 = 0; e6 < r; e6++) {
          const e7 = t2.m_curveData.m_segmentFlags.read(s5);
          if (this.m_curveData.m_segmentFlags.write(n6, e7), _Ya.isNonLinearSegmentFlag(e7)) {
            i3++;
            let r2 = t2.m_curveData.m_segmentParamIndex.read(s5);
            const o3 = Ys2(e7);
            this.m_curveData.m_segmentParamIndex.write(n6, this.m_curveData.m_curveParamWritePoint);
            for (let e8 = 0; e8 < o3; e8++) {
              const e9 = t2.m_curveData.m_segmentParams.read(r2);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, e9), this.m_curveData.m_curveParamWritePoint++, r2++;
            }
            this.incCurveType(e7, 1);
          } else this.m_curveData.m_segmentParamIndex.write(n6, -1);
          n6++, s5++;
        }
        this.modifyCurveCounter(i3);
      }
    }
    if (h2) {
      const t3 = this.getPathCount() - 1, e5 = this.getPathStart(t3), s5 = this.getPathEnd(t3) - 1, n6 = this.getXY(e5), i3 = this.getXY(s5);
      n6.isEqualPoint2D(i3) && (--this.m_pointCount, this.m_paths.write(t3 + 1, this.m_pointCount));
    }
    this.notifyModifiedFlags(2001);
  }
  reverseAllPaths() {
    for (let t2 = 0, e5 = this.getPathCount(); t2 < e5; t2++) this.reversePath(t2);
  }
  reversePath(t2) {
    t2 >= this.getPathCount() && P("");
    const s4 = this.getPathSize(t2);
    if (0 === s4) return;
    const n6 = this.getPathStart(t2), i2 = this.isClosedPath(t2);
    if (this.hasNonLinearSegments()) {
      let t3 = n6;
      const e5 = new this.m_segmentBufferCTor();
      let r2 = false;
      for (let n7 = 0; n7 < s4; n7++, t3++) {
        const s5 = this.m_curveData.m_segmentFlags.read(t3);
        if (!_Ya.isNonLinearSegmentFlag(s5)) continue;
        r2 = true, this.querySegment(t3, e5, true), e5.get().reverse();
        const n8 = this.m_curveData.m_segmentParamIndex.read(t3);
        e5.get().writeInBufferStream(this.m_curveData.m_segmentParams, n8);
      }
      if (r2) {
        const t4 = i2 ? 0 : 1;
        this.m_curveData.m_segmentFlags.reverseRange(n6, s4 - t4, 1), this.m_curveData.m_segmentParamIndex.reverseRange(n6, s4 - t4, 1);
      }
    }
    const r = i2 ? 1 : 0;
    for (let e5 = 0, a2 = this.m_description.getAttributeCount(); e5 < a2; e5++) if (this.m_vertexAttributes.get(e5)) {
      const t3 = this.m_description.getSemantics(e5), i3 = Ia.getComponentCount(t3);
      this.m_vertexAttributes.get(e5).reverseRange(i3 * (n6 + r), i3 * (s4 - r), i3);
    }
    const o2 = 6 & this.m_pathFlags.read(t2);
    if (o2) {
      let e5 = 0;
      4 & o2 && (e5 |= 2), 2 & o2 && (e5 |= 4), this.m_pathFlags.clearBits(t2, 6), this.m_pathFlags.setBits(t2, e5);
    }
    this.notifyModifiedFlags(1233);
  }
  removePath(t2) {
    const s4 = this.getPathCount();
    t2 < 0 && (t2 = s4 - 1), t2 >= s4 && P("");
    const n6 = this.getPathStart(t2), i2 = this.getPathSize(t2);
    for (let e5 = 0, r = this.m_description.getAttributeCount(); e5 < r; e5++) if (this.m_vertexAttributes.get(e5)) {
      const t3 = this.m_description.getSemantics(e5), s5 = Ia.getComponentCount(t3);
      this.m_vertexAttributes.get(e5).eraseRange(s5 * n6, s5 * i2, s5 * this.m_pointCount);
    }
    if (this.hasNonLinearSegments()) {
      let t3 = 0;
      for (let e5 = n6, s5 = n6 + i2; e5 < s5; e5++) {
        const s6 = this.m_curveData.m_segmentFlags.read(e5);
        _Ya.isNonLinearSegmentFlag(s6) && (this.incCurveType(s6, -1), t3++);
      }
      this.modifyCurveCounter(-t3), this.m_curveData.m_segmentFlags.eraseRange(n6, i2, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(n6, i2, this.m_pointCount);
    }
    for (let e5 = t2 + 1; e5 <= s4; e5++) {
      const t3 = this.m_paths.read(e5);
      this.m_paths.write(e5 - 1, t3 - i2);
    }
    if (this.m_pathFlags) for (let e5 = t2 + 1; e5 <= s4; e5++) {
      const t3 = this.m_pathFlags.read(e5);
      this.m_pathFlags.write(e5 - 1, t3);
    }
    this.m_paths.resize(s4), this.m_pathFlags.resize(s4), this.m_pointCount -= i2, this.m_reservedPointCount -= i2, t2 === s4 - 1 && (this.m_bPathStarted = false), this.notifyModifiedFlags(2001), this.checkCompactSegmentParams(), this.dbgVerifyCurves();
  }
  dbgVerifyCurves() {
  }
  insertPath(t2, s4, n6, i2) {
    this === s4 && P("Multi_path_impl::insert_path");
    const r = this.getPathCount();
    if (!i2 && s4.hasNonLinearSegmentsPath(n6)) return t2 = this.insertPath(t2, s4, n6, true), this.reversePath(t2), t2;
    n6 >= s4.getPathCount() && P(""), t2 > r && P(""), t2 < 0 && (t2 = r), n6 < 0 && (n6 = s4.getPathCount() - 1), this.m_bPathStarted = false, this.mergeVertexDescription(s4.getDescription());
    const o2 = s4.getPathStart(n6), a2 = s4.getPathSize(n6);
    if (0 === a2) return this.insertPath2D(t2, null, 0, 0, true);
    const h2 = this.m_pointCount, m2 = s4.isClosedPath(n6) && !i2 ? 1 : 0;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const u = t2 < r ? this.getPathStart(t2) : h2;
    for (let e5 = 0, g2 = this.m_description.getAttributeCount(); e5 < g2; e5++) {
      const t3 = this.m_description.getSemantics(e5), n7 = s4.getDescription().getAttributeIndex(t3), r2 = Ia.getComponentCount(t3);
      if (n7 >= 0 && s4.m_vertexAttributes.get(n7)) 0 !== m2 && this.m_vertexAttributes.get(e5).insertRangeFromStream(u * r2, s4.m_vertexAttributes.get(n7), r2 * o2, r2, true, r2, r2 * h2), this.m_vertexAttributes.get(e5).insertRangeFromStream((u + m2) * r2, s4.m_vertexAttributes.get(n7), r2 * (o2 + m2), r2 * (a2 - m2), i2, r2, r2 * (h2 + m2));
      else {
        const s5 = Ia.getDefaultValue(t3);
        this.m_vertexAttributes.get(e5).insertRange(u * r2, s5, r2 * a2, r2 * h2);
      }
    }
    const l2 = h2 + a2;
    this.m_paths.add(l2);
    for (let e5 = r; e5 >= t2 + 1; e5--) {
      const t3 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t3 + a2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = r - 1; e5 >= t2 + 1; e5--) {
      let t3 = this.m_pathFlags.read(e5);
      t3 &= -9, this.m_pathFlags.write(e5 + 1, t3);
    }
    let c = s4.getPathFlagsStreamRef().read(n6);
    if (c &= -9, this.m_bPolygon && (c |= 1), this.m_pathFlags.write(t2, c), s4.hasNonLinearSegments()) {
      this.initSegmentData(0);
      let t3 = o2, e5 = 0;
      for (let n7 = 0; n7 < a2; n7++) {
        e5 += Ys2(s4.m_curveData.m_segmentFlags.read(t3)), t3++;
      }
      if (e5 > 0) {
        null === this.m_curveData.m_segmentFlags ? (this.m_curveData.m_segmentFlags = K(this.m_pointCount, 1), this.m_curveData.m_segmentParamIndex = J(this.m_pointCount, -1)) : (this.m_curveData.m_segmentFlags.insertRange(u, 1, a2, h2), this.m_curveData.m_segmentParamIndex.insertRange(u, -1, a2, h2)), this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint + e5) : this.m_curveData.m_segmentParams = $2(e5), t3 = o2;
        let n7 = u, i3 = 0;
        for (let e6 = 0; e6 < a2; e6++) {
          const e7 = s4.m_curveData.m_segmentFlags.read(t3);
          if (_Ya.isNonLinearSegmentFlag(e7)) {
            this.m_curveData.m_segmentFlags.write(n7, e7), this.m_curveData.m_segmentParamIndex.write(n7, this.m_curveData.m_curveParamWritePoint);
            const r2 = Ys2(e7);
            let o3 = s4.m_curveData.m_segmentParamIndex.read(t3);
            for (let t4 = 0; t4 < r2; t4++) {
              const t5 = s4.m_curveData.m_segmentParams.read(o3);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, t5), this.m_curveData.m_curveParamWritePoint++, o3++;
            }
            i3++, this.incCurveType(e7, 1);
          }
          t3++, n7++;
        }
        this.modifyCurveCounter(i3);
      }
    }
    return this.notifyModifiedFlags(2001), t2;
  }
  insertPath2D(t2, s4, n6, i2, r) {
    const o2 = this.getPathCount();
    (t2 > o2 || n6 < 0) && P(""), t2 < 0 && (t2 = o2), this.m_bPathStarted = false;
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + i2), 0 === i2 && this.notifyModifiedFlags(32), this.verifyAllStreamsAfterSizeChange();
    const h2 = t2 < o2 ? this.getPathStart(t2) : a2;
    if (s4) this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * h2, s4, n6, i2, r, 2 * a2);
    else {
      const t3 = Ia.getDefaultValue(0);
      this.m_vertexAttributes.get(0).insertRange(2 * h2, t3, 2 * i2, 2 * a2);
    }
    for (let e5 = 1, m2 = this.m_description.getAttributeCount(); e5 < m2; e5++) {
      const t3 = this.m_description.getSemantics(e5), s5 = Ia.getComponentCount(t3), n7 = Ia.getDefaultValue(t3);
      this.m_vertexAttributes.get(e5).insertRange(h2 * s5, n7, s5 * i2, s5 * a2);
    }
    this.m_paths.add(this.m_pointCount);
    for (let e5 = o2; e5 >= t2 + 1; e5--) {
      const t3 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t3 + i2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = o2 - 1; e5 >= t2 + 1; e5--) {
      let t3 = this.m_pathFlags.read(e5);
      t3 &= -9, this.m_pathFlags.write(e5 + 1, t3);
    }
    return this.m_bPolygon && this.m_pathFlags.write(t2, 1), this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2, 1, i2, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2, -1, i2, a2)), this.notifyModifiedFlags(2001), t2;
  }
  insertPathFromMultipoint(t2, s4, n6, i2, r) {
    const o2 = s4.getImpl(), a2 = this.getPathCount();
    (t2 > a2 || n6 < 0) && P("");
    const h2 = i2 < 0 ? o2.getPointCount() - n6 : i2;
    if (h2 > o2.getPointCount() && P(""), n6 >= o2.getPointCount() && P("pointsOffset"), t2 < 0 && (t2 = a2), this.m_bPathStarted = false, this.mergeVertexDescription(o2.getDescription()), 0 === h2) return void this.insertPath2D(t2, null, 0, 0, true);
    const m2 = this.m_pointCount, u = n6;
    this.resizeImpl(this.m_pointCount + h2), this.verifyAllStreamsAfterSizeChange();
    const l2 = t2 < a2 ? this.getPathStart(t2) : m2;
    for (let e5 = 0, d2 = this.m_description.getAttributeCount(); e5 < d2; e5++) {
      const t3 = this.m_description.getSemantics(e5), s5 = o2.getDescription().getAttributeIndex(t3), n7 = Ia.getComponentCount(t3);
      if (s5 >= 0) {
        const s6 = o2.getAttributeStreamRef(t3);
        this.m_vertexAttributes.get(e5).insertRangeFromStream(l2 * n7, s6, n7 * u, n7 * h2, r, n7, n7 * m2);
      } else {
        const s6 = Ia.getDefaultValue(t3);
        this.m_vertexAttributes.get(e5).insertRange(l2 * n7, s6, n7 * h2, n7 * m2);
      }
    }
    const c = m2 + h2;
    this.m_paths.add(c);
    for (let e5 = a2; e5 >= t2 + 1; e5--) {
      const t3 = this.m_paths.read(e5 - 1);
      this.m_paths.write(e5, t3 + h2);
    }
    this.m_pathFlags.add(0);
    for (let e5 = a2 - 1; e5 >= t2 + 1; e5--) {
      let t3 = this.m_pathFlags.read(e5);
      t3 &= -9, this.m_pathFlags.write(e5 + 1, t3);
    }
    let g2 = 0;
    this.m_bPolygon && (g2 |= 1), this.m_pathFlags.write(t2, g2), this.notifyModifiedFlags(2001);
  }
  insertPoints(t2, s4, i2, r, o2, a2, h2) {
    var _a3;
    if (this === i2 && P("Multi_path_impl.insert_points"), t2 < 0 && (t2 = this.getPathCount()), r < 0 && (r = i2.getPathCount() - 1), (t2 > this.getPathCount() || s4 >= 0 && s4 > this.getPathSize(t2) || r >= i2.getPathCount() || a2 > i2.getPathSize(r)) && A(""), !a2) return;
    if (this.mergeVertexDescription(i2.m_description), t2 === this.getPathCount()) {
      this.m_paths.add(this.m_pointCount);
      let t3 = i2.m_pathFlags.read(r);
      t3 &= -9, this.m_bPolygon ? this.m_pathFlags.add(1 | t3) : this.m_pathFlags.add(t3);
    }
    s4 < 0 && (s4 = this.getPathSize(t2));
    const m2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const u = this.getPathStart(t2), l2 = u + s4;
    a2 < 0 && (a2 = i2.getPathSize(r));
    const c = i2.getPathStart(r), g2 = c + a2;
    for (let e5 = 0, n6 = this.m_description.getAttributeCount(); e5 < n6; e5++) {
      const t3 = this.m_description.getSemantics(e5), n7 = Ia.getComponentCount(t3), r2 = i2.m_description.getAttributeIndex(t3);
      if (r2 < 0 || !i2.m_vertexAttributes.get(r2)) {
        const s5 = Ia.getDefaultValue(t3);
        this.m_vertexAttributes.get(e5).insertRange(n7 * l2, s5, g2 * n7, n7 * m2);
      } else (_a3 = this.m_vertexAttributes.get(e5)) == null ? void 0 : _a3.insertRangeFromStream(n7 * (u + s4), i2.m_vertexAttributes.get(r2), n7 * (c + o2), a2 * n7, h2, n7, n7 * m2);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(u + s4, 1, a2, m2), this.m_curveData.m_segmentParamIndex.insertRange(u + s4, -1, a2, m2), s4 > 0 && this.isNonLinearSegment(u + s4 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(u + s4 - 1), -1), this.m_curveData.m_segmentFlags.write(u + s4 - 1, 1), this.m_curveData.m_segmentParamIndex.write(u + s4 - 1, -1), this.modifyCurveCounter(-1)));
    for (let e5 = t2 + 1, n6 = this.getPathCount(); e5 <= n6; e5++) {
      const t3 = this.m_paths.read(e5);
      this.m_paths.write(e5, t3 + a2);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromPoints(t2, e5, s4, i2, r, o2) {
    if (t2 < 0 && (t2 = this.getPathCount()), (t2 > this.getPathCount() || e5 > this.getPathSize(t2) || i2 < 0) && A(""), !r) return;
    t2 === this.getPathCount() && (this.m_paths.add(this.m_pointCount), this.m_bPolygon ? this.m_pathFlags.add(1) : this.m_pathFlags.add(0)), e5 < 0 && (e5 = this.getPathSize(t2));
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const h2 = this.getPathStart(t2);
    this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * (h2 + e5), s4, i2, r, o2, 2 * a2);
    for (let n6 = 1, m2 = this.m_description.getAttributeCount(); n6 < m2; n6++) {
      const t3 = this.m_description.getSemantics(n6), s5 = Ia.getComponentCount(t3), i3 = Ia.getDefaultValue(t3);
      this.m_vertexAttributes.get(n6).insertRange((h2 + e5) * s5, i3, s5 * r, s5 * a2);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2 + e5, 1, r, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2 + e5, -1, r, a2), e5 > 0 && this.isNonLinearSegment(h2 + e5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(h2 + e5 - 1), -1), this.m_curveData.m_segmentFlags.write(h2 + e5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(h2 + e5 - 1, -1), this.modifyCurveCounter(-1)));
    for (let n6 = t2 + 1, m2 = this.getPathCount(); n6 <= m2; n6++) this.m_paths.write(n6, this.m_paths.read(n6) + r);
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromMultipoint(t2, e5, s4, i2, r, o2) {
    const a2 = s4.getImpl(), h2 = this.getPathCount();
    t2 < 0 && (t2 = this.getPathCount());
    const m2 = a2.getPointCount();
    if ((i2 < 0 || i2 > m2) && A(""), (r < 0 || i2 + r > m2) && (r = m2 - i2), e5 < 0 && (e5 = t2 < h2 ? this.getPathSize(t2) : 0), (t2 > h2 || t2 < h2 && e5 > this.getPathSize(t2) || t2 === h2 && e5 > 0 || r < 0) && A(""), !r) return;
    if (this.mergeVertexDescription(a2.getDescription()), t2 === h2) {
      this.m_paths.add(this.m_pointCount);
      const t3 = 0;
      this.m_bPolygon ? this.m_pathFlags.add(1 | t3) : this.m_pathFlags.add(t3);
    }
    e5 < 0 && (e5 = this.getPathSize(t2));
    const u = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const l2 = this.getPathStart(t2), c = l2 + e5, g2 = 0, d2 = g2 + r;
    for (let n6 = 0, _ = this.m_description.getAttributeCount(); n6 < _; n6++) {
      const t3 = this.m_description.getSemantics(n6), s5 = Ia.getComponentCount(t3);
      if (a2.getDescription().getAttributeIndex(t3) < 0) {
        const e6 = Ia.getDefaultValue(t3);
        this.m_vertexAttributes.get(n6).insertRange(s5 * c, e6, d2 * s5, s5 * u);
        continue;
      }
      const h3 = a2.getAttributeStreamRef(t3);
      this.m_vertexAttributes.get(n6).insertRangeFromStream(s5 * (l2 + e5), h3, s5 * (g2 + i2), r * s5, o2, s5, s5 * u);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(l2 + e5, 1, r, u), this.m_curveData.m_segmentParamIndex.insertRange(l2 + e5, -1, r, u), e5 > 0 && this.isNonLinearSegment(l2 + e5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(l2 + e5 - 1), -1), this.m_curveData.m_segmentFlags.write(l2 + e5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(l2 + e5 - 1, -1), this.modifyCurveCounter(-1)));
    for (let n6 = t2 + 1, _ = this.getPathCount(); n6 <= _; n6++) {
      const t3 = this.m_paths.read(n6);
      this.m_paths.write(n6, t3 + r);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint2D(t2, e5, s4) {
    const i2 = this.getPathCount();
    t2 < 0 && (t2 = i2), (t2 > i2 || t2 < i2 && e5 > this.getPathSize(t2)) && A(""), t2 === i2 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o2 = this.getPathStart(t2), a2 = e5 < 0 ? this.getPathSize(t2) + o2 : e5 + o2, h2 = this.m_vertexAttributes.get(0);
    if (a2 === r) this.m_paths.write(t2 + 1, r + 1), h2.writePoint2D(2 * a2, s4);
    else {
      h2.insert(2 * a2, s4, 2 * r);
      for (let t3 = 1, e6 = this.m_description.getAttributeCount(); t3 < e6; t3++) {
        const e7 = this.m_description.getSemantics(t3), s5 = Ia.getComponentCount(e7), n6 = Ia.getDefaultValue(e7);
        this.m_vertexAttributes.get(t3).insertRange(s5 * a2, n6, s5, s5 * r);
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let e6 = t2 + 1, s5 = i2; e6 <= s5; e6++) this.m_paths.write(e6, this.m_paths.read(e6) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o2 && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  insertPoint(t2, e5, s4) {
    const i2 = this.getPathCount();
    t2 < 0 && (t2 = i2), (t2 > i2 || t2 < i2 && e5 > this.getPathSize(t2)) && A(""), t2 === i2 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o2 = this.getPathStart(t2), a2 = e5 < 0 ? this.getPathSize(t2) + o2 : e5 + o2;
    if (a2 === r) this.m_paths.write(t2 + 1, r + 1), this.setPointByVal(a2, s4);
    else {
      const e6 = s4.getDescription();
      this.m_description !== e6 && this.mergeVertexDescription(e6);
      for (let t3 = 0, n6 = this.m_description.getAttributeCount(); t3 < n6; t3++) {
        const n7 = this.m_description.getSemantics(t3), i3 = Ia.getComponentCount(n7);
        if (e6.hasAttribute(n7)) this.m_vertexAttributes.get(t3).insertAttributes(i3 * a2, s4, n7, i3 * r);
        else {
          const e7 = Ia.getDefaultValue(n7);
          this.m_vertexAttributes.get(t3).insertRange(i3 * a2, e7, i3, i3 * r);
        }
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let s5 = t2 + 1, n6 = i2; s5 <= n6; s5++) this.m_paths.write(s5, this.m_paths.read(s5) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o2 && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  removePointFromPath(t2, e5) {
    const s4 = this.getPathCount();
    t2 < 0 && (t2 = s4 - 1), (t2 >= s4 || e5 >= this.getPathSize(t2)) && A("Multi_path.remove_point");
    const i2 = this.getPathStart(t2), r = this.isClosedPath(t2);
    e5 < 0 && (e5 = this.getPathSize(t2) - 1), e5 < 0 && A("Multi_path.remove_point");
    const o2 = i2 + e5;
    for (let n6 = 0, a2 = this.m_description.getAttributeCount(); n6 < a2; n6++) if (this.m_vertexAttributes.get(n6)) {
      const t3 = this.m_description.getSemantics(n6), e6 = Ia.getComponentCount(t3);
      this.m_vertexAttributes.get(n6).eraseRange(e6 * o2, e6, e6 * this.m_pointCount);
    }
    if (this.m_curveData && this.m_curveData.m_segmentFlags) {
      this.checkCompactSegmentParams();
      let e6 = 0;
      if (o2 > i2 && this.isNonLinearSegment(o2 - 1)) e6 += 1, this.incCurveType(this.m_curveData.m_segmentFlags.read(o2 - 1), -1), this.m_curveData.m_segmentFlags.write(o2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(o2 - 1, -1);
      else {
        const s5 = this.getPathEnd(t2);
        r && i2 + 1 < s5 && this.isNonLinearSegment(s5 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(s5 - 1), -1), this.m_curveData.m_segmentFlags.write(s5 - 1, 1), this.m_curveData.m_segmentParamIndex.write(s5 - 1, -1), e6 += 1);
      }
      this.isNonLinearSegment(o2) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(o2), -1), e6 += 1), e6 > 0 && this.modifyCurveCounter(-e6), this.m_curveData.m_segmentFlags.eraseRange(o2, 1, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(o2, 1, this.m_pointCount);
    }
    for (let n6 = s4; n6 >= t2 + 1; n6--) {
      const t3 = this.m_paths.read(n6);
      this.m_paths.write(n6, t3 - 1);
    }
    this.m_pointCount--, this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  removePoint(t2) {
    let e5;
    e5 = t2 < 0 ? this.getPathCount() - 1 : this.getPathIndexFromPointIndex(t2), this.removePointFromPath(e5, t2 - this.getPathStart(e5));
  }
  getNumberOfCurves(t2) {
    if (!this.hasNonLinearSegments()) return 0;
    let e5 = 0;
    for (let s4 = this.getPathStart(t2), n6 = this.getPathEnd(t2); s4 < n6; s4++) _Ya.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s4)) && ++e5;
    return e5;
  }
  getPathCount() {
    return this.m_paths ? this.m_paths.size() - 1 : 0;
  }
  getPathSize(t2) {
    return this.m_paths.read(t2 + 1) - this.m_paths.read(t2);
  }
  getPathStart(t2) {
    return this.m_paths.read(t2);
  }
  getPathEnd(t2) {
    return this.m_paths.read(t2 + 1);
  }
  getPathIndexFromPointIndex(t2, e5 = -1) {
    -1 === e5 && (e5 = this.m_currentPathIndex);
    const s4 = this.getPathCount(), n6 = _Ya.getPathIndexFromPointIndexImpl(this.m_paths, s4, t2, e5);
    return this.m_currentPathIndex = n6, n6;
  }
  startPathCoords(t2, e5) {
    this.startPathPoint(new ee({ x: t2, y: e5 }));
  }
  startPath(t2) {
    this.startPathPoint(new ee({ pt: t2 }));
  }
  startPath3D(t2) {
    this.startPathPoint(new ee({ x: t2.x, y: t2.y, z: t2.z }));
  }
  startPath3DCoords(t2, e5, s4) {
    this.startPathPoint(new ee({ x: t2, y: e5, z: s4 }));
  }
  startPathPoint(t2) {
    t2.isEmpty() && P("");
    const s4 = t2.getDescription();
    let n6;
    if (this.m_description !== s4) {
      this.mergeVertexDescription(s4);
      const e5 = new ee({ vd: this.m_description });
      t2.copyCommonAttributesTo(e5), n6 = e5;
    } else n6 = t2;
    this.m_bPathStarted ? this.setPointByVal(this.m_pointCount - 1, n6) : (this.insertPoint(-1, -1, n6), this.m_bPathStarted = true);
  }
  beforeNewSegmentHelper2() {
    this.m_paths = J(2), this.m_paths.write(0, 0), this.m_pathFlags = K(2, 0), this.m_bPolygon && this.m_pathFlags.write(0, 1);
  }
  beforeNewSegmentHelper1() {
    null !== this.m_paths ? (this.m_paths.add(0), this.m_pathFlags.add(0), this.m_bPolygon && this.m_pathFlags.write(this.m_pathFlags.size() - 2, 1)) : this.beforeNewSegmentHelper2();
  }
  beforeNewSegment(t2) {
    0 !== this.m_pointCount || this.m_bPathStarted || this.startPathCoords(0, 0);
    const e5 = this.m_pointCount, s4 = this.m_paths.size() - 1, n6 = e5 + t2;
    this.m_paths.write(s4, n6), this.resizeImpl(n6), this.m_bPathStarted && (this.m_bPathStarted = false);
  }
  finishLineTo() {
    if (this.hasNonLinearSegments()) {
      const t2 = this.m_curveData.m_segmentFlags.read(this.m_pointCount - 1);
      1 !== t2 && (this.m_curveData.m_segmentFlags.write(this.m_pointCount - 1, 1), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 1, -1), this.modifyCurveCounter(-1), this.incCurveType(t2, -1));
    }
  }
  lineToCoords(t2, e5) {
    if (this.beforeNewSegment(1), 1 === this.m_description.getAttributeCount()) this.setXYCoords(this.m_pointCount - 1, t2, e5);
    else {
      const s4 = z3(), n6 = new ee({ vd: this.m_description, attribBuffer: s4, initDefaultValues: true });
      n6.setXYCoords(t2, e5), this.setPointByVal(this.m_pointCount - 1, n6);
    }
    this.finishLineTo();
  }
  lineTo(t2) {
    this.lineToCoords(t2.x, t2.y);
  }
  lineTo3D(t2) {
    this.beforeNewSegment(1);
    const e5 = H2(this.m_description, O2()), s4 = z3(), n6 = new ee({ vd: e5, attribBuffer: s4, initDefaultValues: true });
    n6.setXYZ(t2), this.setPointByVal(this.m_pointCount - 1, n6), this.finishLineTo();
  }
  lineTo3DCoords(t2, e5, s4) {
    this.lineTo3D(new X2(t2, e5, s4));
  }
  lineToPoint(t2) {
    if (this.beforeNewSegment(1), this.m_description === t2.getDescription()) this.setPointByVal(this.m_pointCount - 1, t2);
    else {
      this.mergeVertexDescription(t2.getDescription());
      const e5 = z3(), s4 = new ee({ vd: this.m_description, attribBuffer: e5, initDefaultValues: false });
      t2.copyCommonAttributesTo(s4), this.setPointByVal(this.m_pointCount - 1, s4);
    }
    this.finishLineTo();
  }
  openPathAndDuplicateStartVertex(t2) {
    this.m_bPolygon && b("");
    const s4 = this.getPathCount();
    if (t2 > s4 && P(""), !this.isClosedPath(t2)) return;
    this.m_pathFlags || b("");
    const n6 = this.m_pointCount, i2 = this.getPathStart(t2), r = this.getPathEnd(t2);
    if (r - i2 != 0) {
      this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
      for (let t3 = 0, e5 = this.m_description.getAttributeCount(); t3 < e5; t3++) if (this.m_vertexAttributes.get(t3)) {
        const e6 = this.m_description.getSemantics(t3), s5 = Ia.getComponentCount(e6);
        this.m_vertexAttributes.get(t3).insertRangeFromStream(s5 * r, this.m_vertexAttributes.get(t3), s5 * i2, s5, true, 1, s5 * n6);
      }
      for (let e5 = s4; e5 > t2; e5--) {
        const t3 = this.m_paths.read(e5);
        this.m_paths.write(e5, t3 + 1);
      }
      this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(r, 1, 1, n6), this.m_curveData.m_segmentParamIndex.insertRange(r, -1, 1, n6)), this.m_pathFlags.clearBits(t2, 1);
    }
  }
  openPath(t2) {
    this.m_bPolygon && b(""), t2 > this.getPathCount() && P(""), this.m_pathFlags || b(""), this.m_pathFlags.clearBits(t2, 1);
  }
  isStrongPathStart(t2) {
    return !!(2 & this.m_pathFlags.read(t2));
  }
  setStrongPathStart(t2, e5) {
    e5 ? this.m_pathFlags.setBits(t2, 2) : this.m_pathFlags.clearBits(t2, 2);
  }
  isStrongPathEnd(t2) {
    return !!(4 & this.m_pathFlags.read(t2));
  }
  setStrongPathEnd(t2, e5) {
    e5 ? this.m_pathFlags.setBits(t2, 4) : this.m_pathFlags.clearBits(t2, 4);
  }
  clearStrongPathEnds() {
    for (let t2 = 0, e5 = this.getPathCount(); t2 < e5; ++t2) this.m_pathFlags.clearBits(t2, 6);
  }
  openAllPathsAndDuplicateStartVertex() {
    if (this.m_bPolygon && b(""), this.isEmpty()) return;
    this.m_pathFlags || b("");
    let t2 = 0;
    const e5 = this.getPathCount();
    for (let h2 = 0; h2 < e5; h2++) this.isClosedPath(h2) && (this.getPathSize(h2) > 0 ? t2++ : this.m_pathFlags.clearBits(h2, 1));
    if (0 === t2) return;
    const s4 = this.hasNonLinearSegments();
    let n6 = 0;
    const i2 = this.getPathCount(), r = this.m_description.getAttributeCount(), o2 = new Array(r);
    let a2 = null, m2 = null;
    for (let h2 = 0; h2 < i2; ++h2) {
      const e6 = this.getPathStart(h2), i3 = this.getPathSize(h2), u = this.isClosedPath(h2);
      if (i3 > 0) {
        const h3 = e6 + n6;
        for (let s5 = 0; s5 < r; s5++) if (this.m_vertexAttributes.get(s5)) {
          const n7 = this.m_description.getSemantics(s5), r2 = Ia.getComponentCount(n7);
          if (!o2[s5]) {
            const e7 = r2 * (this.m_pointCount + t2), i4 = W2(n7, e7);
            o2[s5] = i4;
          }
          o2[s5].writeRange(h3 * r2, i3 * r2, this.m_vertexAttributes.get(s5), e6 * r2, true, 1), u && o2[s5].writeRange((h3 + i3) * r2, r2, this.m_vertexAttributes.get(s5), e6 * r2, true, 1);
        }
        if (s4) {
          if (null === a2) {
            const e7 = this.m_pointCount + t2;
            a2 = K(e7), m2 = J(e7);
          }
          a2.writeRange(h3, i3, this.m_curveData.m_segmentFlags, e6, true, 1), m2.writeRange(h3, i3, this.m_curveData.m_segmentParamIndex, e6, true, 1), u && (a2.write(h3 + i3, 1), m2.write(h3 + i3, -1));
        }
      }
      this.m_paths.write(h2, e6 + n6), u && (this.m_pathFlags.clearBits(h2, 1), ++n6);
    }
    this.m_paths.write(i2, this.m_pointCount + t2), this.m_pathFlags.clearBits(i2, 1);
    for (let h2 = 0; h2 < r; h2++) this.m_vertexAttributes.get(h2) && this.m_vertexAttributes.set(h2, o2[h2]);
    s4 && (this.m_curveData.m_segmentFlags = a2, this.m_curveData.m_segmentParamIndex = m2), this.m_pointCount += t2, this.m_reservedPointCount > 0 && (this.m_reservedPointCount = this.m_pointCount);
  }
  closePathWithLine(t2) {
    void 0 === t2 && (t2 = this.getPathCount() - 1), this.throwIfEmpty(), (t2 < 0 || t2 >= this.getPathCount()) && P("close_path_with_line"), t2 === this.getPathCount() - 1 && (this.m_bPathStarted = false);
    const s4 = this.m_pathFlags.read(t2);
    if (1 & s4 || this.m_pathFlags.write(t2, 1 | s4), this.m_curveData && this.m_curveData.m_segmentFlags) {
      const e5 = this.getPathEnd(t2) - 1, s5 = this.m_curveData.m_segmentFlags.read(e5);
      1 !== s5 && (this.m_curveData.m_segmentFlags.write(e5, 1), this.m_curveData.m_segmentParamIndex.write(e5, -1), 1 !== s5 && (this.incCurveType(s5, -1), this.modifyCurveCounter(-1)));
    }
    this.notifyModifiedFlags(2001);
  }
  closeLastPathWithSegment(t2) {
    this.closePathWithSegment(this.getPathCount() - 1, t2);
  }
  closePathWithSegment(t2, s4) {
    if (this.throwIfEmpty(), (t2 < 0 || t2 >= this.getPathCount()) && P("close_path_with_line"), s4.getEndXY().equals(this.getXY(this.getPathStart(t2))) || P("close_path_with_segment: end point mismatch"), t2 === this.getPathCount() - 1) this.m_bPathStarted = false, this.addSegment(s4, false), --this.m_pointCount, this.m_paths.write(t2 + 1, this.m_pointCount);
    else {
      this.mergeVertexDescription(s4.getDescription());
      const n7 = s4.getStartXY(), r = this.getPathEnd(t2) - 1;
      n7.equals(this.getXY(r)) || P("close_path_with_segment: start point mismatch");
      const o2 = s4.getGeometryType();
      if (o2 === a.enumLine) return void this.closePathWithLine(t2);
      {
        const t3 = Ms2(s4);
        this.initSegmentData(t3);
        const e5 = Ma.toSegType(o2), n8 = this.m_curveData.m_segmentFlags.read(r);
        if (n8 !== e5) this.m_curveData.m_segmentParamIndex.write(r, this.m_curveData.m_curveParamWritePoint), s4.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += t3, this.incCurveType(e5, 1), 1 !== n8 ? this.incCurveType(n8, -1) : this.modifyCurveCounter(1);
        else {
          const t4 = this.m_curveData.m_segmentParamIndex.read(r);
          s4.writeInBufferStream(this.m_curveData.m_segmentParams, t4);
        }
        this.m_curveData.m_segmentFlags.write(r, e5);
      }
    }
    const n6 = this.m_pathFlags.read(t2);
    1 & n6 || this.m_pathFlags.write(t2, 1 | n6), this.notifyModifiedFlags(2001);
  }
  closeAllPaths() {
    if (this.m_bPolygon || this.isEmptyImpl()) return;
    this.m_bPathStarted = false;
    let t2 = false;
    for (let e5 = 0, s4 = this.m_paths.size() - 1; e5 < s4; e5++) {
      if (this.isClosedPath(e5)) continue;
      const s5 = this.m_pathFlags.read(e5);
      this.m_pathFlags.write(e5, 1 | s5), t2 = true;
    }
    t2 && this.notifyModifiedFlags(512);
  }
  isClosedPath(t2) {
    return !!(1 & this.m_pathFlags.read(t2));
  }
  isClosedPathInXYPlane(t2) {
    if (this.isClosedPath(t2)) return true;
    const e5 = this.getPathStart(t2), s4 = this.getPathEnd(t2) - 1;
    if (e5 > s4) return false;
    const n6 = this.getXY(e5), i2 = this.getXY(s4);
    return n6.isEqualPoint2D(i2);
  }
  isClosedPathIn3D(t2) {
    return n2(0), false;
  }
  hasNonLinearSegmentsPath(t2) {
    if (!this.hasNonLinearSegments()) return false;
    for (let e5 = this.getPathStart(t2), s4 = this.getPathEnd(t2); e5 < s4; e5++) if (_Ya.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e5))) return true;
    return false;
  }
  isNonLinearSegment(t2) {
    return !(1 & this.getSegmentFlags(t2));
  }
  addEnvelope(t2, e5) {
    if (t2.isEmpty()) return;
    const s4 = 0 === this.m_pointCount;
    if (t2 instanceof n4) this.startPathCoords(t2.xmin, t2.ymin), e5 ? (this.lineToCoords(t2.xmax, t2.ymin), this.lineToCoords(t2.xmax, t2.ymax), this.lineToCoords(t2.xmin, t2.ymax)) : (this.lineToCoords(t2.xmin, t2.ymax), this.lineToCoords(t2.xmax, t2.ymax), this.lineToCoords(t2.xmax, t2.ymin));
    else {
      const s5 = t2.getDescription(), n6 = z3(), i2 = new ee({ vd: s5, attribBuffer: n6, initDefaultValues: false });
      for (let r = 0, o2 = 4; r < o2; r++) {
        const s6 = e5 ? o2 - r - 1 : r;
        t2.queryCornerByVal(s6, i2), 0 === r ? this.startPathPoint(i2) : this.lineToPoint(i2);
      }
    }
    this.closePathWithLine(), this.m_bPathStarted = false, s4 && !e5 && (this.setDirtyFlagProtected(256, false), this.m_bPolygon && Math.min(t2.width(), t2.height()) > 0 && this.setIsSimple(3, 0));
  }
  addPathFromClosedSegment(t2, s4) {
    if (t2.isClosed() || P("add_path_from_closedSegment: segment must be closed"), s4) {
      const e5 = t2.getReversed(), s5 = new ee();
      e5.queryStart(s5), this.startPathPoint(s5), this.closeLastPathWithSegment(e5);
    } else {
      const e5 = new ee();
      t2.queryStart(e5), this.startPathPoint(e5), this.closeLastPathWithSegment(t2);
    }
  }
  addSegment_(t2, s4) {
    const n6 = t2.getDescription();
    this.mergeVertexDescription(n6);
    const r = z3(), o2 = new ee({ vd: n6, attribBuffer: r, initDefaultValues: false }), a2 = t2.getGeometryType();
    if (a2 === a.enumLine) (s4 || this.isEmptyImpl()) && (t2.queryStart(o2), this.startPathPoint(o2)), t2.queryEnd(o2), this.lineToPoint(o2);
    else {
      let n7 = false;
      if ((s4 || this.isEmptyImpl()) && (n7 = true), !n7) {
        t2.getStartXY().equals(this.getXY(this.m_pointCount - 1)) || P("add_segment: start point mismatch");
      }
      if (n7 && (t2.queryStart(o2), this.startPathPoint(o2)), this.beforeNewSegment(1), t2.queryEnd(o2), o2.getDescription() === this.m_description) this.setPointByVal(this.m_pointCount - 1, o2);
      else {
        const t3 = z3(), e5 = new ee({ vd: this.m_description, attribBuffer: t3, initDefaultValues: false });
        o2.copyCommonAttributesTo(e5), this.setPointByVal(this.m_pointCount - 1, e5);
      }
      const i2 = Ms2(t2);
      this.initSegmentData(i2), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 2, this.m_curveData.m_curveParamWritePoint), t2.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += i2;
      const r2 = Ma.toSegType(a2);
      this.incCurveType(r2, 1), this.modifyCurveCounter(1), this.m_curveData.m_segmentFlags.write(this.m_pointCount - 2, r2);
    }
  }
  addSegment(t2, e5, s4) {
    s4 ? e5 ? this.addPathFromClosedSegment(t2, false) : this.closeLastPathWithSegment(t2) : this.addSegment_(t2, e5);
  }
  interpolateAttributesRange(t2, s4, n6, i2) {
    for (let a2 = t2; a2 < n6 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const r = this.m_description.getAttributeCount();
    if (1 === r) return;
    const o2 = this.calculateSubLength2D(t2, s4, n6, i2);
    if (0 !== o2) for (let e5 = 1; e5 < r; e5++) {
      const r2 = this.m_description.getSemantics(e5);
      this.interpolateAttributesSemanticsImpl(r2, t2, s4, n6, i2, o2);
    }
  }
  interpolateAttributesSemantics(t2, s4, n6, i2, r) {
    if (0 === t2) return;
    this.hasAttribute(t2) || P("does not have the given attribute");
    2 === Ia.getInterpolation(t2) && P("angular interpolation");
    for (let a2 = s4; a2 < i2 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const o2 = this.calculateSubLength2D(s4, n6, i2, r);
    0 !== o2 && this.interpolateAttributesSemanticsImpl(t2, s4, n6, i2, r, o2);
  }
  interpolateAttributesPath(t2, e5, s4) {
    const n6 = this.m_description.getAttributeCount();
    if (1 === n6) return;
    if (e5 === s4) return;
    const i2 = this.calculatePathSubLength2D(t2, e5, s4);
    for (let r = 1; r < n6; r++) {
      const n7 = this.m_description.getSemantics(r);
      this.interpolateAttributesSemanticsPathImpl(n7, t2, e5, s4, i2);
    }
  }
  interpolateAttributesSemanticsPath(t2, s4, n6, i2) {
    if (0 === t2) return;
    this.hasAttribute(t2) || P("does not have the given attribute");
    2 === Ia.getInterpolation(t2) && P("angular interpolation");
    const r = this.calculatePathSubLength2D(s4, n6, i2);
    0 !== r && this.interpolateAttributesSemanticsPathImpl(t2, s4, n6, i2, r);
  }
  interpolateAttributesSemanticsImpl(t2, e5, s4, n6, i2, r) {
    const o2 = this.querySegmentIterator(), a2 = this.getPathStart(e5) + s4, h2 = this.getPathStart(n6) + i2, m2 = Ia.getComponentCount(t2), u = Lt(Ia.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t2, a2, u, m2);
    const l2 = Lt(Ia.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t2, h2, l2, m2);
    const c = Lt(Ia.maxComponentCount(), Number.NaN);
    Tt(c, u, 0, 0, m2);
    let g2 = 0;
    const d2 = Ia.getDefaultValue(t2), _ = Ia.getInterpolation(t2);
    o2.resetToVertex(a2, e5);
    do {
      if (o2.hasNextSegment()) {
        if (o2.nextSegment(), o2.getStartPointIndex() === h2) return;
        this.setAttributeFromArray(t2, o2.getStartPointIndex(), c, m2), o2.previousSegment();
        do {
          const e6 = o2.nextSegment();
          if (o2.getEndPointIndex() === h2) return;
          g2 += e6.calculateLength2D();
          yt(_, u, l2, c, 0, m2, g2 / r, d2), o2.isClosingSegment() || this.setAttributeFromArray(t2, o2.getEndPointIndex(), c, m2);
        } while (o2.hasNextSegment());
      }
    } while (o2.nextPath());
  }
  interpolateAttributesSemanticsPathImpl(t2, e5, s4, n6, i2) {
    const r = this.querySegmentIterator(), o2 = Ia.getInterpolation(t2), a2 = this.getPathStart(e5) + s4, h2 = this.getPathStart(e5) + n6;
    if (h2 === a2) return;
    const m2 = Ia.getComponentCount(t2), u = Lt(Ia.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t2, a2, u, m2);
    const l2 = Lt(Ia.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t2, h2, l2, m2);
    const c = new n3(0);
    r.resetToVertex(a2, e5), r.setCirculator(this.isClosedPath(e5));
    const g2 = Ia.getDefaultValue(t2), d2 = Lt(Ia.maxComponentCount(), Number.NaN);
    Tt(d2, u, 0, 0, m2);
    const _ = 0 === i2;
    let p3 = 0.5;
    do {
      const e6 = r.nextSegment();
      if (this.setAttributeFromArray(t2, r.getStartPointIndex(), d2, m2), !_) {
        const t3 = e6.calculateLength2D();
        c.pe(t3), p3 = c.getResult() / i2;
      }
      yt(o2, u, l2, d2, 0, m2, p3, g2);
    } while (r.getEndPointIndex() !== h2);
  }
  querySegment(t2, s4, n6) {
    const i2 = this.getPathIndexFromPointIndex(t2), r = t2 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("get_segment"), this.getSegmentFromPath(i2, r, s4, n6);
  }
  getSegment(t2, e5) {
    const s4 = new this.m_segmentBufferCTor();
    return this.getSegmentBuffer(t2, s4, e5), s4.releaseSegment();
  }
  getSegmentType(t2) {
    const s4 = this.getPathIndexFromPointIndex(t2), n6 = t2 - this.getPathStart(s4);
    return n6 >= this.getSegmentCountPath(s4) && P("get_segment"), this.getSegmentTypeFromPath(s4, n6);
  }
  getSegmentFromPath(t2, e5, s4, n6) {
    const i2 = this.getPathStart(t2) + e5, r = this.getSegmentFlagsStreamRef();
    let o2 = 1;
    switch (r && (o2 = 31 & r.read(i2)), o2) {
      case 1:
        s4.createLine();
        break;
      case 2:
        s4.createCubicBezier();
        break;
      case 4:
        s4.createEllipticArc();
        break;
      case 8:
        s4.createQuadraticRationalBezier();
        break;
      case 16:
        s4.createQuadraticBezier();
        break;
      default:
        b("");
    }
    const a2 = s4.get();
    let m2, u = null;
    n6 ? (u = M(), a2.assignVertexDescription(u)) : a2.assignVertexDescription(this.m_description), m2 = i2 === this.getPathEnd(t2) - 1 && this.isClosedPath(t2) ? this.getPathStart(t2) : i2 + 1;
    Ne(a2, this.getXY(i2));
    if (Fe(a2, this.getXY(m2)), !n6) for (let h2 = 1, l2 = this.m_description.getAttributeCount(); h2 < l2; h2++) {
      const t3 = this.m_description.getSemantics(h2), e6 = Ia.getComponentCount(t3);
      for (let s5 = 0; s5 < e6; s5++) {
        const e7 = this.getAttributeAsDbl(t3, i2, s5);
        a2.setStartAttribute(t3, s5, e7);
        const n7 = this.getAttributeAsDbl(t3, m2, s5);
        a2.setEndAttribute(t3, s5, n7);
      }
    }
    if (_Ya.isNonLinearSegmentFlag(o2)) {
      const t3 = this.m_curveData.m_segmentParamIndex.read(i2);
      a2.readFromBufferStream(this.m_curveData.m_segmentParams, t3);
    }
  }
  replaceLinearEllipticalArcsWithTrueLines() {
    if (!this.hasNonLinearSegments()) return false;
    if (0 === this.m_curveData.m_arcCount) return false;
    let t2 = false;
    for (let e5 = 0, s4 = this.getPointCount(); e5 < s4; e5++) {
      if (4 === this.m_curveData.m_segmentFlags.read(e5)) {
        const s5 = this.m_curveData.m_segmentParamIndex.read(e5);
        Is2(this.m_curveData.m_segmentParams, s5).isNAN() && (this.m_curveData.m_segmentFlags.write(e5, 1), this.m_curveData.m_segmentParamIndex.write(e5, -1), this.incCurveType(4, -1), this.modifyCurveCounter(-1), t2 = true);
      }
    }
    return t2 && this.checkCompactSegmentParams(), t2;
  }
  queryPointAlongPath(t2, s4, n6, i2 = false) {
    const r = { iSegment: -1 }, o2 = i2 ? r : { iSegment: -1, tSegment: 0 };
    if (n6.setEmpty(), this.isEmpty()) return r;
    if ((t2 < 0 || t2 >= this.getPathCount()) && P("query_point_along_path"), s4 < 0) return r;
    const a2 = this.getPathSize(t2);
    if (0 === a2) return r;
    if (1 === a2) return this.getPointByVal(this.getPathStart(t2), n6), o2.tSegment = 0, r.iSegment = this.getPathStart(t2), r;
    const h2 = this.querySegmentIteratorAtVertex(this.getPathStart(t2)), m2 = new n3(0);
    for (; h2.hasNextSegment(); ) {
      const t3 = h2.nextSegment(), e5 = t3.calculateLength2D(), i3 = m2.getResult();
      if (m2.add(e5), m2.getResult() >= s4) {
        let a3 = s4 - i3;
        a3 > e5 && (a3 = e5);
        const m3 = t3.lengthToT(a3);
        return t3.queryCoord(m3, n6), o2.tSegment = m3, r.iSegment = h2.getStartPointIndex(), r;
      }
    }
    if (this.isClosedPath(t2)) {
      const e5 = this.getPathStart(t2);
      return this.getPointByVal(e5, n6), o2.tSegment = 1, r.iSegment = this.getPathEnd(t2) - 1, r;
    }
    {
      const e5 = this.getPathEnd(t2) - 1;
      return this.getPointByVal(e5, n6), this.getPathSize(t2) > 1 ? (o2.tSegment = 1, r.iSegment = this.getPathEnd(t2) - 2, r) : (o2.tSegment = 0, r.iSegment = this.getPathStart(t2), r);
    }
  }
  queryPointsAlongPath(t2, s4, n6, i2, r, o2) {
    {
      let t3 = 0;
      for (let a3 = 0; a3 < s4; ++a3) i2 && i2[a3].setEmpty(), r && (r[a3] = -1), o2 && (o2[a3] = 0), t3 > n6[a3] && P("query_points_along"), t3 = n6[a3];
    }
    const a2 = this.getPathSize(t2);
    if (0 === s4 || 0 === a2) return 0;
    if (1 === a2) {
      const e5 = this.getPathStart(t2);
      return i2 && this.getPointByVal(e5, i2[0]), o2 && (o2[0] = 0), r && (r[0] = e5), 1;
    }
    const h2 = this.getPathStart(t2), m2 = new n3(0), u = this.querySegmentIteratorAtVertex(h2);
    let l2 = 0, c = 0, g2 = n6[l2];
    for (; u.hasNextSegment(); ) {
      const t3 = u.nextSegment(), e5 = t3.calculateLength2D(), a3 = m2.getResult();
      for (m2.add(e5); m2.getResult() >= g2; ) {
        let h3 = g2 - a3;
        h3 > e5 && (h3 = e5);
        const m3 = t3.lengthToT(h3);
        if (i2 && t3.queryCoord(m3, i2[c]), o2 && (o2[c] = m3), r && (r[c] = u.getStartPointIndex()), c++, l2++, g2 = n6[l2], l2 === s4) return c;
      }
    }
    if (this.isClosedPath(t2)) {
      const e5 = this.getPathStart(t2), s5 = 0;
      i2 && this.getPointByVal(e5, i2[c]), o2 && (o2[c] = s5), r && (r[c] = e5), c++;
    } else if (this.getPathSize(t2) > 1) {
      const e5 = this.getPathEnd(t2) - 2, s5 = 1;
      i2 && this.getPointByVal(e5 + 1, i2[c]), o2 && (o2[c] = s5), r && (r[c] = e5), c++;
    }
    return c;
  }
  queryPointsAlong(t2, s4, n6, i2, r) {
    {
      let o3 = 0;
      for (let a3 = 0; a3 < t2; ++a3) n6 && n6[a3].setEmpty(), i2 && (i2[a3] = -1), r && (r[a3] = 0), o3 > s4[a3] && P("query_points_along"), o3 = s4[a3];
    }
    if (0 === t2) return 0;
    const o2 = new n3(0), a2 = this.querySegmentIterator();
    let h2 = -1, m2 = 0, u = 0, l2 = s4[m2];
    for (; a2.nextPath(); ) for (; a2.hasNextSegment(); ) {
      h2 = a2.getPathIndex();
      const e5 = a2.nextSegment(), c = e5.calculateLength2D(), g2 = o2.getResult();
      for (o2.add(c); o2.getResult() >= l2; ) {
        let o3 = l2 - g2;
        o3 > c && (o3 = c);
        const h3 = e5.lengthToT(o3);
        if (n6 && e5.queryCoord(h3, n6[u]), r && (r[u] = h3), i2 && (i2[u] = a2.getStartPointIndex()), u++, m2++, l2 = s4[m2], m2 === t2) return u;
      }
    }
    if (h2 < 0) return 0;
    if (this.isClosedPath(h2)) {
      const t3 = this.getPathStart(h2), e5 = 0;
      n6 && this.getPointByVal(t3, n6[u]), r && (r[u] = e5), i2 && (i2[u] = t3), u++;
    } else if (this.getPathSize(h2) > 1) {
      const t3 = this.getPathEnd(h2) - 2, e5 = 1;
      n6 && this.getPointByVal(t3 + 1, n6[u]), r && (r[u] = e5), i2 && (i2[u] = t3), u++;
    }
    return u;
  }
  querySegmentIterator() {
    return new Ds({ parent: this });
  }
  querySegmentIteratorAtVertex(t2) {
    return new Ds({ parent: this, pointIndex: t2 });
  }
  queryPathEnvelope(t2, e5) {
    this.queryPathEnvelopeImpl(t2, e5, true);
  }
  queryLoosePathEnvelope(t2, e5) {
    this.queryPathEnvelopeImpl(t2, e5, false);
  }
  queryPathEnvelopeImpl(t2, n6, i2) {
    if (n6 instanceof re && n2(0, "not implemented for Envelope"), n6 instanceof U3 && n2(0, "not implemented for Envelope3D"), (t2 >= this.getPathCount() || t2 < 0) && P(""), this.isEmpty()) return void n6.setEmpty();
    const r = this.getAttributeStreamRef(0), o2 = n4.constructEmpty();
    o2.setEmpty();
    for (let e5 = 2 * this.getPathStart(t2), a2 = 2 * this.getPathEnd(t2); e5 < a2; ) {
      const t3 = a2 - e5;
      n2(!(1 & t3)), o2.mergePointsInterleaved(r, e5 / 2, t3 / 2), e5 += t3;
    }
    if (n6.setCoords({ env2D: o2 }), this.hasNonLinearSegmentsPath(t2)) {
      const e5 = this.querySegmentIterator();
      if (e5.resetToPath(t2), e5.nextPath()) for (; e5.hasNextSegment(); ) {
        const t3 = e5.nextCurve();
        if (!t3) break;
        {
          const e6 = n4.constructEmpty();
          i2 ? t3.queryEnvelope(e6) : t3.queryLooseEnvelope(e6), n6.mergeEnvelope2D(e6);
        }
      }
      else n2(0);
    }
  }
  checkCompactSegmentParams() {
    if (!this.m_curveData || null === this.m_curveData.m_segmentParams) return false;
    if (this.m_curveData.m_segmentParams.size() <= this.m_vertexAttributes.get(0).size()) return false;
    const t2 = 10, e5 = Ys2(4) * this.m_curveData.m_arcCount + Ys2(2) * this.m_curveData.m_bezierCount + Ys2(8) * this.m_curveData.m_rbezier2Count + Ys2(16) * this.m_curveData.m_bezier2Count;
    return this.m_curveData.m_segmentParams.size() > Math.max(3 * e5 >> 1, t2) ? (this.forceCompactSegmentParams(), true) : (0 === this.m_pointCount && (this.m_curveData.m_curveParamWritePoint = 0), false);
  }
  forceCompactSegmentParams() {
    let t2 = 0;
    for (let n6 = 0, i2 = this.getPointCount(); n6 < i2; n6++) {
      const e6 = this.m_curveData.m_segmentFlags.read(n6);
      if (_Ya.isNonLinearSegmentFlag(e6)) {
        t2 += Ys2(e6);
      }
    }
    const e5 = $2(t2);
    let s4 = 0;
    for (let n6 = 0, i2 = this.getPointCount(); n6 < i2; n6++) {
      const t3 = this.m_curveData.m_segmentFlags.read(n6);
      if (_Ya.isNonLinearSegmentFlag(t3)) {
        let i3 = this.m_curveData.m_segmentParamIndex.read(n6);
        this.m_curveData.m_segmentParamIndex.write(n6, s4);
        const r = Ys2(t3);
        for (let t4 = 0; t4 < r; t4++) e5.write(s4, this.m_curveData.m_segmentParams.read(i3)), s4++, i3++;
      }
    }
    this.m_curveData.m_segmentParams = e5, this.m_curveData.m_curveParamWritePoint = s4;
  }
  setEmpty() {
    this.m_curveData && (this.removeAllCurvesFromGlobalCounter(), this.m_curveData = null), this.m_bPathStarted = false, this.m_paths = null, this.m_pathFlags = null, this.setEmptyImpl();
  }
  applyTransformation(t2) {
    this.applyTransformationToPath(t2, -1);
  }
  applyTransformation3D(t2) {
    n2(0);
  }
  getImpl() {
    return this;
  }
  reserve(t2) {
    this.reserveImpl(t2), t2 > 0 && !this.m_paths && (this.m_paths = J(0), this.m_pathFlags = K(0), this.m_paths.reserve(2), this.m_pathFlags.reserve(2), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0));
  }
  reserveParts(t2, e5) {
    this.reserveImpl(t2), e5 > 0 && (this.m_paths ? (this.m_paths.reserve(e5 + 1), this.m_pathFlags.reserve(e5 + 1)) : (this.m_paths = J(0), this.m_pathFlags = K(0), this.m_paths.reserve(e5 + 1), this.m_pathFlags.reserve(e5 + 1), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0)));
  }
  clone() {
    const t2 = this.createInstance();
    return this.copyTo(t2), t2;
  }
  queryLimitedSegmentIterator(t2) {
    return new Xa(this, t2);
  }
  getPathStreamRef() {
    return this.throwIfEmpty(), this.m_paths;
  }
  setPathStreamRef(t2) {
    this.m_paths = t2;
  }
  getSegmentFlagsStreamRef() {
    return this.throwIfEmpty(), null != this.m_curveData ? this.m_curveData.m_segmentFlags : null;
  }
  getPathFlagsStreamRef() {
    return this.throwIfEmpty(), this.m_pathFlags;
  }
  setPathFlagsStreamRef(t2) {
    this.m_pathFlags = t2;
  }
  getSegmentIndexStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParamIndex : null;
  }
  getSegmentDataStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParams : null;
  }
  setSegmentData(t2, e5, s4, n6) {
    this.m_curveData || (this.m_curveData = new Ma()), this.m_curveData.m_segmentFlags = s4, this.m_curveData.m_segmentParams = e5, this.m_curveData.m_segmentParamIndex = t2, this.m_curveData.m_curveParamWritePoint = n6;
  }
  static getPathIndexFromPointIndexImpl(t2, e5, s4, n6) {
    if (n6 >= 0 && n6 < e5) {
      if (s4 >= t2.read(n6)) {
        if (s4 < t2.read(n6 + 1)) return n6;
        n6++;
      } else n6--;
      if (n6 >= 0 && n6 < e5 && s4 >= t2.read(n6) && s4 < t2.read(n6 + 1)) return n6;
    }
    if (e5 < 5) {
      for (let n7 = 0; n7 < e5; n7++) if (s4 < t2.read(n7 + 1)) return n7;
      v("");
    }
    let i2 = 0, r = e5 - 1;
    for (; r > i2; ) {
      const e6 = i2 + (r - i2 >> 1);
      if (s4 < t2.read(e6)) r = e6 - 1;
      else {
        if (!(s4 >= t2.read(e6 + 1))) return e6;
        i2 = e6 + 1;
      }
    }
    return i2;
  }
  getHighestPointIndex(t2) {
    n2(t2 >= 0 && t2 < this.getPathCount());
    const e5 = this.getAttributeStreamRef(0), n6 = this.getPathEnd(t2), i2 = this.getPathStart(t2);
    let r = -1;
    const o2 = new ei();
    o2.y = Number.NEGATIVE_INFINITY, o2.x = Number.NEGATIVE_INFINITY;
    for (let s4 = i2 + 0; s4 < n6; s4++) {
      const t3 = e5.readPoint2D(2 * s4);
      -1 === o2.compare(t3) && (r = s4, o2.setCoordsPoint2D(t3));
    }
    return r;
  }
  applyTransformationToPath(t2, s4) {
    if (s4 >= this.getPathCount() && P("apply_transformation"), this.isEmpty()) return;
    if (t2.isIdentity()) return;
    const n6 = this.m_vertexAttributes.get(0);
    if (!(s4 < 0 ? this.hasNonLinearSegments() : this.hasNonLinearSegmentsPath(s4))) {
      let e5, i3;
      return s4 < 0 ? (e5 = 0, i3 = this.m_pointCount) : (e5 = this.getPathStart(s4), i3 = this.getPathEnd(s4)), n6.applyTransformation(t2, 2 * e5, i3 - e5), void this.notifyModifiedFlags(2001);
    }
    const i2 = new this.m_segmentBufferCTor(), r = this.getPathCount();
    let o2 = s4 < 0 ? 0 : s4;
    do {
      const e5 = this.getPathStart(o2), r2 = this.getPathEnd(o2), a2 = this.isClosedPath(o2), h2 = n6.readPoint2D(2 * e5);
      if (!this.hasNonLinearSegmentsPath(o2)) {
        n6.applyTransformation(t2, 2 * e5, r2 - e5);
        continue;
      }
      const m2 = ei.getNAN();
      for (let s5 = e5; s5 < r2; ++s5) {
        if (1 !== (31 & this.m_curveData.m_segmentFlags.read(s5))) {
          const o4 = a2 && s5 + 1 === r2;
          o4 && n6.writePoint2D(2 * e5, h2), this.getSegmentBuffer(s5, i2, true), i2.get().applyTransformation(t2);
          const m3 = this.m_curveData.m_segmentParamIndex.read(s5);
          i2.get().writeInBufferStream(this.m_curveData.m_segmentParams, m3), n6.writePoint2D(2 * s5, i2.get().getStartXY()), o4 && n6.writePoint2D(2 * e5, i2.get().getEndXY());
          continue;
        }
        const o3 = 2 * s5;
        n6.queryPoint2D(o3, m2), t2.transformInPlace(m2), n6.writePoint2D(o3, m2);
      }
      if (o2 === s4) break;
    } while (++o2 < r);
    this.notifyModifiedFlags(2001);
  }
  calculateSubLength2D(t2, e5, s4, n6) {
    const i2 = this.getPathStart(t2) + e5, r = this.getPathStart(s4) + n6;
    (r < i2 || i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o2 = this.querySegmentIterator();
    let a2 = 0;
    o2.resetToVertex(i2, t2);
    do {
      for (; o2.hasNextSegment(); ) {
        const t3 = o2.nextSegment();
        if (o2.getStartPointIndex() === r) break;
        a2 += t3.calculateLength2D();
      }
      if (o2.getStartPointIndex() === r) break;
    } while (o2.nextPath());
    return a2;
  }
  calculatePathSubLength2D(t2, s4, n6) {
    const i2 = this.getPathStart(t2) + s4, r = this.getPathStart(t2) + n6;
    (i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o2 = this.querySegmentIterator();
    if (i2 > r && (this.isClosedPath(t2) || P("cannot iterate across an open path"), o2.setCirculator(true)), i2 === r) return 0;
    let a2 = 0, h2 = 0;
    o2.resetToVertex(i2, t2);
    do {
      h2 += a2;
      a2 = o2.nextSegment().calculateLength2D();
    } while (o2.getStartPointIndex() !== r);
    return h2;
  }
  calculateEnvelope2D(t2) {
    return this.updateXYImpl(t2);
  }
  updateXYImpl(t2) {
    const e5 = super.updateXYImpl(t2);
    if (this.hasNonLinearSegments()) {
      const s4 = n4.constructEmpty(), n6 = this.querySegmentIterator();
      for (; n6.nextPath(); ) for (; n6.hasNextSegment(); ) {
        const i2 = n6.nextCurve();
        if (!i2) break;
        t2 ? i2.queryEnvelope(s4) : i2.queryLooseEnvelope(s4), e5.mergeEnvelope2D(s4);
      }
    }
    return e5;
  }
  notifyModifiedAllImpl() {
    null !== this.m_paths && this.m_paths.size() ? this.m_pointCount = this.m_paths.read(this.m_paths.size() - 1) : this.m_pointCount = 0;
  }
  setDirtyOGCFlags(t2) {
    this.setDirtyFlagProtected(16, t2);
  }
  hasDirtyOGCStartFlags() {
    return this.hasDirtyFlag(16);
  }
  setDirtyRingAreas2D(t2) {
    this.setDirtyFlagProtected(1024, t2);
  }
  hasDirtyRingAreas2D() {
    return this.hasDirtyFlag(1024);
  }
  static isNonLinearSegmentFlag(t2) {
    return !(1 & t2);
  }
  addAndExplicitlyOpenAllPaths(t2, s4) {
    this === t2 && P("Multi_path_impl::add");
    let n6 = this.getPathCount();
    for (let e5 = 0, i2 = t2.getPathCount(); e5 < i2; e5++) this.addPath(t2, e5, !s4), this.openPathAndDuplicateStartVertex(n6), n6++;
  }
  getSegmentFlags(t2) {
    return null !== this.m_curveData && null !== this.m_curveData.m_segmentFlags ? this.m_curveData.m_segmentFlags.read(t2) : 1;
  }
  getSegmentBuffer(t2, s4, n6) {
    const i2 = this.getPathIndexFromPointIndex(t2), r = t2 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("getSegmentBuffer"), this.getSegmentFromPath(i2, r, s4, n6);
  }
  getSegmentTypeFromPath(t2, e5) {
    const s4 = this.getPathStart(t2) + e5, n6 = this.getSegmentFlagsStreamRef();
    let r = 1;
    switch (n6 && (r = 31 & n6.read(s4)), r) {
      case 1:
        return a.enumLine;
      case 2:
        return a.enumBezier;
      case 4:
        return a.enumEllipticArc;
      case 8:
        return a.enumRationalBezier2;
      case 16:
        return a.enumBezier2;
      default:
        b("");
    }
  }
  ensureXYMonotoneSegments() {
    if (!this.m_curveData) return false;
    let t2 = false;
    for (let e5 = 0, s4 = this.getPathCount(); e5 < s4; e5++) {
      const s5 = this.getPathStart(e5), n6 = this.getPathEnd(e5), i2 = n6 - s5;
      for (let e6 = s5; e6 < n6; e6++) {
        const n7 = 31 & this.m_curveData.m_segmentFlags.read(e6);
        if (1 === n7) continue;
        2 !== n7 && z("ensure_xy_monotone_segments");
        const r = (e6 - s5 + 1) % i2 + s5, o2 = this.m_curveData.m_segmentParamIndex.read(e6), h2 = Rt(ei, 4);
        h2[0] = this.getXY(e6), h2[3] = this.getXY(r), h2[1].x = this.m_curveData.m_segmentParams.read(o2), h2[1].y = this.m_curveData.m_segmentParams.read(o2 + 1), h2[2].x = this.m_curveData.m_segmentParams.read(o2 + 2), h2[2].y = this.m_curveData.m_segmentParams.read(o2 + 3), zo(h2) && (t2 = true, this.m_curveData.m_segmentParams.write(o2, h2[1].x), this.m_curveData.m_segmentParams.write(o2 + 1, h2[1].y), this.m_curveData.m_segmentParams.write(o2 + 2, h2[2].x), this.m_curveData.m_segmentParams.write(o2 + 3, h2[2].y));
      }
    }
    return t2 && this.notifyModifiedFlags(2001), t2;
  }
  buildRasterizedGeometryAccelerator(t2, e5) {
    return false;
  }
  buildQuadTreeAccelerator(t2) {
    if (this.m_accelerators || (this.m_accelerators = new ws2()), null !== this.m_accelerators.getQuadTree()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTree(null);
    const e5 = Wt(this);
    return this.m_accelerators.setQuadTree(e5), true;
  }
  buildQuadTreeForPathsAccelerator(t2) {
    if (this.m_accelerators || (this.m_accelerators = new ws2()), null !== this.m_accelerators.getQuadTreeForPaths()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTreeForPaths(null);
    const e5 = Qt2(this);
    return this.m_accelerators.setQuadTreeForPaths(e5), true;
  }
  updateCurveCounter(t2) {
    this.modifyCurveCounter(t2 - this.getCurveCount());
  }
  removeAllCurvesFromGlobalCounter() {
    this.m_curveData && (_Ya.st_totalCurveCount -= this.m_curveData.m_curveCount, this.m_curveData.m_curveCount = 0, this.m_curveData.m_bezierCount = 0, this.m_curveData.m_arcCount = 0, this.m_curveData.m_bezier2Count = 0, this.m_curveData.m_rbezier2Count = 0, this.m_curveData.m_curveParamWritePoint = 0);
  }
  modifyCurveCounter(t2) {
    t2 && (this.m_curveData || (this.m_curveData = new Ma()), _Ya.st_totalCurveCount += t2, this.m_curveData.m_curveCount += t2);
  }
  getCurveCount() {
    return this.m_curveData ? this.m_curveData.m_curveCount : 0;
  }
  incCurveType(t2, e5) {
    this.m_curveData || (this.m_curveData = new Ma()), 2 & t2 ? this.m_curveData.m_bezierCount += e5 : 4 & t2 ? this.m_curveData.m_arcCount += e5 : 8 & t2 ? this.m_curveData.m_rbezier2Count += e5 : 16 & t2 && (this.m_curveData.m_bezier2Count += e5);
  }
  getCurveWritePoint() {
    return null !== this.m_curveData ? this.m_curveData.m_curveParamWritePoint : 0;
  }
  initSegmentData(t2) {
    null === this.m_curveData && (this.m_curveData = new Ma());
    const e5 = this.m_reservedPointCount > 0 ? this.m_reservedPointCount : this.m_pointCount;
    null === this.m_curveData.m_segmentParamIndex && (this.m_curveData.m_segmentFlags = K(e5, 1), this.m_curveData.m_segmentParamIndex = J(e5, -1));
    const s4 = this.m_curveData.m_curveParamWritePoint + t2;
    null === this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams = $2(s4) : s4 !== this.m_curveData.m_segmentParams.size() && this.m_curveData.m_segmentParams.resize(s4, 0), this.m_curveData.m_segmentFlags.size() < e5 && (this.m_curveData.m_segmentFlags.resize(e5, 1), this.m_curveData.m_segmentParamIndex.resize(e5, -1));
  }
  updateCurveWritePoint(t2) {
    null === this.m_curveData && (this.m_curveData = new Ma()), this.m_curveData.m_curveParamWritePoint = t2;
  }
  updateOGCFlagsHelper() {
    const t2 = this.getPathCount();
    if (0 === t2) return;
    const e5 = this.m_pathFlags;
    let s4 = 0;
    for (let n6 = 0; n6 < t2; n6++) {
      const t3 = this.m_cachedRingAreas2D.read(n6);
      0 === s4 && (s4 = X(t3)), t3 * s4 > 0 || 0 === s4 ? e5.setBits(n6, 8) : e5.clearBits(n6, 8);
    }
  }
  updateOGCFlagsProtected() {
    this.hasDirtyFlag(16) && (this.updateRingAreas2DProtected(), this.updateOGCFlagsHelper(), this.setDirtyFlagProtected(16, false));
  }
  replaceSegment(t2, n6, i2) {
    (t2 < 0 || t2 >= this.getPointCount()) && P("Multi_path_impl.replace_segment"), n2(n6.isCurve());
    const r = this.getPathIndexFromPointIndex(t2), o2 = this.getPathStart(r), a2 = (t2 - o2 + 1) % this.getPathSize(r) + o2;
    {
      const e5 = this.getXY(t2), i3 = this.getXY(a2), r2 = !e5.isEqualPoint2D(n6.getStartXY()) || !i3.isEqualPoint2D(n6.getEndXY());
      n2(!r2);
    }
    const h2 = n6.getDescription();
    this.mergeVertexDescription(h2);
    const m2 = Lt(32, Number.NaN), u = new ee({ vd: h2, attribBuffer: m2, initDefaultValues: false }), l2 = null === this.m_curveData ? 1 : 31 & this.m_curveData.m_segmentFlags.read(t2), c = Ys2(l2), g2 = Ms2(n6);
    let d2, _ = false;
    c >= g2 ? (n2(null !== this.m_curveData), _ = true, d2 = this.m_curveData.m_segmentParamIndex.read(t2)) : (this.initSegmentData(g2), _ = false, d2 = this.m_curveData.m_curveParamWritePoint);
    const p3 = n6.getGeometryType(), f3 = Ma.toSegType(p3);
    i2 || (n6.queryStart(u), this.setPointByVal(t2, u), n6.queryEnd(u), this.setPointByVal(a2, u)), this.m_curveData.m_segmentParamIndex.write(t2, 1 !== f3 ? d2 : -1), this.m_curveData.m_segmentFlags.write(t2, f3), 1 !== f3 && n6.writeInBufferStream(this.m_curveData.m_segmentParams, d2), _ || (this.m_curveData.m_curveParamWritePoint += g2), l2 !== f3 && (this.incCurveType(l2, -1), this.incCurveType(f3, 1), this.modifyCurveCounter(1 === l2 ? 1 : -1));
  }
  setAttributeImpl(t2, s4, n6) {
    if (this.addAttribute(t2), !this.isEmpty()) if (this.hasNonLinearSegments() && 0 === t2) {
      (s4 < 0 || s4 > 1) && P("");
      const t3 = new x3(), i2 = 0 === s4 ? n6 : 0, r = 0 === s4 ? 0 : 1;
      t3.setShiftCoords(i2, r), 0 === s4 ? t3.xx = 0 : t3.yy = 0, this.applyTransformation(t3);
    } else super.setAttributeImpl(t2, s4, n6);
  }
};
Ya.st_totalCurveCount = 0;
var Xa = class {
  constructor(t2, e5) {
    this.m_segIter = null, this.m_quadTree = null, this.m_qtIter = null, this.m_extentOfInterest = new n4(e5), this.m_bfirst = true, this.m_prevIndex = -100, this.m_parent = t2;
  }
  nextSegment() {
    return this.m_bfirst && this.prepare_(), this.m_quadTree ? this.nextSegmentQt() : this.nextSegmentNoQt();
  }
  getPathIndex() {
    return this.m_segIter.getPathIndex();
  }
  getStartPointIndex() {
    return this.m_segIter.getStartPointIndex();
  }
  getEndPointIndex() {
    return this.m_segIter.getEndPointIndex();
  }
  isClosingSegment() {
    return this.m_segIter.isClosingSegment();
  }
  isPathClosed() {
    return this.m_segIter.isPathClosed();
  }
  prepare_() {
    const t2 = this.m_parent.getAccelerators();
    t2 && (this.m_quadTree = t2.getQuadTree(), this.m_quadTree && (this.m_qtIter = this.m_quadTree.getSortedIterator(this.m_extentOfInterest, 0))), this.m_segIter = this.m_parent.querySegmentIterator();
  }
  nextSegmentQt() {
    this.m_bfirst = false;
    const t2 = this.m_qtIter.next();
    if (-1 === t2) return null;
    const e5 = this.m_quadTree.getElement(t2);
    (e5 !== this.m_prevIndex + 1 || this.m_segIter.isLastSegmentInPath()) && (this.m_segIter.resetToVertex(e5, this.m_segIter.getPathIndex()), this.m_prevIndex = e5);
    return this.m_segIter.nextSegment();
  }
  nextSegmentNoQt() {
    for (; ; ) {
      if (!this.m_bfirst && this.m_segIter.hasNextSegment()) {
        const t2 = this.m_segIter.nextSegment(), e5 = n4.constructEmpty();
        if (t2.queryLooseEnvelope(e5), !e5.isIntersecting(this.m_extentOfInterest)) continue;
        return t2;
      }
      if (this.m_bfirst = false, !this.m_segIter.nextPath()) return null;
    }
  }
};
var Na = class _Na extends Ya {
  constructor(t2) {
    t2 ? t2.vd ? (super({ vd: t2.vd, bPolygon: false }), this.m_segmentBufferCTor = nu) : t2.copy ? (super({ vd: t2.copy.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = nu, t2.copy.copyTo(this)) : t2.move ? (super({ move: t2.move }), this.m_segmentBufferCTor = nu) : t2.start ? (super({ vd: t2.start.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = nu, this.startPathPoint(t2.start), this.lineToPoint(t2.end)) : t2.path ? (super({ bPolygon: false }), this.m_segmentBufferCTor = nu, this.addPathPoint2D(t2.path, t2.pointCount, t2.bForward)) : b("bad constructor arg") : (super({ bPolygon: false }), this.m_segmentBufferCTor = nu);
  }
  getBoundary() {
    return Va(this);
  }
  assignCopy(t2) {
    return this !== t2 && t2.copyTo(this), this;
  }
  assignMove(t2) {
    return t2.copyTo(this), this;
  }
  getGeometryType() {
    return _Na.type;
  }
  getDimension() {
    return 1;
  }
  createInstance() {
    return new _Na({ vd: this.getDescription() });
  }
  equals(t2, e5) {
    return this.equalsBase(t2, e5);
  }
};
Na.type = a.enumPolyline;
var qa = a;
function Fa(t2, e5) {
  if (t2.isEmpty()) return false;
  const s4 = t2.getGeometryType();
  if (s4 === qa.enumPolygon) return 0 !== t2.calculateArea2D();
  if (s4 === qa.enumPolyline) return La(t2.getImpl(), e5, true).bNotEmpty;
  if (s4 === qa.enumEnvelope) return true;
  if (f(s4)) return !!t2.isClosed();
  if (l(s4)) return false;
  if (s4 === qa.enumGeometryCollection) {
    const s5 = t2;
    for (let t3 = 0, n6 = s5.getGeometryCount(); t3 < n6; t3++) if (Fa(s5.getGeometry(t3), e5)) return true;
    return false;
  }
  z("");
}
function Va(t2, e5) {
  const s4 = t2.getGeometryType();
  if (s4 === qa.enumPolygon) {
    const e6 = new Na({ vd: t2.getDescription() });
    return t2.isEmpty() || t2.copyToUnchecked(e6), e6;
  }
  if (s4 === qa.enumPolyline) return La(t2.getImpl(), e5, false).boundary;
  if (s4 === qa.enumEnvelope) {
    const e6 = new Na({ vd: t2.getDescription() });
    return t2.isEmpty() || e6.addEnvelope(t2, false), e6;
  }
  if (f(s4)) {
    const e6 = new Ce({ vd: t2.getDescription() });
    if (!t2.isEmpty() && !t2.isClosed()) {
      const s5 = new ee();
      e6.reserve(2), t2.queryStart(s5), e6.add(s5), t2.queryEnd(s5), e6.add(s5);
    }
    return e6;
  }
  if (s4 === qa.enumGeometryCollection) {
    const s5 = t2;
    let n6 = null;
    for (let i2 = 0, r = s5.getGeometryCount(); i2 < r; i2++) {
      const r2 = Va(s5.getGeometry(i2), e5);
      if (null !== r2) {
        null === n6 && (n6 = t2.createInstance());
        const e6 = r2;
        n6.addGeometry(e6);
      }
    }
    return n6;
  }
  if (l(s4)) return new ee({ vd: t2.getDescription() });
  z("");
}
function La(t2, e5, s4) {
  const n6 = false, i2 = t2;
  let r = null;
  if (s4 || (r = new Ce({ vd: i2.getDescription() })), !i2.isEmpty()) {
    const t3 = new st2(0);
    for (let e6 = 0, s5 = i2.getPathCount(); e6 < s5; e6++) {
      if (i2.getPathSize(e6) > 0 && !i2.isClosedPathInXYPlane(e6)) {
        const s6 = i2.getPathStart(e6);
        t3.add(s6);
        const n7 = i2.getPathEnd(e6) - 1;
        t3.add(n7);
      }
    }
    if (t3.size() > 0) {
      const e6 = new ht(), n7 = i2.getAttributeStreamRef(0), o2 = { userSort(t4, e7, s5) {
        const i3 = ei.getNAN(), r2 = ei.getNAN();
        s5.sort(t4, e7, (t5, e8) => (n7.queryPoint2D(2 * t5, i3), n7.queryPoint2D(2 * e8, r2), i3.compare(r2)));
      }, getValue: (t4) => n7.read(2 * t4 + 1) };
      e6.sort(t3, 0, t3.size(), o2);
      let a2 = n7.readPoint2D(2 * t3.read(0)), h2 = 0, m2 = 1;
      const u = new ee();
      for (let i3 = 1, r2 = t3.size(); i3 < r2; i3++) {
        const e7 = n7.readPoint2D(2 * t3.read(i3));
        if (e7.isEqualPoint2D(a2)) t3.read(h2) > t3.read(i3) ? (t3.write(h2, os()), h2 = i3) : t3.write(i3, os()), m2++;
        else {
          if (1 & m2) {
            if (s4) return { bNotEmpty: true, boundary: new Ce({}) };
          } else t3.write(h2, os());
          a2 = e7, h2 = i3, m2 = 1;
        }
      }
      if (1 & m2) {
        if (s4) return { bNotEmpty: true, boundary: new Ce({}) };
      } else t3.write(h2, os());
      if (!s4) {
        t3.sort(0, t3.size());
        for (let e7 = 0, s5 = t3.size(); e7 < s5 && t3.read(e7) !== os(); e7++) i2.getPointByVal(t3.read(e7), u), r.add(u);
      }
    }
  }
  return s4 ? { bNotEmpty: n6, boundary: new Ce({}) } : { bNotEmpty: n6, boundary: r };
}
var Ra = Vt / 180;
var za = 180 / Vt;
function ka(t2) {
  let e5 = t2;
  return e5 >= -360 && e5 < 720 ? (e5 < 0 ? e5 += 360 : e5 >= 360 && (e5 -= 360), e5) : (e5 = ct(e5, 360), e5 < 0 && (e5 += 360), e5);
}
function Ba(t2) {
  let e5 = t2;
  return e5 = ka(e5), e5 > 180 && (e5 -= 360), e5;
}
function Ga(t2) {
  return t2 * Ra;
}
function Wa(t2) {
  return t2 * za;
}
function ja(t2) {
  const e5 = Qs();
  let s4 = t2;
  return s4 >= -e5 && s4 < 2 * e5 ? (s4 < 0 && (s4 += e5), s4 >= e5 && (s4 -= e5), s4) : (s4 = ct(s4, e5), s4 < 0 && (s4 += e5), s4);
}
function Za(t2) {
  const e5 = Gs();
  let s4 = t2;
  return s4 > -e5 && s4 <= e5 || (s4 = ja(s4), s4 > e5 && (s4 -= Qs())), s4;
}
function Ha(t2, e5) {
  return Ba(e5 - t2);
}
var Ua = B3;
var Oa = class _Oa extends ns {
  constructor(t2) {
    if (void 0 === t2 || Ot(t2, "vd")) return super({ vd: t2 == null ? void 0 : t2.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_semiMajorAxis = 0, this.m_minorMajorRatio = 1, this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, this.m_center = new ei(0, 0), this.m_sweepAngle = 0, this.m_startAngle = 0, this.m_interior = new ei(0, 0), void (this.m_bits = 0);
    if (t2.copy) return super(t2), void (this !== t2.copy && (this.m_center = new ei(0, 0), this.m_interior = new ei(0, 0), t2.copy.copyToImpl(this)));
    if (t2.move) super(t2), this.m_semiMajorAxis = t2.move.m_semiMajorAxis, this.m_minorMajorRatio = t2.move.m_minorMajorRatio, this.m_rotation = t2.move.m_rotation, this.m_cosr = t2.move.m_cosr, this.m_sinr = t2.move.m_sinr, this.m_center = t2.move.m_center.clone(), this.m_sweepAngle = t2.move.m_sweepAngle, this.m_startAngle = t2.move.m_startAngle, this.m_interior = t2.move.m_interior.clone(), this.m_bits = t2.move.m_bits, this.m_cachedValues = t2.move.m_cachedValues, t2.move.m_cachedValues = null;
    else {
      if (t2.fromPoint) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new ei(0, 0), this.m_interior = new ei(0, 0), void this.constructCircularArcThreePoint(t2.fromPoint, t2.toPoint, t2.interiorPoint);
      if (t2.center) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new ei(0, 0), this.m_interior = new ei(0, 0), void this.constructCircleRadius(t2.radius, t2.center, t2.bIsCounterClockwise);
      if (t2.semiMajorAxis) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), void this.constructEllipticArcEndPoints(t2.fromPoint, t2.toPoint, t2.semiMajorAxis, t2.minorMajorRatio, t2.axisXRotationRad, t2.bBigArc, t2.bIsCounterClockwise);
    }
  }
  getBoundary() {
    return Va(this);
  }
  assignCopy(t2) {
    return this !== t2 && t2.copyTo(this), this;
  }
  constructCircleRadius(t2, e5, s4 = false) {
    return this.constructEllipse(t2, 1, e5, 0, s4), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircleCenterAndPoint(t2, e5, s4 = false) {
    const n6 = ei.distance(t2, e5);
    return this.constructEllipticArcEndPointsCenter(e5, e5, n6, 1, 0, true, s4, t2), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructTwoPointCircle(t2, e5, s4 = false) {
    const n6 = ei.lerp(t2, e5, 0.5);
    return this.constructCircleCenterAndPoint(n6, t2, s4), this;
  }
  constructLineEllipticArc(t2, e5) {
    return Rh(this, t2, e5, 1), this;
  }
  constructLineCircularArc(t2, e5) {
    return Rh(this, t2, e5, 0), this;
  }
  constructEllipse(t2, e5, s4, n6, i2 = false) {
    this.m_semiMajorAxis = Math.abs(t2), this.m_minorMajorRatio = Math.abs(e5), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const r = new ei(0, this.m_minorMajorRatio * this.m_semiMajorAxis), o2 = Math.cos(n6), a2 = Math.sin(n6);
    return r.rotateDirect(o2, a2), r.addThis(s4), this.constructEllipticArcEndPointsCenter(r, r, this.m_semiMajorAxis, this.m_minorMajorRatio, n6, true, i2, s4), this;
  }
  inflate(t2) {
    if (this.isDegenerateToLine()) return;
    let e5 = this.getSemiMinorAxis() + t2;
    if (e5 = e5 <= 0 ? 0 : (this.getSemiMajorAxis() + t2) / this.getSemiMajorAxis(), this.isCircular()) {
      const t3 = new x3();
      t3.setShiftCoords(-this.m_center.x, -this.m_center.y), t3.scale(e5, e5), t3.shiftCoords(this.m_center.x, this.m_center.y), this.applyTransformation(t3);
    } else {
      const t3 = new x3();
      this.canonicToWorldTransformation(t3);
      const s4 = t3.clone();
      s4.invertPreciseThis(), s4.scale(e5, e5), s4.multiply(t3), this.applyTransformation(s4);
    }
  }
  constructEnclosingCircle(t2, e5, s4 = false) {
    return am(this, t2, e5, s4), this;
  }
  constructThreePointCircle(t2, e5, s4, n6 = false) {
    if (t2.equals(e5) || e5.equals(s4) || t2.equals(s4)) {
      const i2 = t2.clone(), r = e5.clone(), o2 = s4.clone();
      return i2.equals(r) && r.assign(o2), this.constructTwoPointCircle(i2, r, n6);
    }
    {
      const i2 = ei.calculateCircleCenterFromThreePoints(t2, e5, s4);
      if (!i2.isFinite() || !Number.isFinite(ei.distance(t2, i2))) {
        const n7 = ei.distance(t2, e5), i3 = ei.distance(t2, s4);
        this.constructLineCircularArc(t2, n7 >= i3 ? e5 : s4);
      }
      return this.constructCircleCenterAndPoint(i2, t2, n6);
    }
  }
  constructCircularArcThreePoint(t2, e5, s4) {
    const n6 = new p2(t2.x), i2 = new p2(e5.x), r = new p2(s4.x), o2 = new p2(t2.y), a2 = new p2(e5.y), h2 = new p2(s4.y), m2 = new p2(0.5), u = i2.subE(n6), l2 = a2.subE(o2), c = r.subE(n6), g2 = h2.subE(o2), d2 = u.mulE(g2).subThisE(l2.mulE(c));
    if (d2.scaleError(10), d2.isZero()) {
      if (!u.isZero() || !l2.isZero()) return Rh(this, t2, e5, 0), this;
      {
        const n7 = t2.clone().addThis(e5).mulThis(0.5).addThis(s4).mulThis(0.5), i3 = s4.sub(n7).length();
        this.constructEllipticArcEndPointsCenter(t2, e5, i3, 1, 0, true, false, n7), this.m_interior.assign(s4);
      }
      return this.setProjectionBehavior(0), this;
    }
    const _ = u.sqr().addThisE(l2.sqr()).mulThisE(m2), p3 = c.sqr().addThisE(g2.sqr()).mulThisE(m2), f3 = _.mulE(g2).subThisE(p3.mulE(l2)), P5 = u.mulE(p3).subThisE(c.mulE(_));
    f3.divThisE(d2), P5.divThisE(d2);
    const y2 = f3.sqr().addThisE(P5.sqr());
    y2.sqrtThis();
    const x4 = f3.addE(n6), C2 = P5.addE(o2);
    let v3 = t2.x - x4.value(), b2 = t2.y - C2.value();
    const E2 = Math.atan2(b2, v3);
    v3 = e5.x - x4.value(), b2 = e5.y - C2.value();
    const S3 = Math.atan2(b2, v3);
    v3 = s4.x - x4.value(), b2 = s4.y - C2.value();
    const D3 = Math.atan2(b2, v3);
    let w4 = D3 - 2 * Gs();
    for (; w4 < E2; ) w4 += 2 * Gs();
    let A4 = S3 - 2 * Gs();
    for (; A4 < w4; ) A4 += 2 * Gs();
    let T3 = D3 + 2 * Gs();
    for (; T3 > E2; ) T3 -= 2 * Gs();
    let I5, M2 = S3 + 2 * Gs();
    for (; M2 > T3; ) M2 -= 2 * Gs();
    I5 = A4 - E2 < E2 - M2 ? A4 - E2 : M2 - E2;
    const Y3 = new ei(x4.value(), C2.value());
    return this.constructEllipticArcEndPointsCenter(t2, e5, y2.value(), 1, 0, Math.abs(I5) > Gs(), I5 > 0, Y3), this.m_interior.assign(s4), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircularArc(t2, e5, s4, n6) {
    return this.constructEllipticArcGeneral(t2, 1, e5, s4, n6, 0), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructEllipticArcEndPoints(t2, e5, s4, n6, i2, r, o2) {
    return Lh(this, t2, e5, s4, n6, i2, r, o2);
  }
  constructEllipticArcEndPointsCenter(t2, e5, s4, n6, i2, r, o2, a2) {
    return Lh(this, t2, e5, s4, n6, i2, r, o2, a2);
  }
  constructEllipticArcGeneral(t2, e5, s4, n6, i2, r) {
    this.m_semiMajorAxis = Math.abs(t2), this.m_minorMajorRatio = Math.abs(e5), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const o2 = Za(r), a2 = Math.cos(o2), h2 = Math.sin(o2), m2 = new ei(this.m_semiMajorAxis, this.m_minorMajorRatio * this.m_semiMajorAxis), u = ei.getNAN(), l2 = Za(n6);
    u.x = m2.x * Math.cos(l2), u.y = m2.y * Math.sin(l2), u.rotateDirect(a2, h2), u.addThis(s4);
    const c = Os(i2, Qs());
    let g2 = c;
    Math.abs(g2) === Qs() && (g2 = 0);
    const d2 = ei.getNAN();
    return d2.x = m2.x * Math.cos(l2 + g2), d2.y = m2.y * Math.sin(l2 + g2), d2.rotateDirect(a2, h2), d2.addThis(s4), this.constructEllipticArcEndPointsCenter(u, d2, this.m_semiMajorAxis, this.m_minorMajorRatio, o2, Math.abs(c) > Gs(), c > 0, s4);
  }
  constructEllipticArcAsNURB(t2, s4, n6, i2) {
    (i2 >= 1 || i2 < 0) && P("construct_elliptic_arc_as_NURB: weight"), s4.isFinite() || P("construct_elliptic_arc_as_NURB: control_point");
    return im([t2, s4, n6], i2 * i2, null, false, this), this;
  }
  constructCanonic(t2) {
    return this.assignCopy(t2), t2.isDegenerateToLine() || t2.m_center.isEqual(0, 0) && 0 === this.m_rotation || (this.m_XStart = t2.getSemiMajorAxis() * Math.cos(t2.m_startAngle), this.m_YStart = t2.getSemiMinorAxis() * Math.sin(t2.m_startAngle), this.m_XEnd = t2.getSemiMajorAxis() * Math.cos(t2.getEndAngle()), this.m_YEnd = t2.getSemiMinorAxis() * Math.sin(t2.getEndAngle()), this.m_center.setCoords(0, 0), this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, mm(this), this.afterCompletedModification(), t2 !== this && Ze(this, t2)), this;
  }
  isCircular() {
    return 1 === this.m_minorMajorRatio && 0 === this.m_rotation && !this.isDegenerateToLine();
  }
  isDegenerateToLineHelper(t2) {
    return !!Ie(this, [t2]) && zh(this);
  }
  isDegenerateToLine() {
    return zh(this);
  }
  getCenter() {
    return this.m_center.clone();
  }
  setCenter(t2) {
    if (!this.m_center.isNAN()) {
      const e5 = t2.sub(this.m_center);
      this.m_XStart += e5.x, this.m_YStart += e5.y, this.m_XEnd += e5.x, this.m_YEnd += e5.y, this.m_interior.addThis(e5), this.m_center.assign(t2), this.endPointModified(), this.normalizeAfterEndpointChange();
    }
  }
  getAxisXRotation() {
    return this.m_rotation;
  }
  getSemiAxes() {
    return ei.construct(this.m_semiMajorAxis, this.m_semiMajorAxis * this.m_minorMajorRatio);
  }
  getSemiMajorAxis() {
    return this.m_semiMajorAxis;
  }
  getSemiMinorAxis() {
    return this.m_semiMajorAxis * this.m_minorMajorRatio;
  }
  getMinorMajorRatio() {
    return this.m_minorMajorRatio;
  }
  isClockwise() {
    return !Qh(this);
  }
  isMajor() {
    return Kh(this);
  }
  getSweepAngle() {
    return this.m_sweepAngle;
  }
  getStartAngle() {
    return this.m_startAngle;
  }
  getEndAngle() {
    return this.m_startAngle + this.m_sweepAngle;
  }
  getGeometryType() {
    return a.enumEllipticArc;
  }
  queryEnvelope(t2) {
    if (4 === t2.m_EnvelopeType) {
      t2.setEmpty(), t2.assignVertexDescription(this.m_description);
      const e5 = n4.constructEmpty();
      this.queryEnvelope(e5), t2.setEnvelope(e5);
      for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
        const e6 = this.m_description.getSemantics(s4);
        for (let n7 = 0, i2 = Ua.getComponentCount(e6); s4 < i2; s4++) {
          const s5 = this.queryInterval(e6, n7);
          t2.setIntervalEnvelope(e6, n7, s5);
        }
      }
    } else 2 === t2.m_EnvelopeType ? dm(this, x2.unit(), t2) : z("3d not impl");
  }
  applyTransformation(t2) {
    Wh(this, t2, false);
  }
  createInstance() {
    return new _Oa();
  }
  calculateLength2D() {
    return Yh(this, 0, 1);
  }
  queryCoord2D(t2, e5) {
    if (zh(this)) os2(t2, this.getStartXY(), this.getEndXY(), e5);
    else if (0 === t2) e5.assign(ei.construct(this.m_XStart, this.m_YStart));
    else if (1 === t2) e5.assign(ei.construct(this.m_XEnd, this.m_YEnd));
    else {
      const s4 = Ah(this, t2), n6 = new ei(this.m_semiMajorAxis * Math.cos(s4), this.getSemiMinorAxis() * Math.sin(s4));
      n6.rotateDirect(this.m_cosr, this.m_sinr), n6.addThis(this.m_center), e5.assign(n6);
    }
  }
  queryCoord2DE(t2, e5) {
    yh(this, t2, e5);
  }
  getCoordX(t2) {
    const e5 = new ei();
    return this.queryCoord2D(t2, e5), e5.x;
  }
  getCoordY(t2) {
    const e5 = new ei();
    return this.queryCoord2D(t2, e5), e5.y;
  }
  cut(t2, e5, s4) {
    const n6 = new nu();
    return this.queryCut(t2, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t2, e5, s4, n6) {
    const i2 = s4.createEllipticArc();
    let r = 0 === t2 && 1 === e5;
    if (r && !n6) return void this.copyTo(i2);
    const o2 = ei.getNAN();
    this.queryCoord2D(t2, o2);
    const a2 = ei.getNAN();
    if (this.queryCoord2D(e5, a2), !r) {
      if (o2.equals(a2)) e5 - t2 > 0.5 && this.isMajor() && this.isClosed() ? (r = true, t2 = 0, e5 = 1) : 1 === e5 ? t2 = e5 : e5 = t2;
      else if (t2 > 0 && o2.isEqual(this.m_XStart, this.m_YStart) && (t2 = 0), e5 < 1 && a2.isEqual(this.m_XEnd, this.m_YEnd) && (e5 = 1), r = 0 === t2 && 1 === e5, r && !n6) return void this.copyTo(i2);
    }
    if (i2.m_center.assign(this.m_center), i2.m_semiMajorAxis = this.m_semiMajorAxis, i2.m_minorMajorRatio = this.m_minorMajorRatio, i2.m_interior.assign(this.m_interior), i2.m_rotation = this.m_rotation, i2.m_cosr = this.m_cosr, i2.m_sinr = this.m_sinr, i2.m_sweepAngle = this.m_sweepAngle, i2.m_startAngle = this.m_startAngle, i2.m_bits = this.m_bits, qe(i2, o2.x, o2.y), Ve(i2, a2.x, a2.y), r) return void Zh(i2, Xh(this));
    i2.m_startAngle = Ah(this, t2), i2.m_sweepAngle = Ah(this, e5) - i2.m_startAngle, i2.m_startAngle = bh(i2.m_startAngle), Jh(i2, Math.abs(i2.m_sweepAngle) > Gs()), i2.assignVertexDescription(this.m_description), mm(i2), Dh(i2);
    const h2 = this.m_description.getAttributeCount();
    if (h2 > 1) {
      for (let e6 = 1; e6 < h2; e6++) {
        const s5 = this.m_description.getSemantics(e6), n7 = Ua.getComponentCount(s5);
        for (let e7 = 0; e7 < n7; e7++) {
          const n8 = this.getAttributeAsDbl(t2, s5, e7);
          i2.setStartAttribute(s5, e7, n8);
        }
      }
      for (let t3 = 1; t3 < h2; t3++) {
        const s5 = this.m_description.getSemantics(t3), n7 = Ua.getComponentCount(s5);
        for (let t4 = 0; t4 < n7; t4++) {
          const n8 = this.getAttributeAsDbl(e5, s5, t4);
          i2.setEndAttribute(s5, t4, n8);
        }
      }
    }
    i2.afterCompletedModification();
  }
  queryDerivative(t2, e5) {
    Pm(this, t2, e5);
  }
  cutArcIgnoreAttributes(t2, e5, s4) {
    let n6 = 0 === t2 && 1 === e5;
    const i2 = new ei();
    this.queryCoord2D(t2, i2);
    const r = new ei();
    this.queryCoord2D(e5, r), n6 || (i2.equals(r) ? e5 - t2 > 0.5 && this.isMajor() && this.isClosed() ? (n6 = true, t2 = 0, e5 = 1) : 1 === e5 ? t2 = e5 : e5 = t2 : (t2 > 0 && i2.isEqual(this.m_XStart, this.m_YStart) && (t2 = 0), e5 < 1 && r.isEqual(this.m_XEnd, this.m_YEnd) && (e5 = 1), n6 = 0 === t2 && 1 === e5)), s4.m_center.assign(this.m_center), s4.m_semiMajorAxis = this.m_semiMajorAxis, s4.m_minorMajorRatio = this.m_minorMajorRatio, s4.m_interior.assign(this.m_interior), s4.m_rotation = this.m_rotation, s4.m_cosr = this.m_cosr, s4.m_sinr = this.m_sinr, s4.m_sweepAngle = this.m_sweepAngle, s4.m_startAngle = this.m_startAngle, s4.m_bits = this.m_bits, qe(s4, i2.x, i2.y), Ve(s4, r.x, r.y), n6 ? Zh(s4, Xh(this)) : (s4.m_startAngle = Ah(this, t2), s4.m_sweepAngle = Ah(this, e5) - s4.m_startAngle, s4.m_startAngle = bh(s4.m_startAngle), Jh(s4, Math.abs(s4.m_sweepAngle) > Math.PI), mm(s4), s4.afterCompletedModification());
  }
  changeEndPoints2D(t2, e5) {
    qh(this, t2, e5, false);
  }
  getAttributeAsDbl(t2, e5, s4) {
    if (0 === e5) return 0 === s4 ? this.getCoordX(t2) : this.getCoordY(t2);
    if (0 === t2) return this.getStartAttributeAsDbl(e5, s4);
    if (1 === t2) return this.getEndAttributeAsDbl(e5, s4);
    const n6 = this.calculateLength2D(), i2 = n6 > 0 ? this.tToLength(t2) / n6 : 0, r = Ua.getInterpolation(e5), o2 = this.getStartAttributeAsDbl(e5, s4), a2 = this.getEndAttributeAsDbl(e5, s4);
    return pt(r, o2, a2, i2, Ua.getDefaultValue(e5));
  }
  getClosestCoordinate(t2, e5) {
    return _m(this, t2, x2.unit(), e5);
  }
  getClosestCoordinateOnInterval(t2, e5, s4 = -1) {
    return _m(this, t2, e5, false);
  }
  getYMonotonicParts(t2, n6 = false) {
    t2.length < 2 && P("");
    const i2 = this.getSemiAxes(), r = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), o2 = r + Gs(), a2 = Lt(3, Number.NaN);
    let h2 = 0;
    if (a2[0] = wh(this, r), a2[0] > 0 && a2[0] < 1 && h2++, a2[1] = wh(this, o2), a2[1] > 0 && a2[1] < 1 && (a2[h2] = a2[1], h2++), 0 === h2) return 0;
    a2[h2] = 1, h2++, n2(t2.length >= h2);
    let m2 = 0;
    for (let e5 = 0; e5 < h2; e5++) {
      const s4 = a2[e5];
      this.queryCut(m2, s4, t2[e5], n6), m2 = s4;
    }
    return h2;
  }
  getMonotonicParts(t2, n6) {
    if (t2.length < 4 && P(""), this.isDegenerateToLine()) return t2[0].createEllipticArc().assignCopy(this), n6 && t2[0].get().dropAllAttributes(), 1;
    const i2 = this.getSemiAxes(), r = Lt(4, Number.NaN);
    r[0] = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), r[1] = r[0] + Gs(), r[2] = Math.atan2(-i2.y * this.m_sinr, i2.x * this.m_cosr), r[3] = r[2] + Gs();
    const o2 = Lt(5, Number.NaN);
    let a2 = 0;
    for (let e5 = 0; e5 < 4; e5++) o2[a2] = wh(this, r[e5]), o2[a2] > 0 && o2[a2] < 1 && a2++;
    if (0 === a2) return 0;
    It(o2, a2), o2[a2 - 1] < 1 && (o2[a2] = 1, a2++), n2(t2.length >= a2);
    let h2 = 0;
    for (let e5 = 0; e5 < a2; e5++) {
      const s4 = o2[e5];
      this.queryCut(h2, s4, t2[e5], n6), h2 = s4;
    }
    return a2;
  }
  intersectionWithAxis2D(t2, e5, s4, n6) {
    if (zh(this)) {
      return new su({ start: this.getStartXY(), end: this.getEndXY() }).intersectionWithAxis2D(t2, e5, s4, n6);
    }
    let i2, r;
    const o2 = new p2(e5), a2 = this.getSemiAxes();
    if (t2) {
      if (e5 > this.m_center.y + a2.x || e5 < this.m_center.y - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_sinr), r = new p2(a2.y).mulThis(this.m_cosr), o2.subThis(this.m_center.y);
    } else {
      if (e5 > this.m_center.x + a2.x || e5 < this.m_center.x - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_cosr), r = new p2(a2.y).mulThis(-this.m_sinr), o2.subThis(this.m_center.x);
    }
    const h2 = i2.sqr(), m2 = r.sqr(), u = h2.addE(m2), l2 = r.mulE(o2).mulThis(-2), c = o2.sqr().subThisE(h2), g2 = l2.sqr().subThisE(u.mulE(c).mulThis(4)), d2 = i2.mulE(o2).mulThis(-2), _ = o2.sqr().subThisE(m2), p3 = d2.sqr().subThisE(u.mulE(_).mulThis(4));
    let f3 = g2.eps() * Math.abs(p3.value()) <= p3.eps() * Math.abs(g2.value());
    f3 ? i2.isZero() && (f3 = false) : r.isZero() && (f3 = true), f3 || (l2.setE(d2), c.setE(_));
    const P5 = Rt(p2, 2);
    let y2 = js2(u, l2, c, x2.construct(-1, 1), false, P5);
    if (0 === y2) return 0;
    const x4 = [0, 0];
    let C2 = 0;
    for (let v3 = 0; v3 < y2; v3++) {
      const t3 = new p2(), e6 = new p2();
      f3 ? (t3.setE(P5[v3]), e6.setE(o2.subE(r.mulE(P5[v3])).divThisE(i2))) : (e6.setE(P5[v3]), t3.setE(o2.subE(i2.mulE(P5[v3])).divThisE(r)));
      const s5 = wh(this, Math.atan2(t3.value(), e6.value()));
      s5 >= 0 && s5 <= 1 && (x4[C2] = s5, C2++);
    }
    return y2 = C2, 0 === y2 ? 0 : (2 === y2 && x4[0] > x4[1] && (x4[1] = Mt(x4[0], x4[0] = x4[1])), n6 && Tt(n6, x4, 0, 0, y2), s4 && (s4[0] = t2 ? this.getCoordX(x4[0]) : this.getCoordY(x4[0]), y2 > 1 && (s4[1] = t2 ? this.getCoordX(x4[1]) : this.getCoordY(x4[1]), !n6 && s4[0] > s4[1] && (s4[1] = Mt(s4[0], s4[0] = s4[1])))), y2);
  }
  intersectionOfYMonotonicWithAxisX(t2, e5) {
    if (this.m_YStart === this.m_YEnd) return t2 === this.m_YStart ? e5 : Number.NaN;
    if (t2 === this.m_YStart) return this.m_XStart;
    if (t2 === this.m_YEnd) return this.m_XEnd;
    const s4 = [0, 0];
    return -1 === this.intersectionWithAxis2D(true, t2, s4, null) ? e5 : s4[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t2) {
    return Te(this, t2);
  }
  isDegenerate3D(t2, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t2) {
    3 !== t2.m_EnvelopeType ? this.queryLooseEnvelopeOnInterval(new x2(0, 1), t2) : z("3d not impl");
  }
  clone(t2) {
    const e5 = new _Oa();
    return this.copyTo(e5), e5;
  }
  queryInterval(t2, e5) {
    if (0 === t2) {
      if (zh(this)) return 0 === e5 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY());
      let t3;
      const s4 = this.getSemiAxes();
      t3 = 0 === e5 ? Math.atan2(-s4.y * this.m_sinr, s4.x * this.m_cosr) : Math.atan2(s4.y * this.m_cosr, s4.x * this.m_sinr);
      const n6 = t3 + Math.PI, i2 = [0, 0];
      i2[0] = wh(this, t3), i2[1] = wh(this, n6);
      const r = 0 === e5 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY()), o2 = new ei();
      for (let a2 = 0; a2 < 2; a2++) {
        const t4 = i2[a2];
        t4 > 0 && t4 < 1 && (this.queryCoord2D(t4, o2), r.mergeNeCoordinate(0 === e5 ? o2.x : o2.y));
      }
      return r;
    }
    return super.queryInterval(t2, e5);
  }
  queryLooseEnvelopeOnInterval(t2, e5) {
    const s4 = new x2(0, 1);
    if (s4.intersect(t2), s4.isEmpty()) return void e5.setEmpty();
    if (zh(this)) return e5.setCoords(this.getCoord2D(s4.vmin)), void e5.mergeNe(this.getCoord2D(s4.vmax));
    const n6 = this.getCoord2D(s4.vmin), i2 = this.getCoord2D(s4.vmax);
    if (1 === this.m_minorMajorRatio && Math.abs(this.m_sweepAngle) * s4.width() <= Yt) {
      let t3 = ei.lerp(n6, i2, 0.5);
      const s5 = t3.sub(this.m_center);
      return s5.normalize(), t3 = t3.add(s5.mul(0.5 * ei.distance(n6, i2))), e5.setCoords(n6), e5.mergeNe(i2), void e5.mergeNe(t3);
    }
    dm(this, s4, e5);
  }
  tToLength(t2) {
    return zh(this) ? t2 * ei.distance(this.getStartXY(), this.getEndXY()) : 1 === this.m_minorMajorRatio ? Math.abs(this.getSweepAngle() * t2) * this.m_semiMajorAxis : kh(this, t2);
  }
  parametricAngleToT(t2) {
    return wh(this, t2);
  }
  tToParametricAngle(t2) {
    return Ah(this, t2);
  }
  lengthToT(t2) {
    if (zh(this)) {
      const e5 = ei.distance(this.getStartXY(), this.getEndXY());
      return 0 === e5 ? 0 : t2 / e5;
    }
    if (1 === this.m_minorMajorRatio) {
      const e5 = Math.abs(this.getSweepAngle()) * this.m_semiMajorAxis;
      return 0 === e5 ? 0 : t2 / e5;
    }
    return Bh(this, t2);
  }
  calculateWeightedAreaCentroid2D(t2) {
    if (zh(this)) {
      const t3 = new ei();
      return t3.setCoords(0, 0), t3;
    }
    const e5 = hm(this), s4 = this.getStartXY().sub(this.m_center), n6 = this.getEndXY().sub(this.m_center), i2 = this.m_semiMajorAxis, r = this.getSemiMinorAxis(), o2 = this.m_startAngle + this.m_sweepAngle, a2 = new ei();
    a2.x = i2 * r * (i2 * this.m_cosr * (-Math.sin(o2) + Math.sin(this.m_startAngle)) + r * (-Math.cos(o2) + Math.cos(this.m_startAngle)) * this.m_sinr) / 3, a2.y = i2 * r * (r * (Math.cos(o2) - Math.cos(this.m_startAngle)) * this.m_cosr + i2 * (-Math.sin(o2) + Math.sin(this.m_startAngle)) * this.m_sinr) / 3;
    const h2 = n6.add(s4).mul(n6.crossProduct(s4) / 6);
    return a2.x -= h2.x, a2.y -= h2.y, a2.add(this.m_center.sub(t2).mul(e5));
  }
  calculateWeightedCentroid2D() {
    const t2 = new ei();
    if (this.isDegenerate(0)) return t2.setCoords(0, 0), t2;
    if (zh(this)) return t2.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t2;
    let e5 = this.m_startAngle, s4 = this.m_startAngle + this.m_sweepAngle;
    if (s4 < e5) {
      const t3 = e5;
      e5 = s4, s4 = t3;
    }
    const n6 = Math.sin(e5), i2 = Math.sin(s4), r = Math.cos(e5), o2 = Math.cos(s4);
    if (1 === this.m_minorMajorRatio) {
      const e6 = this.getSemiMajorAxis(), s5 = e6 * e6, a2 = s5 * (i2 - n6), h2 = s5 * (r - o2);
      t2.setCoords(a2, h2);
    } else {
      const e6 = this.getSemiMajorAxis(), s5 = this.getSemiMinorAxis(), a2 = e6 * e6, h2 = s5 * s5, m2 = e6 * s5, u = a2 - h2, l2 = u / h2, c = u / a2, g2 = Math.sqrt(l2), d2 = Math.sqrt(c), _ = 0.5 * m2 * (Math.asinh(g2 * i2) / g2 + i2 * Math.sqrt(1 + l2 * i2 * i2)) - 0.5 * m2 * (Math.asinh(g2 * n6) / g2 + n6 * Math.sqrt(1 + l2 * n6 * n6)), p3 = -0.5 * m2 * (Math.asin(d2 * o2) / d2 + o2 * Math.sqrt(1 - c * o2 * o2)) - -0.5 * m2 * (Math.asin(d2 * r) / d2 + r * Math.sqrt(1 - c * r * r));
      t2.setCoords(_, p3);
    }
    return t2.rotateDirect(this.m_cosr, this.m_sinr), t2.assign(t2.add(this.m_center.mul(this.calculateLength2D()))), t2;
  }
  isIntersectingPoint(t2, e5, s4) {
    if (s4 && (t2.isEqualPoint2D(this.getStartXY()) || t2.isEqualPoint2D(this.getEndXY()))) return false;
    if (!zh(this)) {
      const s5 = ei.distance(t2, this.m_center), n7 = this.getSemiAxes();
      if (s5 < n7.x - e5 || s5 > n7.y + e5) return false;
    }
    const n6 = this.getClosestCoordinate(t2, false), i2 = new ei();
    this.queryCoord2D(n6, i2);
    return ei.distance(i2, t2) <= e5;
  }
  isIntersectingPoint3D(t2, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  getTangent(t2) {
    if (zh(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e5 = Ah(this, t2), s4 = new ei();
      return s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), this.getSemiMinorAxis() * Math.cos(e5)), this.m_rotation && s4.rotateDirect(this.m_cosr, this.m_sinr), s4.scale(this.getSweepAngle()), s4;
    }
  }
  getDerivative(t2) {
    if (zh(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e5 = Ah(this, t2), s4 = new ei();
      return s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), this.getSemiMinorAxis() * Math.cos(e5)), this.m_rotation && s4.rotateDirect(this.m_cosr, this.m_sinr), s4.scale(this.getSweepAngle()), s4;
    }
  }
  normalizeAfterEndpointChange() {
    return !!tm(this) && (zh(this) ? (em(this), false) : sm(this, false));
  }
  projectionBehavior() {
    return (4 & this.m_bits) >> 2;
  }
  setProjectionBehavior(t2) {
    this.m_bits = -5 & this.m_bits | t2 << 2;
  }
  convertToCanonic(t2) {
    const e5 = new ei(t2.x, t2.y);
    return e5.subThis(this.m_center), e5.rotateReverse(this.m_cosr, this.m_sinr), e5;
  }
  convertFromCanonic(t2) {
    const e5 = new ei(t2.x, t2.y);
    return e5.rotateDirect(this.m_cosr, this.m_sinr), e5.addThis(this.m_center), e5;
  }
  canonicToWorldTransformation(t2) {
    t2.setRotate(this.m_cosr, this.m_sinr), t2.shiftCoords(this.m_center.x, this.m_center.y);
  }
  getCurvature(t2) {
    const e5 = Ah(this, t2), s4 = new ei(), n6 = this.getSemiMinorAxis();
    s4.setCoords(-this.m_semiMajorAxis * Math.sin(e5), n6 * Math.cos(e5));
    const i2 = new ei();
    i2.setCoords(-this.m_semiMajorAxis * Math.cos(e5), -n6 * Math.sin(e5)), this.m_rotation && (s4.rotateDirect(this.m_cosr, this.m_sinr), i2.rotateDirect(this.m_cosr, this.m_sinr));
    const r = s4.sqrLength();
    if (0 === r) return Number.NaN;
    const o2 = Math.sqrt(r);
    s4.divThis(o2);
    return s4.crossProduct(i2) / r;
  }
  getMonotonicPartParams(t2, s4) {
    const n6 = Lt(6, Number.NaN);
    n6[0] = 0;
    let i2 = 1;
    if (this.isDegenerateToLine()) n6[1] = 1, i2 = 2;
    else {
      const t3 = this.getSemiAxes(), e5 = Lt(4, Number.NaN);
      this.m_rotation ? (e5[0] = Math.atan2(t3.y * this.m_cosr, t3.x * this.m_sinr), e5[1] = e5[0] + Math.PI, e5[2] = Math.atan2(-t3.y * this.m_sinr, t3.x * this.m_cosr), e5[3] = e5[2] + Math.PI) : (e5[0] = 0, e5[1] = Math.PI, e5[2] = 0.5 * Math.PI, e5[3] = Ys());
      for (let s5 = 0; s5 < 4; s5++) {
        const t4 = wh(this, e5[s5]);
        t4 > 0 && t4 < 1 && (n6[i2] = t4, i2++);
      }
      i2 > 2 && It(n6, i2), n6[i2] = 1, i2++;
    }
    if (s4) {
      t2 < i2 && P("");
      for (let t3 = 0; t3 < i2; t3++) s4[t3] = n6[t3];
    }
    return i2;
  }
  calculateLowerLength2D() {
    const t2 = ei.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t2;
    const e5 = Math.abs(this.m_sweepAngle) * this.getSemiMinorAxis();
    return Math.max(e5, t2);
  }
  calculateUpperLength2D() {
    const t2 = ei.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t2;
    const e5 = Math.abs(this.m_sweepAngle) * this.getSemiMajorAxis();
    return Math.max(e5, t2);
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Mt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Mt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t2 = 0, e5 = this.m_description.getTotalComponentCount() - 2; t2 < e5; t2++) this.m_attributes[t2 + e5] = Mt(this.m_attributes[t2], this.m_attributes[t2] = this.m_attributes[t2 + e5]);
      this.m_startAngle = this.m_startAngle + this.m_sweepAngle, this.m_sweepAngle = -this.m_sweepAngle;
    }
  }
  isLine() {
    return zh(this);
  }
  copyIgnoreAttributes(t2) {
    t2.m_XStart = this.m_XStart, t2.m_YStart = this.m_YStart, t2.m_XEnd = this.m_XEnd, t2.m_YEnd = this.m_YEnd, t2.m_center.assign(this.m_center), t2.m_semiMajorAxis = this.m_semiMajorAxis, t2.m_minorMajorRatio = this.m_minorMajorRatio, t2.m_interior.assign(this.m_interior), t2.m_rotation = this.m_rotation, t2.m_cosr = this.m_cosr, t2.m_sinr = this.m_sinr, t2.m_sweepAngle = this.m_sweepAngle, t2.m_startAngle = this.m_startAngle, t2.m_bits = this.m_bits, Hh(t2);
  }
  calculateArea2DHelper() {
    return hm(this);
  }
  absNorm() {
    let t2 = this.getStartXY().norm(1) + this.getEndXY().norm(1);
    return this.isDegenerateToLine() || (t2 += this.m_center.norm(1), t2 += this.m_semiMajorAxis), t2;
  }
  queryEnvelopeW(t2, e5) {
    if (e5.setCoords(this.getCoord2D(t2.vmin)), e5.mergeNe(this.getCoord2D(t2.vmax)), zh(this)) return;
    const s4 = this.getSemiAxes(), n6 = Lt(8, Number.NaN);
    {
      const t3 = Math.atan2(-s4.y * this.m_sinr, s4.x * this.m_cosr), e6 = t3 + Math.PI, i3 = Math.atan2(s4.y * this.m_cosr, s4.x * this.m_sinr), r = i3 + Math.PI;
      n6[0] = wh(this, t3), n6[1] = wh(this, e6), n6[2] = wh(this, i3), n6[3] = wh(this, r);
    }
    {
      const t3 = this.m_cosr + this.m_sinr, e6 = this.m_cosr - this.m_sinr, i3 = Math.atan2(-s4.y * t3, s4.x * e6), r = i3 + Math.PI, o2 = Math.atan2(s4.y * e6, s4.x * t3), a2 = o2 + Math.PI;
      n6[4] = wh(this, i3), n6[5] = wh(this, r), n6[6] = wh(this, o2), n6[7] = wh(this, a2);
    }
    const i2 = ei.getNAN();
    for (let r = 0; r < 8; r++) {
      const s5 = n6[r];
      t2.containsExclusiveCoordinate(s5) && (this.queryCoord2D(s5, i2), e5.mergeNe(i2));
    }
  }
  setSegmentFromCoords(t2, e5) {
    Fh(this, t2, e5);
  }
  writeInBufferStream(t2, e5) {
    const s4 = new Float64Array(10);
    return s4[0] = this.m_bits, s4[1] = this.m_semiMajorAxis, s4[2] = this.m_minorMajorRatio, s4[3] = this.m_rotation, s4[4] = this.m_center.x, s4[5] = this.m_center.y, s4[6] = this.m_sweepAngle, s4[7] = this.m_startAngle, s4[8] = this.m_interior.x, s4[9] = this.m_interior.y, t2.writeRangeFromArray(e5, s4.length, s4, true, 1), e5 + s4.length;
  }
  readFromBufferStream(t2, e5) {
    const s4 = new Float64Array(10);
    t2.queryRange(e5, s4.length, s4, true, 1), this.m_bits = s4[0], this.m_semiMajorAxis = s4[1], this.m_minorMajorRatio = s4[2], this.m_rotation = s4[3], this.m_center.x = s4[4], this.m_center.y = s4[5], this.m_sweepAngle = s4[6], this.m_startAngle = s4[7], this.m_interior.x = s4[8], this.m_interior.y = s4[9], this.m_cosr = Math.cos(this.m_rotation), this.m_sinr = Math.sin(this.m_rotation), this.m_cachedValues = null;
  }
  snapControlPoints(t2) {
    return false;
  }
  needsSnapControlPoints(t2) {
    return false;
  }
  calculateSpecialPointsForCracking(t2, e5) {
    return b("should not1; be called"), 0;
  }
  ensureXYMonotone() {
    if (zh(this)) return false;
    if (this.getStartXY().equals(this.getEndXY())) return Rh(this, this.getStartXY(), this.getEndXY(), this.projectionBehavior()), true;
    const t2 = Rt(ei, 3);
    let e5 = nm(this, t2);
    if (Ii(t2)) {
      let s4 = false;
      if (0 === this.projectionBehavior()) {
        const n6 = new n4();
        n6.setCoords({ pt: t2[0] }), n6.mergeNe(t2[2]);
        const i2 = new ei();
        i2.setSub(t2[2], t2[0]), i2.leftPerpendicularThis(), i2.normalize(), i2.scale(ei.distance(t2[2], t2[0]));
        const r = ei.lerp(t2[2], t2[0], 0.5), o2 = r.sub(i2), a2 = r.add(i2);
        n6.clipLine(o2, a2);
        const h2 = ei.getClosestCoordinate(o2, a2, t2[1], false);
        t2[1] = ei.lerp(o2, a2, h2);
        const m2 = t2[2].sub(t2[1]), u = t2[0].sub(t2[1]), l2 = m2.crossProduct(u), c = m2.dotProduct(u);
        e5 = Vs() - Math.abs(0.5 * Math.atan2(l2, c)), s4 = true;
      }
      return im(t2, e5 * e5, null, s4, this), true;
    }
    return false;
  }
  setCoordsForIntersector(t2, e5, s4) {
    qh(this, t2, e5, s4);
  }
  getInteriorPoint() {
    return this.m_interior.clone();
  }
  copyToImpl(t2) {
    const e5 = t2;
    e5.m_center.assign(this.m_center), e5.m_semiMajorAxis = this.m_semiMajorAxis, e5.m_minorMajorRatio = this.m_minorMajorRatio, e5.m_interior.assign(this.m_interior), e5.m_rotation = this.m_rotation, e5.m_cosr = this.m_cosr, e5.m_sinr = this.m_sinr, e5.m_sweepAngle = this.m_sweepAngle, e5.m_startAngle = this.m_startAngle, e5.m_bits = this.m_bits, Zh(e5, Xh(this));
  }
  reverseImpl() {
    Oh(this, !Qh(this)), Dh(this), (0 !== this.projectionBehavior() || this.getStartXY().equals(this.getEndXY())) && mm(this);
  }
  equalsImpl(t2) {
    const e5 = t2;
    if (this.m_bits !== e5.m_bits) return false;
    if (this.m_semiMajorAxis !== e5.m_semiMajorAxis) return false;
    if (this.m_minorMajorRatio !== e5.m_minorMajorRatio) return false;
    if (!(this.m_center.isEqualPoint2D(e5.m_center) || this.m_center.isNAN() && e5.m_center.isNAN())) return false;
    if (this.m_rotation !== e5.m_rotation) return false;
    if (!this.m_interior.equals(e5.m_interior)) return false;
    const s4 = e5.m_sweepAngle;
    if (this.m_sweepAngle !== s4) return false;
    const n6 = e5.m_startAngle;
    return this.m_startAngle === n6;
  }
  equalsImplTol(t2, e5) {
    const s4 = t2;
    if (this.m_bits !== s4.m_bits) return false;
    if (this.m_center.isNAN() && s4.m_center.isNAN()) return true;
    if (this.m_center.isNAN() !== s4.m_center.isNAN()) return false;
    if (!this.getSemiAxes().isEqualPoint2D(s4.getSemiAxes(), e5)) return false;
    if (!this.m_center.isEqualPoint2D(s4.m_center, e5)) return false;
    const n6 = Math.abs(Ga(Ba(Wa(this.m_rotation - s4.m_rotation)))), i2 = Math.abs(Gs() - n6), r = Math.min(n6, i2);
    if (this.m_semiMajorAxis * Math.abs(r) > e5) return false;
    const o2 = this.getCoord2D(0.5), a2 = s4.getCoord2D(0.5);
    return !!o2.isEqualPoint2D(a2, e5);
  }
  swapImpl(t2) {
    const e5 = t2;
    this.m_center = Mt(e5.m_center, e5.m_center = this.m_center), this.m_semiMajorAxis = Mt(e5.m_semiMajorAxis, e5.m_semiMajorAxis = this.m_semiMajorAxis), this.m_minorMajorRatio = Mt(e5.m_minorMajorRatio, e5.m_minorMajorRatio = this.m_minorMajorRatio), this.m_interior = Mt(e5.m_interior, e5.m_interior = this.m_interior), this.m_rotation = Mt(e5.m_rotation, e5.m_rotation = this.m_rotation), this.m_cosr = Mt(e5.m_cosr, e5.m_cosr = this.m_cosr), this.m_sinr = Mt(e5.m_sinr, e5.m_sinr = this.m_sinr), this.m_sweepAngle = Mt(e5.m_sweepAngle, e5.m_sweepAngle = this.m_sweepAngle), this.m_startAngle = Mt(e5.m_startAngle, e5.m_startAngle = this.m_startAngle), this.m_bits = Mt(e5.m_bits, e5.m_bits = this.m_bits), Uh(this, e5);
  }
  afterCompletedModification() {
    em(this), Hh(this);
  }
  intersect(t2, e5, s4, n6, i2) {
    return Om(false, this, t2, e5, s4, n6, i2);
  }
  intersectPoint(t2, e5, s4) {
    if (e5.length < 2 && A(""), zh(this)) {
      return new su({ start: this.getStartXY(), end: this.getEndXY() }).intersectPoint(t2, e5, s4);
    }
    {
      const e6 = ei.distance(t2, this.m_center);
      if (e6 > this.m_semiMajorAxis + s4 || e6 < this.getSemiMinorAxis() - s4) return 0;
    }
    const i2 = this.getClosestCoordinate(t2, false), r = ei.getNAN();
    return this.queryCoord2D(i2, r), ei.distance(r, t2) <= s4 ? Fs(i2, 0, 1) && (this.queryCoord2D(0 === i2 ? 1 : 0, r), ei.distance(r, t2) <= s4) ? (e5 && (e5[0] = 0, e5[1] = 1), 2) : (e5 && (e5[0] = i2), 1) : 0;
  }
  isIntersecting(t2, e5, s4) {
    return 0 !== jm(false, this, t2, e5, s4);
  }
  endPointModified() {
    this.m_bits |= 8, Hh(this);
  }
  clearEndPointModified() {
    em(this);
  }
};
function Ja(t2, e5, s4, n6) {
  const i2 = [];
  return $a(e5, i2), th(t2, i2, e5, s4);
}
function $a(t2, e5) {
  e5.length = t2;
  for (let s4 = 0; s4 < e5.length; ++s4) e5[s4] = s4;
  t2 > 3 && ce(t2, e5);
}
function th(t2, e5, s4, n6, i2) {
  let r = 0;
  const o2 = [0, 0, 0];
  let a2 = 0;
  const h2 = 3;
  let m2 = 0;
  for (let u = 0; u < h2; ++u) {
    let i3 = false;
    for (; m2 < s4; ) {
      const s5 = t2.at(e5[m2]);
      let l2 = 1;
      if (3 === r ? l2 = ei.inCircleRobust(t2.at(n6[0]), t2.at(n6[1]), t2.at(n6[2]), s5) : 2 === r ? l2 = ei.inCircleRobust3Point(t2.at(n6[0]), t2.at(n6[1]), s5) : 1 === r && s5.equals(t2.at(n6[0])) && (l2 = 0), l2 <= 0) {
        if (l2 < 0 && u + 1 < h2) {
          e5[a2] = Mt(e5[m2], e5[m2] = e5[a2]);
          for (let t3 = 0; t3 < r; t3++) if (n6[t3] === e5[m2]) {
            o2[t3] = m2;
            break;
          }
          a2++;
        }
        m2++;
        continue;
      }
      i3 = true;
      let c = 0;
      for (let t3 = 0; t3 < r; t3++) o2[t3] > m2 && (n6[c] = n6[t3], o2[c] = o2[t3], c++);
      r = c, n6[r] = e5[m2], o2[r] = m2, r++, r < 3 ? m2 = a2 : (1 === ei.orientationRobust(t2.at(n6[0]), t2.at(n6[1]), t2.at(n6[2])) && (n6[2] = Mt(n6[0], n6[0] = n6[2]), o2[2] = Mt(o2[0], o2[0] = o2[2])), m2++);
    }
    if (!i3) break;
    if (u + 1 < h2) {
      a2 = 0;
      let s5 = false;
      for (let t3 = 0; t3 < r; t3++) for (let e6 = t3 + 1; e6 < r; e6++) o2[t3] > o2[e6] && (o2[e6] = Mt(o2[t3], o2[t3] = o2[e6]), n6[e6] = Mt(n6[t3], n6[t3] = n6[e6]), s5 = true);
      for (let t3 = 0; t3 < r; t3++) e5[o2[t3]] = Mt(e5[t3], e5[t3] = e5[o2[t3]]), o2[t3] = t3;
      s5 && 3 === r && 1 === ei.orientationRobust(t2.at(n6[0]), t2.at(n6[1]), t2.at(n6[2])) && (n6[2] = Mt(n6[0], n6[0] = n6[2]), o2[2] = Mt(o2[0], o2[0] = o2[2]));
    }
    m2 = r;
  }
  return r;
}
Oa.type = a.enumEllipticArc;
var eh = class _eh extends Ya {
  constructor(t2) {
    t2 ? t2.vd ? (super({ vd: t2.vd, bPolygon: true }), this.m_segmentBufferCTor = nu) : t2.copy ? (super({ vd: t2.copy.getDescription(), bPolygon: true }), this.m_segmentBufferCTor = nu, t2.copy.copyTo(this)) : t2.move ? (super({ move: t2.move }), this.m_segmentBufferCTor = nu) : t2.envelope ? z("envelope constructor not impl") : b("bad arg to polygon constructor") : (super({ bPolygon: true }), this.m_segmentBufferCTor = nu);
  }
  assignMove(t2) {
    return t2.copyTo(this), this;
  }
  assignCopy(t2) {
    return t2.copyTo(this), this;
  }
  getBoundary() {
    return Va(this);
  }
  getExteriorRingCount() {
    return this.getOGCPolygonCount();
  }
  getGeometryType() {
    return _eh.type;
  }
  getDimension() {
    return 2;
  }
  createInstance() {
    return new _eh({ vd: this.getDescription() });
  }
  equals(t2, e5) {
    return this.equalsBase(t2, e5);
  }
};
function sh(t2, e5, s4, n6, i2, r) {
  return new ah(0, 0, 0, null, false, ls()).densifyEx(t2, e5, s4, n6, false, r);
}
function ih(t2, e5, n6, r, o2, h2, m2, u) {
  h2 && (h2.length = 0), m2 && (m2.length = 0);
  const l2 = t2.getGeometryType();
  if (l2 === a.enumLine) return h2 && (h2.push(t2.getStartXY()), h2.push(ei.getNAN()), h2.push(ei.getNAN()), h2.push(t2.getEndXY())), m2 && (m2.push(0), m2.push(1)), 1;
  if (l2 === a.enumBezier) {
    if (!r) return h2 && (h2.push(t2.getStartXY()), h2.push(t2.getControlPoint1()), h2.push(t2.getControlPoint2()), h2.push(t2.getEndXY())), m2 && (m2.push(0), m2.push(1)), 1;
    const e6 = Lt(9, Number.NaN);
    let s4 = t2.getMonotonicPartParams(e6.length, e6);
    if (e6.length = s4, s4 = hh(t2, n6, e6), 2 === s4 && o2 && (e6[1] = 0.5, e6.push(1), s4 = 3), m2 && m2.splice(0, 0, ...e6.slice(0, s4)), h2) {
      const n7 = new nu();
      for (let i2 = 1; i2 < s4; i2++) {
        const s5 = e6[i2 - 1], r2 = e6[i2];
        t2.queryCut(s5, r2, n7, true);
        const o3 = n7.get();
        Ro(o3), 1 === i2 && h2.push(o3.getStartXY()), h2.push(o3.getControlPoint1()), h2.push(o3.getControlPoint2()), h2.push(o3.getEndXY());
      }
    }
    return s4 - 1;
  }
  if (l2 === a.enumEllipticArc) {
    const i2 = t2;
    if (i2.isDegenerateToLine() || i2.isDegenerate(0)) return h2 && (h2.push(t2.getStartXY()), h2.push(ei.getNAN()), h2.push(ei.getNAN()), h2.push(t2.getEndXY())), m2 && (m2.push(0), m2.push(1)), 1;
    if (r && (o2 || !i2.isMonotoneQuickAndDirty())) {
      const a2 = Lt(6, Number.NaN);
      let u2 = i2.getMonotonicPartParams(a2.length, a2);
      a2.length = u2, u2 = hh(t2, n6, a2), 2 === u2 && o2 && (a2[1] = 0.5, a2.push(1), u2 = 3);
      let l3 = 0;
      if (u2 > 2) {
        const t3 = new nu(), o3 = m2 || [];
        let c = 0;
        for (let g2 = 1; g2 < u2; g2++) {
          const d2 = a2[c], _ = a2[g2];
          if (i2.queryCut(d2, _, t3, true), t3.get().isDegenerate(0)) continue;
          const p3 = o3.length, f3 = ch(1 === g2, t3.get(), e5, n6, r, h2, m2);
          n2(f3 > 0), l3 += f3;
          const P5 = g2 === u2 - 1, y2 = a2[c], x4 = t3.get().getSweepAngle() / i2.getSweepAngle();
          for (let t4 = p3, e6 = o3.length; t4 < e6; t4++) if (o3[t4] = !P5 || t4 + 1 < e6 ? y2 + o3[t4] * x4 : 1, h2) {
            const e7 = 3 * t4, s4 = i2.getCoord2D(o3[t4]);
            if (h2[e7].setCoordsPoint2D(s4), e7 > 0) {
              zo(h2.slice(e7 - 3));
            }
          }
          c = g2;
        }
        return l3;
      }
    }
    return ch(true, i2, e5, n6, r, h2, m2);
  }
  if (l2 === a.enumRationalBezier2) {
    const s4 = t2;
    if (r && (o2 || !s4.isMonotoneQuickAndDirty())) {
      const i2 = Lt(6, Number.NaN);
      let r2 = s4.getMonotonicPartParams(i2.length, i2);
      i2.length = r2, r2 = hh(t2, n6, i2), 2 === r2 && o2 && (i2[1] = 0.5, i2.push(1), r2 = 3);
      let a2 = 0;
      if (r2 > 2) {
        const t3 = new nu(), o3 = m2 || [];
        for (let u2 = 1; u2 < r2; u2++) {
          const l3 = i2[u2 - 1], c = i2[u2];
          s4.queryCut(l3, c, t3, true);
          const g2 = o3.length;
          a2 += dh(1 === u2, t3.get(), e5, n6, false, h2, m2);
          const d2 = u2 === r2 - 1, _ = i2[u2 - 1];
          for (let t4 = g2, e6 = o3.length; t4 < e6; t4++) if (o3[t4] = !d2 || t4 + 1 < e6 ? _ + o3[t4] : 1, h2) {
            const e7 = 3 * t4, n7 = s4.getCoord2D(o3[t4]);
            if (h2[e7].setCoordsPoint2D(n7), e7 > 0) {
              Nr(h2.slice(e7 - 3));
            }
          }
        }
        return a2;
      }
    }
    return dh(true, s4, e5, n6, r, h2, m2);
  }
  if (l2 === a.enumBezier2) {
    const s4 = t2, i2 = Rt(ei, 3);
    s4.queryControlPoints(i2);
    const a2 = new mo();
    return a2.constructFromQuadratic(i2), ih(a2, e5, n6, r, o2, h2, m2);
  }
  z("");
}
function oh(t2, e5, n6, r, o2, a2, h2, m2, u) {
  const l2 = t2.getGeometryType();
  if (a2 && (a2.length = 0, h2.length = 0), m2 && (m2.length = 0), l2 === a.enumEllipticArc) {
    const e6 = t2;
    if (e6.isDegenerateToLine() || e6.isDegenerate(0)) return a2 && (a2.push(t2.getStartXY()), a2.push(ei.getNAN()), a2.push(t2.getEndXY()), h2.push(Number.NaN), h2.push(Number.NaN), h2.push(Number.NaN)), m2 && (m2.push(0), m2.push(1)), 1;
  }
  const c = Lt(9, Number.NaN);
  let g2;
  if (o2) g2 = t2.getMonotonicPartParams(c.length, c), c.length = g2, g2 = hh(t2, n6, c);
  else {
    if (g2 = 2, c[0] = 0, c[1] = 1, l2 === Oa.type) {
      const e6 = t2.getSweepAngle();
      if (e6 > 0.9 * Math.PI) {
        const t3 = 2 * Math.PI / 3;
        Math.min(3, Math.trunc(e6 / t3 + 0.5)) > 2 ? (c[0] = 0, c[1] = 1 / 3, c[2] = 2 / 3, c[3] = 1, g2 = 4) : (c[0] = 0, c[1] = 0.5, c[2] = 1, g2 = 3);
      }
    } else n2(l2 === on.type);
    c.length = g2;
  }
  if (2 === g2 && r && (c[1] = 0.5, c.push(1), g2 = 3), a2) {
    const e6 = new nu();
    let s4 = 1;
    for (; s4 < g2; ) {
      const n7 = c[s4 - 1], r2 = c[s4];
      t2.queryCut(n7, r2, e6, true);
      const m3 = Rt(ei, 3), u2 = [1, 1, 1];
      if (l2 === a.enumEllipticArc) {
        const t3 = e6.get();
        if (Math.abs(t3.getSweepAngle()) > 0.9 * Math.PI) {
          const t4 = (r2 - n7) / 3;
          c.splice(s4, 0, n7 + t4), c.splice(s4 + 1, 0, n7 + 2 * t4), g2 += 2;
          continue;
        }
        u2[1] = nm(t3, m3);
      } else {
        const t3 = e6.get();
        t3.queryControlPoints(m3), t3.queryWeights(u2);
      }
      o2 && Ii(m3), 1 === s4 && (a2.push(m3[0].clone()), h2.push(u2[0])), a2.push(m3[1].clone()), a2.push(m3[2].clone()), h2.push(u2[1]), h2.push(u2[2]), s4++;
    }
  }
  return m2 && (m2.length = g2, Tt(m2, c, 0, 0, g2)), g2 - 1;
}
eh.type = a.enumPolygon;
var ah = class _ah {
  static constructDefault(t2) {
    return new _ah(0, 0, 0, t2, false, ls());
  }
  constructor(t2, e5, s4, n6, i2, r) {
    this.m_segmentBuffer = null, this.m_dummyPoint = new ee(), this.m_progressCounter = 0, this.m_progressTracker = n6, this.m_bSetDensifyFlag = i2, this.m_maxLength = t2, this.m_maxDeviation = e5, this.m_maxAngle = s4 > Vs() ? Vs() : s4, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve;
  }
  densify(t2) {
    return this.densifyGeom(t2);
  }
  densifySegment(t2, e5) {
    this.densifySegmentEx(t2, null, true, false, e5);
  }
  densifyEx(t2, e5, s4, n6, i2, r) {
    return this.m_maxLength = e5, this.m_maxDeviation = s4, this.m_maxAngle = n6 > Vs() ? Vs() : n6, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_bSetDensifyFlag = i2, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve, this.densifyGeom(t2);
  }
  densifyGeom(t2) {
    if (t2.isEmpty() || t2.getDimension() < 1) return t2;
    const e5 = t2.getGeometryType();
    return g(e5) ? t2 : h(e5) ? this.densifyMultiPath(t2) : f(e5) ? this.densifySegmentImpl(t2) : e5 === a.enumEnvelope ? this.densifyEnvelope(t2) : void b("");
  }
  densifySegmentEx(t2, e5, s4, n6, r) {
    const o2 = t2.getGeometryType();
    if (!(this.m_maxLength > 0 || this.m_bOnlyCurveDensify && o2 !== a.enumLine) && (!n6 || s4)) return void (e5 ? o2 === a.enumLine ? e5.addSegment(t2, s4) : (s4 && (t2.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)), t2.queryEnd(this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint)) : (s4 && r.push(0), r.push(1)));
    if (o2 === a.enumBezier) return void this.densifyCubicBezier(t2, e5, s4, n6, r);
    if (o2 === a.enumRationalBezier2) return void this.densifyRationalBezier2(t2, e5, s4, n6, r);
    if (o2 === a.enumBezier2) return void this.densifyBezier2(t2, e5, s4, n6, r);
    if (o2 === a.enumEllipticArc && !t2.isLine() && t2.getMinorMajorRatio() < 0.25) return void this.densifyEllipticArc(t2, e5, s4, n6, r);
    let a2 = 1;
    this.m_maxLength > 0 && (a2 = this.calculateLengthSubdivisionStep(t2, this.m_maxLength)), this.m_maxDeviation > 0 && (a2 = Math.min(a2, this.calculateDeviationSubdivisionStep(t2, this.m_maxDeviation))), this.m_maxAngle > 0 && (a2 = Math.min(a2, this.calculateAngularSubdivisionStep(t2, this.m_maxAngle))), this.densifySegmentByLength(t2, a2, e5, s4, n6, r);
  }
  densifyMultiPath(t2) {
    if (!t2.hasNonLinearSegments()) {
      if (1 === t2.getDescription().getAttributeCount()) return this.densifyMultiPathLinear(t2);
      if (!(this.m_maxLength > 0)) return t2;
    }
    const e5 = t2.createInstance();
    if (e5.getGeometryType() === a.enumPolygon) {
      e5.setFillRule(t2.getFillRule());
    }
    e5.reserve(t2.getPointCount());
    const s4 = t2.getImpl().querySegmentIterator();
    for (; s4.nextPath(); ) {
      let t3 = true;
      for (; s4.hasNextSegment(); ) {
        const n6 = s4.nextSegment(), i2 = s4.isClosingSegment();
        this.densifySegmentEx(n6, e5, t3, i2, null), i2 && e5.closePathWithLine(), t3 = false;
      }
    }
    return e5;
  }
  densifySegmentImpl(t2) {
    const e5 = new Na({ vd: t2.getDescription() }), s4 = [0];
    return this.densifySegmentEx(t2, e5, true, false, s4), e5;
  }
  densifyEnvelope(t2) {
    const e5 = new eh({ vd: t2.getDescription() });
    e5.addEnvelope(t2, false);
    const s4 = n4.constructEmpty();
    t2.queryEnvelope(s4);
    const n6 = s4.width(), i2 = s4.height();
    return !(this.m_maxLength > 0) || n6 <= this.m_maxLength && i2 <= this.m_maxLength ? e5 : this.densifyMultiPath(e5);
  }
  densifyMultiPathLinear(t2) {
    if (!(this.m_maxLength > 0)) return t2;
    const e5 = t2.createInstance();
    if (e5.getGeometryType() === a.enumPolygon) {
      e5.setFillRule(t2.getFillRule());
    }
    e5.reserve(t2.getPointCount());
    const s4 = e5.getImpl(), n6 = t2.getImpl(), r = n6.getAttributeStreamRef(0), o2 = new su();
    for (let i2 = 0, a2 = n6.getPathCount(); i2 < a2; i2++) {
      const t3 = n6.isClosedPath(i2);
      if (0 === n6.getPathSize(i2)) continue;
      const a3 = n6.getPathStart(i2), h2 = r.readPoint2D(2 * a3), m2 = h2.clone();
      s4.startPath(h2);
      for (let u = a3 + 1, l2 = n6.getPathEnd(i2); u < l2; u++) {
        const t4 = r.readPoint2D(2 * u), n7 = ei.distance(m2, t4);
        if (n7 > this.m_maxLength) {
          let e6 = Math.ceil(n7 / this.m_maxLength);
          e6 > ls() && (e6 = ls());
          const i3 = 1 / e6;
          let r2, a4, h3;
          m2.compare(t4) < 0 ? (o2.setStartXY(m2), o2.setEndXY(t4), r2 = 0, a4 = 1) : (o2.setStartXY(t4), o2.setEndXY(m2), r2 = e6 - 2, a4 = -1);
          for (let t5 = 0, n8 = e6 - 1; t5 < n8; t5++, r2 += a4) {
            this.progress_(), h3 = i3 * (r2 + 1);
            const t6 = new ei();
            o2.queryCoord2D(h3, t6), s4.lineTo(t6), this.m_bSetDensifyFlag && s4.setAttribute(10, s4.getPointCount() - 1, 0, 1);
          }
        } else this.progress_();
        e5.lineTo(t4), m2.assign(t4);
      }
      if (t3) {
        const t4 = ei.distance(m2, h2);
        if (t4 > this.m_maxLength) {
          const e6 = h2;
          let n7 = Math.ceil(t4 / this.m_maxLength);
          n7 > ls() && (n7 = ls());
          const i3 = 1 / n7;
          let r2, a4;
          m2.compare(e6) < 0 ? (o2.setStartXY(m2), o2.setEndXY(e6), r2 = 0, a4 = 1) : (o2.setStartXY(e6), o2.setEndXY(m2), r2 = n7 - 2, a4 = -1);
          const u = new ei(0, 0);
          let l2;
          for (let t5 = 0, h3 = n7 - 1; t5 < h3; t5++, r2 += a4) this.progress_(), l2 = i3 * (r2 + 1), o2.queryCoord2D(l2, u), s4.lineTo(u), this.m_bSetDensifyFlag && s4.setAttribute(10, s4.getPointCount() - 1, 0, 1);
        }
        s4.closePathWithLine();
      }
    }
    return e5;
  }
  densifySegmentByLength(t2, e5, n6, r, o2, h2) {
    n2(t2.getGeometryType() !== a.enumBezier);
    let m2 = t2.getStartXY().compare(t2.getEndXY());
    if (0 === m2 && e5 < 1) {
      t2.getGeometryType() === a.enumEllipticArc ? m2 = t2.getSweepAngle() < 0 ? 1 : -1 : z("densify segment by length");
    }
    let u = 0;
    if (r && (n6 ? (t2.queryStart(this.m_dummyPoint), n6.startPathPoint(this.m_dummyPoint)) : h2.push(0), ++u), e5 * this.m_maxSegmentsPerCurve < 1 && (e5 = 1 / this.m_maxSegmentsPerCurve), e5 < 1) {
      this.m_segmentBuffer || (this.m_segmentBuffer = new nu());
      let s4 = Math.ceil(1 / e5);
      s4 > ls() && (s4 = ls()), e5 = 1 / s4, this.m_segmentBuffer.create(t2.getGeometryType());
      let i2, r2, o3, a2 = t2;
      m2 < 0 ? (i2 = 0, r2 = 1) : (t2.copyTo(this.m_segmentBuffer.get()), this.m_segmentBuffer.get().reverse(), i2 = s4 - 2, r2 = -1, a2 = this.m_segmentBuffer.get());
      const l2 = s4 - 1;
      for (let t3 = 0; t3 < l2; t3++, i2 += r2) o3 = e5 * (i2 + 1), n6 ? (a2.queryCoord(o3, this.m_dummyPoint), n6.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== o3 && 0 !== o3 && n6.setAttribute(10, n6.getPointCount() - 1, 0, 1)) : h2.push(m2 > 0 ? 1 - o3 : o3), this.progress_();
      o3 = 1, u += l2;
    }
    (!o2 || o2 && r && u < 2) && (n6 ? (t2.queryEnd(this.m_dummyPoint), n6.lineToPoint(this.m_dummyPoint)) : h2.push(1));
  }
  densifyCubicBezier(t2, e5, s4, n6, i2) {
    const r = new mo();
    let o2 = t2;
    const a2 = t2.calculateUpperLength2D();
    let h2 = t2.getStartXY().compare(t2.getEndXY());
    if (0 === h2 && a2 > 0) {
      const e6 = Rt(ei, 4);
      t2.queryControlPoints(e6), h2 = e6[1].compare(e6[2]), 0 === h2 && (h2 = e6[1].compare(e6[0]));
    }
    h2 > 0 && (t2.copyTo(r), r.reverse(), o2 = r);
    let m2 = 0;
    s4 && (e5 ? (t2.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++m2);
    const u = [], l2 = [], c = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));
    let g2 = true, d2 = 0;
    if (h2 > 0) for (u.push([o2.getStartXY(), o2.getControlPoint1(), o2.getControlPoint2(), o2.getEndXY(), new ei(0, 1)]), l2.push(0); u.length; ) {
      this.progress_();
      const t3 = u.at(-1), r2 = l2.at(-1), a3 = t3[4].x, h3 = t3[4].y;
      if (r2 < c && this.bezierNeedsSplit(t3)) {
        g2 && (d2 = o2.findMinDeriv(), g2 = false);
        let e6 = 0.5 * (a3 + h3);
        Math.abs(d2 - e6) < 0.4 * (h3 - a3) && (e6 = d2);
        const s5 = (e6 - a3) / (h3 - a3), n7 = t3[0].mul(1 - s5).add(t3[1].mul(s5)), i3 = t3[1].mul(1 - s5).add(t3[2].mul(s5)), m3 = t3[2].mul(1 - s5).add(t3[3].mul(s5)), c2 = n7.mul(1 - s5).add(i3.mul(s5)), _ = i3.mul(1 - s5).add(m3.mul(s5)), p3 = c2.mul(1 - s5).add(_.mul(s5)), f3 = t3[3];
        t3[1] = n7, t3[2] = c2, t3[3] = p3, t3[4].setCoords(a3, e6);
        const P5 = [p3, _, m3, f3, new ei(e6, h3)];
        u.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
      } else u.pop(), l2.pop(), (u.length > 0 || !n6 || n6 && s4 && m2 < 2) && (e5 ? (o2.queryCoord(a3, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== a3 && 0 !== a3 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(1 - a3), ++m2);
    }
    else for (u.push([o2.getStartXY(), o2.getControlPoint1(), o2.getControlPoint2(), o2.getEndXY(), new ei(0, 1)]), l2.push(0); u.length; ) {
      this.progress_();
      const t3 = u.at(-1), r2 = l2.at(-1), a3 = t3[4].x, h3 = t3[4].y;
      if (r2 < c && this.bezierNeedsSplit(t3)) {
        g2 && (d2 = o2.findMinDeriv(), g2 = false);
        let e6 = 0.5 * (a3 + h3);
        Math.abs(d2 - e6) < 0.4 * (h3 - a3) && (e6 = d2);
        const s5 = (e6 - a3) / (h3 - a3), n7 = t3[0].mul(1 - s5).add(t3[1].mul(s5)), i3 = t3[1].mul(1 - s5).add(t3[2].mul(s5)), m3 = t3[2].mul(1 - s5).add(t3[3].mul(s5)), c2 = n7.mul(1 - s5).add(i3.mul(s5)), _ = i3.mul(1 - s5).add(m3.mul(s5)), p3 = c2.mul(1 - s5).add(_.mul(s5)), f3 = t3[0];
        t3[0] = p3, t3[1] = _, t3[2] = m3, t3[4].setCoords(e6, h3);
        const P5 = [f3, n7, c2, p3, new ei(a3, e6)];
        u.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
      } else u.pop(), l2.pop(), (u.length > 0 || !n6 || n6 && s4 && m2 < 2) && (e5 ? (o2.queryCoord(h3, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== h3 && 0 !== h3 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h3), ++m2);
    }
  }
  densifyRationalBezier2(t2, e5, s4, n6, i2) {
    const r = new on();
    let o2 = t2;
    const a2 = t2.calculateUpperLength2D();
    let h2 = t2.getStartXY().compare(t2.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t2.copyTo(r), r.reverse(), o2 = r);
    let m2 = 0;
    s4 && (e5 ? (t2.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++m2);
    const u = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new on(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t3 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < u && this.rationalBezier2NeedsSplit(o2, l2, t3.vmin, t3.vmax)) {
        const e6 = t3.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t3.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t3.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && m2 < 2) {
        const s5 = h2 > 0 ? t3.vmin : t3.vmax;
        e5 ? (o2.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++m2;
      }
    }
  }
  densifyBezier2(t2, e5, s4, n6, i2) {
    const r = new nn();
    let o2 = t2;
    const a2 = t2.calculateUpperLength2D();
    let h2 = t2.getStartXY().compare(t2.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t2.copyTo(r), r.reverse(), o2 = r);
    let m2 = 0;
    s4 && (e5 ? (t2.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++m2);
    const u = Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new nn(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t3 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < u && this.bezier2NeedsSplit(o2, l2, t3.vmin, t3.vmax)) {
        const e6 = t3.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t3.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t3.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && m2 < 2) {
        const s5 = h2 > 0 ? t3.vmin : t3.vmax;
        e5 ? (o2.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++m2;
      }
    }
  }
  densifyEllipticArc(t2, e5, s4, n6, i2) {
    const r = new Oa();
    let o2 = t2;
    const a2 = t2.calculateUpperLength2D();
    let h2 = t2.getStartXY().compare(t2.getEndXY());
    0 === h2 && a2 > 0 && (h2 = t2.isClockwise() ? 0 : 1), h2 > 0 && (t2.copyTo(r), r.reverse(), o2 = r);
    let m2 = 0;
    s4 && (e5 ? (t2.queryStart(this.m_dummyPoint), e5.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++m2);
    const u = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new Oa(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t3 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < u && this.ellipticArcNeedsSplit(o2, l2, t3.vmin, t3.vmax)) {
        const e6 = t3.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e6, c.push(new x2(e6, t3.vmax))) : (c.at(-1).vmin = e6, c.push(new x2(t3.vmin, e6))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
      } else if (c.pop(), g2.pop(), c.length > 0 || !n6 || n6 && s4 && m2 < 2) {
        const s5 = h2 > 0 ? t3.vmin : t3.vmax;
        e5 ? (o2.queryCoord(s5, this.m_dummyPoint), e5.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s5 && 0 !== s5 && e5.setAttribute(10, e5.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s5 : s5), ++m2;
      }
    }
  }
  calculateLengthSubdivisionStep(t2, e5) {
    const s4 = t2.calculateUpperLength2D();
    if (!t2.isCurve()) return s4 ? e5 / s4 : 1;
    if (t2.getGeometryType() === a.enumEllipticArc) {
      const n6 = t2;
      if (n6.isCircular() || n6.isDegenerate(0) || n6.isDegenerateToLine()) {
        let t3 = e5 / s4;
        return t3 < this.m_minStep && (t3 = this.m_minStep), t3;
      }
      return e5 / s4 * n6.getSemiAxes().y / n6.getSemiAxes().x;
    }
    t2.getGeometryType() === a.enumBezier && z(""), z("");
  }
  calculateDeviationSubdivisionStep(t2, e5) {
    if (!t2.isCurve()) return 1;
    if (t2.getGeometryType() === a.enumEllipticArc) {
      const s4 = t2;
      if (s4.isDegenerate(0) || s4.isDegenerateToLine()) return 1;
      {
        const n6 = s4.getSemiMajorAxis(), i2 = 1 - e5 / n6;
        let r = Math.PI / 2;
        if (i2 > 0) {
          const t3 = 4 * Math.sqrt(e5 / n6 * 0.5);
          r = Math.min(Math.PI / 2, Math.abs(t3));
        }
        r = Math.max(r, 2 * Math.PI / this.m_maxSegmentsPerCurve);
        const o2 = r * n6;
        return this.calculateLengthSubdivisionStep(t2, o2);
      }
    }
    z("");
  }
  calculateAngularSubdivisionStep(t2, e5) {
    if (!t2.isCurve()) return 1;
    if (t2.getGeometryType() === a.enumEllipticArc) {
      const s4 = t2;
      return s4.isDegenerate(0) || s4.isDegenerateToLine() ? 1 : this.calculateLengthSubdivisionStep(t2, e5 * s4.getSemiMinorAxis());
    }
    z("");
  }
  rationalBezier2NeedsSplit(t2, e5, s4, n6) {
    t2.cutBezierIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Rt(ei, 3);
    e5.queryControlPoints(r);
    const o2 = [0, 0, 0];
    return e5.queryWeights(o2), !i2 && this.m_maxDeviation > 0 && (i2 = !_ah.checkRationalBezier2MaxDeviation(r, o2, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_ah.checkRationalBezier2MaxAngle(r, o2, this.m_cosMaxAngle)), i2;
  }
  bezier2NeedsSplit(t2, e5, s4, n6) {
    t2.cutBezierIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Rt(ei, 3);
    return e5.queryControlPoints(r), !i2 && this.m_maxDeviation > 0 && (i2 = !_ah.checkBezier2MaxDeviation(r, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_ah.checkBezier2MaxAngle(r, this.m_cosMaxAngle)), i2;
  }
  ellipticArcNeedsSplit(t2, e5, s4, n6) {
    t2.cutArcIgnoreAttributes(s4, n6, e5);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e5.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    return !i2 && this.m_maxDeviation > 0 && (i2 = !_ah.checkEllipticArcMaxDeviation(e5, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_ah.checkEllipticArcMaxAngle(e5, this.m_cosMaxAngle)), i2;
  }
  bezierNeedsSplit(t2) {
    let e5 = false;
    if (this.m_maxLength > 0) {
      if (ei.distance(t2[0], t2[1]) + ei.distance(t2[1], t2[2]) + ei.distance(t2[2], t2[3]) > this.m_maxLength) return e5 = true, true;
    }
    return !e5 && this.m_maxDeviation > 0 && (e5 = !_ah.checkBezierMaxDeviation(t2, this.m_maxDeviation)), !e5 && this.m_maxAngle > 0 && (e5 = !_ah.checkBezierMaxAngle(t2, this.m_cosMaxAngle)), e5;
  }
  progress_() {
  }
  static checkBezierMaxDeviation(t2, e5) {
    const s4 = t2[3].sub(t2[0]);
    if (s4.sqrLength() > 0) {
      const n6 = s4.clone();
      n6.leftPerpendicularThis(), n6.normalize();
      const i2 = n6.dotProduct(t2[0].sub(t2[1])), r = n6.dotProduct(t2[0].sub(t2[2]));
      if (Math.max(Math.abs(i2), Math.abs(r)) <= e5) {
        const e6 = new ei();
        jo(t2, 0.5, e6, false);
        const n7 = e6.sub(t2[0]).dotProduct(s4);
        return n7 >= 0 && n7 <= s4.sqrLength();
      }
      return false;
    }
    return Math.max(t2[0].sub(t2[1]).sqrLength(), t2[0].sub(t2[2]).sqrLength()) <= e5 * e5;
  }
  static checkBezierMaxAngle(t2, e5) {
    if (t2[0].equals(t2[3])) return !(!t2[0].equals(t2[1]) || !t2[1].equals(t2[2]));
    const s4 = t2[3].sub(t2[0]);
    s4.normalize();
    {
      const n6 = t2[1].sub(t2[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    {
      const n6 = t2[2].sub(t2[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    {
      const n6 = t2[2].sub(t2[1]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    return true;
  }
  static checkRationalBezier2MaxDeviation(t2, e5, s4) {
    if (0 === e5[1]) return false;
    const n6 = t2[2].sub(t2[0]);
    if (n6.sqrLength() > 0) {
      const e6 = n6.clone();
      e6.leftPerpendicularThis(), e6.normalize();
      const i2 = e6.dotProduct(t2[0].sub(t2[1]));
      if (Math.abs(i2) <= s4) {
        const e7 = t2[1].sub(t2[0]).dotProduct(n6);
        return e7 >= 0 && e7 <= n6.sqrLength();
      }
      return false;
    }
    return t2[0].sub(t2[1]).sqrLength() <= s4 * s4;
  }
  static checkRationalBezier2MaxAngle(t2, e5, s4) {
    if (0 === e5[1]) return false;
    if (t2[0].equals(t2[2])) return !!t2[0].equals(t2[1]);
    const n6 = t2[2].sub(t2[0]);
    n6.normalize();
    {
      const e6 = t2[1].sub(t2[0]), i2 = e6.dotProduct(n6);
      if (i2 < 0) return false;
      if (e6.length() * s4 > i2) return false;
    }
    return true;
  }
  static checkBezier2MaxDeviation(t2, e5) {
    const s4 = t2[2].sub(t2[0]);
    if (s4.sqrLength() > 0) {
      const n6 = s4.clone();
      n6.leftPerpendicularThis(), n6.normalize();
      const i2 = n6.dotProduct(t2[0].sub(t2[1]));
      if (Math.abs(i2) <= e5) {
        const e6 = t2[1].sub(t2[0]).dotProduct(s4);
        return e6 >= 0 && e6 <= s4.sqrLength();
      }
      return false;
    }
    return t2[0].sub(t2[1]).sqrLength() <= e5 * e5;
  }
  static checkBezier2MaxAngle(t2, e5) {
    if (t2[0].equals(t2[2])) return !!t2[0].equals(t2[1]);
    const s4 = t2[2].sub(t2[0]);
    s4.normalize();
    {
      const n6 = t2[1].sub(t2[0]), i2 = n6.dotProduct(s4);
      if (i2 < 0) return false;
      if (n6.length() * e5 > i2) return false;
    }
    return true;
  }
  static checkEllipticArcMaxDeviation(t2, e5) {
    if (Math.abs(t2.getSweepAngle()) < Math.PI) {
      const s5 = t2.getEndXY().sub(t2.getStartXY()), n7 = [0, 0];
      if (1 === pm(t2, s5, n7)) {
        const s6 = t2.getCoord2D(n7[0]), i2 = ei.getClosestCoordinate(t2.getStartXY(), t2.getEndXY(), s6), r = new ei();
        Y(t2.getStartXY(), t2.getEndXY(), i2, r);
        return ei.distance(s6, r) <= e5;
      }
    }
    const s4 = t2.getCoord2D(0.5), n6 = new ei();
    Y(t2.getEndXY(), t2.getStartXY(), 0.5, n6);
    return ei.distance(s4, n6) <= e5;
  }
  static checkEllipticArcMaxAngle(t2, e5) {
    const s4 = t2.getTangent(0), n6 = t2.getTangent(1), i2 = s4.dotProduct(n6);
    return !(i2 < 0) && !(s4.length() * n6.length() * e5 > i2);
  }
  static checkTypeForReplace(t2, e5) {
    return t2.getGeometryType() === e5 && (e5 !== a.enumEllipticArc || t2.isCircular());
  }
};
function hh(t2, e5, s4) {
  const n6 = s4.length;
  if (e5 <= 0 || n6 <= 2) return n6;
  let i2 = 0;
  const r = Lt(n6 - 1, Number.NaN);
  for (let o2 = 1, a2 = n6; o2 < a2; o2++) {
    const e6 = t2.tToLength(s4[o2]);
    r[o2 - 1] = e6 - i2, i2 = e6;
  }
  for (; r.length > 1; ) {
    const t3 = r.findIndex((t4) => t4 <= 2 * e5);
    if (-1 === t3) break;
    let n7 = t3 + 1, i3 = t3 + 1;
    if (t3 > 0) {
      const e6 = t3 - 1;
      (i3 === r.length || r[e6] > r[i3]) && (i3 = e6, n7--);
    }
    r[i3] += r[t3], r.splice(t3, 1), s4.splice(n7, 1);
  }
  return s4.length;
}
function ch(t2, e5, s4, n6, i2, r, o2, a2) {
  const h2 = e5.clone();
  h2.dropAllAttributes();
  const m2 = (t3, e6, s5, n7) => (e6 && (t3 && e6.push(n7.getStartXY()), e6.push(ei.getNAN()), e6.push(ei.getNAN()), e6.push(n7.getEndXY())), s5 && (t3 && s5.push(0), s5.push(1)), 1);
  if (h2.isDegenerateToLine() || h2.isDegenerate(0)) return m2(t2, r, o2, e5);
  const u = h2.getStartXY(), l2 = h2.getEndXY(), c = h2.getSemiAxes(), g2 = new x3();
  if (h2.isCircular()) g2.setIdentity();
  else {
    const t3 = h2.getAxisXRotation();
    g2.setScaleCoords(1, h2.getMinorMajorRatio()), g2.rotateAngle(t3);
  }
  const d2 = h2.getCenter();
  g2.shift(d2);
  const _ = g2.clone();
  _.invertThis(), h2.applyTransformation(_);
  const p3 = h2.getSweepAngle();
  if (0 === p3) return m2(t2, r, o2, e5);
  const f3 = n4.constructEmpty();
  f3.setCoords({ center: d2, width: 2 * c.x, height: 2 * c.x });
  const P5 = 0.05 * f3.calculateToleranceFromEnvelope(), y2 = Math.max(s4 / c.x, P5 / c.x);
  let x4 = 4 * Math.pow(y2 / 0.0741, 1 / 6);
  x4 = Math.min(x4, Math.PI / 2);
  const C2 = ja(h2.getStartAngle());
  let v3 = p3 > 0 ? Math.floor(C2 / x4) : Math.ceil(C2 / x4);
  v3 *= x4;
  const b2 = p3 > 0 ? x4 : -x4;
  v3 + b2 === C2 && (v3 += b2);
  let E2 = 4 / 3 * Math.tan(Math.abs(x4) / 4);
  p3 > 0 && (E2 = -E2), o2 && t2 && o2.push(0);
  const S3 = x4 / Math.abs(p3);
  let D3 = (v3 - C2) / p3;
  const w4 = u.clone(), A4 = new ei();
  h2.queryCoord2D(0, A4);
  const T3 = A4.clone(), I5 = 1 - 0.01 * S3;
  let M2 = 0, Y3 = 0;
  for (; D3 < 1; ) {
    let s5;
    if (D3 += S3, Y3 > 0 && D3 < I5) s5 = E2;
    else {
      D3 >= I5 && (D3 = 1);
      const t3 = (D3 - Y3) * p3;
      s5 = 4 / 3 * Math.tan(Math.abs(t3) / 4), p3 > 0 && (s5 = -s5);
    }
    h2.queryCoord2D(D3, A4);
    const a3 = new ei();
    g2.queryTransform(A4, a3);
    const m3 = e5.getClosestCoordinate(a3, false);
    if (e5.queryCoord2D(m3, a3), 1 !== D3 && (ei.distance(w4, a3) <= 2 * n6 || ei.distance(a3, l2) <= 2 * n6)) continue;
    w4.setCoordsPoint2D(a3);
    const c2 = Rt(ei, 4);
    c2[0].assign(T3), c2[3].assign(A4), c2[1].rightPerpendicularOther(T3), c2[1].scaleAddThis(s5, T3), c2[2].leftPerpendicularOther(A4), c2[2].scaleAddThis(s5, A4), g2.transformPoints2D(c2, 3, c2), c2[3].assign(a3), 0 === Y3 && c2[0].setCoordsPoint2D(u), 1 === D3 && c2[3].setCoordsPoint2D(l2), i2 && zo(c2);
    let d3 = true;
    for (let t3 = 1; t3 < 4; t3++) if (!c2[t3].isEqualPoint2D(c2[0])) {
      d3 = false;
      break;
    }
    d3 || (o2 && o2.push(m3), r && (0 === Y3 && t2 && r.push(c2[0].clone()), r.push(c2[1].clone()), r.push(c2[2].clone()), r.push(c2[3].clone())), M2++), Y3 = D3, T3.setCoordsPoint2D(A4);
  }
  return M2;
}
function dh(t2, e5, s4, n6, i2, r, o2, a2) {
  e5.clone().dropAllAttributes();
  const h2 = new n4();
  e5.queryLooseEnvelope(h2);
  const m2 = 0.05 * h2.calculateToleranceFromEnvelope(), u = Math.max(s4, m2);
  o2 && t2 && o2.push(0);
  let l2 = 0;
  const c = Rt(ei, 3);
  e5.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e5.queryWeights(g2);
  const d2 = [], _ = Lt(9, Number.NaN);
  let p3 = 0;
  i2 ? (p3 = e5.getMonotonicPartParams(_.length, _), _.length = p3, p3 = hh(e5, n6, _)) : (_.length = 2, p3 = 2, _[0] = 0, _[1] = 1);
  let f3 = 0, P5 = t2;
  for (let y2 = 1; y2 < p3; y2++) {
    const t3 = _[y2];
    for (d2.length = 0, d2.push(t3), d2.push(f3); d2.length > 1; ) {
      const t4 = d2.at(-1);
      d2.pop();
      const e6 = d2.at(-1), s5 = Rt(ei, 3), n7 = [0, 0, 0];
      Xi(c, g2, t4, e6, s5, n7);
      const i3 = Rt(ei, 4), a3 = Ni(s5, n7, i3), h3 = 16, m3 = d2.length > h3;
      u >= a3 || m3 ? (o2.push(e6), r && (P5 && (r.push(i3[0]), P5 = false), r.push(i3[1]), r.push(i3[2]), r.push(i3[3])), l2++) : (d2.push(0.5 * (t4 + e6)), d2.push(t4));
    }
    f3 = t3;
  }
  return l2;
}
function fh() {
  return { e2: 0, completeE: 0 };
}
var Ph = class {
  constructor(t2, e5) {
    this.m_arc = t2, this.m_sqrChordLength = e5;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t2, e5) {
    return 0 === t2 ? ei.sqrDistance(this.m_arc.getCoord2D(e5), this.m_arc.getCoord2D(1 - e5)) - this.m_sqrChordLength : 0;
  }
  getError(t2) {
    return 0;
  }
};
function yh(t2, e5, s4) {
  if (zh(t2)) {
    ls2(new su({ start: t2.getStartXY(), end: t2.getEndXY() }), e5, s4);
  } else if (0 === e5.value()) s4.set(t2.getStartXY());
  else if (1 === e5.value()) s4.set(t2.getEndXY());
  else {
    const n6 = new p2();
    Th(t2, e5, n6);
    const i2 = new p2(), r = new p2();
    p2.st_cosAndSin(n6, i2, r);
    const o2 = Se.constructCoordsE(new p2(t2.m_semiMajorAxis).mulThisE(i2), new p2(t2.m_semiMajorAxis).mulThis(t2.m_minorMajorRatio).mulThisE(r)), a2 = new p2(t2.m_rotation);
    p2.st_cosAndSin(a2, i2, r), o2.rotateDirect(i2, r), o2.addThisE(Se.constructPoint2D(t2.m_center)), s4.setE(o2);
  }
}
function xh(t2, e5) {
  return t2.convertToCanonic(e5);
}
function Ch(t2, e5) {
  const s4 = new x2(t2.getStartAngle(), t2.getEndAngle());
  s4.normalize();
  const n6 = Qs(), i2 = ct(e5, n6);
  if (i2 < s4.vmin) {
    let t3 = i2 + n6;
    for (; t3 < s4.vmin; ) t3 += n6;
    return s4.containsCoordinate(t3) ? t3 : s4.vmin - i2 < t3 - s4.vmax ? i2 : t3;
  }
  if (i2 > s4.vmax) {
    let t3 = i2 - n6;
    for (; t3 > s4.vmax; ) t3 -= n6;
    return s4.containsCoordinate(t3) || s4.vmin - t3 < i2 - s4.vmax ? t3 : i2;
  }
  return i2;
}
function vh(t2, e5, s4, n6) {
  let i2 = t2.m_startAngle, r = t2.m_sweepAngle;
  const o2 = 1e-12;
  for (; i2 > Gs(); ) i2 -= 2 * Gs();
  for (; i2 <= -Gs(); ) i2 += 2 * Gs();
  if (!Number.isNaN(e5)) {
    for (; e5 > Gs(); ) e5 -= 2 * Gs();
    for (; e5 <= -Gs(); ) e5 += 2 * Gs();
    !s4 && e5 > i2 && (e5 -= 2 * Gs()), s4 && e5 < i2 && (e5 += 2 * Gs()), r = e5 - i2, Math.abs(r) < o2 && !n6 && (r = s4 ? 2 * Gs() : -2 * Gs()), Math.abs(r) > 2 * Gs() - o2 && n6 && (r = 0);
  }
  Math.abs(r) > 2 * Gs() - o2 && (r = r >= 0 ? 2 * Gs() : -2 * Gs(), t2.setEndXY(t2.getStartXY())), Math.abs(r) < o2 && (r = 0, t2.setEndXY(t2.getStartXY())), n6 = Math.abs(r) <= Gs(), r && (s4 = r > 0), t2.m_startAngle = bh(i2), t2.m_sweepAngle = r, Jh(t2, !n6), Oh(t2, s4);
}
function bh(t2) {
  let e5 = t2, s4 = false;
  return e5 <= -Gs() ? (e5 += Qs(), s4 = true) : e5 > Gs() && (e5 -= Qs(), s4 = true), e5 <= -Gs() ? (e5 = ct(e5, Qs()), e5 <= -Gs() && (e5 += Qs()), s4 = true) : e5 > Gs() && (e5 = ct(e5, Qs()), e5 > Gs() && (e5 -= Qs()), s4 = true), s4 && (e5 > Gs() || e5 <= -Gs()) && (e5 = Gs()), e5;
}
function Eh(t2, e5, s4) {
  const n6 = s4, i2 = n6.getSemiAxes();
  let r = new ei(i2.x * Math.cos(t2[0]), i2.y * Math.sin(t2[0]));
  return r = n6.convertFromCanonic(r), ei.sqrDistance(r, n6.getStartXY());
}
function Sh(t2, e5, s4) {
  const n6 = s4, i2 = n6.getSemiAxes(), r = t2[0] + n6.getStartAngle();
  let o2 = new ei(i2.x * Math.cos(r), i2.y * Math.sin(r));
  return o2 = n6.convertFromCanonic(o2), ei.sqrDistance(o2, n6.getEndXY());
}
function Dh(t2) {
  if (t2.m_center.isNAN()) return t2.m_startAngle = 0, void (t2.m_sweepAngle = 0);
  const e5 = t2.getStartXY(), s4 = t2.getEndXY(), n6 = e5.equals(s4), i2 = Kh(t2), r = Qh(t2), o2 = t2.projectionBehavior();
  if (n6) {
    const s5 = t2.convertToCanonic(e5), n7 = new ei(t2.m_semiMajorAxis, t2.m_semiMajorAxis * t2.m_minorMajorRatio);
    s5.x /= n7.x, s5.y /= n7.y, t2.m_startAngle = bh(Math.atan2(s5.y, s5.x)), t2.m_sweepAngle = i2 ? r ? Qs() : -Qs() : 0;
  } else {
    const n7 = t2.convertToCanonic(e5), a2 = new ei(t2.m_semiMajorAxis, t2.m_semiMajorAxis * t2.m_minorMajorRatio);
    n7.x /= a2.x, n7.y /= a2.y;
    const h2 = t2.convertToCanonic(s4);
    h2.x /= a2.x, h2.y /= a2.y, t2.m_startAngle = Math.atan2(n7.y, n7.x), t2.m_sweepAngle = ei.calculateAngle(n7, h2), r ? t2.m_sweepAngle < 0 && (t2.m_sweepAngle += Qs()) : t2.m_sweepAngle > 0 && (t2.m_sweepAngle -= Qs()), t2.m_startAngle = bh(t2.m_startAngle);
    let m2 = Eh([t2.m_startAngle], 1, t2);
    if (m2 = Math.sqrt(m2), m2 > 0.25 * Ue(t2)) {
      const e6 = t2.m_startAngle - 1e-4, s5 = t2.m_startAngle + 1e-4, n8 = [0];
      Vs2(Eh, t2, 1, [t2.m_startAngle], [e6], [s5], 1e-14, n8), t2.m_startAngle = bh(n8[0]);
    }
    if (m2 = Sh([t2.m_sweepAngle], 1, t2), m2 = Math.sqrt(m2), m2 > 0.25 * Ue(t2)) {
      const e6 = t2.m_sweepAngle - 1e-4, s5 = t2.m_sweepAngle + 1e-4, n8 = [0];
      Vs2(Sh, t2, 1, [t2.m_sweepAngle], [e6], [s5], 1e-14, n8), t2.m_sweepAngle = n8[0];
    }
    const u = Math.abs(t2.m_sweepAngle) > Gs();
    if (Jh(t2, u), i2 !== u && !i2 && Math.abs(t2.m_sweepAngle) > 1.5 * Gs()) return void Rh(t2, e5, s4, o2);
    if (0 === t2.m_sweepAngle || r !== t2.m_sweepAngle > 0) return void Rh(t2, e5, s4, o2);
  }
}
function wh(t2, e5) {
  return (Ch(t2, e5) - t2.getStartAngle()) / t2.getSweepAngle();
}
function Ah(t2, e5) {
  return t2.m_startAngle + e5 * t2.m_sweepAngle;
}
function Th(t2, e5, s4) {
  s4.assign(new p2(t2.m_startAngle).addE(e5.mulE(new p2(t2.m_sweepAngle))));
}
function Ih(t2, e5) {
  const s4 = new p2(t2.m_cosr).sqrThis(), n6 = new p2(t2.m_sinr).sqrThis(), i2 = new p2(t2.m_minorMajorRatio), r = new p2(1 / t2.m_minorMajorRatio), o2 = i2.mulE(s4).addThisE(r.mulE(n6)), a2 = i2.subE(r).mulThis(2 * t2.m_cosr * t2.m_sinr), h2 = i2.mulE(n6).addThisE(r.mulE(s4));
  e5[0] = o2, e5[1] = a2, e5[2] = h2, e5[3] = new p2(-t2.m_semiMajorAxis).mulThis(t2.m_semiMajorAxis).mulThis(t2.m_minorMajorRatio);
}
function Mh(t2, e5) {
  const s4 = new De();
  s4.a11.setE(t2[0]), s4.a12 = p2.st_mulByPower2(t2[1], 0.5), s4.a21.setE(s4.a12), s4.a22.setE(t2[2]);
  const n6 = [ei.getNAN(), ei.getNAN()], i2 = [new p2(), new p2()];
  s4.eigenSymmetric(i2, n6);
  const r = t2[3].clone();
  r.negateThis(), r.invThis(), i2[0].mulThisE(r), i2[1].mulThisE(r), i2[0].sqrtThis().invThis(), i2[1].sqrtThis().invThis(), e5.x = i2[0].toDouble(), e5.y = i2[1].toDouble();
  return Math.atan2(n6[0].y, n6[0].x);
}
function Yh(t2, e5, s4) {
  if (zh(t2)) return (s4 - e5) * ei.distance(t2.getStartXY(), t2.getEndXY());
  if (1 === t2.m_minorMajorRatio) return Math.abs(t2.getSweepAngle() * (e5 - s4)) * t2.m_semiMajorAxis;
  const n6 = kh(t2, e5);
  return kh(t2, s4) - n6;
}
function Xh(t2) {
  return t2.m_cachedValues;
}
function Nh(t2) {
  if (t2.m_cachedValues) return t2.m_cachedValues;
  const e5 = fh();
  return e5.e2 = Vh(t2), e5.completeE = ft(e5.e2), t2.m_cachedValues = e5, e5;
}
function qh(t2, e5, s4, n6) {
  if (!e5.isEqual(t2.m_XStart, t2.m_YStart) || !s4.isEqual(t2.m_XEnd, t2.m_YEnd)) {
    if (zh(t2)) return t2.m_XStart = e5.x, t2.m_YStart = e5.y, t2.m_XEnd = s4.x, t2.m_YEnd = s4.y, mm(t2), void t2.afterCompletedModification();
    if (n6 && Math.abs(t2.getSweepAngle()) <= 1.01 * Vs()) {
      const n7 = Rt(ei, 3), i2 = nm(t2, n7);
      if (Ai(n7)) {
        n7[0].assign(e5), n7[2].assign(s4), Ii(n7);
        if (0 === t2.projectionBehavior()) {
          let e6 = 0, s5 = 2;
          ei.sqrDistance(n7[1], n7[0]) < ei.sqrDistance(n7[1], n7[2]) && (s5 = Mt(e6, e6 = s5));
          const i3 = n7[s5].sub(n7[e6]), r = i3.length();
          i3.divThis(r);
          const o2 = n7[1].sub(n7[e6]), a2 = o2.length(), h2 = o2.dotProduct(i3) / a2, m2 = o2.crossProduct(i3) / a2, u = new ei();
          Y(n7[e6], n7[s5], 0.5, u);
          const l2 = 0.5 * r / m2 * ks(1 - h2, 0, 1), c = n7[1].side(n7[e6], n7[s5]), g2 = i3.clone();
          c ? g2.leftPerpendicularThis() : g2.rightPerpendicularThis();
          const d2 = u.sub(g2.mul(l2));
          t2.constructCircularArcThreePoint(n7[0], n7[2], d2);
        } else im(n7, i2 * i2, null, false, t2);
        return;
      }
    }
    0 === t2.projectionBehavior() ? ym(t2, e5, s4) : xm(t2, e5, s4);
  }
}
function Fh(t2, e5, s4) {
  const n6 = 0 === t2.projectionBehavior();
  if (s4 <= 2) return void Rh(t2, e5[0], e5[s4 - 1], n6 ? 0 : 1);
  if (n6) {
    t2.constructCircularArcThreePoint(e5[0], e5[s4 - 1], e5[Math.trunc(s4 / 2)]);
    const n7 = new ei();
    return t2.queryCoord2D(0.5, n7), void t2.m_interior.setCoordsPoint2D(n7);
  }
  const i2 = t2.getSemiMajorAxis(), r = t2.getMinorMajorRatio(), o2 = t2.getAxisXRotation(), a2 = t2.getCenter(), h2 = new Array(4);
  h2[0] = t2.isMajor(), h2[1] = !h2[0], h2[2] = h2[0], h2[3] = !h2[0];
  const m2 = new Array(4);
  m2[0] = t2.isClockwise(), m2[1] = m2[0], m2[2] = !m2[0], m2[3] = !m2[0];
  const u = Math.trunc(s4 < 5 ? 1 : (s4 + 4) / 5), l2 = Rt(Oa, 4), c = Lt(4, Number.NaN);
  let g2 = 0;
  for (let d2 = 0; d2 < 4; d2++) {
    l2[d2].constructEllipticArcEndPointsCenter(e5[0], e5[s4 - 1], i2, r, o2, h2[d2], m2[d2], a2), c[d2] = 0;
    let t3 = 0;
    for (let n7 = u; n7 < s4 - 1; n7 += u) {
      const s5 = l2[d2].getClosestCoordinate(e5[n7], false);
      c[d2] += ei.sqrDistance(l2[d2].getCoord2D(s5), e5[n7]), t3++;
    }
    c[d2] /= t3, c[d2] < c[g2] && (g2 = d2);
  }
  t2.assignCopy(l2[g2]);
}
function Vh(t2) {
  return 1 - $(t2.m_minorMajorRatio);
}
function Lh(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  return t2.m_bits = 0, t2.m_rotation = r, Ne(t2, e5), Fe(t2, s4), t2.m_cosr = Math.cos(r), t2.m_sinr = Math.sin(r), Jh(t2, o2), Oh(t2, a2), void 0 !== h2 ? t2.m_center.assign(h2) : t2.m_center.setNAN(), t2.setProjectionBehavior(1), t2.m_semiMajorAxis = n6, t2.m_minorMajorRatio = i2, sm(t2, void 0 === h2);
}
function Rh(t2, e5, s4, n6) {
  t2.m_bits = 0, t2.m_rotation = 0, Ne(t2, e5), Fe(t2, s4), t2.m_interior.assign(e5.add(s4).mul(0.5)), t2.m_startAngle = 0, t2.m_sweepAngle = 0, t2.m_cosr = 1, t2.m_sinr = 0, Jh(t2, false), Oh(t2, false), t2.m_center.setNAN(), t2.m_semiMajorAxis = 1, t2.m_minorMajorRatio = 0, t2.setProjectionBehavior(n6), t2.afterCompletedModification();
}
function zh(t2) {
  return t2.m_center.isNAN();
}
function kh(t2, e5) {
  if (0 === e5) return 0;
  const s4 = Nh(t2), n6 = Ah(t2, e5), i2 = Vs(), r = Gh(t2), o2 = _t(n6 + i2, s4.e2, s4.completeE), a2 = t2.m_semiMajorAxis * (o2 - r);
  return Math.abs(a2);
}
function Bh(t2, e5) {
  if (zh(t2)) {
    const s5 = ei.distance(t2.getStartXY(), t2.getEndXY());
    return 0 === s5 ? 0 : e5 / s5;
  }
  if (1 === t2.m_minorMajorRatio) {
    const s5 = Math.abs(t2.getSweepAngle() * t2.m_semiMajorAxis);
    return 0 === s5 ? 0 : e5 / s5;
  }
  if (0 === e5) return 0;
  const s4 = t2.getSweepAngle();
  if (0 === s4) return 0.5;
  const n6 = Nh(t2), i2 = Vs(), r = Gh(t2);
  s4 < 0 && (e5 = -e5);
  const o2 = e5 / t2.m_semiMajorAxis + r;
  let a2 = vt(o2, n6.e2, n6.completeE);
  a2 -= i2, a2 -= t2.getStartAngle();
  return a2 / s4;
}
function Gh(t2) {
  const e5 = Nh(t2);
  return _t(t2.getStartAngle() + Vs(), e5.e2, e5.completeE);
}
function Wh(t2, e5, n6) {
  if (2 === e5.m_TransformationType) return void n2(0);
  if (n2(!tm(t2)), e5.isIdentity()) return;
  Hh(t2);
  const i2 = ei.getNAN();
  i2.x = t2.m_XStart, i2.y = t2.m_YStart, e5.transformInPlace(i2);
  const r = ei.getNAN();
  if (r.x = t2.m_XEnd, r.y = t2.m_YEnd, e5.transformInPlace(r), zh(t2)) return t2.m_XStart = i2.x, t2.m_YStart = i2.y, t2.m_XEnd = r.x, void (t2.m_YEnd = r.y);
  const o2 = t2.m_center.clone();
  if (e5.transformInPlace(o2), n6 || e5.isUniformNoRotation()) {
    let s4 = Qh(t2);
    e5.isReflective() && (s4 = !s4);
    if (0 === t2.projectionBehavior()) {
      if (!i2.equals(r)) {
        const s5 = t2.m_interior.clone();
        return e5.transformInPlace(s5), void t2.constructCircularArcThreePoint(i2, r, s5);
      }
      return void jh(t2, i2, r, o2, s4, false);
    }
    const n7 = new ei(t2.m_cosr, t2.m_sinr);
    e5.transformWithoutTranslateInPlace(n7);
    const a2 = Math.atan2(n7.y, n7.x), h2 = t2.getSemiAxes();
    e5.transformWithoutTranslateInPlace(h2);
    const m2 = t2.m_center.clone();
    return e5.transformInPlace(m2), void t2.constructEllipticArcEndPointsCenter(i2, r, h2.x, h2.y / h2.x, a2, t2.isMajor(), s4, m2);
  }
  {
    {
      const s5 = new Array(4);
      Ih(t2, s5);
      const n8 = new De();
      n8.a11.setE(s5[0]), n8.a12.setE(s5[1]), n8.a12.mulThisByPower2(0.5), n8.a21.setE(n8.a12), n8.a22.setE(s5[2]);
      if (!n8.det().isZero()) {
        const a3 = new De();
        if (a3.a11.set(e5.xx), a3.a12.set(e5.xy), a3.a21.set(e5.yx), a3.a22.set(e5.yy), a3.invertThis()) {
          const h3 = a3.clone();
          h3.transposeThis();
          const m3 = n8.clone();
          m3.mulThis(a3), m3.mulLeftThis(h3);
          if (!m3.det().isZero()) {
            const n9 = Rt(p2, 4);
            n9[0].setE(m3.a11), n9[1].setE(m3.a12), n9[1].mulThisByPower2(2), n9[2].setE(m3.a22), n9[3].setE(s5[3]);
            const a4 = ei.getNAN(), h4 = Mh(n9, a4);
            let u = Qh(t2);
            return e5.isReflective() && (u = !u), void t2.constructEllipticArcEndPointsCenter(i2, r, a4.x, a4.y / a4.x, h4, t2.isMajor(), u, o2);
          }
        }
      }
    }
    const s4 = [ei.getNAN(), ei.getNAN(), ei.getNAN()];
    s4[0].setCoords(t2.getSemiMajorAxis(), 0), s4[0].rotateDirect(t2.m_cosr, t2.m_sinr), s4[1].setCoords(t2.getSemiMajorAxis(), t2.getSemiMinorAxis()), s4[1].rotateDirect(t2.m_cosr, t2.m_sinr), s4[2].setCoords(0, t2.getSemiMinorAxis()), s4[2].rotateDirect(t2.m_cosr, t2.m_sinr);
    let n7 = t2.isClockwise();
    n7 && (s4[2] = Mt(s4[0], s4[0] = s4[2]));
    const a2 = 0.5;
    e5.transformWithoutTranslateArray(s4, 3, s4), e5.isReflective() && (n7 = !n7);
    const h2 = new ei(0, 0), m2 = t2.createInstance();
    im(s4, a2, h2, false, m2), t2.constructEllipticArcEndPointsCenter(i2, r, m2.getSemiMajorAxis(), m2.getMinorMajorRatio(), m2.getAxisXRotation(), t2.isMajor(), !n7, o2);
  }
}
function jh(t2, e5, s4, n6, i2, r) {
  const o2 = 0.5 * (n6.sub(e5).length() + n6.sub(s4).length());
  t2.m_center.assign(n6), t2.m_startAngle = Math.atan2(e5.y - t2.m_center.y, e5.x - t2.m_center.x);
  vh(t2, Math.atan2(s4.y - t2.m_center.y, s4.x - t2.m_center.x), i2, r);
  const a2 = t2.constructEllipticArcEndPointsCenter(e5, s4, o2, 1, 0, Math.abs(t2.m_sweepAngle) > Math.PI, t2.m_sweepAngle > 0, n6);
  return t2.setProjectionBehavior(0), a2;
}
function Zh(t2, e5) {
  t2.m_cachedValues = e5;
}
function Hh(t2) {
  t2.m_cachedValues = null;
}
function Uh(t2, e5) {
  e5.m_cachedValues = Mt(t2.m_cachedValues, t2.m_cachedValues = e5.m_cachedValues);
}
function Oh(t2, e5) {
  const s4 = e5 ? 1 : 0;
  t2.m_bits = -2 & t2.m_bits | s4;
}
function Qh(t2) {
  return !!(1 & t2.m_bits);
}
function Jh(t2, e5) {
  const s4 = e5 ? 1 : 0;
  t2.m_bits = -3 & t2.m_bits | s4 << 1;
}
function Kh(t2) {
  return !!(2 & t2.m_bits);
}
function $h(t2) {
  if (t2.m_center.isNAN()) return false;
  const e5 = 8, s4 = new Se();
  s4.setWithEps(t2.getStartXY(), e5), s4.subThisE(new Se().setWithEps(t2.m_center, e5));
  const n6 = new p2();
  n6.setWithEps(t2.m_rotation, e5);
  const i2 = new p2(), r = new p2();
  p2.st_cosAndSin(n6, i2, r), s4.rotateReverse(i2, r);
  const o2 = new Se();
  o2.setWithEps(t2.getEndXY()), o2.subThisE(Se.constructPoint2D(t2.m_center)), o2.rotateReverse(i2, r);
  const a2 = new p2();
  a2.setWithEps(t2.m_semiMajorAxis, e5);
  const h2 = a2.clone(), m2 = new p2();
  m2.setWithEps(t2.m_minorMajorRatio), h2.mulThisE(m2), s4.x.divThisE(a2), s4.y.divThisE(h2), o2.x.divThisE(a2), o2.y.divThisE(h2);
  const u = s4.x.sqr().addThisE(s4.y.sqr()).subThisE(w2), l2 = o2.x.sqr().addThisE(o2.y.sqr()).subThisE(w2);
  return !u.isZero() || !l2.isZero();
}
function tm(t2) {
  return !!(8 & t2.m_bits);
}
function em(t2) {
  t2.m_bits &= -9;
}
function sm(t2, e5) {
  em(t2);
  const s4 = t2.getStartXY(), n6 = t2.getEndXY();
  let i2 = false;
  const r = Kh(t2), o2 = Qh(t2), a2 = t2.projectionBehavior(), h2 = s4.equals(n6);
  let m2 = 0 === t2.m_minorMajorRatio || 0 === t2.m_semiMajorAxis;
  if (Number.isNaN(t2.m_minorMajorRatio) && (0 === t2.m_semiMajorAxis ? t2.m_minorMajorRatio = 1 : v("NAN minor major ratio and non-zero major axis")), m2 || (m2 = e5 ? h2 : t2.m_center.isNAN()), m2) return Rh(t2, s4, n6, a2), true;
  t2.m_semiMajorAxis = Math.abs(t2.m_semiMajorAxis), t2.m_minorMajorRatio = Math.abs(t2.m_minorMajorRatio), t2.m_minorMajorRatio > 1 && (t2.m_semiMajorAxis *= t2.m_minorMajorRatio, t2.m_minorMajorRatio = 1 / t2.m_minorMajorRatio);
  const u = new ei(t2.m_semiMajorAxis, t2.m_semiMajorAxis * t2.m_minorMajorRatio);
  if (h2) {
    const e6 = t2.convertToCanonic(s4);
    e6.x /= u.x, e6.y /= u.y;
    const n7 = Math.sqrt($(e6.x) + $(e6.y));
    if (i2 = 1 !== n7, t2.m_semiMajorAxis *= n7, u.mulThis(n7), t2.m_startAngle = bh(Math.atan2(e6.y, e6.x)), !r) return t2.m_interior.assign(s4), t2.m_sweepAngle = 0, t2.afterCompletedModification(), i2;
    t2.m_sweepAngle = o2 ? Qs() : -Qs();
  } else {
    let e6 = t2.m_center.isNAN() || $h(t2);
    if (!e6) {
      const i3 = t2.convertToCanonic(s4);
      i3.x /= u.x, i3.y /= u.y;
      const r2 = new ei(1, 0);
      t2.m_startAngle = ei.calculateAngle(r2, i3);
      const o3 = t2.convertToCanonic(n6);
      o3.x /= u.x, o3.y /= u.y, t2.m_sweepAngle = ei.calculateAngle(i3, o3), e6 = !om(t2);
    }
    if (e6) {
      i2 = true;
      const e7 = s4.sub(n6).mulThis(0.5);
      e7.rotateReverse(t2.m_cosr, t2.m_sinr);
      let a3 = $(e7.x / u.x) + $(e7.y / u.y);
      a3 > 1 && (a3 = Math.sqrt(a3), t2.m_semiMajorAxis *= a3, u.mulThis(a3));
      const h3 = new ei(0, 0);
      {
        const t3 = u.x * u.x, s5 = u.y * u.y, n7 = t3 * e7.y * e7.y + s5 * e7.x * e7.x, i3 = t3 * s5 - n7;
        if (i3 > 0) {
          const t4 = Math.sqrt(i3 / n7);
          h3.setCoords(u.x * e7.y / u.y, -u.y * e7.x / u.x), h3.mulThis(t4), r === o2 && h3.negateThis();
        }
      }
      {
        const e8 = new ei(h3.x, h3.y);
        e8.rotateDirect(t2.m_cosr, t2.m_sinr), e8.addThis(s4.add(n6).mulThis(0.5)), t2.m_center.assign(e8);
      }
    }
    if (Dh(t2), !om(t2)) return Rh(t2, s4, n6, a2), true;
  }
  return mm(t2), t2.afterCompletedModification(), i2;
}
function nm(t2, e5) {
  n2(Math.abs(t2.getSweepAngle()) < 15 * Math.PI / 16);
  const n6 = t2.getSemiMajorAxis(), i2 = t2.getSemiMinorAxis();
  let r;
  if (0 === n6) return e5[0].setCoordsPoint2D(t2.getStartXY()), e5[1].setCoordsPoint2D(t2.getStartXY()), e5[2].setCoordsPoint2D(t2.getStartXY()), r = 1, r;
  if (0 === i2) return e5[0].setCoordsPoint2D(t2.getStartXY()), e5[2].setCoordsPoint2D(t2.getEndXY()), e5[1] = ei.lerp(e5[0], e5[2], 0.5), r = 1, r;
  const o2 = t2.getSweepAngle(), a2 = t2.getStartAngle(), h2 = a2 + o2, m2 = new ei(-n6 * Math.sin(a2), i2 * Math.cos(a2)), u = new ei(-n6 * Math.sin(h2), i2 * Math.cos(h2));
  m2.normalize(), u.normalize(), m2.rotateDirect(t2.m_cosr, t2.m_sinr), u.rotateDirect(t2.m_cosr, t2.m_sinr), e5[0].setCoordsPoint2D(t2.getStartXY()), e5[2].setCoordsPoint2D(t2.getEndXY()), e5[1].setSub(e5[2], e5[0]);
  const l2 = m2.crossProduct(u);
  e5[1].assign(m2.mul(e5[1].crossProduct(u) / l2)), e5[1].addThis(e5[0]);
  return r = Math.cos(0.5 * o2), r;
}
function im(t2, e5, n6, i2, r) {
  if (i2) {
    const s4 = 0.5, n7 = Math.sqrt(e5), i3 = $(1 - s4) + 2 * n7 * s4 * (1 - s4) + $(s4), o3 = t2[0].mul($(1 - s4)).add(t2[1].mul(2 * n7 * s4 * (1 - s4))).add(t2[2].mul($(s4))).divThis(i3);
    return r.constructCircularArcThreePoint(t2[0], t2[2], o3), true;
  }
  const o2 = t2[0].sub(t2[1]), a2 = t2[2].sub(t2[1]), h2 = o2.crossProduct(a2), m2 = o2.dotProduct(a2), u = e5;
  n2(u <= 1), n2(u > 0);
  const l2 = 0.5 / (1 - u), c = o2.sqrLength(), g2 = m2, d2 = a2.sqrLength(), _ = $(h2), p3 = o2.sub(a2).sqrLength();
  if (0 === _) return Rh(r, t2[0], t2[2], 1), false;
  if (m2 <= -Math.sqrt(c) * Math.sqrt(d2)) return Rh(r, t2[0], t2[2], 1), false;
  const f3 = [0, 0], P5 = new x2();
  P5.setInfinite();
  const y2 = qs2(2 * _, -(p3 / u + 4 * g2), 2 * (1 - u) / u, P5, false, f3);
  if (0 === y2) return Rh(r, t2[0], t2[2], 1), false;
  1 === y2 && (f3[1] = f3[0]);
  const x4 = Math.sqrt(l2 / f3[0]), C2 = Math.sqrt(l2 / f3[1]), v3 = 0.5 / u;
  let b2 = v3 - d2 * f3[0], E2 = v3 - c * f3[0];
  Math.abs(b2) > Math.abs(E2) ? E2 = g2 * f3[0] - v3 + 1 : b2 = g2 * f3[0] - v3 + 1;
  const S3 = o2.mul(b2).add(a2.mul(E2)), D3 = S3.norm(1) < 1e-15 * x4 ? 0 : Math.atan2(S3.y, S3.x) + Math.PI, w4 = o2.add(a2), A4 = n6 ? n6.clone() : t2[1].add(w4.mul(l2)), T3 = t2[0].sub(A4), I5 = t2[2].sub(A4), M2 = T3.crossProduct(I5) < 0, Y3 = false;
  new Oa();
  return r.constructEllipticArcEndPointsCenter(t2[0], t2[2], x4, C2 / x4, D3, Y3, !M2, A4);
}
function rm(t2, e5, s4, n6, i2) {
  return im(t2, e5, s4, n6, i2);
}
function om(t2) {
  let e5 = false;
  {
    const s5 = new ei(t2.m_semiMajorAxis * Math.cos(t2.m_startAngle), t2.getSemiMinorAxis() * Math.sin(t2.m_startAngle));
    s5.rotateDirect(t2.m_cosr, t2.m_sinr), s5.addThis(t2.m_center);
    e5 = ei.distance(t2.getStartXY(), s5) > Ue(t2);
  }
  let s4 = false;
  if (!e5) {
    const e6 = new ei(t2.m_semiMajorAxis * Math.cos(t2.m_startAngle + t2.m_sweepAngle), t2.getSemiMinorAxis() * Math.sin(t2.m_startAngle + t2.m_sweepAngle));
    e6.rotateDirect(t2.m_cosr, t2.m_sinr), e6.addThis(t2.m_center);
    s4 = ei.distance(t2.getEndXY(), e6) > Ue(t2);
  }
  return !e5 && !s4;
}
function am(t2, s4, n6, i2) {
  0 === n6 && P("construct_enclosing_circle");
  const r = [0, 0, 0], o2 = Ja(s4, n6, r);
  if (1 === o2) t2.constructCircleRadius(0, s4[r[0]], i2);
  else if (2 === o2) {
    const e5 = ei.lerp(s4[r[0]], s4[r[1]], 0.5), n7 = ei.distance(s4[r[0]], e5), o3 = ei.distance(s4[r[1]], e5);
    t2.constructCircleRadius(Math.max(n7, o3), e5, i2);
  } else if (3 === o2) {
    const e5 = ei.calculateCircleCenterFromThreePoints(s4[r[0]], s4[r[1]], s4[r[2]]), n7 = ei.distance(s4[r[0]], e5), o3 = ei.distance(s4[r[1]], e5), a2 = ei.distance(s4[r[2]], e5);
    t2.constructCircleRadius(Math.max(n7, o3, a2), e5, i2);
  } else b("unexpected");
}
function hm(t2) {
  if (zh(t2)) return 0;
  if (t2.isDegenerate(0)) return 0;
  const e5 = t2.m_semiMajorAxis, s4 = t2.getSemiMinorAxis(), n6 = e5 * e5 + s4 * s4, i2 = t2.getStartAngle(), r = t2.getEndAngle(), o2 = t2.m_center.y - t2.m_YStart, a2 = t2.m_cosr, h2 = t2.m_sinr;
  let m2 = 1, u = 0;
  t2.m_rotation && (m2 = (a2 - h2) * (a2 + h2), u = 2 * a2 * h2);
  const l2 = ((-0.5 * (r - i2) + 0.25 * m2 * (2 * Math.cos(r + i2) * Math.sin(r - i2))) * s4 + -2 * Math.sin(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2)) * a2 * o2) * e5 / n6;
  let c = 0;
  if (t2.m_rotation) {
    c = 0.125 * (-2 * Math.sin(r + i2) * Math.sin(r - i2)) * u - s4 * o2 / n6 * (2 * Math.cos(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2))) * h2;
  }
  return n6 * (l2 + c) + -0.5 * (t2.m_XEnd - t2.m_XStart) * (t2.m_YEnd - t2.m_YStart);
}
function mm(t2) {
  t2.queryCoord2D(0.5, t2.m_interior);
}
function um(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== cm(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function lm(t2, e5, s4, n6, i2) {
  if (i2) {
    if (0 !== Hm(e5, s4)) return 2;
  } else if (Ae(e5, s4)) return 1;
  return 0 !== gm(t2, e5, s4, null, null, null, n6, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function cm(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  if (zh(e5)) {
    return ps(new su({ start: e5.getStartXY(), end: e5.getEndXY() }), n6, i2, r, o2, a2, h2, u);
  }
  null !== r && (r.length = 0), null !== o2 && (o2.length = 0), null !== i2 && (i2.length = 0);
  const l2 = Oe(e5, n6);
  if (Qe(e5, n6, a2 = Math.max(l2, a2))) return 0;
  const c = n6.getStartXY();
  c.subThis(e5.m_center);
  const g2 = n6.getEndXY();
  g2.subThis(e5.m_center), c.rotateReverse(e5.m_cosr, e5.m_sinr), g2.rotateReverse(e5.m_cosr, e5.m_sinr);
  const d2 = g2.clone();
  d2.subThis(c);
  const _ = e5.m_semiMajorAxis, p3 = 1 / _, f3 = e5.getSemiMinorAxis(), P5 = 1 / f3, y2 = d2.clone();
  y2.leftPerpendicularThis();
  const x4 = Math.atan2(f3 * y2.y, _ * y2.x), C2 = Lt(16, Number.NaN), v3 = Lt(16, Number.NaN);
  let b2 = 0;
  const E2 = [x4, x4 + Math.PI];
  for (let s4 = 0; s4 < 2; ++s4) {
    const t3 = wh(e5, E2[s4]);
    if (t3 >= 0 && t3 <= 1) {
      C2[b2] = t3;
      const s5 = e5.getCoord2D(C2[b2]);
      v3[b2] = n6.getClosestCoordinate(s5, false), ei.distance(s5, n6.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  const S3 = c.x * p3, D3 = c.y * P5, w4 = d2.x * p3, A4 = d2.y * P5;
  let T3 = qs2(w4 * w4 + A4 * A4, 2 * (S3 * w4 + D3 * A4), S3 * S3 + D3 * D3 - 1, x2.unit(), false, v3);
  n2(T3 >= 0);
  for (let s4 = 0; s4 < T3; s4++) {
    const t3 = d2.mul(v3[s4]).add(c);
    t3.x *= p3, t3.y *= P5;
    const i3 = wh(e5, Math.atan2(t3.y, t3.x));
    if (i3 >= 0 && i3 <= 1) {
      C2[b2] = i3;
      const t4 = e5.getCoord2D(i3);
      v3[b2] = n6.getClosestCoordinate(t4, false), ei.distance(t4, n6.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  n2(b2 < C2.length + 4);
  const I5 = Lt(16, Number.NaN);
  T3 = e5.intersectPoint(n6.getStartXY(), I5, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C2[b2] = I5[s4], v3[b2] = 0;
  T3 = e5.intersectPoint(n6.getEndXY(), I5, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C2[b2] = I5[s4], v3[b2] = 1;
  T3 = n6.intersectPoint(e5.getStartXY(), I5, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C2[b2] = 0, v3[b2] = I5[s4];
  T3 = n6.intersectPoint(e5.getEndXY(), I5, a2);
  for (let s4 = 0; s4 < T3; s4++, b2++) C2[b2] = 1, v3[b2] = I5[s4];
  return 0 === b2 ? 0 : Km(t2, e5, n6, C2, v3, b2, i2, r, o2, a2, h2, m2, u);
}
function gm(t2, e5, n6, i2, r, o2, a2, h2, m2, u) {
  if (zh(e5)) {
    const s4 = new su({ start: e5.getStartXY(), end: e5.getEndXY() });
    return cm(t2, n6, s4, i2, o2, r, a2, h2, m2, true);
  }
  if (zh(n6)) {
    const s4 = new su({ start: n6.getStartXY(), end: n6.getEndXY() });
    return cm(t2, e5, s4, i2, r, o2, a2, h2, m2, u);
  }
  const l2 = Oe(e5, n6);
  a2 = Math.max(a2, l2);
  let c = false;
  {
    const t3 = e5.getSemiAxes(), i3 = e5.getCenter(), u2 = n6.getSemiAxes(), l3 = n6.getCenter(), g3 = ei.distance(l3, i3), d3 = t3.x + u2.x;
    if (g3 > d3 + a2) return 0;
    if (t3.y > u2.x) {
      if (g3 + u2.x + a2 < t3.y) return 0;
    } else if (u2.y > t3.x && g3 + t3.x + a2 < u2.y) return 0;
    if (m2 && !h2) {
      const i4 = 1 === e5.m_minorMajorRatio && e5.isClosed() && e5.isMajor(), a3 = 1 === n6.m_minorMajorRatio && n6.isClosed() && n6.isMajor();
      if (i4 && a3 && (c = true, g3 <= d3)) {
        if (Math.max(t3.x, u2.x) <= Math.min(t3.x, u2.x) + g3) return n2(!r && !o2), 1;
      }
    }
  }
  if (!c && Qe(e5, n6, a2)) return 0;
  const g2 = [], d2 = [], _ = false, p3 = false, f3 = oh(e5, 0, 0, _, p3, g2, d2, null), P5 = [], y2 = [], x4 = oh(n6, 0, 0, _, p3, P5, y2, null);
  if (1 === f3 && 1 === x4) {
    const t3 = new on({ points: g2, weights: d2 }), s4 = new on({ points: P5, weights: y2 }), l3 = [], c2 = [], _2 = Gi(false, t3, s4, i2, null === r ? null : l3, null === o2 ? null : c2, a2, h2, m2, u);
    if (_2 > 0 && null !== r || null !== o2) {
      r && (r.length = 0), o2 && (o2.length = 0);
      for (let i3 = 0; i3 < _2; ++i3) {
        if (r) if (Fs(l3[i3], 0, 1)) r.push(l3[i3]);
        else {
          const s5 = t3.tToLength(l3[i3]), n7 = e5.lengthToT(s5);
          r.push(n7);
        }
        if (o2) if (Fs(c2[i3], 0, 1)) o2.push(c2[i3]);
        else {
          const t4 = s4.tToLength(c2[i3]), e6 = n6.lengthToT(t4);
          o2.push(e6);
        }
      }
    }
    return _2;
  }
  let C2 = [];
  const v3 = [];
  let b2 = 0;
  const E2 = m2 && !h2;
  for (let s4 = 0; s4 < f3; s4++) {
    const t3 = new on({ points: g2.slice(2 * s4, 2 * s4 + 3), weights: d2.slice(2 * s4, 2 * s4 + 3) });
    let i3 = 0;
    for (let r2 = 0; r2 < x4; r2++) {
      v3.length <= r2 && v3.push(new on({ points: P5.slice(2 * r2, 2 * r2 + 3), weights: y2.slice(2 * r2, 2 * r2 + 3) }));
      const o3 = [], h3 = [], m3 = E2 ? null : o3, u2 = E2 ? null : h3, l3 = Gi(false, t3, v3[r2], null, m3, u2, a2, false, E2, false);
      if (l3 > 0 && E2) return 1;
      for (let a3 = 0; a3 < l3; ++a3) {
        if (0 === o3[a3] && 0 === s4) o3[a3] = 0;
        else if (1 === o3[a3] && s4 === f3 - 1) o3[a3] = 1;
        else {
          const s5 = t3.tToLength(o3[a3]) + b2, n7 = e5.lengthToT(s5);
          o3[a3] = n7;
        }
        if (0 === h3[a3] && 0 === r2) h3[a3] = 0;
        else if (1 === h3[a3] && r2 === x4 - 1) h3[a3] = 1;
        else {
          const t4 = v3[r2].tToLength(h3[a3]) + i3, e6 = n6.lengthToT(t4);
          h3[a3] = e6;
        }
        C2.push(Qt(o3[a3], h3[a3]));
      }
      i3 += v3[r2].calculateLength2D();
    }
    b2 += t3.calculateLength2D();
  }
  if (0 === C2.length) return 0;
  if (h2 && (C2 = C2.filter((t3) => !Fs(t3.first, 0, 1) || !Fs(t3.second, 0, 1) || !e5.getCoord2D(t3.first).equals(n6.getCoord2D(t3.second)))), m2) return C2.length;
  const S3 = [], D3 = [];
  for (const s4 of C2) S3.push(s4.first), D3.push(s4.second);
  return Km(t2, e5, n6, S3, D3, S3.length, i2, r, o2, a2, h2, m2, u);
}
function dm(t2, e5, s4) {
  if (s4.setCoords(t2.getCoord2D(e5.vmin)), s4.mergeNe(t2.getCoord2D(e5.vmax)), zh(t2)) return;
  const n6 = t2.getSemiAxes(), i2 = [0, 0, 0, 0];
  {
    const e6 = Math.atan2(-n6.y * t2.m_sinr, n6.x * t2.m_cosr), s5 = e6 + Math.PI, r2 = Math.atan2(n6.y * t2.m_cosr, n6.x * t2.m_sinr), o2 = r2 + Math.PI;
    i2[0] = wh(t2, e6), i2[1] = wh(t2, s5), i2[2] = wh(t2, r2), i2[3] = wh(t2, o2);
  }
  const r = new ei();
  for (let o2 = 0; o2 < 4; o2++) {
    const n7 = i2[o2];
    e5.containsExclusiveCoordinate(n7) && (t2.queryCoord2D(n7, r), s4.mergeNe(r));
  }
}
function _m(t2, e5, n6, i2, r) {
  if (0 === t2.m_semiMajorAxis) return n6.vmin;
  let o2 = ei.getNAN();
  t2.queryCoord2D(n6.vmin, o2);
  let a2 = ei.getNAN();
  if (t2.queryCoord2D(n6.vmax, a2), zh(t2)) {
    return new su({ start: o2, end: a2 }).getClosestCoordinate(e5, i2);
  }
  const h2 = xh(t2, e5);
  if (o2 = xh(t2, o2), a2 = xh(t2, a2), 1 === t2.m_minorMajorRatio) {
    if (h2.isEqual(0, 0)) return n6.vmin;
    const e6 = wh(t2, Math.atan2(h2.y, h2.x));
    if (i2 || n6.containsCoordinate(e6)) return e6;
    return ei.distance(h2, o2) <= ei.distance(h2, a2) ? n6.vmin : n6.vmax;
  }
  const m2 = t2.getSemiMajorAxis(), u = t2.getSemiMinorAxis(), l2 = (m2 - u) * (m2 + u), c = $(l2), g2 = h2.x, d2 = h2.y, _ = $(u * d2), p3 = u * l2 * d2 * 2, f3 = [new p2(_), new p2(p3), new p2(c - $(m2 * g2) - _), new p2(-p3), new p2(-c)], P5 = Rt(p2, 4), y2 = Hs2(f3, 4, new x2(-1, 1), false, P5, 4);
  let x4 = n6.vmin, C2 = ei.sqrDistance(h2, o2);
  {
    const t3 = ei.sqrDistance(h2, a2);
    t3 < C2 && (x4 = n6.vmax, C2 = t3);
  }
  n2(!i2);
  let v3 = Lt(8, Number.NaN);
  for (let s4 = 0; s4 < y2; ++s4) {
    const e6 = P5[s4].value(), n7 = Math.sqrt(1 - e6 * e6), i3 = Math.atan2(e6, n7), r2 = Math.atan2(e6, -n7);
    v3[2 * s4] = wh(t2, i3), v3[2 * s4 + 1] = wh(t2, r2);
  }
  v3 = v3.slice(0, 2 * y2), Et(v3);
  for (let s4 = 0, b2 = 2 * y2; s4 < b2; ++s4) if (v3[s4] > n6.vmin && v3[s4] < n6.vmax) {
    const n7 = ei.sqrDistance(e5, t2.getCoord2D(v3[s4]));
    C2 > n7 && (C2 = n7, x4 = v3[s4]);
  }
  return x4;
}
function pm(t2, e5, n6) {
  n2(!zh(t2));
  const i2 = new x3();
  i2.setRotateAngle(-t2.getAxisXRotation());
  const r = new ei();
  i2.queryTransform(e5, r);
  const o2 = Math.atan2(-r.x * t2.getMinorMajorRatio(), r.y), a2 = o2 + Gs();
  let h2 = wh(t2, o2), m2 = wh(t2, a2);
  m2 < h2 && (m2 = Mt(h2, h2 = m2));
  let u = 0;
  return h2 >= 0 && h2 <= 1 && (n6[u++] = h2), m2 >= 0 && m2 <= 1 && (n6[u++] = m2), u;
}
function fm(t2, e5, s4) {
  return t2.m_semiMajorAxis === e5.m_semiMajorAxis && (t2.isMajor() !== e5.isMajor() && (!!t2.m_center.equals(e5.m_center) && (t2.m_sinr === e5.m_sinr && (t2.m_cosr === e5.m_cosr && (t2.m_minorMajorRatio === e5.m_minorMajorRatio && (s4 ? t2.isClockwise() !== e5.isClockwise() : t2.isClockwise() === e5.isClockwise()))))));
}
function Pm(t2, e5, s4) {
  if (zh(t2)) s4.setE(Se.constructPoint2D(t2.getEndXY()).subE(Se.constructPoint2D(t2.getStartXY())));
  else {
    const n6 = new p2();
    Th(t2, e5, n6);
    const i2 = new Se();
    if (i2.setCoordsE(new p2(t2.m_semiMajorAxis).negate().mulE(new p2().setSin(n6)), new p2(t2.getSemiMinorAxis()).mulE(new p2().setCos(n6))), t2.m_rotation) {
      const e6 = new p2(t2.m_rotation);
      i2.rotateDirect(new p2().setCos(e6), new p2().setSin(e6));
    }
    i2.scaleThis(new p2(t2.getSweepAngle())), s4.setE(i2);
  }
}
function ym(t2, e5, s4, n6) {
  const i2 = t2.getStartXY(), r = t2.getEndXY(), o2 = i2.equals(r), a2 = e5.equals(s4);
  if (!o2 && !a2) {
    const n7 = new x3();
    n7.setShiftCoords(-t2.m_XStart, -t2.m_YStart);
    const o3 = ei.distance(e5, s4), a3 = ei.distance(i2, r), h3 = o3 / a3;
    n7.scale(h3, h3);
    const m3 = r.sub(i2);
    m3.divThis(a3);
    const u2 = s4.sub(e5);
    u2.divThis(o3);
    const l3 = m3.crossProduct(u2), c2 = u2.dotProduct(m3);
    return n7.rotate(c2, l3), n7.shiftCoords(e5.x, e5.y), Wh(t2, n7, true), t2.m_XStart = e5.x, t2.m_YStart = e5.y, t2.m_XEnd = s4.x, void (t2.m_YEnd = s4.y);
  }
  const h2 = new ei();
  if (t2.queryCoord2D(0.5, h2), a2) {
    if (o2) {
      const n7 = t2.m_center.add(e5.sub(i2));
      t2.constructEllipticArcEndPointsCenter(e5, s4, t2.getSemiMajorAxis(), 1, 0, true, !t2.isClockwise(), n7), t2.setProjectionBehavior(0);
    } else if (t2.isMajor()) {
      const n7 = h2.sub(e5).getUnitVector().mul(2 * t2.getSemiMajorAxis()).add(e5);
      t2.constructCircularArcThreePoint(e5, s4, n7);
    } else t2.constructCircularArcThreePoint(e5, s4, e5);
    return;
  }
  const m2 = e5.add(s4).mul(0.5), u = s4.sub(e5);
  u.rightPerpendicularThis();
  const l2 = m2.add(u), c = ei.getClosestCoordinate(m2, l2, t2.getCenter(), true), g2 = new ei();
  Y(m2, l2, c, g2);
  const d2 = ei.distance(e5, g2);
  t2.constructEllipticArcEndPointsCenter(e5, s4, d2, 1, 0, true, !t2.isClockwise(), g2), t2.setProjectionBehavior(0);
}
function xm(t2, e5, n6, i2) {
  const r = t2.getStartXY(), o2 = t2.getEndXY(), a2 = r.equals(o2), h2 = e5.equals(n6);
  if (!a2 && !h2) {
    const s4 = new x3();
    return s4.initializeFromTwoPoints(r, o2, e5, n6), Wh(t2, s4, true), t2.m_XStart = e5.x, t2.m_YStart = e5.y, t2.m_XEnd = n6.x, t2.m_YEnd = n6.y, t2.endPointModified(), void t2.normalizeAfterEndpointChange();
  }
  if (!t2.isMajor()) return void Rh(t2, e5, n6, 1);
  if (a2 && h2) {
    const s4 = t2.m_center.add(e5.sub(r));
    return void t2.constructEllipticArcEndPointsCenter(e5, n6, t2.getSemiMajorAxis(), t2.getMinorMajorRatio(), t2.getAxisXRotation(), true, !t2.isClockwise(), s4);
  }
  if (!a2) {
    const s4 = 0.5 * (Qs() - Math.abs(t2.getSweepAngle())), i3 = (t2.getSweepAngle() + s4 * X(t2.getSweepAngle())) / t2.getSweepAngle(), r2 = new ei();
    t2.queryCoord2D(i3, r2), t2.constructEllipticArcEndPointsCenter(r2, r2, t2.getSemiMajorAxis(), t2.getMinorMajorRatio(), t2.getAxisXRotation(), true, !t2.isClockwise(), t2.getCenter());
    const o3 = t2.getCenter().add(e5.sub(r2));
    return void t2.constructEllipticArcEndPointsCenter(e5, n6, t2.getSemiMajorAxis(), t2.getMinorMajorRatio(), t2.getAxisXRotation(), true, !t2.isClockwise(), o3);
  }
  const m2 = ei.sqrDistance(e5, n6);
  let u = 0.25, l2 = 0.75;
  if (m2 < ei.sqrDistance(t2.getCoord2D(0.25), t2.getCoord2D(0.75))) {
    const e6 = [0], n7 = Xs2(new Ph(t2, m2), x2.construct(0, 0.25), 1, e6);
    n7 > 0 && (n2(1 === n7), u = e6[0], l2 = 1 - e6[0]);
  }
  const c = t2.getCoord2D(u), g2 = t2.getCoord2D(l2);
  n2(!c.equals(g2)), t2.constructEllipticArcEndPointsCenter(c, g2, t2.getSemiMajorAxis(), t2.getMinorMajorRatio(), t2.getAxisXRotation(), true, !t2.isClockwise(), t2.m_center), xm(t2, e5, n6);
}
function Cm(t2, s4) {
  let n6, r = s4, o2 = null;
  switch (r || (o2 = g(t2) ? O2() : M(), r = o2), t2) {
    case a.enumPoint:
      n6 = new ee({ vd: r });
      break;
    case a.enumLine:
      n6 = new su({ vd: r });
      break;
    case a.enumBezier:
      n6 = new mo({ vd: r });
      break;
    case a.enumEllipticArc:
      n6 = new Oa({ vd: r });
      break;
    case a.enumRationalBezier2:
      n6 = new on({ vd: r });
      break;
    case a.enumBezier2:
      n6 = new nn({ vd: r });
      break;
    case a.enumEnvelope:
      n6 = new re({ vd: r });
      break;
    case a.enumMultiPoint:
      n6 = new Ce({ vd: r });
      break;
    case a.enumPolyline:
      n6 = new Na({ vd: r });
      break;
    case a.enumPolygon:
      n6 = new eh({ vd: r });
      break;
    case a.enumMultipatch:
      z("multipatch not impl");
      break;
    case a.enumGeometryCollection:
      n6 = new es({ vd: r });
      break;
    default:
      P("Geometry.create");
  }
  return n6;
}
var vm = B3;
var bm = -1;
var Em = 1;
var Sm = class {
  constructor(t2) {
    this.m_shape = t2;
  }
  userSort(t2, e5, s4) {
    this.m_shape.sortVerticesSimpleByYHelper(s4, t2, e5);
  }
  getValue(t2) {
    return this.m_shape.getY(t2);
  }
};
function Dm(t2) {
  return void 0 !== t2.parent;
}
var wm = class _wm {
  constructor(t2) {
    Dm(t2) ? (this.m_parent = t2.parent, this.m_geometry = t2.geometry, this.m_path = t2.path, this.m_vertex = t2.vertex, this.m_firstVertex = t2.firstVertex, this.m_index = t2.selection ? 0 : t2.index, this.m_bSkipMultiPoints = t2.bSkipMultiPoints, this.m_selection = t2.selection, this.m_bOneGeom = t2.bOneGeom, this.m_bFirst = true) : (this.m_parent = t2.copy.m_parent, this.m_geometry = t2.copy.m_geometry, this.m_path = t2.copy.m_path, this.m_vertex = t2.copy.m_vertex, this.m_index = t2.copy.m_index, this.m_bSkipMultiPoints = t2.copy.m_bSkipMultiPoints, this.m_firstVertex = t2.copy.m_firstVertex, this.m_bFirst = true, this.m_selection = t2.copy.m_selection, this.m_bOneGeom = t2.copy.m_bOneGeom);
  }
  moveToNextHelper() {
    for (this.m_path = this.m_parent.getNextPath(this.m_path), this.m_index = 0; this.m_geometry !== bm; ) {
      for (; this.m_path !== bm; this.m_path = this.m_parent.getNextPath(this.m_path)) if (this.m_vertex = this.m_parent.getFirstVertex(this.m_path), this.m_firstVertex = this.m_vertex, this.m_vertex !== bm) return this.m_vertex;
      if (this.m_bOneGeom) return bm;
      if (this.m_geometry = this.m_parent.getNextGeometry(this.m_geometry), this.m_geometry === bm) break;
      this.m_bSkipMultiPoints && !h(this.m_parent.getGeometryType(this.m_geometry)) || (this.m_path = this.m_parent.getFirstPath(this.m_geometry));
    }
    return bm;
  }
  nextSelection() {
    for (; this.m_index < this.m_parent.m_selectedVertices.length; ) {
      const t2 = this.m_parent.m_selectedVertices[this.m_index++];
      if (t2 !== bm && (this.m_path = this.m_parent.getPathFromVertex(t2), !this.m_bOneGeom || this.m_geometry === this.m_parent.getGeometryFromPath(this.m_path))) return this.m_geometry = this.m_parent.getGeometryFromPath(this.m_path), t2;
    }
    return bm;
  }
  next() {
    return this.m_selection ? this.nextSelection() : this.m_bFirst ? (this.m_bFirst = false, this.m_vertex) : this.m_vertex !== bm ? (this.m_vertex = this.m_parent.getNextVertex(this.m_vertex), this.m_index++, this.m_vertex !== bm && this.m_vertex !== this.m_firstVertex ? this.m_vertex : this.moveToNextHelper()) : bm;
  }
  currentGeometry() {
    return this.m_geometry;
  }
  currentPath() {
    return this.m_path;
  }
  static create_(t2, e5, s4, n6, i2, r, o2, a2, h2) {
    return new _wm({ parent: t2, geometry: e5, path: s4, vertex: n6, firstVertex: i2, index: r, bSkipMultiPoints: o2, selection: a2, bOneGeom: h2 });
  }
};
var Am = class {
  constructor(t2) {
    this.parentage = t2;
  }
  equals(t2) {
    return this.parentage === t2.parentage;
  }
};
var Tm = class _Tm {
  setPrevPath(t2, e5) {
    this.m_pathIndexList.setField(t2, 1, e5);
  }
  setNextPath(t2, e5) {
    this.m_pathIndexList.setField(t2, 2, e5);
  }
  setPathFlags(t2, e5) {
    this.m_pathIndexList.setField(t2, 6, e5);
  }
  getPathFlags(t2) {
    return this.m_pathIndexList.getField(t2, 6);
  }
  setPathGeometry(t2, e5) {
    this.m_pathIndexList.setField(t2, 7, e5);
  }
  getPathIndex(t2) {
    return this.m_pathIndexList.getField(t2, 0);
  }
  setNextGeometry(t2, e5) {
    this.m_geometryIndexList.setField(t2, 1, e5);
  }
  setPrevGeometry(t2, e5) {
    this.m_geometryIndexList.setField(t2, 0, e5);
  }
  getGeometryIndex(t2) {
    return this.m_geometryIndexList.getField(t2, 7);
  }
  setFirstPath(t2, e5) {
    this.m_geometryIndexList.setField(t2, 3, e5);
  }
  setLastPath(t2, e5) {
    this.m_geometryIndexList.setField(t2, 4, e5);
  }
  newGeometry(t2) {
    const e5 = this.m_geometryIndexList.newElement();
    return this.m_geometryIndexList.setField(e5, 2, t2), this.m_geometryIndexList.setField(e5, 5, 0), this.m_geometryIndexList.setField(e5, 6, 0), this.m_geometryIndexList.setField(e5, 7, this.m_geometryIndexList.elementToIndex(e5)), e5;
  }
  freeGeometry(t2) {
    this.m_geometryIndexList.deleteElement(t2);
  }
  newPath(t2) {
    const e5 = this.m_pathIndexList.newElement(), s4 = this.m_pathIndexList.elementToIndex(e5);
    if (this.m_pathIndexList.setField(e5, 0, s4), this.m_pathIndexList.setField(e5, 3, 0), this.m_pathIndexList.setField(e5, 6, 0), this.setPathGeometry(e5, t2), s4 >= this.m_pathAreas.length) {
      const t3 = Math.trunc(s4 < 16 ? 16 : 3 * s4 / 2);
      this.m_pathAreas.length = t3, this.m_pathLengths.length = t3;
    }
    return this.m_pathAreas[s4] = 0, this.m_pathLengths[s4] = 0, this.m_pathCount++, e5;
  }
  freePath(t2) {
    this.m_pathIndexList.deleteElement(t2), this.m_pathCount--;
  }
  newVertex(t2) {
    const e5 = this.m_vertexIndexList.newElement(), s4 = t2 >= 0 ? t2 : this.m_vertexIndexList.elementToIndex(e5);
    if (this.m_vertexIndexList.setField(e5, 0, s4), t2 < 0) {
      if (s4 >= this.m_vertices.getPointCount()) {
        const t3 = Math.trunc(s4 < 16 ? 16 : 3 * s4 / 2);
        this.m_vertices.reserveRounded(t3), this.m_vertices.resizeNoInit(t3), null !== this.m_segments && (this.m_segments.length = t3), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
      }
      this.m_segments && (this.m_segments[s4] = null);
    }
    return this.m_pointCount++, e5;
  }
  freeVertex(t2) {
    this.unselect(t2);
    const e5 = this.getVertexIndex(t2);
    this.m_vertexIndexList.deleteElement(t2), this.m_pointCount--;
    for (let s4 = 0, n6 = this.m_indices.length; s4 < n6; s4++) {
      if (s4 === this.m_selectionIndex) continue;
      const t3 = this.m_indices[s4];
      null !== t3 && t3.size() > e5 && t3.write(e5, -1);
    }
    this.m_weights && this.m_weights.size() > e5 && this.m_weights.write(e5, 1), this.m_ranks && this.m_ranks.size() > e5 && this.m_ranks.write(e5, Em), this.m_segmentWeights && this.m_segmentWeights.size() > e5 && this.m_segmentWeights.write(e5, 1), this.m_segmentRanks && this.m_segmentRanks.size() > e5 && this.m_segmentRanks.write(e5, Em), this.m_segments && this.setSegmentToIndex(e5, null);
  }
  insertVertex_(t2, e5, s4, n6) {
    this.m_hasForceSetEnvelope = 0;
    const i2 = e5 !== bm ? this.getPrevVertex(e5) : this.getLastVertex(t2), r = i2 !== bm ? this.getNextVertex(i2) : bm, o2 = this.newVertex(null === s4 ? this.m_pointCount : -1), a2 = this.getVertexIndex(o2);
    null !== s4 && this.m_vertices.setPointByVal(a2, s4), this.setPathToVertex(o2, t2), this.setNextVertex(o2, r), this.setPrevVertex(o2, i2), r !== bm && this.setPrevVertex(r, o2), i2 !== bm && this.setNextVertex(i2, o2);
    const h2 = this.isClosedPath(t2), m2 = this.getFirstVertex(t2);
    e5 === bm && this.setLastVertex(t2, o2), e5 === m2 && (h2 && n6 && m2 !== bm || this.setFirstVertex(t2, o2)), h2 && r === bm && (this.setNextVertex(o2, o2), this.setPrevVertex(o2, o2)), this.setPathSize(t2, this.getPathSize(t2) + 1);
    const u = this.getGeometryFromPath(t2);
    return this.setGeometryVertexCount(u, this.getPointCount(u) + 1), o2;
  }
  getHelperPoint() {
    return this.m_helperPoint || (this.m_helperPoint = new ee({ vd: this.m_vertices.getDescription() }), this.m_helperPoint.setXYCoords(0, 0)), this.m_helperPoint;
  }
  addMultiPoint(t2, e5) {
    const s4 = this.createGeometry(t2.getGeometryType(), t2.getDescription());
    return this.appendMultiPoint(s4, t2, e5), s4;
  }
  addPoint_(t2, e5) {
    const s4 = this.createGeometry(a.enumMultiPoint, t2.getDescription());
    return this.appendPoint(s4, t2, e5), s4;
  }
  appendMultiPath_(t2, e5) {
    if (e5.isEmpty()) return;
    const s4 = e5.getImpl();
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + s4.getPointCount()), this.m_verticesMp.addPoints(e5, 0, s4.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const n6 = null !== this.m_segments || null !== s4.getSegmentFlagsStreamRef();
    this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + s4.getPointCount()), this.m_pathIndexList.setCapacity(this.m_pathIndexList.size() + s4.getPathCount());
    for (let i2 = 0, r = s4.getPathCount(); i2 < r; i2++) {
      if (0 === s4.getPathSize(i2)) continue;
      const e6 = this.insertPath(t2, bm);
      this.setClosedPath(e6, s4.isClosedPath(i2));
      for (let t3 = s4.getPathStart(i2), r2 = s4.getPathEnd(i2); t3 < r2; t3++) {
        const i3 = this.insertVertex_(e6, bm, null, false);
        if (n6) {
          const e7 = this.getVertexIndex(i3);
          if (1 & s4.getSegmentFlags(t3)) this.setSegmentToIndex(e7, null);
          else {
            const n7 = new nu();
            s4.querySegment(t3, n7, true), this.setSegmentToIndex(e7, n7.releaseSegment());
          }
        }
      }
      s4.isStrongPathStart(i2) && this.setStrongPathStart(e6, true), s4.isStrongPathEnd(i2) && this.setStrongPathEnd(e6, true);
    }
  }
  addMultiPath(t2, e5) {
    const s4 = this.createGeometry(t2.getGeometryType(), t2.getDescription());
    return t2.getGeometryType() === a.enumPolygon && this.setFillRule(s4, t2.getFillRule()), this.appendMultiPath(s4, t2, e5), s4;
  }
  appendMultiPathPolyline(t2, e5, s4) {
    var _a3;
    const n6 = e5.getImpl(), i2 = null !== this.m_segments || null !== n6.getSegmentFlagsStreamRef(), r = new n4();
    e5.queryEnvelope(r);
    {
      const r2 = s4.clone();
      let o2 = n6.getPointCount();
      const a2 = n6.getAccelerators();
      if (a2 && a2.getQuadTree()) {
        o2 = a2.getQuadTree().getIntersectionCount(r2, 0, n6.getPointCount() + 1);
      }
      if (o2 < e5.getPointCount()) {
        if (0 === o2) return;
        const s5 = n6.queryLimitedSegmentIterator(r2);
        let a3 = -1, h2 = -100, m2 = -1, u = 0, l2 = -1, c = bm, g2 = false, d2 = s5.nextSegment();
        if (null !== d2) for (; ; d2 = s5.nextSegment()) {
          let r3 = null === d2;
          const o3 = null !== d2 ? s5.getPathIndex() : a3, _ = null !== d2 ? s5.getStartPointIndex() : h2;
          if (r3 || (a3 === o3 && h2 + 1 === _ ? u++ : r3 = true), r3) {
            if (-1 !== l2) {
              let t3 = -1, s6 = -1;
              if (u === m2) {
                this.setClosedPath(c, g2);
                const i3 = n6.getPathEnd(a3);
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i3 - l2), this.m_verticesMp.addPoints(e5, l2, i3), s6 = n6.getPathSize(a3), t3 = i3 - 1;
              } else if (!g2 || h2 + 1 < n6.getPathEnd(a3)) this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), this.m_verticesMp.addPoints(e5, l2, h2 + 2), s6 = h2 - l2 + 2, t3 = h2;
              else {
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), (_a3 = this.m_verticesMp) == null ? void 0 : _a3.addPoints(e5, l2, h2 + 1), t3 = h2, s6 = h2 - l2 + 1;
                const i3 = n6.getPathStart(a3);
                this.m_verticesMp.addPoints(e5, i3, i3 + 1), s6 += 1;
              }
              this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
              for (let e6 = 0, r4 = l2; e6 < s6; e6++, r4++) {
                const e7 = this.insertVertex_(c, bm, null, false);
                if (i2) {
                  const s7 = this.getVertexIndex(e7);
                  if (1 & n6.getSegmentFlags(r4) || r4 > t3) this.setSegmentToIndex(s7, null);
                  else {
                    const t4 = new nu();
                    n6.getSegmentBuffer(r4, t4, true), this.setSegmentToIndex(s7, t4.releaseSegment());
                  }
                }
              }
            }
            if (null === d2) break;
            u = 1, l2 = _, a3 !== o3 ? (c = this.insertPath(t2, bm), this.setClosedPath(c, false), m2 = n6.getSegmentCountPath(o3), g2 = n6.isClosedPath(o3), a3 = o3) : c = this.insertPath(t2, bm);
          }
          h2 = _;
        }
        return;
      }
    }
    this.appendMultiPath_(t2, e5);
  }
  appendMultiPathPolygon(t2, e5, n6) {
    var _a3;
    const i2 = e5.getImpl(), r = null !== this.m_segments || null !== i2.getSegmentFlagsStreamRef(), o2 = n4.constructEmpty();
    e5.queryEnvelope(o2), n2(n6.isIntersecting(o2) && !n6.containsEnvelope(o2));
    let a2 = n4.construct(Number.NEGATIVE_INFINITY, n6.ymin, Number.POSITIVE_INFINITY, n6.ymax), h2 = n4.construct(n6.xmin, Number.NEGATIVE_INFINITY, n6.xmax, Number.POSITIVE_INFINITY);
    const m2 = i2.getAccelerators();
    if (m2 && m2.getQuadTree()) {
      const t3 = m2.getQuadTree(), e6 = t3.getIntersectionCount(a2, 0, 0);
      e6 > t3.getIntersectionCount(h2, 0, e6 + 1) && (h2 = Mt(a2, a2 = h2));
    } else a2.height() > h2.width() && (h2 = Mt(a2, a2 = h2));
    const u = [], l2 = i2.queryLimitedSegmentIterator(a2);
    let c = -1, g2 = -100, d2 = -1, _ = 0, p3 = -1, f3 = -1, P5 = bm, y2 = true, x4 = l2.nextSegment();
    if (null !== x4) for (; ; x4 = l2.nextSegment()) {
      let n7 = null === x4;
      const o3 = null !== x4 ? l2.getPathIndex() : c, a3 = null !== x4 ? l2.getStartPointIndex() : g2;
      if (n7 || (o3 === c ? g2 + 1 === a3 ? _++ : n7 = true : (n7 = c >= 0, c < 0 && (c = o3, d2 = i2.getSegmentCountPath(c), p3 = a3, P5 = bm, _ = 1))), n7) {
        if (!(0 === u.length && d2 === _)) {
          0 !== u.length && u[0].first === p3 || (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e5, p3, p3 + 1), -1 === f3 && (f3 = p3), P5 === bm && (P5 = this.insertPath(t2, bm), this.setClosedPath(P5, true)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.insertVertex_(P5, bm, null, false));
          for (const { first: n8, second: o4 } of u) {
            -1 === f3 && (f3 = n8);
            let a4 = -1, h3 = -1;
            const m3 = n8 + o4 - 1;
            if (o4 === d2) {
              const t3 = m3 + 1;
              h3 = t3 - n8, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e5, n8, t3), a4 = m3, n2(1 === u.length);
            } else if (m3 + 1 < i2.getPathEnd(c)) {
              const t3 = m3 + 2;
              h3 = t3 - n8, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e5, n8, t3), a4 = m3;
            } else {
              const t3 = i2.getPathStart(c), s4 = t3 !== f3 ? 1 : 0, r2 = m3 + 1;
              h3 = r2 - n8 + s4, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + (r2 - n8) + s4), this.m_verticesMp.addPoints(e5, n8, r2), a4 = m3, s4 > 0 && ((_a3 = this.m_verticesMp) == null ? void 0 : _a3.addPoints(e5, t3, t3 + 1));
            }
            this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), P5 === bm && (P5 = this.insertPath(t2, bm), this.setClosedPath(P5, true));
            for (let t3 = 0, e6 = n8; t3 < h3; t3++, e6++) {
              const t4 = this.insertVertex_(P5, bm, null, false);
              if (r) {
                const s4 = this.getVertexIndex(t4);
                if (1 & i2.getSegmentFlags(e6) || e6 > a4) this.setSegmentToIndex(s4, null);
                else {
                  const t5 = new nu();
                  i2.getSegmentBuffer(e6, t5, true), this.setSegmentToIndex(s4, t5.releaseSegment());
                }
              }
            }
          }
          if (0 === u.length || u.at(-1).first + u.at(-1).second !== p3 + _) {
            let t3 = p3 + _;
            t3 === e5.getPathEnd(c) && (t3 = e5.getPathStart(c)), f3 !== t3 && (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e5, t3, t3 + 1), this.insertVertex_(P5, bm, null, false));
          }
        }
        u.length = 0, y2 = true, o3 !== c && (c = o3, d2 = i2.getSegmentCountPath(c), P5 = bm, f3 = -1), p3 = a3, _ = 1;
      }
      if (!x4) break;
      {
        const t3 = n4.constructEmpty();
        x4.queryLooseEnvelope(t3), h2.isIntersecting(t3) ? (y2 ? u.push(Qt(a3, 1)) : u.at(-1).second++, y2 = false) : y2 = true;
      }
      g2 = a3;
    }
  }
  appendMultiPath(t2, e5, s4) {
    if (void 0 === s4) return void this.appendMultiPath_(t2, e5);
    if (e5.isEmpty()) return;
    const n6 = e5.getGeometryType() === a.enumPolygon, r = n4.constructEmpty();
    e5.queryEnvelope(r), s4.isIntersecting(r) && (!s4.containsEnvelope(r) && e5.getPointCount() > 10 ? n6 ? this.appendMultiPathPolygon(t2, e5, s4) : this.appendMultiPathPolyline(t2, e5, s4) : this.appendMultiPath_(t2, e5));
  }
  appendPoint(t2, e5, s4) {
    if (e5.isEmpty()) return;
    if (void 0 !== s4 && !s4.contains(e5.getXY())) return;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.add(e5), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + 1);
    const n6 = this.insertPath(t2, bm);
    this.insertVertex_(n6, bm, null, false);
  }
  appendMultiPoint_(t2, e5) {
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + e5.getPointCount()), this.m_verticesMp.addPoints(e5, 0, e5.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + e5.getPointCount());
    const s4 = this.insertPath(t2, bm);
    for (let n6 = 0, i2 = e5.getPointCount(); n6 < i2; n6++) this.insertVertex_(s4, bm, null, false);
  }
  appendMultiPoint(t2, e5, s4) {
    if (void 0 === s4) return void this.appendMultiPoint_(t2, e5);
    const n6 = e5.getAttributeStreamRef(0);
    let i2 = 0;
    for (let m2 = 0, u = e5.getPointCount(); m2 < u; m2++) {
      const t3 = n6.readPoint2D(2 * m2);
      s4.contains(t3) && i2++;
    }
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i2);
    let r = -1, o2 = -1, a2 = 0;
    for (let m2 = 0, u = e5.getPointCount(); m2 < u; m2++) {
      const t3 = n6.readPoint2D(2 * m2);
      s4.contains(t3) ? (-1 === r && (r = m2, o2 = m2), o2++) : r >= 0 && (this.m_verticesMp.addPoints(e5, r, o2 - r), r = -1, a2++);
    }
    if (r > 0 && (this.m_verticesMp.addPoints(e5, r, o2 - r), a2++), !a2) return;
    this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + i2);
    const h2 = this.insertPath(t2, bm);
    for (let m2 = 0, u = e5.getPointCount(); m2 < u; m2++) {
      const t3 = n6.readPoint2D(2 * m2);
      s4.contains(t3) && this.insertVertex_(h2, bm, null, false);
    }
  }
  splitSegmentForward(t2, s4, n6, r, o2) {
    const a2 = this.getNextVertex(t2);
    a2 === bm && P("Edit_shape.split_segment_forward_");
    const h2 = this.getHelperPoint(), m2 = this.getPathFromVertex(t2);
    let u = t2;
    const l2 = this.hasSegmentParentage();
    for (let e5 = 0, c = s4.getResultSegmentCount(n6); e5 < c; e5++) {
      const t3 = this.getVertexIndex(u), r2 = this.getNextVertex(u), g2 = s4.getResultSegment(n6, e5);
      let d2 = null;
      if (g2.getGeometryType() !== a.enumLine && (d2 = g2.clone(), d2.dropAllAttributes()), 0 === e5 && (g2.queryStart(h2), this.setSegmentToIndex(t3, null), this.setPointEx(u, h2, s4.getResultSegmentStartPointRank(n6, e5), s4.getResultSegmentStartPointWeight(n6, e5), o2)), this.setSegmentRank(u, s4.getResultSegmentInteriorRank(n6, e5)), this.setSegmentWeight(u, s4.getResultSegmentInteriorWeight(n6, e5)), l2) {
        const t4 = s4.getResultSegmentSegmentParentage(n6, e5), i2 = s4.getResultSegmentStartPointIsBreak(n6, e5);
        this.setSegmentParentageAndBreak(u, t4, i2);
      }
      if (g2.queryEnd(h2), e5 < c - 1) {
        this.setSegmentToIndex(t3, d2);
        const i2 = this.insertVertex(m2, r2, h2);
        this.setWeight(i2, s4.getResultSegmentEndPointWeight(n6, e5)), this.setRank(i2, s4.getResultSegmentEndPointRank(n6, e5)), this.select(i2), u = i2;
      } else {
        this.setPointEx(a2, h2, s4.getResultSegmentEndPointRank(n6, e5), s4.getResultSegmentEndPointWeight(n6, e5), o2);
        const i2 = s4.getResultSegmentEndPointIsBreak(n6, e5);
        this.setSegmentParentageBreakVertex(a2, i2), this.setSegmentToIndex(t3, d2);
      }
    }
  }
  splitSegmentBackward(t2, s4, n6, r, o2) {
    const a2 = this.getNextVertex(t2);
    a2 === bm && P("Edit_shape.split_segment_backward_");
    const h2 = this.getHelperPoint(), m2 = this.getPathFromVertex(t2);
    let u = t2;
    const l2 = this.hasSegmentParentage();
    for (let e5 = 0, c = s4.getResultSegmentCount(n6); e5 < c; e5++) {
      const t3 = c - e5 - 1, r2 = this.getVertexIndex(u), g2 = this.getNextVertex(u), d2 = s4.getResultSegment(n6, t3);
      let _ = null;
      if (d2.getGeometryType() !== a.enumLine && (_ = d2.clone(), _.reverse(), _.dropAllAttributes()), 0 === e5 && (d2.queryEnd(h2), this.setSegmentToIndex(r2, null), this.setPointEx(u, h2, s4.getResultSegmentEndPointRank(n6, t3), s4.getResultSegmentEndPointWeight(n6, t3), o2), this.setSegmentParentageAndBreak(u, s4.getResultSegmentSegmentParentage(n6, t3), s4.getResultSegmentEndPointIsBreak(n6, t3))), d2.getGeometryType() === a.enumLine ? this.setSegmentToIndex(r2, null) : this.setSegmentToIndex(r2, _), this.setSegmentRank(u, s4.getResultSegmentInteriorRank(n6, t3)), this.setSegmentWeight(u, s4.getResultSegmentInteriorWeight(n6, t3)), d2.queryStart(h2), e5 < c - 1) {
        const e6 = this.insertVertex(m2, g2, h2);
        this.setWeight(e6, s4.getResultSegmentStartPointWeight(n6, t3)), this.setRank(e6, s4.getResultSegmentStartPointRank(n6, t3)), this.select(e6), u = e6, l2 && this.setSegmentParentageAndBreak(e6, s4.getResultSegmentSegmentParentage(n6, t3), s4.getResultSegmentEndPointIsBreak(n6, t3));
      } else this.setPointEx(a2, h2, s4.getResultSegmentStartPointRank(n6, t3), s4.getResultSegmentStartPointWeight(n6, t3), o2);
    }
  }
  selected_(t2) {
    return this.getUserIndex(t2, this.m_selectionIndex) >= 0;
  }
  allocateIndex(t2 = true) {
    if (this.m_deletedIndices.length) {
      const e5 = this.m_deletedIndices.pop();
      return t2 && e5.setRange(-1, 0, e5.size()), e5;
    }
    return t2 ? J(0, -1) : J(0);
  }
  recycleUserIndex(t2) {
    this.m_deletedIndices.push(t2);
  }
  allocatePathIndex() {
    if (this.m_deletedPathIndices.length) {
      const t2 = this.m_deletedPathIndices.at(-1);
      return this.m_deletedPathIndices.pop(), t2;
    }
    return J(0);
  }
  recyclePathUserIndex(t2) {
    this.m_deletedPathIndices.push(t2);
  }
  peelALoop_(t2, e5, s4) {
    const n6 = this.getNextVertex(t2), i2 = this.getNextVertex(e5), r = this.getVertexIndex(t2), o2 = this.getVertexIndex(e5);
    if (this.setNextVertex(t2, i2), this.setPrevVertex(i2, t2), this.setNextVertex(e5, n6), this.setPrevVertex(n6, e5), this.m_segments) {
      const t3 = this.getSegmentFromIndex(r), e6 = this.getSegmentFromIndex(o2);
      this.setSegmentToIndex(o2, null), this.setSegmentToIndex(r, e6), this.setSegmentToIndex(o2, t3);
    }
    if (this.hasSegmentParentage()) {
      let s5 = this.getSegmentParentage(e5), n7 = this.getSegmentParentage(t2);
      -1 === s5 && -1 === n7 || (n7 = Mt(s5, s5 = n7), this.setSegmentParentageAndBreak(t2, n7), this.setSegmentParentageAndBreak(e5, s5));
    }
    if (s4) {
      const e6 = this.getPathFromVertex(t2), s5 = this.getGeometryFromPath(e6), r2 = [false], o3 = this.insertClosedPath(s5, bm, n6, this.getFirstVertex(e6), r2);
      r2[0] && this.setFirstVertex(e6, i2);
      let a2 = this.getPathSize(e6);
      return a2 -= this.getPathSize(o3), this.setPathSize(e6, a2), o3;
    }
    return bm;
  }
  sortVerticesSimpleByYHelper(t2, e5, s4) {
    t2.sort(e5, s4, (t3, e6) => {
      let s5 = this.compareVerticesSimpleY(t3, e6);
      if (0 === s5) {
        const n6 = this.getPathInternalIndexFromVertex(t3), i2 = this.getPathInternalIndexFromVertex(e6);
        s5 = n6 < i2 ? -1 : n6 > i2 ? 1 : 0;
      }
      return s5;
    });
  }
  sortVerticesSimpleByYHelper3D(t2, e5, n6) {
    n2(0);
  }
  constructor() {
    this.m_verticesMp = null, this.m_vertices = null, this.m_xyStream = null, this.m_vertexDescription = null, this.m_segments = null, this.m_weights = null, this.m_ranks = null, this.m_segmentWeights = null, this.m_segmentRanks = null, this.m_indices = [], this.m_deletedIndices = [], this.m_pathAreas = [], this.m_pathLengths = [], this.m_pathindices = [], this.m_deletedPathIndices = [], this.m_geometryIndices = [], this.m_selectedVertices = [], this.m_helperPoint = null, this.m_forceSetEnvelope = U3.constructEmpty(), this.m_hasForceSetEnvelope = 0, this.m_workPoint2D = ei.getNAN(), this.m_workPoint2_2D = ei.getNAN(), this.m_curveStitcher = null, this.m_pathCount = 0, this.m_pointCount = 0, this.m_firstGeometry = bm, this.m_lastGeometry = bm, this.m_vertexIndexList = new at(5), this.m_pathIndexList = new at(8), this.m_geometryIndexList = new at(8), this.m_bHasAttributes = false, this.m_selectedCount = 0, this.m_selectionIndex = -1, this.m_selection = false, this.m_bucketSort = new ht(), this.m_segmentParentageIndex = -1;
  }
  getTotalPointCount() {
    return this.m_pointCount;
  }
  getEnvelope2D(t2) {
    if (0 !== this.m_hasForceSetEnvelope) return new n4(this.m_forceSetEnvelope.xmin, this.m_forceSetEnvelope.ymin, this.m_forceSetEnvelope.xmax, this.m_forceSetEnvelope.ymax);
    const e5 = this.hasCurves(), s4 = n4.constructEmpty(), n6 = this.queryVertexIterator();
    let i2 = true;
    for (let r = n6.next(); r !== bm; r = n6.next()) {
      if (i2 ? s4.merge(this.getXY(r)) : s4.mergeNe(this.getXY(r)), e5) {
        const t3 = this.getSegment(r);
        if (null !== t3) {
          const e6 = n4.constructEmpty();
          t3.queryLooseEnvelope(e6), s4.mergeEnvelope2D(e6);
        }
      }
      i2 = false;
    }
    return s4;
  }
  getEnvelope3D(t2) {
    return n2(0), U3.constructEmpty();
  }
  forceSetEnvelope2D(t2) {
    this.m_hasForceSetEnvelope = 1, this.m_forceSetEnvelope.setCoords(t2.xmin, t2.ymin, 0, t2.xmax, t2.ymax, 0);
  }
  forceSetEnvelope3D(t2) {
    n2(0);
  }
  forgetForceSetEnvelope() {
    this.m_hasForceSetEnvelope = 0;
  }
  getGeometryCount() {
    return this.m_geometryIndexList.size();
  }
  addGeometry(t2, s4) {
    const n6 = t2.getGeometryType();
    if (h(n6)) return this.addMultiPath(t2, s4);
    if (n6 === a.enumMultiPoint) return this.addMultiPoint(t2, s4);
    if (n6 === a.enumPoint) return this.addPoint_(t2, s4);
    if (n6 === a.enumEnvelope) {
      const e5 = new eh();
      return e5.addEnvelope(t2, false), this.addMultiPath(e5, s4);
    }
    P("");
  }
  appendGeometry(t2, s4) {
    this.mergeVertexDescription(s4.getDescription());
    const n6 = s4.getGeometryType();
    h(n6) ? this.appendMultiPath(t2, s4) : n6 !== a.enumMultiPoint ? P("") : this.appendMultiPoint(t2, s4);
  }
  assignRankToGeometryVertices(t2, e5) {
    e5 < Em && (e5 = Em);
    const s4 = this.queryVertexIterator();
    for (let n6 = s4.next(); n6 !== bm; n6 = s4.next()) this.setRank(n6, e5), this.setSegmentRank(n6, e5);
  }
  collapseAllGeometriesToFirst() {
    this.collapseGeometriesToFirst(a.enumUnknown);
  }
  collapseGeometriesToFirst(t2) {
    this.dbgVerifyVertexCounts();
    let e5 = bm, s4 = -1, n6 = -1;
    for (let r = this.getFirstGeometry(); r !== bm; ) if (t2 !== a.enumUnknown && this.getGeometryType(r) !== t2) r = this.getNextGeometry(r);
    else {
      if (e5 === bm) {
        e5 = r, s4 = this.getPathCount(e5), n6 = this.getPointCount(e5), r = this.getNextGeometry(r);
        continue;
      }
      for (let s5 = this.getFirstPath(r); s5 !== bm; s5 = this.getNextPath(s5)) this.setPathGeometry(s5, e5);
      s4 += this.getPathCount(r), n6 += this.getPointCount(r);
      const t3 = this.getLastPath(e5), i2 = this.getFirstPath(r);
      t3 !== bm ? this.setNextPath(t3, i2) : this.setFirstPath(e5, i2), i2 !== bm && (this.setPrevPath(i2, t3), this.setLastPath(e5, this.getLastPath(r))), this.setFirstPath(r, bm), this.setLastPath(r, bm);
      const o2 = r;
      r = this.getNextGeometry(r), this.setGeometryVertexCount(o2, 0), this.removeGeometry(o2);
    }
    return e5 !== bm && (this.setGeometryVertexCount(e5, n6), this.setGeometryPathCount(e5, s4), this.dbgVerifyVertexCounts()), e5;
  }
  setFillRule(t2, e5) {
    let s4 = this.m_geometryIndexList.getField(t2, 2);
    s4 &= -134217729, s4 |= 1 === e5 ? 134217728 : 0, this.m_geometryIndexList.setField(t2, 2, s4);
  }
  getFillRule(t2) {
    return 134217728 & this.m_geometryIndexList.getField(t2, 2) ? 1 : 0;
  }
  setGeometryModified(t2, e5) {
    let s4 = this.m_geometryIndexList.getField(t2, 2);
    !!(67108864 & s4) !== e5 && (s4 &= -67108865, s4 |= e5 ? 67108864 : 0, this.m_geometryIndexList.setField(t2, 2, s4));
  }
  getGeometryModified(t2) {
    return !!(67108864 & this.m_geometryIndexList.getField(t2, 2));
  }
  setGeometryModifiedWithVertex(t2, e5) {
    const s4 = this.getPathFromVertex(t2), n6 = this.getGeometryFromPath(s4);
    this.setGeometryModified(n6, e5);
  }
  getGeometryModifiedWithVertex(t2) {
    const e5 = this.getPathFromVertex(t2), s4 = this.getGeometryFromPath(e5);
    return this.getGeometryModified(s4);
  }
  swapGeometry(t2, e5) {
    const s4 = this.getFirstPath(t2), n6 = this.getFirstPath(e5), i2 = this.getLastPath(t2), r = this.getLastPath(e5);
    for (let c = this.getFirstPath(t2); c !== bm; c = this.getNextPath(c)) this.setPathGeometry(c, e5);
    for (let c = this.getFirstPath(e5); c !== bm; c = this.getNextPath(c)) this.setPathGeometry(c, t2);
    this.setFirstPath(t2, n6), this.setFirstPath(e5, s4), this.setLastPath(t2, r), this.setLastPath(e5, i2);
    const o2 = this.getPointCount(t2), a2 = this.getPathCount(t2), h2 = this.getPointCount(e5), m2 = this.getPathCount(e5);
    this.setGeometryVertexCount(t2, h2), this.setGeometryVertexCount(e5, o2), this.setGeometryPathCount(t2, m2), this.setGeometryPathCount(e5, a2);
    const u = this.m_geometryIndexList.getField(t2, 2), l2 = this.m_geometryIndexList.getField(e5, 2);
    this.m_geometryIndexList.setField(t2, 2, l2), this.m_geometryIndexList.setField(e5, 2, u);
  }
  addPathFromMultiPath(t2, e5, s4) {
    const n6 = this.createGeometry(s4 ? a.enumPolygon : a.enumPolyline, t2.getDescription()), r = t2.getImpl();
    if (t2.getPathSize(e5) < 2) return n6;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + t2.getPathSize(e5)), this.m_verticesMp.addPoints(t2, t2.getPathStart(e5), r.getPathEnd(e5)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const o2 = this.insertPath(n6, bm);
    this.setClosedPath(o2, r.isClosedPath(e5) || s4);
    const a2 = null !== this.m_segments || null !== r.getSegmentFlagsStreamRef();
    for (let i2 = r.getPathStart(e5), h2 = r.getPathEnd(e5); i2 < h2; i2++) {
      const t3 = this.insertVertex_(o2, bm, null, false);
      if (a2) {
        const e6 = this.getVertexIndex(t3);
        if (1 & r.getSegmentFlags(i2)) this.setSegmentToIndex(e6, null);
        else {
          const t4 = new nu();
          r.querySegment(i2, t4, true), this.setSegmentToIndex(e6, t4.releaseSegment());
        }
      }
    }
    return r.isStrongPathStart(e5) && this.setStrongPathStart(o2, true), r.isStrongPathEnd(e5) && this.setStrongPathEnd(o2, true), n6;
  }
  getGeometry(t2) {
    const e5 = this.getGeometryType(t2), s4 = Cm(e5, this.m_verticesMp.getDescription()), n6 = this.getPointCount(t2);
    if (0 === n6) return s4;
    if (h(e5)) {
      const e6 = s4.getImpl(), i2 = this.getPathCount(t2), r = J(i2 + 1), o2 = K(i2 + 1, 0), a2 = s4.getDescription(), h2 = this.hasCurves();
      for (let s5 = 0, m2 = a2.getAttributeCount(); s5 < m2; s5++) {
        const h3 = a2.getSemantics(s5), m3 = vm.getComponentCount(h3), u = j3(h3, n6), l2 = this.m_vertices.getAttributeStreamRef(h3);
        let c = 0, g2 = 0, d2 = 0;
        for (let e7 = this.getFirstPath(t2); e7 !== bm; e7 = this.getNextPath(e7)) {
          let t3 = 0;
          this.isClosedPath(e7) && (t3 |= 1), this.isExterior(e7) && (t3 |= 8), this.isStrongPathStart(e7) && (t3 |= 2), this.isStrongPathEnd(e7) && (t3 |= 4), t3 && o2.setBits(g2, t3);
          const s6 = this.getPathSize(e7);
          if (r.write(g2++, d2), d2 += s6, 0 === h3) {
            const t4 = l2, s7 = u;
            let n7;
            for (let i3 = this.getFirstVertex(e7); c < d2; i3 = this.getNextVertex(i3), c++) {
              const e8 = this.getVertexIndex(i3);
              n7 = t4.readPoint2D(2 * e8), s7.writePoint2D(2 * c, n7);
            }
          } else for (let n7 = this.getFirstVertex(e7); c < d2; n7 = this.getNextVertex(n7), c++) {
            const t4 = this.getVertexIndex(n7);
            for (let e8 = 0; e8 < m3; e8++) {
              const s7 = l2.readAsDbl(t4 * m3 + e8);
              u.writeAsDbl(c * m3 + e8, s7);
            }
          }
        }
        e6.setAttributeStreamRef(h3, u), r.write(i2, n6);
      }
      if (e6.setPathFlagsStreamRef(o2), e6.setPathStreamRef(r), e6.notifyModifiedFlags(65535), h2) {
        let s5 = 0, n7 = 0;
        for (let i3 = this.getFirstPath(t2); i3 !== bm; i3 = this.getNextPath(i3)) {
          s5 += this.getPathSize(i3);
          for (let t3 = this.getFirstVertex(i3); n7 < s5; t3 = this.getNextVertex(t3)) {
            const s6 = this.getSegment(t3);
            null !== s6 && s6.isCurve() && e6.replaceSegment(n7, s6, true), n7++;
          }
        }
      }
    } else if (e5 === a.enumMultiPoint) {
      const e6 = s4.getImpl(), i2 = s4.getDescription();
      e6.reserve(n6), e6.resizeNoInit(n6);
      for (let s5 = 0, n7 = i2.getAttributeCount(); s5 < n7; s5++) {
        const n8 = i2.getSemantics(s5), r = vm.getComponentCount(n8), o2 = e6.getAttributeStreamRef(n8), a2 = this.m_vertices.getAttributeStreamRef(n8);
        let h2 = 0;
        const m2 = this.getFirstPath(t2), u = this.getPathSize(m2);
        for (let t3 = this.getFirstVertex(m2); h2 < u; t3 = this.getNextVertex(t3), h2++) {
          const e7 = this.getVertexIndex(t3);
          for (let t4 = 0; t4 < r; t4++) {
            const s6 = a2.readAsDbl(e7 * r + t4);
            o2.writeAsDbl(h2 * r + t4, s6);
          }
        }
        e6.setAttributeStreamRef(n8, o2);
      }
      e6.notifyModifiedFlags(65535);
    } else b("getGeometry");
    return s4;
  }
  queryPointGeometryOnly(t2, s4) {
    this.getGeometryType(t2) !== a.enumMultiPoint && P("get_point_geometry_only");
    const n6 = this.getPointCount(t2);
    if (n6 > 1 && P("get_point_geometry_only"), 0 === n6) return s4.assignVertexDescription(this.m_vertexDescription), void s4.setEmpty();
    const r = this.getFirstPath(t2), o2 = this.getFirstVertex(r);
    this.queryPoint(o2, s4);
  }
  removeGeometry(t2) {
    for (let n6 = this.getFirstPath(t2); n6 !== bm; n6 = this.removePath(n6)) ;
    const e5 = this.getPrevGeometry(t2), s4 = this.getNextGeometry(t2);
    return e5 !== bm ? this.setNextGeometry(e5, s4) : this.m_firstGeometry = s4, s4 !== bm ? this.setPrevGeometry(s4, e5) : this.m_lastGeometry = e5, this.freeGeometry(t2), s4;
  }
  createGeometry(t2, e5) {
    void 0 === e5 && (e5 = M());
    const s4 = this.newGeometry(t2);
    return this.m_vertices || (this.m_verticesMp = new Ce({ vd: e5 }), this.m_vertices = this.m_verticesMp.getImpl()), this.mergeVertexDescription(e5), this.m_firstGeometry === bm ? (this.m_firstGeometry = s4, this.m_lastGeometry = s4) : (this.setPrevGeometry(s4, this.m_lastGeometry), this.setNextGeometry(this.m_lastGeometry, s4), this.m_lastGeometry = s4), s4;
  }
  getFirstGeometry() {
    return this.m_firstGeometry;
  }
  getLastGeometry() {
    return this.m_lastGeometry;
  }
  getNextGeometry(t2) {
    return this.m_geometryIndexList.getField(t2, 1);
  }
  getPrevGeometry(t2) {
    return this.m_geometryIndexList.getField(t2, 0);
  }
  getGeometryType(t2) {
    return 16777215 & this.m_geometryIndexList.getField(t2, 2);
  }
  setGeometryUserIndex(t2, e5, s4) {
    const n6 = this.m_geometryIndices[e5], i2 = this.getGeometryIndex(t2);
    i2 >= n6.size() && n6.resize(Math.max(1.25 * i2, 16), -1), n6.write(i2, s4);
  }
  getGeometryUserIndex(t2, e5) {
    const s4 = this.getGeometryIndex(t2), n6 = this.m_geometryIndices[e5];
    return s4 < n6.size() ? n6.read(s4) : -1;
  }
  createGeometryUserIndex() {
    for (let e5 = 0; e5 < this.m_geometryIndices.length; e5++) if (null === this.m_geometryIndices[e5]) return this.m_geometryIndices[e5] = J(0), e5;
    this.m_geometryIndices.push(J(0));
    const t2 = this.m_geometryIndices.length - 1;
    return n2(t2 >= 0 && t2 <= Number.MAX_SAFE_INTEGER), t2;
  }
  removeGeometryUserIndex(t2) {
    for (this.m_geometryIndices[t2] = null; this.m_geometryIndices.length > 0 && null === this.m_geometryIndices.at(-1); ) this.m_geometryIndices.pop();
  }
  getFirstPath(t2) {
    return this.m_geometryIndexList.getField(t2, 3);
  }
  getLastPath(t2) {
    return this.m_geometryIndexList.getField(t2, 4);
  }
  hasPointFeatures() {
    for (let t2 = this.getFirstGeometry(); t2 !== bm; t2 = this.getNextGeometry(t2)) if (!h(this.getGeometryType(t2))) return true;
    return false;
  }
  getPointCount(t2) {
    return this.m_geometryIndexList.getField(t2, 5);
  }
  getPathCount(t2) {
    return this.m_geometryIndexList.getField(t2, 6);
  }
  filterClosePoints(t2, e5, n6, r, o2) {
    const a2 = t2 * t2;
    let h2 = 0;
    const m2 = this.hasCurves(), u = this.hasSegmentParentage();
    for (let l2 = o2 === bm ? this.getFirstGeometry() : o2; l2 !== bm; l2 = o2 === bm ? this.getNextGeometry(l2) : bm) {
      const t3 = this.getGeometryType(l2);
      if (!h(t3)) continue;
      if (n6 && t3 !== a.enumPolygon) continue;
      const o3 = this.getGeometryType(l2) === a.enumPolygon;
      let g2 = this.getGeometryModified(l2);
      for (let n7 = this.getFirstPath(l2); n7 !== bm; ) {
        let t4 = 0;
        for (let e6 = this.getFirstVertex(n7); t4 < Math.trunc(this.getPathSize(n7) / 2); ) {
          const i3 = this.getNextVertex(e6);
          if (i3 === bm) break;
          const o4 = this.getXY(e6), c2 = this.getXY(i3);
          let d3 = ei.sqrDistance(o4, c2), _ = true;
          do {
            if (d3 <= a2) {
              if (m2) {
                const t5 = this.getSegment(e6);
                if (null !== t5) {
                  const e7 = t5.calculateLength2D();
                  if (d3 = e7 * e7, d3 > a2) break;
                }
              }
              if (0 === d3 ? 0 === h2 && (h2 = -1) : h2 = 1, i3 !== this.getLastVertex(n7)) {
                const t5 = u && (this.getSegmentParentageBreakVertex(e6) || this.getSegmentParentageBreakVertex(i3));
                if (this.transferAllDataToTheVertex(i3, e6), this.removeVertex(i3, false), r && !g2 && (this.setGeometryModified(l2, true), g2 = true), u && e6 !== i3) {
                  this.setSegmentParentageBreakVertex(e6, t5);
                  const n8 = this.getNextVertex(e6);
                  n2(n8 !== bm), this.isDiscontinuousSegmentParentage(n8) && this.setSegmentParentageBreakVertex(n8, true);
                }
              }
              _ = false;
            }
          } while (0);
          _ && (e6 = this.getNextVertex(e6)), t4++;
        }
        let i2 = this.getFirstVertex(n7);
        for (let e6 = this.isClosedPath(n7) ? i2 : this.getLastVertex(n7); this.getPathSize(n7) > 0; ) {
          const t5 = this.getPrevVertex(e6);
          if (t5 === bm) break;
          {
            const s4 = this.getXY(t5), o4 = this.getXY(e6);
            let c2 = ei.sqrDistance(s4, o4), d3 = true;
            do {
              if (c2 <= a2) {
                if (m2) {
                  const e7 = this.getSegment(t5);
                  if (null !== e7) {
                    const t6 = e7.calculateLength2D();
                    if (c2 = t6 * t6, c2 > a2) break;
                  }
                }
                0 === c2 ? 0 === h2 && (h2 = -1) : h2 = 1;
                const s5 = u && (this.getSegmentParentageBreakVertex(e6) || this.getSegmentParentageBreakVertex(t5));
                this.removeVertex(t5, true), r && !g2 && (this.setGeometryModified(l2, true), g2 = true), u && t5 !== e6 && (s5 || this.isDiscontinuousSegmentParentage(e6)) && this.setSegmentParentageBreakVertex(e6, true), i2 === t5 && (i2 = this.getFirstVertex(n7)), d3 = false;
              }
            } while (0);
            if (d3 && (e6 = this.getPrevVertex(e6), e6 === i2)) break;
          }
        }
        const c = this.getPathSize(n7);
        let d2 = e5 && c < (o3 ? 3 : 2);
        d2 && o3 && 2 === c && m2 && (d2 = !this.pathHasCurves(n7)), d2 ? (n7 = this.removePath(n7), 0 === h2 && (h2 = -1), r && !g2 && (this.setGeometryModified(l2, true), g2 = true)) : n7 = this.getNextPath(n7);
      }
    }
    return h2;
  }
  filterClosePoints3D(t2, e5, n6, i2, r, o2) {
    return n2(0), 0;
  }
  hasDegenerateSegments(t2) {
    for (let e5 = this.getFirstGeometry(); e5 !== bm; e5 = this.getNextGeometry(e5)) if (h(this.getGeometryType(e5))) for (let s4 = this.getFirstPath(e5); s4 !== bm; ) {
      const e6 = this.getPathSize(s4);
      if (0 === e6) return true;
      let n6 = this.getFirstVertex(s4);
      for (let s5 = 0; s5 < e6; s5++) {
        const e7 = this.getNextVertex(n6);
        if (e7 === bm) break;
        const s6 = this.getVertexIndex(n6), i2 = this.getSegmentFromIndex(s6);
        let r = 0;
        if (null !== i2) {
          if (r = i2.calculateLowerLength2D(), r <= t2) {
            if (r = i2.calculateUpperLength2D(), r <= t2) return true;
            if (r = i2.calculateLength2D(), r <= t2) return true;
          }
        } else {
          const n7 = this.getVertexIndex(e7);
          if (r = this.m_vertices.getShortestDistance(s6, n7), r <= t2) return true;
        }
        n6 = e7;
      }
      s4 = this.getNextPath(s4);
    }
    return false;
  }
  hasDegenerateSegments3D(t2, e5) {
    return n2(0), false;
  }
  transferAllDataToTheVertex(t2, e5) {
    const s4 = this.getVertexIndex(t2), n6 = this.getVertexIndex(e5);
    if (this.m_weights) {
      const t3 = this.getWeightWithIndex(s4);
      this.setWeightWithIndex(n6, t3);
    }
    if (this.m_ranks) {
      const t3 = this.getRankWithIndex(s4);
      this.setRankWithIndex(n6, t3);
    }
    if (this.m_segmentWeights) {
      const t3 = this.getSegmentWeightWithIndex(s4);
      this.setSegmentWeightWithIndex(n6, t3);
    }
    if (this.m_segmentRanks) {
      const t3 = this.getSegmentRankWithIndex(s4);
      this.setSegmentRankWithIndex(n6, t3);
    }
    for (let r = 0, o2 = this.m_indices.length; r < o2; r++) if (r !== this.m_selectionIndex && null !== this.m_indices[r]) {
      const s5 = this.getUserIndex(t2, r);
      -1 !== s5 && this.setUserIndex(e5, r, s5);
    }
    const i2 = this.selected(t2);
    i2 !== this.selected(e5) && (i2 ? this.select(e5) : this.unselect(e5));
  }
  splitSegmentAxisAware(t2, s4, n6, i2, r) {
    let o2 = 0;
    const a2 = this.getNextVertex(t2);
    a2 === bm && P("");
    const h2 = this.getVertexIndex(t2), m2 = this.getVertexIndex(a2), u = this.getSegmentFromIndex(h2);
    let l2 = this.m_vertices.getShortestDistance(h2, m2);
    const c = this.getPathFromVertex(t2), g2 = this.m_bHasAttributes;
    g2 && u && (l2 = u.calculateLength2D());
    const d2 = this.getSegmentParentage(t2), _ = this.getHelperPoint();
    if (u) {
      let t3 = 0, e5 = 0, r2 = bm;
      for (let p3 = 0; p3 < n6; p3++) {
        const n7 = s4[p3];
        if (t3 < n7 && n7 < 1) {
          const s5 = u.cut(t3, n7);
          if (null !== i2 && (p3 > 0 && s5.setStartXY(i2[p3 - 1]), s5.setEndXY(i2[p3]), s5.normalizeAfterEndpointChange(), e5 = p3), g2) {
            const t4 = l2 > 0 ? u.calculateSubLengthFromStart(n7) / l2 : 0;
            this.m_vertices.interpolateTwoVertices(h2, m2, t4, _);
          }
          _.setXY(s5.getEndXY()), r2 = this.insertVertex(c, a2, _), o2++;
          const f3 = this.getPrevVertex(r2), P5 = this.getVertexIndex(f3);
          this.setSegmentToIndex(P5, s5), -1 !== d2 && this.setSegmentParentageAndBreak(r2, d2, false), t3 = n7;
        }
      }
      if (r2 !== bm) {
        const s5 = u.cut(t3, 1);
        null !== i2 && (s5.setStartXY(i2[e5]), s5.normalizeAfterEndpointChange());
        const n7 = this.getVertexIndex(r2);
        this.setSegmentToIndex(n7, s5);
      }
    } else {
      let t3 = 0;
      for (let e5 = 0; e5 < n6; e5++) {
        const n7 = s4[e5];
        if (t3 < n7 && n7 < 1) {
          this.m_vertices.interpolateTwoVertices(h2, m2, n7, _);
          const t4 = this.insertVertex(c, a2, _);
          o2++, -1 !== d2 && this.setSegmentParentageAndBreak(t4, d2, false);
        }
        t3 = n7;
      }
    }
    return o2;
  }
  splitSegment(t2, e5, s4, n6 = null) {
    return this.splitSegmentAxisAware(t2, e5, s4, n6, -1);
  }
  snapControlPoints(t2, s4, n6) {
    this.getNextVertex(t2) === bm && P("");
    let i2 = t2, r = false;
    for (let e5 = 0; e5 < s4; ++e5) {
      const t3 = this.getVertexIndex(i2), e6 = this.getSegmentFromIndex(t3);
      if (e6) {
        const t4 = e6.snapControlPoints(n6);
        r || (r = t4);
      }
      i2 = this.getNextVertex(i2);
    }
    return r;
  }
  snapControlPointsOnSelection(t2) {
    if (!this.hasCurves()) return false;
    let e5 = 0;
    const s4 = this.queryVertexIteratorOnSelection();
    for (let n6 = s4.next(); n6 !== bm; n6 = s4.next()) {
      const s5 = this.getVertexIndex(n6), i2 = this.getSegmentFromIndex(s5);
      i2 && (e5 |= i2.snapControlPoints(t2) ? 1 : 0);
    }
    return 0 !== e5;
  }
  calculateSubLength2D(t2, e5, n6) {
    return n2(0), 0;
  }
  setPoint(t2, e5, s4) {
    if (this.setPointOnly(t2, e5), null !== this.m_segments) {
      const n6 = this.getVertexIndex(t2), i2 = this.getSegmentFromIndex(n6);
      null !== i2 && (i2.setStartXY(e5.getXY()), i2.normalizeAfterEndpointChange(), s4 && i2.ensureXYMonotone());
      const r = this.getPrevVertex(t2);
      if (r !== bm) {
        const t3 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t3);
        null !== n7 && (n7.setEndXY(e5.getXY()), n7.normalizeAfterEndpointChange(), s4 && n7.ensureXYMonotone());
      }
    }
  }
  setPointEx(t2, e5, s4, n6, i2) {
    this.setPoint(t2, e5, i2);
    const r = this.getVertexIndex(t2);
    this.setWeightWithIndex(r, n6), this.setRankWithIndex(r, s4);
  }
  setPointOnly(t2, e5) {
    const s4 = this.getVertexIndex(t2);
    this.m_vertices.setPointByVal(s4, e5);
  }
  setPointOnlyEx(t2, e5, n6, i2) {
    n2(0);
  }
  queryPoint(t2, e5) {
    const s4 = this.getVertexIndex(t2);
    this.m_vertices.getPointByVal(s4, e5);
  }
  setXY(t2, e5) {
    this.setXYCoords(t2, e5.x, e5.y);
  }
  setXYCoords(t2, e5, s4) {
    var _a3;
    const n6 = this.getVertexIndex(t2);
    if ((_a3 = this.m_vertices) == null ? void 0 : _a3.setXYCoords(n6, e5, s4), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n6);
      null !== i2 && (i2.setStartXYCoords(e5, s4), i2.normalizeAfterEndpointChange());
      const r = this.getPrevVertex(t2);
      if (r !== bm) {
        const t3 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t3);
        null != n7 && (n7.setEndXYCoords(e5, s4), n7.normalizeAfterEndpointChange());
      }
    }
  }
  setXYMonotonic(t2, e5, s4) {
    const n6 = this.getVertexIndex(t2);
    if (this.m_vertices.setXYCoords(n6, e5, s4), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n6);
      if (null !== i2) {
        const t3 = i2.getEndXY();
        i2.setCoordsForIntersector(new ei(e5, s4), t3, false), i2.ensureXYMonotone();
      }
      const r = this.getPrevVertex(t2);
      if (r !== bm) {
        const t3 = this.getVertexIndex(r), n7 = this.getSegmentFromIndex(t3);
        if (null !== n7) {
          const t4 = n7.getStartXY();
          n7.setCoordsForIntersector(t4, new ei(e5, s4), false), n7.ensureXYMonotone();
        }
      }
    }
  }
  setXYMonotonicPoint2D(t2, e5) {
    this.setXYMonotonic(t2, e5.x, e5.y);
  }
  queryXY(t2, e5) {
    const s4 = this.getVertexIndex(t2);
    return this.m_vertices.queryXY(s4, e5);
  }
  getXY(t2) {
    const e5 = this.getVertexIndex(t2);
    return this.m_vertices.getXY(e5);
  }
  getXYWithIndex(t2) {
    return this.m_xyStream.readPoint2D(2 * t2);
  }
  static setSegDefault(t2, e5, n6) {
    n2(0);
  }
  setXYZ(t2, e5, n6) {
    n2(0);
  }
  setXYZCoords(t2, e5, n6, i2) {
    n2(0);
  }
  queryXYZ(t2, e5) {
    n2(0);
  }
  getXYZ(t2) {
    return n2(0), X2.getNAN();
  }
  getXYZWithIndex(t2) {
    return n2(0), X2.getNAN();
  }
  mergeVertexDescription(t2) {
    this.m_verticesMp.mergeVertexDescription(t2), this.m_vertexDescription = this.m_verticesMp.getDescription(), this.m_bHasAttributes = this.m_vertexDescription.getAttributeCount() > 1;
  }
  addAttribute(t2) {
    n2(0);
  }
  getAttributeAsDbl(t2, e5, s4) {
    return this.m_vertices.getAttributeAsDbl(t2, this.getVertexIndex(e5), s4);
  }
  queryAttributeAsDbl(t2, e5, n6, i2) {
    n2(0);
  }
  setAttribute(t2, e5, n6, i2) {
    n2(0);
  }
  setAttributeInt(t2, e5, n6, i2) {
    n2(0);
  }
  getVertexDescription() {
    return this.m_vertexDescription;
  }
  getMinPathVertexY(t2) {
    return n2(0), 0;
  }
  getVertexIndex(t2) {
    return this.m_vertexIndexList.getField(t2, 0);
  }
  getY(t2) {
    const e5 = this.getVertexIndex(t2);
    return this.m_vertices.queryXY(e5, this.m_workPoint2D), this.m_workPoint2D.y;
  }
  getX(t2) {
    return this.getXY(t2).x;
  }
  isEqualXY(t2, e5) {
    return this.queryXY(t2, this.m_workPoint2D), this.queryXY(e5, this.m_workPoint2_2D), this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D);
  }
  isEqualXYPoint2D(t2, e5) {
    return this.queryXY(t2, this.m_workPoint2D), this.m_workPoint2D.isEqualPoint2D(e5);
  }
  isEqualXYZPoint3D(t2, e5) {
    return n2(0), false;
  }
  setWeight(t2, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null == this.m_weights) {
      if (s4) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n6 = this.getVertexIndex(t2);
    if (n6 >= this.m_weights.size()) {
      if (s4) return;
      this.m_weights.resize(n6 + 1, 1);
    }
    this.m_weights.write(n6, e5);
  }
  setWeightWithIndex(t2, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null === this.m_weights) {
      if (s4) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t2 >= this.m_weights.size()) {
      if (s4) return;
      this.m_weights.resize(t2 + 1, 1);
    }
    this.m_weights.write(t2, e5);
  }
  getWeight(t2) {
    if (null === this.m_weights) return 1;
    const e5 = this.getVertexIndex(t2);
    return e5 >= this.m_weights.size() ? 1 : this.m_weights.read(e5);
  }
  getWeightWithIndex(t2) {
    return null === this.m_weights || t2 >= this.m_weights.size() ? 1 : this.m_weights.read(t2);
  }
  getRank(t2) {
    if (null === this.m_ranks) return Em;
    const e5 = this.getVertexIndex(t2);
    return e5 >= this.m_ranks.size() ? Em : this.m_ranks.read(e5);
  }
  getRankWithIndex(t2) {
    return null === this.m_ranks || t2 >= this.m_ranks.size() ? Em : this.m_ranks.read(t2);
  }
  setRank(t2, e5) {
    e5 < Em && (e5 = Em);
    const s4 = e5 === Em;
    if (null === this.m_ranks) {
      if (s4) return;
      this.m_ranks = J(this.m_vertices.getPointCount(), Em);
    }
    const n6 = this.getVertexIndex(t2);
    if (n6 >= this.m_ranks.size()) {
      if (s4) return;
      this.m_ranks.resize(n6 + 1, Em);
    }
    this.m_ranks.write(n6, e5);
  }
  setRankWithIndex(t2, e5) {
    e5 < Em && (e5 = Em);
    const s4 = e5 === Em;
    if (null === this.m_ranks) {
      if (s4) return;
      this.m_ranks = J(this.m_vertices.getPointCount(), Em);
    }
    if (t2 >= this.m_ranks.size()) {
      if (s4) return;
      this.m_ranks.resize(t2 + 1, Em);
    }
    this.m_ranks.write(t2, e5);
  }
  setSegmentWeight(t2, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null === this.m_segmentWeights) {
      if (s4) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n6 = this.getVertexIndex(t2);
    if (n6 >= this.m_segmentWeights.size()) {
      if (s4) return;
      this.m_segmentWeights.resize(n6 + 1, 1);
    }
    this.m_segmentWeights.write(n6, e5);
  }
  setSegmentWeightWithIndex(t2, e5) {
    e5 < 1 && (e5 = 1);
    const s4 = 1 === e5;
    if (null == this.m_segmentWeights) {
      if (s4) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t2 >= this.m_segmentWeights.size()) {
      if (s4) return;
      this.m_segmentWeights.resize(t2 + 1, 1);
    }
    this.m_segmentWeights.write(t2, e5);
  }
  getSegmentWeight(t2) {
    if (null === this.m_segmentWeights) return 1;
    const e5 = this.getVertexIndex(t2);
    return e5 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(e5);
  }
  getSegmentWeightWithIndex(t2) {
    return null == this.m_segmentWeights || t2 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(t2);
  }
  getSegmentRank(t2) {
    if (null === this.m_segmentRanks) return _Tm.st_defaultRank;
    const e5 = this.getVertexIndex(t2);
    return e5 >= this.m_segmentRanks.size() ? _Tm.st_defaultRank : this.m_segmentRanks.read(e5);
  }
  getSegmentRankWithIndex(t2) {
    return null === this.m_segmentRanks || t2 >= this.m_segmentRanks.size() ? Em : this.m_segmentRanks.read(t2);
  }
  setSegmentRank(t2, e5) {
    e5 < Em && (e5 = Em);
    const s4 = e5 === Em;
    if (null === this.m_segmentRanks) {
      if (s4) return;
      this.m_segmentRanks = J(this.m_vertices.getPointCount(), Em);
    }
    const n6 = this.getVertexIndex(t2);
    if (n6 >= this.m_segmentRanks.size()) {
      if (s4) return;
      this.m_segmentRanks.resize(n6 + 1, Em);
    }
    this.m_segmentRanks.write(n6, e5);
  }
  setSegmentRankWithIndex(t2, e5) {
    e5 < Em && (e5 = Em);
    const s4 = e5 === Em;
    if (null === this.m_segmentRanks) {
      if (s4) return;
      this.m_segmentRanks = J(this.m_vertices.getPointCount(), Em);
    }
    if (t2 >= this.m_segmentRanks.size()) {
      if (s4) return;
      this.m_segmentRanks.resize(t2 + 1, Em);
    }
    this.m_segmentRanks.write(t2, e5);
  }
  removeWeights() {
    this.m_weights = null, this.m_segmentWeights = null;
  }
  removeRanks() {
    this.m_ranks = null, this.m_segmentRanks = null;
  }
  setUserIndex(t2, e5, s4) {
    const n6 = this.m_indices[e5], i2 = this.getVertexIndex(t2);
    if (n6.size() <= i2) {
      if (-1 === s4) return;
      n6.resize(this.m_vertices.getPointCount(), -1);
    }
    n6.write(i2, s4);
  }
  getUserIndex(t2, e5) {
    const s4 = this.getVertexIndex(t2), n6 = this.m_indices[e5];
    if (s4 < n6.size()) {
      return n6.read(s4);
    }
    return -1;
  }
  addToUserIndex(t2, e5, s4) {
    const n6 = this.m_indices[e5], i2 = this.getVertexIndex(t2);
    n6.size() <= i2 && n6.resize(this.m_vertices.getPointCount(), -1);
    const r = n6.read(i2);
    n6.write(i2, r + s4);
  }
  createUserIndex() {
    for (let e5 = 0; e5 < this.m_indices.length; e5++) if (null === this.m_indices[e5]) return this.m_indices[e5] = this.allocateIndex(), e5;
    this.m_indices.push(this.allocateIndex());
    const t2 = this.m_indices.length - 1;
    return n2(t2 >= 0 && t2 <= ls()), t2;
  }
  createUserIndexUninitialized() {
    for (let e5 = 0; e5 < this.m_indices.length; e5++) if (null === this.m_indices[e5]) return this.m_indices[e5] = this.allocateIndex(false), e5;
    this.m_indices.push(this.allocateIndex(false));
    const t2 = this.m_indices.length - 1;
    return n2(t2 >= 0 && t2 <= Number.MAX_SAFE_INTEGER), t2;
  }
  fillUserIndexForGeometry(t2, e5, s4) {
    const n6 = this.m_indices[e5], i2 = n6.size();
    for (let r = this.getFirstPath(t2); r !== bm; r = this.getNextPath(r)) {
      let t3 = this.getFirstVertex(r);
      for (let e6 = 0, o2 = this.getPathSize(r); e6 < o2; e6++, t3 = this.getNextVertex(t3)) {
        const e7 = this.getVertexIndex(t3);
        e7 < i2 && n6.write(e7, s4);
      }
    }
  }
  fillUserIndexForSelection(t2, e5) {
    n2(0);
  }
  removeUserIndex(t2) {
    for (this.recycleUserIndex(this.m_indices[t2]), this.m_indices[t2] = null; this.m_indices.length > 0 && null === this.m_indices[this.m_indices.length - 1]; ) this.m_indices.pop();
  }
  replaceCurveWithLine(t2) {
    if (null !== this.m_segments) {
      const e5 = this.getVertexIndex(t2);
      this.setSegmentToIndex(e5, null);
    }
  }
  queryLineConnector(t2, e5, s4 = false) {
    const n6 = this.getNextVertex(t2);
    if (n6 === bm) return false;
    if (!this.m_bHasAttributes || s4) {
      const s5 = this.getXY(t2);
      e5.setStartXY(s5);
      const i2 = this.getXY(n6);
      e5.setEndXY(i2);
    } else {
      const s5 = new ee({ vd: this.getVertexDescription() });
      this.queryPoint(t2, s5), e5.setStart(s5), this.queryPoint(n6, s5), e5.setEnd(s5);
    }
    return true;
  }
  queryLineConnector3D(t2, e5, n6 = false) {
    return n2(0), false;
  }
  hasCurves() {
    return null !== this.m_segments;
  }
  geometryHasCurves(t2) {
    return n2(0), false;
  }
  pathHasCurves(t2) {
    if (!this.hasCurves()) return false;
    const e5 = this.getFirstVertex(t2);
    if (e5 === bm) return false;
    const s4 = this.getPathSize(t2);
    let n6 = e5;
    for (let r = 0; r < s4; r++, n6 = this.getNextVertex(n6)) {
      const t3 = this.getSegment(n6);
      if (null !== t3 && t3.getGeometryType() !== a.enumLine) return true;
    }
    return false;
  }
  insertPath(t2, s4) {
    let n6 = bm;
    s4 !== bm ? (t2 !== this.getGeometryFromPath(s4) && P(""), n6 = this.getPrevPath(s4)) : n6 = this.getLastPath(t2);
    const i2 = this.newPath(t2);
    return s4 !== bm && this.setPrevPath(s4, i2), this.setNextPath(i2, s4), this.setPrevPath(i2, n6), n6 !== bm ? this.setNextPath(n6, i2) : this.setFirstPath(t2, i2), s4 === bm && this.setLastPath(t2, i2), this.setGeometryPathCount(t2, this.getPathCount(t2) + 1), i2;
  }
  removePath(t2) {
    const e5 = this.getPrevPath(t2), s4 = this.getNextPath(t2), n6 = this.getGeometryFromPath(t2);
    return e5 !== bm ? this.setNextPath(e5, s4) : this.setFirstPath(n6, s4), s4 !== bm ? this.setPrevPath(s4, e5) : this.setLastPath(n6, e5), this.clearPath(t2), this.setGeometryPathCount(n6, this.getPathCount(n6) - 1), this.freePath(t2), s4;
  }
  clearPath(t2) {
    const e5 = this.getFirstVertex(t2);
    if (e5 !== bm) {
      let s4 = e5;
      for (let e6 = 0, i2 = this.getPathSize(t2); e6 < i2; e6++) {
        const t3 = s4;
        s4 = this.getNextVertex(s4), this.freeVertex(t3);
      }
      const n6 = this.getGeometryFromPath(t2);
      this.setGeometryVertexCount(n6, this.getPointCount(n6) - this.getPathSize(t2));
    }
    this.setPathSize(t2, 0);
  }
  getNextPath(t2) {
    return this.m_pathIndexList.getField(t2, 2);
  }
  getPrevPath(t2) {
    return this.m_pathIndexList.getField(t2, 1);
  }
  getPathSize(t2) {
    return this.m_pathIndexList.getField(t2, 3);
  }
  isClosedPath(t2) {
    return !!(1 & this.getPathFlags(t2));
  }
  setClosedPath(t2, e5) {
    if (this.isClosedPath(t2) === e5) return;
    if (this.getPathSize(t2) > 0) {
      const s5 = this.getFirstVertex(t2), n6 = this.getLastVertex(t2);
      if (e5) {
        this.setNextVertex(n6, s5), this.setPrevVertex(s5, n6);
        const t3 = this.getVertexIndex(n6);
        this.setSegmentToIndex(t3, null);
      } else {
        this.setNextVertex(n6, bm), this.setPrevVertex(s5, bm);
        const t3 = this.getVertexIndex(n6);
        this.setSegmentToIndex(t3, null);
      }
    }
    const s4 = (1 | this.getPathFlags(t2)) - 1;
    this.setPathFlags(t2, s4 | (e5 ? 1 : 0));
  }
  closeAllPaths(t2) {
    n2(0);
  }
  isStrongPathStart(t2) {
    return !!(8 & this.getPathFlags(t2));
  }
  isStrongPathEnd(t2) {
    return !!(16 & this.getPathFlags(t2));
  }
  setStrongPathStart(t2, e5) {
    const s4 = (8 | this.getPathFlags(t2)) - 8;
    this.setPathFlags(t2, s4 | (e5 ? 8 : 0));
  }
  setStrongPathEnd(t2, e5) {
    const s4 = (16 | this.getPathFlags(t2)) - 16;
    this.setPathFlags(t2, s4 | (e5 ? 16 : 0));
  }
  getGeometryFromPath(t2) {
    return this.m_pathIndexList.getField(t2, 7);
  }
  isExterior(t2) {
    return !!(2 & this.getPathFlags(t2));
  }
  setExterior(t2, e5) {
    const s4 = (2 | this.getPathFlags(t2)) - 2;
    this.setPathFlags(t2, s4 | (e5 ? 2 : 0));
  }
  getRingArea(t2) {
    if (this.isRingAreaValid(t2)) return this.m_pathAreas[this.getPathIndex(t2)];
    const e5 = this.getFirstVertex(t2);
    if (e5 === bm) return 0;
    const s4 = this.getXY(e5), n6 = new n3(0), r = this.getPathSize(t2);
    if (r > 2) {
      const t3 = s4.clone(), i2 = t3.x, o3 = t3.y;
      let a2 = this.getNextVertex(e5);
      const h2 = this.getXY(a2);
      a2 = this.getNextVertex(a2);
      const m2 = ei.getNAN();
      for (let e6 = 2; e6 < r; e6++, a2 = this.getNextVertex(a2)) this.queryXY(a2, m2), n6.pe((m2.x - t3.x) * (h2.y - o3)), t3.setCoordsPoint2D(h2), h2.setCoordsPoint2D(m2);
      n6.pe((i2 - t3.x) * (h2.y - o3));
    }
    if (this.hasCurves()) {
      let t3 = e5;
      for (let e6 = 0; e6 < r; e6++, t3 = this.getNextVertex(t3)) {
        const e7 = this.getSegment(t3);
        if (null === e7 || e7.getGeometryType() === a.enumLine) continue;
        const s5 = 2 * e7.calculateArea2DHelper();
        n6.pe(s5);
      }
    }
    this.setRingAreaValid(t2, true);
    const o2 = 0.5 * n6.getResult();
    return this.m_pathAreas[this.getPathIndex(t2)] = o2, o2;
  }
  getPathIndexInternal(t2) {
    return this.getPathIndex(t2);
  }
  getPathInternalIndexFromVertex(t2) {
    return this.getPathIndex(this.getPathFromVertex(t2));
  }
  setPathUserIndex(t2, e5, s4) {
    const n6 = this.m_pathindices[e5], i2 = this.getPathIndex(t2);
    n6.size() < this.m_pathAreas.length && n6.resize(this.m_pathAreas.length, -1), n6.write(i2, s4);
  }
  getPathUserIndex(t2, e5) {
    const s4 = this.getPathIndex(t2), n6 = this.m_pathindices[e5];
    return s4 < n6.size() ? n6.read(s4) : -1;
  }
  createPathUserIndex() {
    for (let e5 = 0; e5 < this.m_pathindices.length; e5++) if (null === this.m_pathindices[e5]) return this.m_pathindices[e5] = this.allocatePathIndex(), e5;
    this.m_pathindices.push(this.allocatePathIndex());
    const t2 = this.m_pathindices.length - 1;
    return n2(t2 >= 0 && t2 <= Number.MAX_SAFE_INTEGER), t2;
  }
  fillPathUserIndexForGeometry(t2, e5, s4) {
    const n6 = this.m_pathindices[e5], i2 = n6.size();
    for (let r = this.getFirstPath(t2); r !== bm; r = this.getNextPath(r)) {
      const t3 = this.getPathIndex(r);
      t3 < i2 && n6.write(t3, s4);
    }
  }
  removePathUserIndex(t2) {
    for (this.recyclePathUserIndex(this.m_pathindices[t2]), this.m_pathindices[t2] = null; this.m_pathindices.length > 0 && null === this.m_pathindices.at(-1); ) this.m_pathindices.pop();
  }
  movePath(t2, s4, n6) {
    if (n6 === bm && P(""), s4 === n6) return;
    const i2 = this.getNextPath(n6);
    let r = this.getPrevPath(n6);
    const o2 = this.getGeometryFromPath(n6);
    r === bm ? this.setFirstPath(o2, i2) : this.setNextPath(r, i2), i2 === bm ? this.setLastPath(o2, r) : this.setPrevPath(i2, r), this.setGeometryVertexCount(o2, this.getPointCount(o2) - this.getPathSize(n6)), this.setGeometryPathCount(o2, this.getPathCount(o2) - 1), r = s4 === bm ? this.getLastPath(t2) : this.getPrevPath(s4), this.setPrevPath(n6, r), this.setNextPath(n6, s4), s4 === bm ? this.setLastPath(t2, n6) : this.setPrevPath(s4, n6), r === bm ? this.setFirstPath(t2, n6) : this.setNextPath(r, n6), this.setGeometryVertexCount(t2, this.getPointCount(t2) + this.getPathSize(n6)), this.setGeometryPathCount(t2, this.getPathCount(t2) + 1), this.setPathGeometry(n6, t2);
  }
  addVertex(t2, e5) {
    this.m_vertices.getPointByVal(this.getVertexIndex(e5), this.getHelperPoint());
    return this.insertVertex_(t2, bm, this.getHelperPoint(), false);
  }
  insertVertex(t2, e5, s4) {
    return this.insertVertex_(t2, e5, s4, true);
  }
  removeVertex(t2, e5) {
    const s4 = this.getPathFromVertex(t2), n6 = this.getPrevVertex(t2), i2 = this.getNextVertex(t2);
    n6 !== bm && this.setNextVertex(n6, i2);
    const r = this.getPathSize(s4);
    t2 === this.getFirstVertex(s4) && this.setFirstVertex(s4, r > 1 ? i2 : bm), i2 !== bm && this.setPrevVertex(i2, n6), t2 === this.getLastVertex(s4) && this.setLastVertex(s4, r > 1 ? n6 : bm);
    if (this.hasCurves() && n6 !== bm && i2 !== bm) {
      const s5 = this.getVertexIndex(t2), r2 = this.getVertexIndex(n6), o3 = this.getVertexIndex(i2);
      if (e5) {
        const t3 = this.getSegmentFromIndex(r2);
        if (null !== t3) {
          const e6 = this.m_vertices.getXY(o3);
          t3.setEndXY(e6), t3.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(s5, null);
      } else {
        const t3 = this.getSegmentFromIndex(s5);
        if (this.setSegmentToIndex(s5, null), null !== t3) {
          const e6 = this.m_vertices.getXY(r2);
          t3.setStartXY(e6), t3.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r2, t3);
      }
    }
    this.setPathSize(s4, r - 1);
    const o2 = this.getGeometryFromPath(s4);
    return this.setGeometryVertexCount(o2, this.getPointCount(o2) - 1), this.freeVertex(t2), i2;
  }
  removeVertices(t2, e5) {
    n2(t2 !== e5);
    const n6 = this.getPathFromVertex(t2), i2 = this.getPrevVertex(t2), r = this.getPrevVertex(e5);
    i2 !== bm && this.setNextVertex(i2, e5);
    let o2 = this.getPathSize(n6);
    const a2 = this.getVertexIndex(t2);
    this.setSegmentToIndex(a2, null), this.setPrevVertex(e5, i2), this.setPrevVertex(t2, bm), this.setNextVertex(r, bm);
    let h2 = 0, m2 = t2;
    const u = this.getFirstVertex(n6);
    let l2 = false;
    for (; ; ) {
      const t3 = this.getNextVertex(m2);
      if (l2 || (l2 = u === m2), this.freeVertex(m2), h2++, m2 === r) break;
      m2 = t3;
    }
    o2 -= h2, l2 && this.setFirstVertex(n6, o2 > 0 ? e5 : bm), this.setPathSize(n6, o2);
    const c = this.getGeometryFromPath(n6);
    this.setGeometryVertexCount(c, this.getPointCount(c) - h2);
  }
  getFirstVertex(t2) {
    return this.m_pathIndexList.getField(t2, 4);
  }
  getLastVertex(t2) {
    return this.m_pathIndexList.getField(t2, 5);
  }
  getNextVertex(t2) {
    return this.m_vertexIndexList.getField(t2, 2);
  }
  getPrevVertex(t2) {
    return this.m_vertexIndexList.getField(t2, 1);
  }
  getNextVertexEx(t2, e5) {
    return e5 > 0 ? this.m_vertexIndexList.getField(t2, 2) : this.m_vertexIndexList.getField(t2, 1);
  }
  getPrevVertexEx(t2, e5) {
    return e5 > 0 ? this.m_vertexIndexList.getField(t2, 1) : this.m_vertexIndexList.getField(t2, 2);
  }
  getPathFromVertex(t2) {
    return this.m_vertexIndexList.getField(t2, 3);
  }
  addPoint(t2, e5) {
    return this.insertVertex_(t2, bm, e5, false);
  }
  getGeometryFromVertex(t2) {
    return this.getGeometryFromPath(this.getPathFromVertex(t2));
  }
  replaceNaNs(t2, e5) {
    this.m_vertexDescription.hasAttribute(t2) || b(""), this.m_vertices.replaceNaNs(t2, e5);
  }
  removeNaNVertices() {
    for (let t2 = this.getFirstGeometry(); t2 !== bm; t2 = this.getNextGeometry(t2)) for (let e5 = this.getFirstPath(t2); e5 !== bm; e5 = this.getNextPath(e5)) {
      let t3 = this.getFirstVertex(e5);
      for (let s4 = 0, n6 = this.getPathSize(e5); s4 < n6; s4++) t3 = this.getXY(t3).isFinite() ? this.getNextVertex(t3) : this.removeVertex(t3, true);
    }
  }
  queryVertexIterator(t2 = bm) {
    return this.queryVertexIteratorEx(false, t2);
  }
  queryVertexIteratorEx(t2, e5 = bm) {
    let s4 = bm, n6 = bm, i2 = bm, r = bm, o2 = 0, a2 = false;
    for (s4 = e5 !== bm ? e5 : this.getFirstGeometry(); s4 !== bm; s4 = this.getNextGeometry(s4)) if (!t2 || h(this.getGeometryType(s4))) {
      for (n6 = this.getFirstPath(s4); n6 !== bm; n6 = this.getNextPath(n6)) if (i2 = this.getFirstVertex(n6), r = i2, o2 = 0, i2 !== bm) {
        a2 = true;
        break;
      }
      if (a2 || e5 !== bm) break;
    }
    return a2 || (s4 = bm), wm.create_(this, s4, n6, i2, r, o2, t2, false, e5 !== bm);
  }
  queryVertexIteratorOnSelection(t2 = bm) {
    return this.m_selection ? wm.create_(this, t2, bm, bm, bm, -1, false, true, t2 !== bm) : this.queryVertexIteratorEx(false, t2);
  }
  hasSelection() {
    return this.m_selection;
  }
  createEmptySelection() {
    n2(0);
  }
  removeSelection() {
    this.m_selection && (this.m_selectedVertices.length = 0, this.removeUserIndex(this.m_selectionIndex), this.m_selectionIndex = -1, this.m_selection = false, this.m_selectedCount = 0);
  }
  select(t2) {
    return !!this.selected(t2) || (this.setUserIndex(t2, this.m_selectionIndex, this.m_selectedVertices.length), this.m_selectedVertices.push(t2), this.m_selectedCount++, false);
  }
  unselect(t2) {
    if (!this.m_selection) return;
    const e5 = this.getUserIndex(t2, this.m_selectionIndex);
    e5 >= 0 && (this.m_selectedVertices[e5] = bm, this.setUserIndex(t2, this.m_selectionIndex, -1), this.m_selectedCount--);
  }
  selected(t2) {
    return !this.m_selection || this.selected_(t2);
  }
  getSelectedCount() {
    return this.m_selection ? this.m_selectedCount : this.getTotalPointCount();
  }
  createSelectionForCrackingAndClustering(t2, e5) {
    return n2(0), false;
  }
  peelALoop(t2, e5) {
    this.peelALoop_(t2, e5, false);
  }
  peelALoopIntoAPath(t2, e5) {
    return this.peelALoop_(t2, e5, true);
  }
  applyTransformation(t2) {
    if (this.m_verticesMp.applyTransformation(t2), null !== this.m_segments) for (let e5 = 0, s4 = this.m_segments.length; e5 < s4; e5++) this.m_segments[e5] && this.m_segments[e5].applyTransformation(t2);
  }
  setGeometryType(t2, e5) {
    this.m_geometryIndexList.setField(t2, 2, e5);
  }
  splitSegmentWithIntersector(t2, e5, s4, n6, i2) {
    n6 ? this.splitSegmentForward(t2, e5, s4, true, i2) : this.splitSegmentBackward(t2, e5, s4, true, i2);
  }
  setPrevVertex(t2, e5) {
    this.m_vertexIndexList.setField(t2, 1, e5);
  }
  setNextVertex(t2, e5) {
    this.m_vertexIndexList.setField(t2, 2, e5);
  }
  setPathToVertex(t2, e5) {
    this.m_vertexIndexList.setField(t2, 3, e5);
  }
  setPathSize(t2, e5) {
    this.m_pathIndexList.setField(t2, 3, e5);
  }
  setFirstVertex(t2, e5) {
    this.m_pathIndexList.setField(t2, 4, e5);
  }
  setLastVertex(t2, e5) {
    this.m_pathIndexList.setField(t2, 5, e5);
  }
  getSegment(t2) {
    if (null != this.m_segments) {
      const e5 = this.getVertexIndex(t2);
      return this.getSegmentFromIndex(e5);
    }
    return null;
  }
  isCurve(t2) {
    return n2(0), false;
  }
  querySegment(t2, e5, s4 = true, n6 = false) {
    const i2 = this.getNextVertex(t2);
    if (i2 === bm) return false;
    const r = this.getSegment(t2);
    if (!r) return !s4 && (this.queryLineConnector(t2, e5.createLine(), n6), true);
    if (e5.copyFrom(r, true), n6) return true;
    if (this.m_vertexDescription.getAttributeCount() > 1) {
      const s5 = this.getHelperPoint();
      this.queryPoint(t2, s5), e5.get().setStart(s5), this.queryPoint(i2, s5), e5.get().setEnd(s5);
    }
    return true;
  }
  getSegmentFromIndex(t2) {
    const e5 = null !== this.m_segments && this.m_segments.length > t2 ? this.m_segments[t2] : null;
    return e5 || null;
  }
  getAndClearSegmentFromIndex(t2) {
    const e5 = null !== this.m_segments && this.m_segments.length > t2 ? this.m_segments[t2] : null;
    return e5 || null;
  }
  setSegmentToIndex(t2, e5) {
    if (this.m_hasForceSetEnvelope = 0, null === this.m_segments) {
      if (!e5) return;
      this.m_segments = [], this.m_segments.length = this.m_vertices.getPointCount();
    }
    t2 >= this.m_segments.length && (this.m_segments.length = t2 + 1), this.m_segments[t2] = e5;
  }
  setGeometryPathCount(t2, e5) {
    this.m_geometryIndexList.setField(t2, 6, e5);
  }
  setGeometryVertexCount(t2, e5) {
    this.m_geometryIndexList.setField(t2, 5, e5);
  }
  ringParentageCheckInternal(t2, e5) {
    return n2(0), false;
  }
  reverseRingInternal(t2) {
    const e5 = this.hasCurves(), s4 = this.hasSegmentParentage();
    let n6 = null, i2 = -1, r = t2;
    if (e5) {
      const t3 = this.getVertexIndex(r);
      n6 = this.getAndClearSegmentFromIndex(t3);
    }
    s4 && (i2 = this.getSegmentParentage(r));
    do {
      const t3 = this.getPrevVertex(r), o2 = this.getNextVertex(r);
      if (this.setNextVertex(r, t3), this.setPrevVertex(r, o2), e5) {
        const t4 = this.getVertexIndex(o2), e6 = this.getSegmentFromIndex(t4);
        n6 && n6.reverse(), this.setSegmentToIndex(t4, n6), n6 = e6;
      }
      if (s4) {
        const t4 = this.getSegmentParentage(o2);
        this.setSegmentParentagePreserveBreak(o2, i2), i2 = t4;
      }
      r = o2;
    } while (r !== t2);
    this.dbgVerifyIntegrity(t2);
  }
  setTotalPointCount(t2) {
    this.m_pointCount = t2;
  }
  removePathOnly(t2) {
    const e5 = this.getPrevPath(t2), s4 = this.getNextPath(t2), n6 = this.getGeometryFromPath(t2);
    e5 !== bm ? this.setNextPath(e5, s4) : this.setFirstPath(n6, s4), s4 !== bm ? this.setPrevPath(s4, e5) : this.setLastPath(n6, e5), this.setFirstVertex(t2, bm), this.setLastVertex(t2, bm), this.freePath(t2);
  }
  insertClosedPath(t2, e5, s4, n6, i2) {
    const r = this.insertPath(t2, bm);
    let o2 = 0, a2 = s4;
    for (i2[0] = false; ; ) {
      a2 === n6 && (i2[0] = true), this.setPathToVertex(a2, r), o2++;
      const t3 = this.getNextVertex(a2);
      if (t3 === s4) break;
      a2 = t3;
    }
    return this.setClosedPath(r, true), this.setPathSize(r, o2), i2[0] && (s4 = n6), this.setFirstVertex(r, s4), this.setLastVertex(r, this.getPrevVertex(s4)), this.setRingAreaValid(r, false), r;
  }
  findVertex2D(t2, e5) {
    return n2(0), 0;
  }
  findVertex3D(t2, e5, n6) {
    return n2(0), 0;
  }
  dbgVerifyMonotone() {
  }
  dbgCheckSelection() {
  }
  dbgVerifySegment(t2) {
  }
  dbgVerifyIntegrity(t2, e5 = true) {
  }
  dbgVerifyVertexCounts() {
  }
  dbgVerifyCurves() {
  }
  dbgDumpGeometry(t2, e5) {
  }
  removeVertexInternal(t2, e5) {
    const s4 = this.getPrevVertex(t2), n6 = this.getNextVertex(t2);
    s4 !== bm && this.setNextVertex(s4, n6), n6 !== bm && this.setPrevVertex(n6, s4);
    if (this.hasCurves() && s4 !== bm && n6 !== bm) {
      const i2 = this.getVertexIndex(t2), r = this.getVertexIndex(s4), o2 = this.getVertexIndex(n6);
      if (e5) {
        const t3 = this.getSegmentFromIndex(r);
        if (null !== t3) {
          const e6 = this.m_vertices.getXY(o2);
          t3.setEndXY(e6), t3.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(i2, null);
      } else {
        const t3 = this.getSegmentFromIndex(i2);
        if (this.setSegmentToIndex(i2, null), null !== t3) {
          const e6 = this.m_vertices.getXY(r);
          t3.setStartXY(e6), t3.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r, t3);
      }
    }
    return this.freeVertex(t2), n6;
  }
  isRingAreaValid(t2) {
    return !!(4 & this.getPathFlags(t2));
  }
  setRingAreaValid(t2, e5) {
    const s4 = (4 | this.getPathFlags(t2)) - 4;
    this.setPathFlags(t2, s4 | (e5 ? 4 : 0));
  }
  compareVerticesSimpleY(t2, e5) {
    return this.queryXY(t2, this.m_workPoint2D), this.queryXY(e5, this.m_workPoint2_2D), this.m_workPoint2D.compare(this.m_workPoint2_2D);
  }
  compareVerticesSimpleY3D(t2, e5) {
    return this.getXYZ(t2).compare(this.getXYZ(e5));
  }
  compareVerticesSimpleX(t2, e5) {
    return this.getXY(t2).compareX(this.getXY(e5));
  }
  sortVerticesSimpleByYHeapMerge(t2, e5) {
    n2(0);
  }
  sortVerticesSimpleByY(t2, e5, s4) {
    this.m_bucketSort.sort(t2, e5, s4, new Sm(this));
  }
  sortVerticesSimpleByX(t2, e5, n6) {
    n2(0);
  }
  sortVerticesSimpleByY3D(t2, e5, n6) {
    n2(0);
  }
  snapVertexForPoleClipping(t2, e5) {
    const s4 = this.getPrevVertex(t2);
    s4 !== bm && this.replaceCurveWithLine(s4);
    this.getNextVertex(t2) !== bm && this.replaceCurveWithLine(t2);
    const n6 = new ei();
    this.queryXY(t2, n6), n6.y = e5, this.setXY(t2, n6);
  }
  setSegmentParentageAndBreak(t2, e5, n6 = true) {
    if (-1 === this.m_segmentParentageIndex) {
      if (-1 === e5) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    e5 >= 0 && (n2(e5 <= os() >> 1), e5 <<= 1, e5 |= n6 ? 1 : 0), this.setUserIndex(t2, this.m_segmentParentageIndex, e5);
  }
  setSegmentParentagePreserveBreak(t2, e5) {
    if (n2(e5 >= -1), -1 === this.m_segmentParentageIndex) {
      if (-1 === e5) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    if (e5 >= 0) {
      n2(e5 <= os() >> 1), e5 <<= 1;
      e5 |= this.getSegmentParentageBreakVertex(t2) ? 1 : 0;
    }
    this.setUserIndex(t2, this.m_segmentParentageIndex, e5);
  }
  getSegmentParentage(t2) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const e5 = this.getUserIndex(t2, this.m_segmentParentageIndex);
    return e5 < 0 ? e5 : e5 >> 1;
  }
  getOriginalSegmentInfo(t2) {
    if (-1 !== this.m_segmentParentageIndex) {
      const e5 = this.getSegmentParentage(t2);
      return new Am(e5);
    }
    return new Am(-1);
  }
  setSegmentParentageBreakVertex(t2, e5) {
    if (-1 === this.m_segmentParentageIndex) return;
    let s4 = this.getUserIndex(t2, this.m_segmentParentageIndex);
    s4 < 0 || !!(1 & s4) !== e5 && (e5 ? s4 |= 1 : s4 &= os() >> 1 << 1, this.setUserIndex(t2, this.m_segmentParentageIndex, s4));
  }
  getSegmentParentageBreakVertex(t2) {
    if (-1 === this.m_segmentParentageIndex) return true;
    const e5 = this.getUserIndex(t2, this.m_segmentParentageIndex);
    return e5 < 0 || !!(1 & e5);
  }
  isDiscontinuousSegmentParentage(t2) {
    const e5 = this.getPrevVertex(t2);
    if (e5 === bm) return false;
    return this.getSegmentParentage(e5) !== this.getSegmentParentage(t2);
  }
  setCurveStitcherPointer(t2) {
    this.m_curveStitcher = t2;
  }
  hasSegmentParentage() {
    return -1 !== this.m_segmentParentageIndex;
  }
  deleteSegmentParentage() {
    -1 !== this.m_segmentParentageIndex && (this.removeUserIndex(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), this.m_curveStitcher = null;
  }
  clearSegments() {
    this.m_segments = null;
  }
};
function Im(t2) {
  if (t2.isEmpty()) return new eh({ vd: t2.getDescription() });
  const e5 = t2.getImpl(), s4 = e5.getPointCount();
  if (s4 <= 2) {
    if (1 === s4 || e5.getXY(0).equals(e5.getXY(1))) {
      const t3 = new ee({ vd: e5.getDescription() });
      return e5.getPointByVal(0, t3), t3;
    }
    {
      const t3 = new ee(), s5 = new Na({ vd: e5.getDescription() });
      return e5.getPointByVal(0, t3), s5.startPathPoint(t3), e5.getPointByVal(1, t3), s5.lineToPoint(t3), s5;
    }
  }
  const n6 = e5.getAttributeStreamRef(0), i2 = new qm({ stream: n6, n: s4 });
  let r = 0, o2 = 1;
  const a2 = n6.readPoint2D(r << 1), h2 = new ei();
  for (; o2 < s4 && n6.queryPoint2D(o2 << 1, h2).equals(a2); ) o2++;
  if (i2.m_treeHull.addElement(r), o2 < s4) {
    i2.m_treeHull.addBiggestElement(o2);
    const t3 = new ei();
    for (let s5 = o2 + 1; s5 < e5.getPointCount(); s5++) {
      n6.queryPoint2D(s5 << 1, t3);
      const e6 = i2.treeHull(t3);
      -1 !== e6 && i2.m_treeHull.setElement(e6, s5);
    }
  }
  const m2 = e5.getDescription(), u = m2.getAttributeCount() > 1, l2 = i2.m_treeHull.size();
  let c = null;
  if (l2 >= 2) {
    c = l2 >= 3 ? new eh({ vd: m2 }) : new Na({ vd: m2 });
    const t3 = c.getImpl();
    t3.reserve(i2.m_treeHull.size()), t3.addPathPoint2D(null, 0, true);
    const s5 = new ei();
    for (let r2 = i2.m_treeHull.getFirst(); -1 !== r2; r2 = i2.m_treeHull.getNext(r2)) if (u) {
      const s6 = new ee();
      e5.getPointByVal(i2.m_treeHull.getElement(r2), s6), t3.insertPoint(0, -1, s6);
    } else n6.queryPoint2D(i2.m_treeHull.getElement(r2) << 1, s5), t3.insertPoint2D(0, -1, s5);
  } else if (u) {
    const t3 = new ee({ vd: m2 });
    e5.getPointByVal(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()), t3), c = t3;
  } else {
    const t3 = n6.readPoint2D(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()) << 1);
    c = new ee(t3);
  }
  return c;
}
function Mm(t2, e5, n6) {
  if (e5 <= 262144) return Lm(t2, e5, n6);
  n2(0);
  const i2 = new qm({ points: t2, n: e5 }), r = 0;
  let o2 = 1;
  const a2 = t2[r].clone();
  for (; o2 < e5 && t2[o2].equals(a2); ) o2++;
  if (i2.m_treeHull.addElement(r), o2 < e5) {
    i2.m_treeHull.addBiggestElement(o2);
    for (let s4 = o2 + 1; s4 < e5; s4++) {
      const e6 = t2[s4], n7 = i2.treeHull(e6);
      -1 !== n7 && i2.m_treeHull.setElement(n7, s4);
    }
  }
  let h2 = 0;
  for (let s4 = i2.m_treeHull.getFirst(); -1 !== s4; s4 = i2.m_treeHull.getNext(s4)) n6[h2++] = i2.m_treeHull.getElement(s4);
  return h2;
}
function Ym(t2, e5, s4) {
  const n6 = t2.getImpl(), i2 = n6.getPathStart(e5), r = n6.getPathEnd(e5), o2 = !n6.isClosedPath(e5) && n6.isClosedPathInXYPlane(e5), a2 = n6.getAttributeStreamRef(0), h2 = 2 * i2;
  let m2 = 2 * r;
  if (o2 && (m2 -= 2), m2 - h2 < 6) return true;
  const u = a2.readPoint2D(h2), l2 = a2.readPoint2D(h2 + 2), c = a2.readPoint2D(h2 + 4);
  if (!Rm(ei.orientationRobust(l2, c, u))) return false;
  const g2 = l2.clone(), d2 = new ei();
  for (let _ = h2 + 6; _ < m2; _ += 2) {
    d2.assign(l2), l2.assign(c), a2.queryPoint2D(_, c);
    if (!Rm(ei.orientationRobust(l2, c, u))) return false;
    if (!Rm(ei.orientationRobust(g2, c, u))) return false;
    if (!Rm(ei.orientationRobust(l2, c, d2))) return false;
  }
  return true;
}
function Xm(t2, e5, s4, n6, r) {
  if (s4.setNAN(), n6.setCoords(1, 0), r.setCoords(0, 0), t2.isEmpty()) return;
  if (t2.getGeometryType() === a.enumPoint) return void s4.assign(t2.getXY());
  const o2 = t2, a2 = o2.getPointCount();
  if (2 === a2) {
    const t3 = o2.getXY(0), e6 = o2.getXY(1);
    s4.assign(t3.add(e6).mul(0.5));
    const i2 = e6.sub(t3);
    n6 = Bm(i2), r.setCoords(0.5 * i2.length(), 0);
  } else {
    let t3 = Number.MAX_VALUE;
    const i2 = [0, 1, 0, 0], h2 = new jt(4, 2);
    for (h2.set(0, 0, 0), h2.set(0, 1, 1), h2.set(1, 0, 1), h2.set(1, 1, 2); i2[0] < a2; ++i2[0], Gm(h2, 0, a2)) {
      i2[1] === i2[0] && (++i2[1], Gm(h2, 1, a2));
      for (let t4 = 1; ; ++t4) {
        for (; ; ) {
          const e6 = Wm(o2.getXY(h2.get(0, 0)), o2.getXY(h2.get(0, 1)), o2.getXY(h2.get(t4, 0)), o2.getXY(h2.get(t4, 1)), 2 ^ t4);
          if (e6 > 0) break;
          if (++i2[t4], Gm(h2, t4, a2), 0 === e6) break;
        }
        if (3 === t4) break;
        i2[t4 + 1] < i2[t4] && (i2[t4 + 1] = i2[t4], h2.set(t4 + 1, 0, h2.get(t4, 0)), h2.set(t4 + 1, 1, h2.get(t4, 1)));
      }
      const m2 = o2.getXY(h2.get(0, 0)).add(o2.getXY(h2.get(2, 0))).mul(0.5), u = Bm(o2.getXY(h2.get(0, 1)).sub(o2.getXY(h2.get(0, 0)))), l2 = new ei();
      let c, g2;
      if (l2.x = Math.max(0, u.dotProduct(o2.getXY(h2.get(1, 0)).sub(o2.getXY(h2.get(3, 0))))), l2.y = Math.max(0, u.crossProduct(o2.getXY(h2.get(0, 0)).sub(o2.getXY(h2.get(2, 0))))), e5 ? (c = l2.x * l2.y, g2 = c < t3) : (c = l2.y, g2 = c < t3), g2) {
        t3 = c;
        const e6 = o2.getXY(h2.get(1, 0)), i3 = o2.getXY(h2.get(3, 0)), a3 = e6.add(i3).mul(0.5).sub(m2);
        s4.assign(m2.add(u.mul(u.dotProduct(a3)))), n6.assign(u), r.assign(l2);
      }
    }
    r.mulThis(0.5), r.x < r.y && (r.y = Mt(r.x, r.x = r.y), n6.leftPerpendicularThis());
  }
  n6.y < 0 ? n6.negateThis() : 0 === n6.y && (n6.x = 1);
}
Tm.st_defaultRank = 1;
var Nm = class {
  constructor(t2) {
    this.m_handleP = -1, this.m_handleQ = -1, this.m_currentSupport = -1, this.m_area = 0, this.m_bDone = true, n2(0), this.m_convexHull = t2, this.m_function = this.done_;
  }
  next() {
    return n2(0), false;
  }
  get_vertex_handle_p() {
    return n2(0), 0;
  }
  get_vertex_handle_q() {
    return n2(0), 0;
  }
  get_current_support() {
    return n2(0), 0;
  }
  getNext(t2) {
    return n2(0), 0;
  }
  getPrev(t2) {
    return n2(0), 0;
  }
  intialize_() {
    return n2(0), false;
  }
  increment_() {
    return n2(0), false;
  }
  increment_q_() {
    return n2(0), false;
  }
  increment_p_() {
    return n2(0), false;
  }
  parallel_edge_with_q_support_() {
    return n2(0), false;
  }
  parallel_edge_with_p_support_() {
    return n2(0), false;
  }
  done_() {
    return n2(0), false;
  }
};
var qm = class {
  nullGetXY(t2) {
    return b("m_getXY is null"), {};
  }
  nullDeleteNode(t2) {
    b("m_deleteNode is null");
  }
  constructor(t2) {
    return this.m_treeHull = new ct2(), this.m_shape = null, this.m_stream = null, this.m_points = null, this.m_geometryHandle = -1, this.m_pathHandle = -1, this.m_getXY = this.nullGetXY, this.m_deleteNode = this.nullDeleteNode, t2 ? t2.stream ? (this.m_treeHull.setCapacity(Math.min(20, t2.n)), this.m_stream = t2.stream, this.m_getXY = this.getXYStream, this.m_deleteNode = this.deleteNodeStream, this.m_points = null, this.m_geometryHandle = bm, void (this.m_pathHandle = bm)) : t2.points ? (this.m_treeHull.setCapacity(Math.min(20, t2.n)), this.m_points = t2.points, this.m_getXY = this.getXYPoints, this.m_deleteNode = this.deleteNodePoints, this.m_stream = null, this.m_geometryHandle = bm, void (this.m_pathHandle = bm)) : void C("unrecognized constructor parameter") : (this.m_treeHull.setCapacity(20), this.m_shape = new Tm(), this.m_geometryHandle = this.m_shape.createGeometry(a.enumMultiPoint), this.m_pathHandle = this.m_shape.insertPath(this.m_geometryHandle, bm), this.m_getXY = this.getXYShape, this.m_deleteNode = this.deleteNodeShape, this.m_stream = null, void (this.m_points = null));
  }
  getXYShape(t2) {
    return this.m_shape.getXY(t2);
  }
  getXYStream(t2) {
    return this.m_stream.readPoint2D(t2 << 1);
  }
  getXYPoints(t2) {
    return n2(0), new ei();
  }
  deleteNodeShape(t2) {
    const e5 = this.m_treeHull.getElement(t2);
    this.m_treeHull.deleteNode(t2), this.m_shape.removeVertex(e5, false);
  }
  deleteNodeStream(t2) {
    this.m_treeHull.deleteNode(t2);
  }
  deleteNodePoints(t2) {
    n2(0);
  }
  addGeometry(s4) {
    if (s4.isEmpty()) return;
    const n6 = s4.getGeometryType();
    if (n6 === a.enumGeometryCollection) {
      const t2 = s4;
      for (let e5 = 0, s5 = t2.getGeometryCount(); e5 < s5; e5++) this.addGeometry(t2.getGeometry(e5));
    } else y(n6) ? this.addMultiVertexGeometry(s4) : f(n6) ? this.addSegment(s4) : n6 === a.enumEnvelope ? this.addEnvelope(s4) : n6 === a.enumPoint ? this.addPoint(s4) : P("Convex_hull: geometry not supported");
  }
  getBoundingGeometry() {
    const t2 = new ee(), e5 = this.m_treeHull.getFirst(), s4 = new eh({ vd: this.m_shape.getVertexDescription() });
    if (0 === this.m_treeHull.size()) return s4;
    s4.reserve(this.m_treeHull.size()), this.m_shape.queryPoint(this.m_treeHull.getElement(e5), t2), s4.startPathPoint(t2);
    for (let n6 = this.m_treeHull.getNext(e5); -1 !== n6; n6 = this.m_treeHull.getNext(n6)) this.m_shape.queryPoint(this.m_treeHull.getElement(n6), t2), s4.lineToPoint(t2);
    return s4;
  }
  getAntipodalPairsIterator() {
    return n2(0), new Nm(this);
  }
  getXY(t2) {
    return n2(0), new ei();
  }
  getXYWithIndex(t2) {
    return n2(0), new ei();
  }
  getFirst() {
    return n2(0), 0;
  }
  getLast() {
    return n2(0), 0;
  }
  getNext(t2) {
    return n2(0), 0;
  }
  getPrev(t2) {
    return n2(0), 0;
  }
  getVertexIndex(t2) {
    return n2(0), 0;
  }
  getPointCount() {
    return n2(0), 0;
  }
  addMultiVertexGeometry(t2) {
    const e5 = new ee(), s4 = t2.getImpl(), n6 = new ei();
    for (let i2 = 0; i2 < t2.getPointCount(); i2++) {
      s4.queryXY(i2, n6);
      const r = this.addPoint2D(n6);
      if (-1 !== r) {
        t2.getPointByVal(i2, e5);
        const s5 = this.m_shape.addPoint(this.m_pathHandle, e5);
        this.m_treeHull.setElement(r, s5);
      }
    }
  }
  addEnvelope(t2) {
    const e5 = new ee();
    for (let s4 = 0; s4 < 4; s4++) {
      const n6 = new ei();
      t2.queryCorner(s4, n6);
      const i2 = this.addPoint2D(n6);
      if (-1 !== i2) {
        t2.queryCornerByVal(s4, e5);
        const n7 = this.m_shape.addPoint(this.m_pathHandle, e5);
        this.m_treeHull.setElement(i2, n7);
      }
    }
  }
  addSegment(t2) {
    const e5 = new ee(), s4 = t2.getStartXY(), n6 = this.addPoint2D(s4);
    if (-1 !== n6) {
      t2.queryStart(e5);
      const s5 = this.m_shape.addPoint(this.m_pathHandle, e5);
      this.m_treeHull.setElement(n6, s5);
    }
    const i2 = t2.getEndXY(), r = this.addPoint2D(i2);
    if (-1 !== r) {
      t2.queryEnd(e5);
      const s5 = this.m_shape.addPoint(this.m_pathHandle, e5);
      this.m_treeHull.setElement(r, s5);
    }
  }
  addPoint(t2) {
    const e5 = t2.getXY(), s4 = this.addPoint2D(e5);
    if (-1 !== s4) {
      const e6 = this.m_shape.addPoint(this.m_pathHandle, t2);
      this.m_treeHull.setElement(s4, e6);
    }
  }
  addPoint2D(t2) {
    let e5 = -1;
    if (0 === this.m_treeHull.size()) return e5 = this.m_treeHull.addElement(-4), e5;
    if (1 === this.m_treeHull.size()) {
      const s4 = this.m_treeHull.getElement(this.m_treeHull.getFirst()), n6 = this.m_shape.getXY(s4);
      return t2.equals(n6) || (e5 = this.m_treeHull.addBiggestElement(-5)), e5;
    }
    return e5 = this.treeHull(t2), e5;
  }
  treeHull(t2) {
    let e5 = -1;
    do {
      const s4 = this.m_treeHull.getFirst(), n6 = this.m_treeHull.getLast(), i2 = this.m_treeHull.getElement(s4), r = this.m_treeHull.getElement(n6), o2 = this.m_getXY(i2), a2 = this.m_getXY(r), h2 = ei.orientationRobust(a2, t2, o2);
      if (Rm(h2)) {
        e5 = this.m_treeHull.addBiggestElement(-1);
        const i3 = this.treeHullWalkBackward(t2, n6, s4);
        i3 !== s4 && this.treeHullWalkForward(t2, s4, this.m_treeHull.getPrev(i3));
        break;
      }
      if (zm(h2)) {
        let i3 = this.m_treeHull.getRoot(), r2 = this.m_treeHull.getFirst(), a3 = this.m_treeHull.getLast(), h3 = -1, m2 = -1, u = -1;
        for (; r2 !== this.m_treeHull.getPrev(a3); ) {
          m2 = this.m_treeHull.getElement(i3);
          const e6 = this.m_getXY(m2);
          zm(ei.orientationRobust(e6, t2, o2)) ? (a3 = i3, i3 = this.m_treeHull.getLeft(i3)) : (r2 = i3, i3 = this.m_treeHull.getRight(i3));
        }
        i3 = a3, h3 = r2, m2 = this.m_treeHull.getElement(i3), u = this.m_treeHull.getElement(h3);
        const l2 = this.m_getXY(m2), c = this.m_getXY(u);
        if (h3 !== s4) {
          if (!Rm(ei.orientationRobust(c, t2, l2))) break;
        }
        e5 = this.m_treeHull.addElementAtPosition(h3, i3, -2, true, false), this.treeHullWalkForward(t2, i3, n6), this.treeHullWalkBackward(t2, h3, s4);
        break;
      }
      {
        const i3 = km(t2, a2, o2);
        if (-1 === i3) {
          const i4 = this.m_treeHull.getPrev(n6);
          this.m_treeHull.deleteNode(n6), e5 = this.m_treeHull.addBiggestElement(-3), this.treeHullWalkBackward(t2, i4, s4);
        } else if (1 === i3) {
          const i4 = this.m_treeHull.getNext(s4);
          this.m_treeHull.deleteNode(s4), e5 = this.m_treeHull.addElementAtPosition(-1, i4, -3, true, false), this.treeHullWalkForward(t2, i4, n6);
        }
        break;
      }
    } while (0);
    return e5;
  }
  treeHullWalkForward(t2, e5, s4) {
    if (e5 === s4) return s4;
    let n6 = e5, i2 = this.m_treeHull.getElement(n6), r = this.m_treeHull.getNext(n6);
    const o2 = this.m_getXY(i2);
    for (; n6 !== s4 && this.m_treeHull.size() > 2; ) {
      const e6 = this.m_treeHull.getElement(r), s5 = this.m_getXY(e6);
      if (Rm(ei.orientationRobust(s5, t2, o2))) break;
      const a2 = n6;
      n6 = r, i2 = e6, o2.assign(s5), r = this.m_treeHull.getNext(n6), this.m_deleteNode(a2);
    }
    return n6;
  }
  treeHullWalkBackward(t2, e5, s4) {
    if (e5 === s4) return s4;
    let n6 = e5, i2 = this.m_treeHull.getElement(n6), r = this.m_treeHull.getPrev(n6);
    const o2 = this.m_getXY(i2);
    for (; n6 !== s4 && this.m_treeHull.size() > 2; ) {
      const e6 = this.m_treeHull.getElement(r), s5 = this.m_getXY(e6);
      if (Rm(ei.orientationRobust(o2, t2, s5))) break;
      const a2 = n6;
      n6 = r, i2 = e6, o2.assign(s5), r = this.m_treeHull.getPrev(n6), this.m_deleteNode(a2);
    }
    return n6;
  }
};
function Fm(t2, e5, s4) {
  const n6 = e5.sub(t2), i2 = s4.sub(e5);
  if (0 === n6.x) return i2.x > 0 ? -1 : 0;
  if (0 === n6.y) return i2.y > 0 ? 1 : i2.y < 0 ? -1 : 0;
  const r = n6.crossProduct(i2), o2 = 4 * Number.EPSILON * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o2 ? 1 : r < -o2 ? -1 : ei.orientationRobust(t2, e5, s4);
}
function Vm(t2, e5, s4) {
  const n6 = e5.sub(t2), i2 = s4.sub(e5);
  if (0 === n6.x) return i2.x < 0 ? -1 : 0;
  if (0 === n6.y) return i2.y > 0 ? -1 : i2.y < 0 ? 1 : 0;
  const r = n6.crossProduct(i2), o2 = 4 * Number.EPSILON * (Math.abs(i2.x * n6.y) + Math.abs(i2.y * n6.x));
  return r > o2 ? 1 : r < -o2 ? -1 : ei.orientationRobust(t2, e5, s4);
}
function Lm(t2, e5, s4) {
  const n6 = new st2(0);
  for (let a2 = 0; a2 < e5; a2++) n6.add(a2);
  const i2 = { userSort(e6, s5, n7) {
    n7.sort(e6, s5, (e7, s6) => t2[e7].compareX(t2[s6]));
  }, getValue: (e6) => t2[e6].x };
  ht.sortEx(n6, 0, e5, i2);
  let r = 0;
  t: for (let a2 = 0; a2 < e5; ++a2) {
    const e6 = n6.read(a2);
    for (; r >= 2; ) {
      const i3 = s4[r - 2], o3 = s4[r - 1];
      if (t2[o3].equals(t2[e6])) {
        n6.write(a2, -1);
        continue t;
      }
      if (!(Fm(t2[i3], t2[o3], t2[e6]) >= 0)) {
        o3 === n6.read(a2 - 1) && n6.write(a2 - 1, -1);
        break;
      }
      r--;
    }
    s4[r++] = e6, 2 === r && t2[e6].equals(t2[s4[0]]) && (n6.write(1, -1), r--);
  }
  const o2 = r + 1;
  t: for (let a2 = e5 - 2; a2 >= 0; --a2) {
    const e6 = n6.read(a2);
    if (!(e6 < 0)) {
      for (; r >= o2; ) {
        const n7 = s4[r - 2], i3 = s4[r - 1];
        if (t2[i3].equals(t2[e6])) continue t;
        if (!(Vm(t2[n7], t2[i3], t2[e6]) >= 0)) break;
        r--;
      }
      if (0 !== a2) {
        const n7 = s4[r - 1];
        s4[r++] = e6, t2[e6].equals(t2[n7]) && r--;
      }
    }
  }
  return r > 1 && t2[s4[0]].equals(t2[s4[r - 1]]) && r--, r;
}
function Rm(t2) {
  return t2 < 0;
}
function zm(t2) {
  return t2 > 0;
}
function km(t2, e5, s4) {
  let n6 = -1;
  if (e5.y === s4.y) n6 = 0;
  else if (e5.x === s4.x) n6 = 1;
  else {
    n6 = Math.abs(e5.x - s4.x) >= Math.abs(e5.y - s4.y) ? 0 : 1;
  }
  let i2 = -1;
  return i2 = e5[n6] < s4[n6] ? t2[n6] < e5[n6] ? -1 : s4[n6] < t2[n6] ? 1 : 0 : e5[n6] < t2[n6] ? -1 : t2[n6] < s4[n6] ? 1 : 0, i2;
}
function Bm(t2) {
  return (t2 = t2.clone()).divThis(Math.max(Math.abs(t2.x), Math.abs(t2.y))), t2.normalize(), t2;
}
function Gm(t2, e5, s4) {
  t2.inc(e5, 0) === s4 && t2.set(e5, 0, 0), t2.inc(e5, 1) === s4 && t2.set(e5, 1, 0);
}
function Wm(t2, s4, n6, i2, r) {
  switch (r) {
    case 0:
      break;
    case 1:
      s4.rightPerpendicularThis(), t2.rightPerpendicularThis();
      break;
    case 2:
      s4.negateThis(), t2.negateThis();
      break;
    case 3:
      s4.leftPerpendicularThis(), t2.leftPerpendicularThis();
      break;
    default:
      P("");
  }
  return ei.orientationRobustEx(t2, s4, n6, i2);
}
function jm(t2, e5, s4, n6, i2) {
  return Zm(t2, false, e5, s4, n6, i2);
}
function Zm(t2, e5, s4, n6, r, o2) {
  const a2 = s4.getGeometryType(), m2 = n6.getGeometryType(), u = Math.max(r, Oe(s4, n6));
  if (a2 === a.enumLine && m2 === a.enumLine) return _s(s4, n6, u, o2);
  let l2 = s4, c = n6, g2 = s4.getStartXY(), d2 = s4.getEndXY();
  if (g2.compare(d2) > 0 && (l2 = s4.clone().reverse()), g2 = n6.getStartXY(), d2 = n6.getEndXY(), g2.compare(d2) > 0 && (c = n6.clone().reverse()), e5) {
    if (s4.equals(n6)) return 2;
    if (Xe(s4, n6, u)) return 4;
  }
  switch (a2) {
    case a.enumLine:
      switch (m2) {
        case a.enumEllipticArc:
          return um(t2, c, l2, u, o2);
        case a.enumBezier:
          return Jo(t2, c, l2, u, o2);
        case a.enumRationalBezier2:
          return Fi(t2, c, l2, u, o2);
        case a.enumBezier2:
          return zr(t2, c, l2, u, o2);
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (m2) {
        case a.enumLine:
          return um(t2, l2, c, u, o2);
        case a.enumEllipticArc:
          return lm(t2, l2, c, u, o2);
        case a.enumBezier:
          return Ko(t2, c, l2, u, o2);
        case a.enumRationalBezier2:
          return Vi(t2, c, l2, u, o2);
        case a.enumBezier2:
          return kr(t2, c, l2, u, o2);
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (m2) {
        case a.enumLine:
          return Jo(t2, l2, c, u, o2);
        case a.enumEllipticArc:
          return Ko(t2, l2, c, u, o2);
        case a.enumBezier:
          return $o(t2, l2, c, u, o2);
        case a.enumRationalBezier2:
          return ta(t2, l2, c, u, o2);
        case a.enumBezier2:
          return ea(t2, l2, c, u, o2);
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (m2) {
        case a.enumLine:
          return Fi(t2, l2, c, u, o2);
        case a.enumEllipticArc:
          return Vi(t2, l2, c, u, o2);
        case a.enumBezier:
          return ta(t2, c, l2, u, o2);
        case a.enumRationalBezier2:
          return Ri(t2, l2, c, u, o2);
        case a.enumBezier2:
          return zi(t2, l2, c, u, o2);
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (m2) {
        case a.enumLine:
          return zr(t2, l2, c, u, o2);
        case a.enumEllipticArc:
          return kr(t2, l2, c, u, o2);
        case a.enumBezier:
          return ea(t2, c, l2, u, o2);
        case a.enumRationalBezier2:
          return zi(t2, c, l2, u, o2);
        case a.enumBezier2:
          return Br(t2, l2, c, u, o2);
        default:
          b("");
      }
      break;
    default:
      b("");
  }
}
function Hm(t2, e5, s4 = true) {
  if (!s4 && !Um(t2, e5)) return 0;
  const n6 = t2.isLine() && e5.isLine();
  if (t2.getStartXY().equals(e5.getStartXY()) && t2.getEndXY().equals(e5.getEndXY())) {
    const s5 = 1;
    if (n6) return s5;
    const r = t2.getGeometryType();
    if (r !== e5.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const n7 = t2, i2 = e5;
      return n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getControlPoint2().equals(i2.getControlPoint2()) ? s5 : 0;
    }
    if (r === a.enumEllipticArc) {
      return fm(t2, e5, false) ? s5 : 0;
    }
    if (r === a.enumRationalBezier2) {
      const n7 = t2, i2 = e5;
      if (n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getStandardFormWeight() === i2.getStandardFormWeight()) return s5;
    } else if (r === a.enumBezier2) {
      const n7 = e5;
      if (t2.getControlPoint1().equals(n7.getControlPoint1())) return s5;
    }
    return 0;
  }
  if (t2.getStartXY().equals(e5.getEndXY()) && t2.getEndXY().equals(e5.getStartXY())) {
    const s5 = -1;
    if (n6) return s5;
    const r = t2.getGeometryType();
    if (r !== e5.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const n7 = t2, i2 = e5;
      return n7.getControlPoint1().equals(i2.getControlPoint2()) && n7.getControlPoint2().equals(i2.getControlPoint1()) ? s5 : 0;
    }
    if (r === a.enumEllipticArc) {
      return fm(t2, e5, true) ? s5 : -1;
    }
    if (r === a.enumRationalBezier2) {
      const n7 = t2, i2 = e5;
      if (n7.getControlPoint1().equals(i2.getControlPoint1()) && n7.getStandardFormWeight() === i2.getStandardFormWeight()) return s5;
    } else if (r === a.enumBezier2) {
      const n7 = e5;
      if (t2.getControlPoint1().equals(n7.getControlPoint1())) return s5;
    }
    return 0;
  }
  return 0;
}
function Um(t2, e5) {
  const s4 = t2.getGeometryType();
  return s4 === e5.getGeometryType() && (s4 !== a.enumEllipticArc || t2.projectionBehavior() === e5.projectionBehavior());
}
function Om(t2, s4, n6, r, o2, a2, m2) {
  !o2 && a2 && P("");
  const u = s4.getGeometryType(), l2 = n6.getGeometryType(), c = Math.max(m2, Oe(s4, n6));
  if (r && (r.length = 0), o2 && (o2.length = 0), a2 && (a2.length = 0), u === a.enumLine && l2 === a.enumLine) return ps(s4, n6, r, o2, a2, c, false, false);
  let g2 = s4, d2 = n6, _ = s4.getStartXY(), p3 = s4.getEndXY(), f3 = false, P5 = false;
  _.compare(p3) > 0 && (g2 = s4.clone(true).reverse(), f3 = true), _ = n6.getStartXY(), p3 = n6.getEndXY(), _.compare(p3) > 0 && (d2 = n6.clone(true).reverse(), P5 = true);
  let y2 = 0;
  switch (u) {
    case a.enumLine:
      switch (l2) {
        case a.enumEllipticArc:
          y2 = cm(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumBezier:
          y2 = sa(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = ki(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Gr(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (l2) {
        case a.enumLine:
          y2 = cm(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = gm(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = na(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = Bi(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Wr(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = ki(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Bi(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = ra(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = Gi(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = Wi(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = Gr(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Wr(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = oa(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = Wi(t2, d2, g2, r, a2, o2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = jr(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (l2) {
        case a.enumLine:
          y2 = sa(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = na(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = ia(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumRationalBezier2:
          y2 = ra(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = oa(t2, g2, d2, r, o2, a2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    default:
      b("");
  }
  if (f3) {
    if (o2) {
      for (let t3 = 0; t3 < y2; t3++) o2[t3] = 1 - o2[t3];
      o2.reverse();
    }
    r && r.reverse(), a2 && a2.reverse();
  }
  if (P5 && a2) for (let e5 = 0; e5 < y2; e5++) a2[e5] = 1 - a2[e5];
  return y2;
}
function Qm(t2, e5, s4) {
  if (e5 === s4) return 0;
  e5 > s4 && (s4 = Mt(e5, e5 = s4));
  return t2.cut(e5, s4, true).calculateUpperLength2D();
}
function Jm(t2, e5, s4, n6, i2) {
  const r = [], o2 = [], a2 = [];
  for (let m2 = 0, u = i2; m2 < u; m2++) r.push(t2.calculateSubLengthFromStart(s4[m2])), o2.push(e5.calculateSubLengthFromStart(n6[m2])), Fs(s4[m2], 0, 1) && Fs(n6[m2], 0, 1) && t2.getCoord2D(s4[m2]).equals(e5.getCoord2D(n6[m2])) && a2.push(m2);
  if (0 === a2.length || a2.length === i2) return;
  a2.sort((t3, e6) => s4[t3] < s4[e6] ? -1 : s4[t3] > s4[e6] ? 1 : n6[t3] < n6[e6] ? -1 : n6[t3] > n6[e6] ? 1 : 0);
  let h2 = -1;
  for (const m2 of a2) {
    if (h2 >= 0 && s4[m2] === s4[h2] && s4[m2] === s4[h2]) {
      h2 = m2;
      continue;
    }
    h2 = m2;
    const a3 = [];
    a3.length = i2;
    for (let t3 = 0; t3 < a3.length; ++t3) a3[t3] = t3;
    a3.sort((t3, e6) => {
      const s5 = r[m2], n7 = o2[m2], i3 = r[t3] - s5, a4 = o2[t3] - n7, h3 = i3 * i3 + a4 * a4, u = r[e6] - s5, l2 = o2[e6] - n7, c = u * u + l2 * l2;
      return h3 < c ? -1 : h3 > c ? 1 : 0;
    });
    for (let r2 = 0; r2 < i2; r2++) {
      const i3 = a3[r2];
      if (i3 === m2 || s4[i3] === s4[m2] && n6[i3] === n6[m2] || Fs(s4[i3], 0, 1) && Fs(n6[i3], 0, 1)) continue;
      const o3 = (s5, n7, i4, r3) => {
        const o4 = new Se(), a4 = new p2();
        a4.setWithEps(1);
        const h4 = new p2();
        h4.set(n7, a4.eps()), t2.queryCoord2DE(h4, o4);
        const m3 = new Se();
        t2.queryCoord2DE(new p2(s5), m3);
        let u2 = false;
        return o4.eq(m3) && (h4.set(r3, a4.eps()), e5.queryCoord2DE(h4, o4), e5.queryCoord2DE(new p2(i4), m3), u2 = o4.eq(m3)), !u2;
      }, h3 = ei.getNAN();
      t2.queryCoord2D(s4[i3], h3);
      const u = ei.getNAN();
      e5.queryCoord2D(n6[i3], u);
      if (0 === ei.distance(h3, u) && o3(s4[m2], s4[i3], n6[m2], n6[i3])) break;
      const l2 = new x2(n6[i3], n6[m2]);
      l2.normalizeNoNAN();
      const c = new x2(s4[i3], s4[m2]);
      c.normalizeNoNAN();
      let g2 = -1, d2 = Number.POSITIVE_INFINITY, _ = Number.POSITIVE_INFINITY, p3 = s4[i3];
      h3.assign(t2.getCoord2D(p3));
      for (let r3 = 0; r3 < 5; r3++) {
        const r4 = e5.getClosestCoordinateOnInterval(h3, l2, -1);
        u.assign(e5.getCoord2D(r4));
        const a4 = ei.distance(h3, u);
        if (p3 = t2.getClosestCoordinateOnInterval(u, c, -1), p3 === s4[m2] && r4 === n6[m2]) {
          g2 = 1;
          break;
        }
        h3.assign(t2.getCoord2D(p3));
        const f3 = ei.distance(u, h3);
        if (!(f3 < _ && a4 < d2)) {
          g2 = 0;
          break;
        }
        if (0 === f3 && 0 === a4) {
          o3(s4[m2], s4[i3], n6[m2], n6[i3]) ? (s4[i3] = p3, n6[i3] = r4, g2 = 0) : g2 = 1;
          break;
        }
        _ = f3, d2 = a4;
      }
      if (-1 === g2 && (g2 = Fs(s4[i3], 0, 1) || Fs(n6[i3], 0, 1) ? 0 : 1), 1 !== g2) break;
      s4[i3] = s4[m2], n6[i3] = n6[m2];
    }
  }
}
function Km(t2, e5, s4, n6, i2, r, o2, a2, h2, m2, u, l2, c) {
  if (!r) return 0;
  const g2 = (t3, e6) => {
    for (let s5 = 0; s5 < r; ++s5) {
      let n7 = e6[s5];
      if (Fs(n7, 0, 1)) {
        n7 = js(n7);
        continue;
      }
      const i3 = t3.getCoord2D(n7);
      n7 < 0.5 ? i3.equals(t3.getStartXY()) && Qm(t3, 0, n7) <= Ue(t3) && (e6[s5] = 0) : i3.equals(t3.getEndXY()) && Qm(t3, n7, 1) <= Ue(t3) && (e6[s5] = 1);
    }
  };
  g2(e5, n6), g2(s4, i2), Jm(e5, s4, n6, i2, r);
  const d2 = [];
  for (let f3 = 0, P5 = r; f3 < P5; f3++) d2.push(f3);
  const _ = (t3, e6) => c ? At(i2[t3], n6[t3], i2[e6], n6[e6]) : At(n6[t3], i2[t3], n6[e6], i2[e6]);
  if (d2.length > 1) {
    d2.sort(_);
    const t3 = Math.max(Ue(e5), Ue(s4));
    let r2 = 0;
    for (let o3 = 1, a3 = d2.length; o3 < a3; o3++) {
      const a4 = n6[d2[r2]], h3 = n6[d2[o3]], m3 = i2[d2[r2]], u2 = i2[d2[o3]];
      if (a4 !== h3 || m3 !== u2) if (!(Qm(e5, a4, h3) <= t3 && Qm(s4, m3, u2) <= t3) || Fs(a4, 0, 1) && Fs(m3, 0, 1) || Fs(h3, 0, 1) && Fs(u2, 0, 1)) r2++, d2[r2] = d2[o3];
      else {
        const t4 = ei.distance(e5.getCoord2D(a4), s4.getCoord2D(m3)), n7 = ei.distance(e5.getCoord2D(h3), s4.getCoord2D(u2));
        if (t4 <= n7) continue;
        if (n7 < t4) {
          d2[r2] = d2[o3];
          continue;
        }
      }
    }
    if (d2.length = r2 + 1, 1 === d2.length && 0 !== d2[0] && (n6[0] = n6[d2[0]], i2[0] = i2[d2[0]], d2[0] = 0), d2.length > 2) {
      const t4 = x2.constructEmpty(), r3 = x2.constructEmpty();
      t4.setCoords(n6[d2[0]], n6[d2.at(-1)]), r3.setCoords(i2[d2[0]], i2[d2.at(-1)]);
      let o3 = true;
      for (let e6 = 1, s5 = d2.length - 1; e6 < s5; e6++) if (!t4.containsCoordinate(n6[d2[e6]]) || !r3.containsCoordinate(i2[d2[e6]])) {
        o3 = false;
        break;
      }
      if (o3) {
        const n7 = [0.5, 0.2, 0.7, 0.1, 0.3, 0.4, 0.6, 0.8, 0.9];
        for (let i3 = 0; i3 < n7.length; i3++) {
          let a3 = Q(t4.vmin, t4.vmax, n7[i3]);
          const h3 = e5.getCoord2D(a3);
          if (!s4.isCloserThanDistance(h3, r3, m2)) {
            o3 = false;
            break;
          }
          a3 = Q(r3.vmin, r3.vmax, n7[i3]);
          const u2 = s4.getCoord2D(a3);
          if (!e5.isCloserThanDistance(u2, t4, m2)) {
            o3 = false;
            break;
          }
        }
      }
      o3 && (d2[1] = d2.at(-1), d2.length = 2);
    }
  }
  if (1 === d2.length && t2) {
    const t3 = 0, r2 = 0;
    Ye(e5, s4, n6[0], i2[0], m2, 1, [t3], [r2]) && (d2.push(1), n6[1] = t3, i2[1] = r2, d2.sort(_));
  }
  if (u && 1 === d2.length) {
    let t3 = true;
    for (let r2 = 0, o3 = d2.length; r2 < o3; r2++) {
      if (Fs(n6[d2[r2]], 0, 1) && Fs(i2[d2[r2]], 0, 1)) {
        if (0 === ei.distance(e5.getCoord2D(n6[d2[r2]]), s4.getCoord2D(i2[d2[r2]]))) continue;
      }
      t3 = false;
      break;
    }
    if (t3) return 0;
  }
  let p3 = 0;
  for (let f3 = 0, P5 = d2.length; f3 < P5; f3++) {
    if (a2 && a2.push(n6[d2[f3]]), h2 && h2.push(i2[d2[f3]]), o2) {
      const t3 = ei.getNAN();
      e5.queryCoord2D(n6[d2[f3]], t3), o2.push(t3);
    }
    p3++;
  }
  return p3;
}
function $m(t2, e5, s4, n6, i2, r, o2, a2, h2) {
  if (Fs(s4, 0, 1) && Fs(n6, 0, 1)) {
    if (0 === ei.distance(t2.getCoord2D(s4), e5.getCoord2D(n6))) {
      const m2 = 1e-12, u = new Se(), l2 = Number.EPSILON;
      if (t2.queryDerivative(new p2(s4, l2), u), u.isTrueZero()) {
        const e6 = 1 === s4 ? -1e-12 : m2;
        t2.queryDerivative(new p2(s4, l2).add(e6), u);
      }
      1 === s4 && u.negateThis();
      const c = new Se();
      if (e5.queryDerivative(new p2(n6, l2), c), c.isTrueZero()) {
        const t3 = 1 === s4 ? -1e-12 : m2;
        e5.queryDerivative(new p2(n6, l2).add(t3), c);
      }
      1 === n6 && c.negateThis(), u.isZero() || u.normalize(), c.isZero() || c.normalize();
      const g2 = u.dotProduct(c), d2 = u.crossProduct(c);
      d2.scaleError(3);
      const _ = () => {
        if (h2) return 1e-3;
        {
          const s5 = t2.calculateUpperLength2D(), n7 = e5.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s5, n7), 1e-10);
        }
      };
      if (g2.ge(I2) && (d2.isZero() || Math.abs(d2.value()) < _())) {
        return Me(t2, e5, s4, n6, i2, r, o2, a2);
      }
    }
  }
  return 0;
}
function tu(t2, e5, n6, i2, r) {
  let o2 = -1, a2 = -1, h2 = -1, m2 = -1;
  {
    const s4 = [0, e5], r2 = [e5, 0], u = [0, i2], l2 = [i2, 0];
    for (let e6 = 0; e6 < 2 && -1 === o2; ++e6) for (let i3 = 0; i3 < 2; ++i3) if (t2[s4[e6]].equals(n6[u[i3]])) {
      o2 = s4[e6], a2 = r2[e6], h2 = u[i3], m2 = l2[i3];
      break;
    }
  }
  if (-1 === o2) {
    const s4 = new ve();
    s4.setFromPoints(t2, e5 + 1);
    const o3 = new ve();
    return o3.setFromPoints(n6, i2 + 1), o3.inflate(r), s4.isIntersectingW(o3) ? -1 : 0;
  }
  {
    const u = Lt(e5 + 1, Number.NaN), l2 = Mm(t2, e5 + 1, u);
    n2(l2 > 1);
    let c = 0, g2 = 0;
    for (let t3 = 0; t3 < l2; ++t3) o2 === u[t3] && (g2 = t3, c++), a2 === u[t3] && c++;
    if (2 !== c) return -1;
    const d2 = Lt(i2 + 1, Number.NaN), _ = Mm(n6, i2 + 1, d2);
    n2(_ > 1), c = 0;
    let p3 = 0;
    for (let t3 = 0; t3 < _; ++t3) h2 === d2[t3] && (p3 = t3, c++), m2 === d2[t3] && c++;
    if (2 !== c) return -1;
    const f3 = t2[u[(g2 + l2 - 1) % l2]], P5 = t2[u[(g2 + 1) % l2]], y2 = n6[d2[(p3 + _ - 1) % _]], x4 = n6[d2[(p3 + 1) % _]], C2 = t2[o2], v3 = [f3, P5, y2, x4], b2 = [0, 1, 2, 3];
    b2.sort((t3, e6) => ei.compareVectorsOrigin(C2, v3[t3], v3[e6]));
    let E2 = b2[0];
    for (let t3 = 1; t3 < 4; t3++) {
      if (b2[t3] !== (E2 + 1) % 4) return -1;
      E2 = b2[t3];
    }
    {
      const t3 = f3.sub(C2), e6 = x4.sub(C2), s4 = e6.dotProduct(t3);
      if (s4 > 0) {
        const n7 = e6.crossProduct(t3), i3 = Math.abs(Math.atan2(n7, s4)), o3 = i3 * t3.length(), a3 = i3 * e6.length();
        if (o3 <= r || a3 <= r) return -1;
      }
    }
    {
      const t3 = P5.sub(C2), e6 = y2.sub(C2), s4 = e6.dotProduct(t3);
      if (s4 > 0) {
        const n7 = e6.crossProduct(t3), i3 = Math.abs(Math.atan2(n7, s4)), o3 = i3 * t3.length(), a3 = i3 * e6.length();
        if (o3 <= r || a3 <= r) return -1;
      }
    }
    return 1;
  }
}
var eu = B3;
var su = class _su extends is {
  constructor(t2) {
    super(t2 || { XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 });
  }
  assignMove(t2) {
    return this !== t2 && (this.m_description = t2.m_description, t2.m_description = null, this.m_attributes = t2.m_attributes, t2.m_attributes = null, this.m_XStart = t2.m_XStart, t2.m_XStart = Number.NaN, this.m_YStart = t2.m_YStart, this.m_XEnd = t2.m_XEnd, t2.m_XEnd = Number.NaN, this.m_YEnd = t2.m_YEnd), this;
  }
  assignCopy(t2) {
    return this !== t2 && t2.copyTo(this), this;
  }
  calculateLowerLength3D() {
    return n2(0), 0;
  }
  calculateUpperLength3D() {
    return n2(0), 0;
  }
  changeEndPoints3D(t2, e5) {
    n2(0);
  }
  getClosestCoordinate3D(t2, e5, n6) {
    return n2(0), 0;
  }
  getBoundary() {
    return Va(this);
  }
  getAttributeAsDbl(t2, e5, s4) {
    if (0 === e5) return 0 === s4 ? as2(this, t2) : hs2(this, t2);
    const n6 = eu.getInterpolation(e5), i2 = this.getStartAttributeAsDbl(e5, s4), r = this.getEndAttributeAsDbl(e5, s4);
    return pt(n6, i2, r, t2, eu.getDefaultValue(e5));
  }
  constructFromCoords(t2, e5, s4, n6) {
    this.dropAllAttributes(), this.setStartXYCoords(t2, e5), this.setEndXYCoords(s4, n6);
  }
  construct(t2, e5) {
    this.dropAllAttributes(), this.setStartXY(t2), this.setEndXY(e5);
  }
  construct3D(t2, e5) {
    n2(0);
  }
  constructPoint(t2, e5) {
    this.assignVertexDescription(t2.getDescription()), this.mergeVertexDescription(e5.getDescription()), this.setStart(t2), this.setEnd(e5);
  }
  getGeometryType() {
    return _su.type;
  }
  queryEnvelope(t2) {
    if (4 === t2.m_EnvelopeType) {
      t2.setEmpty(), t2.assignVertexDescription(this.m_description);
      const e5 = n4.constructEmpty();
      this.queryEnvelope(e5), t2.setEnvelope(e5);
      for (let s4 = 1, n6 = this.m_description.getAttributeCount(); s4 < n6; s4++) {
        const e6 = this.m_description.getSemantics(s4);
        for (let n7 = 0, i2 = eu.getComponentCount(e6); s4 < i2; s4++) {
          const s5 = this.queryInterval(e6, n7);
          t2.setIntervalEnvelope(e6, n7, s5);
        }
      }
    } else 2 === t2.m_EnvelopeType ? t2.setCoords({ xmin: this.m_XStart, ymin: this.m_YStart, xmax: this.m_XEnd, ymax: this.m_YEnd }) : 3 === t2.m_EnvelopeType ? (t2.setEmpty(), t2.mergeCoords(this.m_XStart, this.m_YStart, We(this, 0, 1, 0)), t2.mergeCoords(this.m_XEnd, this.m_YEnd, We(this, 1, 1, 0))) : z("env type not impl");
  }
  applyTransformation(t2) {
    n2(t2 instanceof x3);
    const e5 = new ei();
    e5.x = this.m_XStart, e5.y = this.m_YStart, t2.transformInPlace(e5), this.m_XStart = e5.x, this.m_YStart = e5.y, e5.x = this.m_XEnd, e5.y = this.m_YEnd, t2.transformInPlace(e5), this.m_XEnd = e5.x, this.m_YEnd = e5.y;
  }
  createInstance() {
    return new _su({ vd: this.m_description });
  }
  calculateLength2D() {
    return Math.sqrt(Es2(this));
  }
  calculateLength3D(t2) {
    return n2(0), 0;
  }
  changeEndPoints2D(t2, e5) {
    this.setStartXY(t2), this.setEndXY(e5), this.normalizeAfterEndpointChange();
  }
  queryCoord2D(t2, e5) {
    return rs2(this, t2, e5);
  }
  queryCoord3D(t2, e5) {
    n2(0);
  }
  getCoordZ(t2) {
    return ms2(this, t2);
  }
  queryCoord2DE(t2, e5) {
    ls2(this, t2, e5);
  }
  getCoordX(t2) {
    return as2(this, t2);
  }
  getCoordY(t2) {
    return hs2(this, t2);
  }
  cut(t2, e5, s4) {
    const n6 = new nu();
    return this.queryCut(t2, e5, n6, s4), n6.releaseSegment();
  }
  queryCut(t2, e5, s4, n6) {
    const i2 = s4.createLine();
    n6 && i2.assignVertexDescription(this.m_description);
    const r = ei.getNAN();
    if (rs2(this, t2, r), i2.setStartXYCoords(r.x, r.y), rs2(this, e5, r), i2.setEndXYCoords(r.x, r.y), !n6) for (let o2 = 1, a2 = this.m_description.getAttributeCount(); o2 < a2; o2++) {
      const s5 = this.m_description.getSemantics(o2), n7 = eu.getComponentCount(s5);
      for (let r2 = 0; r2 < n7; r2++) {
        const n8 = this.getAttributeAsDbl(t2, s5, r2);
        i2.setStartAttribute(s5, r2, n8);
        const o3 = this.getAttributeAsDbl(e5, s5, r2);
        i2.setEndAttribute(s5, r2, o3);
      }
    }
  }
  queryDerivative(t2, e5) {
    us2(this, t2, e5);
  }
  getClosestCoordinate(t2, e5) {
    return ei.getClosestCoordinate(this.getStartXY(), this.getEndXY(), t2, e5);
  }
  getClosestCoordinateOnInterval(t2, e5, s4 = -1) {
    const n6 = new ei();
    this.queryCoord2D(e5.vmin, n6);
    const i2 = new ei();
    this.queryCoord2D(e5.vmax, i2);
    const r = ei.getClosestCoordinate(n6, i2, t2, false);
    return $e.recalculateParentT(e5.vmin, e5.vmax, r);
  }
  intersectionOfYMonotonicWithAxisX(t2, e5) {
    const s4 = this.m_YEnd - this.m_YStart;
    if (!s4) return t2 === this.m_YEnd ? e5 : Number.NaN;
    const n6 = (t2 - this.m_YStart) / s4;
    let i2 = as2(this, n6);
    return 1 === n6 && (i2 = this.m_XEnd), i2;
  }
  isCurve() {
    return false;
  }
  isMonotoneQuickAndDirty() {
    return true;
  }
  isDegenerate(t2) {
    const e5 = this.m_XStart - this.m_XEnd, s4 = this.m_YStart - this.m_YEnd;
    return Math.sqrt(e5 * e5 + s4 * s4) <= t2;
  }
  isDegenerate3D(t2, e5) {
    return n2(0), false;
  }
  queryLooseEnvelope(t2) {
    this.queryEnvelope(t2);
  }
  clone(t2) {
    const e5 = new _su();
    return this.copyTo(e5), e5;
  }
  tToLength(t2) {
    return t2 * this.calculateLength2D();
  }
  lengthToT(t2) {
    const e5 = this.calculateLength2D();
    return 0 !== e5 ? t2 / e5 : 0;
  }
  calculateWeightedAreaCentroid2D(t2) {
    const e5 = new ei();
    return e5.setCoords(0, 0), e5;
  }
  calculateWeightedCentroid2D() {
    return this.getCoord2D(0.5).mul(this.calculateLength2D());
  }
  getTangent(t2) {
    const e5 = ei.getNAN();
    return e5.setSub(this.getEndXY(), this.getStartXY()), e5;
  }
  getDerivative(t2) {
    const e5 = new ei();
    return e5.setSub(this.getEndXY(), this.getStartXY()), e5;
  }
  getCurvature(t2) {
    return 0;
  }
  isIntersectingPoint(t2, e5, s4) {
    return xs(this, t2, e5, s4) >= 0;
  }
  isIntersectingPoint3D(t2, e5, n6, i2, r = 1) {
    return n2(0), false;
  }
  getYMonotonicParts(t2, e5) {
    return 0;
  }
  getMonotonicParts(t2, e5) {
    return 0;
  }
  getMonotonicPartParams(t2, s4) {
    return s4 && (t2 < 2 && P(""), s4[0] = 0, s4[1] = 1), 2;
  }
  intersectionWithAxis2D(t2, e5, s4, n6) {
    if (t2) {
      const t3 = this.m_YEnd - this.m_YStart;
      if (!t3) return e5 === this.m_YEnd ? -1 : 0;
      const i2 = (e5 - this.m_YStart) / t3;
      return i2 < 0 || i2 > 1 ? 0 : (s4 && (s4[0] = as2(this, i2)), n6 && (n6[0] = i2), 1);
    }
    {
      const t3 = this.m_XEnd - this.m_XStart;
      if (!t3) return e5 === this.m_XEnd ? -1 : 0;
      const i2 = (e5 - this.m_XStart) / t3;
      return i2 < 0 || i2 > 1 ? 0 : (s4 && (s4[0] = hs2(this, i2)), n6 && (n6[0] = i2), 1);
    }
  }
  calculateUpperLength2D() {
    return this.calculateLength2D();
  }
  calculateLowerLength2D() {
    return this.calculateLength2D();
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  queryLooseEnvelopeOnInterval(t2, e5) {
    if (2 === e5.m_EnvelopeType) {
      let s4 = ks(t2.vmin, 0, 1);
      const n6 = new ei();
      return this.queryCoord2D(s4, n6), e5.setCoords({ pt: n6 }), s4 = ks(t2.vmax, 0, 1), this.queryCoord2D(s4, n6), void e5.mergeNe(n6);
    }
    z("3d dst not impl");
  }
  orientBottomUp() {
    ds(this);
  }
  isLine() {
    return true;
  }
  isDegenerateToLineHelper(t2) {
    return true;
  }
  copyIgnoreAttributes(t2) {
    t2.setStartXY(this.getStartXY()), t2.setEndXY(this.getEndXY()), t2.normalizeAfterEndpointChange();
  }
  calculateArea2DHelper() {
    return 0;
  }
  absNormXYZ(t2) {
    return gs2(this, t2);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1);
  }
  queryEnvelopeW(t2, e5) {
    e5.setCoords(this.getCoord2D(t2.vmin)), e5.mergeNe(this.getCoord2D(t2.vmax));
  }
  setSegmentFromCoords(t2, e5) {
    cs(this, t2[0], t2[e5 - 1]);
  }
  writeInBufferStream(t2, e5) {
    return n2(0), 0;
  }
  readFromBufferStream(t2, e5) {
    n2(0);
  }
  snapControlPoints(t2) {
    return false;
  }
  needsSnapControlPoints(t2) {
    return false;
  }
  calculateSpecialPointsForCracking(t2, e5) {
    return 0;
  }
  ensureXYMonotone() {
    return false;
  }
  setCoordsForIntersector(t2, e5, s4) {
    cs(this, t2, e5);
  }
  static isIntersectingLineLine(t2, e5, s4, n6) {
    return _s(t2, e5, s4, n6);
  }
  static isIntersectingLineLine_(t2, e5, s4, n6) {
    return _s(t2, e5, s4, n6);
  }
  copyToImpl(t2) {
  }
  reverseImpl() {
  }
  equalsImpl(t2) {
    return true;
  }
  equalsImplTol(t2, e5) {
    return true;
  }
  swapImpl(t2) {
  }
  afterCompletedModification() {
  }
  endPointModified() {
  }
  clearEndPointModified() {
  }
  intersect(t2, e5, s4, n6, i2) {
    return Om(false, this, t2, e5, s4, n6, i2);
  }
  intersectPoint(t2, e5, s4) {
    e5.length < 1 && A("");
    const i2 = xs(this, t2, s4, false);
    return i2 >= 0 ? (e5 && (e5[0] = i2), 1) : 0;
  }
  isIntersecting(t2, e5, s4) {
    return 0 !== jm(false, this, t2, e5, s4);
  }
};
su.type = a.enumLine;
var nu = class _nu {
  constructor(t2) {
    this.m_seg = null, this.m_curves = null, this.m_lineBuffer = new su(), this.m_mask = 0, this.m_active = 0, void 0 !== t2 && (t2.copy ? t2.copy.copyTo(this, false) : t2.move ? this.assignMove(t2.move) : t2.segment ? this.copyFrom(t2.segment, !!t2.bIgnoreAttributes) : b("bad constructor params"));
  }
  assignCopy(t2) {
    return t2 instanceof _nu ? this !== t2 && t2.copyTo(this, false) : this.copyFrom(t2, false), this;
  }
  assignMove(t2) {
    if (t2 instanceof _nu) {
      if (this === t2) return this;
      this.reset(), 1 & t2.m_mask && (this.m_lineBuffer = t2.m_lineBuffer, t2.m_lineBuffer = null, this.m_mask = 1), this.m_curves = t2.m_curves, this.m_mask = t2.m_mask, this.m_active = t2.m_active, t2.reset(), this.m_seg = this.activeSegment(), t2.m_seg = null;
    } else {
      if (this.m_seg === t2) return this;
      this.create(t2.getGeometryType()), this.m_seg.swap(t2);
    }
    return this;
  }
  activeSegment() {
    switch (this.m_active) {
      case 0:
        return null;
      case 1:
        return this.line();
      case 2:
        return this.arc();
      case 4:
        return this.bezier3();
      case 8:
        return this.bezier2();
      case 16:
        return this.rbezier2();
      default:
        b("");
    }
  }
  get() {
    return this.m_seg;
  }
  reset() {
    1 & this.m_mask && (this.m_lineBuffer = null), this.m_mask > 1 && (this.m_curves = null), this.m_mask = 0, this.m_active = 0;
  }
  empty() {
    return null === this.m_seg;
  }
  copyTo(t2, e5) {
    this !== t2 && (this.empty() ? t2.m_seg = null : t2.copyFrom(this.m_seg, e5));
  }
  copyToWithZ(t2, e5) {
    n2(0);
  }
  createImpl(t2) {
    switch (t2) {
      case a.enumLine:
        1 & this.m_mask || (this.m_lineBuffer = new su(), this.m_mask |= 1, this.m_active = 1);
        break;
      case a.enumEllipticArc:
        2 & this.m_mask || (this.m_curves = new Oa(), this.m_mask = 1 & this.m_mask | 2, this.m_active = 2);
        break;
      case a.enumBezier:
        4 & this.m_mask || (this.m_curves = new mo(), this.m_mask = 1 & this.m_mask | 4, this.m_active = 4);
        break;
      case a.enumBezier2:
        8 & this.m_mask || (this.m_curves = new nn(), this.m_mask = 1 & this.m_mask | 8, this.m_active = 8);
        break;
      case a.enumRationalBezier2:
        16 & this.m_mask || (this.m_curves = new on(), this.m_mask = 1 & this.m_mask | 16, this.m_active = 16);
        break;
      default:
        P("");
    }
  }
  create(t2) {
    t2 === a.enumLine ? this.createLine() : t2 === a.enumEllipticArc ? this.createEllipticArc() : t2 === a.enumBezier ? this.createCubicBezier() : t2 === a.enumRationalBezier2 ? this.createQuadraticRationalBezier() : t2 === a.enumBezier2 ? this.createQuadraticBezier() : P("Segment_buffer.create");
  }
  copyFrom(t2, e5) {
    this.m_seg !== t2 && (this.create(t2.getGeometryType()), e5 ? t2.copyIgnoreAttributes(this.m_seg) : t2.copyTo(this.m_seg));
  }
  copyFromWithZ(t2, e5) {
    n2(0);
  }
  line() {
    return this.m_lineBuffer;
  }
  arc() {
    return this.m_curves;
  }
  bezier3() {
    return this.m_curves;
  }
  bezier2() {
    return this.m_curves;
  }
  rbezier2() {
    return this.m_curves;
  }
  createLine() {
    return this.createImpl(a.enumLine), this.m_seg = this.line(), this.line();
  }
  createEllipticArc() {
    return this.createImpl(a.enumEllipticArc), this.m_seg = this.arc(), this.arc();
  }
  createCubicBezier() {
    return this.createImpl(a.enumBezier), this.m_seg = this.bezier3(), this.bezier3();
  }
  createQuadraticRationalBezier() {
    return this.createImpl(a.enumRationalBezier2), this.m_seg = this.rbezier2(), this.rbezier2();
  }
  createQuadraticBezier() {
    return this.createImpl(a.enumBezier2), this.m_seg = this.bezier2(), this.bezier2();
  }
  releaseSegment() {
    if (this.m_seg = null, 0 === this.m_active && b("releaseSegment"), 1 & this.m_active) {
      const t3 = this.line();
      return this.m_mask -= 1, this.m_active = 0, this.m_lineBuffer = null, t3;
    }
    let t2;
    return 2 & this.m_active ? t2 = this.arc() : 4 & this.m_active ? t2 = this.bezier3() : 8 & this.m_active ? t2 = this.bezier2() : 16 & this.m_active ? t2 = this.rbezier2() : b("releaseSegment"), this.m_mask -= this.m_active, this.m_active = 0, this.m_curves = null, t2;
  }
  equals(t2) {
    return t2 instanceof _nu ? this === t2 || (this.empty() ? t2.empty() : !t2.empty() && this.get().equals(t2.get())) : (z("seg comparison not yet impl"), false);
  }
};

// node_modules/@arcgis/core/chunks/OperatorClip.js
function f2(e5, t2, s4, i2, n6) {
  return v2(e5, t2, null, s4, i2, n6);
}
function v2(e5, h2, o2, x4, p3, c) {
  const l2 = e5.getGeometryType();
  if (l2 === a.enumPoint) {
    const t2 = e5.getXY();
    return h2.contains(t2) ? e5 : e5.createInstance();
  }
  if (l2 === a.enumEnvelope) {
    const t2 = n4.constructEmpty();
    if (e5.queryEnvelope(t2), t2.intersect(h2)) {
      const s4 = e5.clone();
      return s4.setEnvelope(t2), s4;
    }
    return e5.createInstance();
  }
  if (e5.isEmpty()) return e5;
  if (h2.isEmpty()) return e5.createInstance();
  const _ = h2.clone();
  {
    const t2 = new n4();
    if (e5.queryLooseEnvelope(t2), _.containsEnvelope(t2)) return e5;
    if (!_.isIntersecting(t2)) return e5.createInstance();
    0 === p3 && (t2.intersect(_), t2.inflate(Math.max(0.1 * t2.maxDimension(), 1)), t2.intersect(_), _.assign(t2));
  }
  let u = x4;
  if ((null !== o2 || Number.isNaN(u)) && (u = wt2(o2, _, false).total()), l2 === a.enumGeometryCollection) {
    const t2 = e5, s4 = e5.createInstance();
    for (let e6 = 0, i2 = t2.getGeometryCount(); e6 < i2; e6++) {
      const i3 = t2.getGeometry(e6);
      if (i3.isEmpty()) continue;
      const n6 = f2(i3, _, u, p3, c);
      n6.isEmpty() || (n6 === i3 ? s4.addGeometry(n6.clone()) : s4.addGeometry(n6));
    }
    return s4;
  }
  y(l2) || P("Clip: geometry not supported");
  const g2 = e5.getImpl().getAccelerators();
  if (null !== g2) {
    const e6 = g2.getRasterizedGeometry();
    n2(null === e6);
  }
  switch (l2) {
    case a.enumMultiPoint: {
      const t2 = e5;
      let s4;
      const i2 = t2.getPointCount(), r = t2.getImpl().getAttributeStreamRef(0);
      let h3 = 0;
      for (let e6 = 0; e6 < i2; e6++) {
        const i3 = r.readPoint2D(2 * e6);
        _.contains(i3) || (0 === h3 && (s4 = t2.createInstance()), h3 < e6 && s4.addPoints(t2, h3, e6), h3 = e6 + 1);
      }
      return h3 > 0 && s4.addPoints(t2, h3, i2), 0 === h3 ? t2 : (n2(null !== s4), s4);
    }
    case a.enumPolygon:
    case a.enumPolyline:
      return P4(e5, _, u, p3, c);
    default:
      b("");
  }
}
function d(e5, t2, s4, i2, n6, r) {
  const h2 = new E(t2, r), m2 = new n4();
  return e5.queryLooseEnvelope(m2), t2.containsEnvelope(m2) ? e5 : t2.isIntersecting(m2) ? h2.clipPolesOut(e5, n6) : e5.createInstance();
}
function P4(e5, t2, s4, i2, n6) {
  return new E(t2, n6).clipMultiPath2(e5, s4, i2);
}
var E = class _E {
  constructor(e5, t2) {
    this.m_shape = new Tm(), this.m_geometry = bm, this.m_verticesOnExtentIndex = -1, this.m_verticesOnExtent = [], this.m_progressCounter = 0, this.m_extent = new n4(e5), this.m_progressTracker = t2;
  }
  progress_() {
  }
  clipMultiPath2(e5, s4, i2) {
    return e5.getGeometryType() === a.enumPolygon ? this.clipPolygonOrProjectedPolyline2(e5, i2) : this.clipPolyline(e5, s4);
  }
  clipPolygonOrProjectedPolyline2(e5, s4) {
    const i2 = e5.getGeometryType() === a.enumPolyline;
    if (0 === this.m_extent.width() || 0 === this.m_extent.height()) return e5.createInstance();
    const r = n4.constructEmpty();
    e5.queryLooseEnvelope(r), this.m_geometry = i2 ? this.m_shape.addGeometry(e5) : this.m_shape.addGeometry(e5, this.m_extent);
    const h2 = n4.constructEmpty(), m2 = n4.constructEmpty(), o2 = new ei(), c = new ei(), g2 = Lt(9, Number.NaN), y2 = Lt(9, Number.NaN), f3 = Rt(ei, 9);
    let v3 = null;
    const d2 = new su(), P5 = [];
    let I5 = false;
    for (let t2 = 0; !I5 && t2 < 4; t2++) {
      let e6 = false;
      const s5 = !!(1 & t2);
      let a2 = 0;
      switch (t2) {
        case 0:
          a2 = this.m_extent.xmin, e6 = r.xmin <= a2 && r.xmax >= a2;
          break;
        case 1:
          a2 = this.m_extent.ymin, e6 = r.ymin <= a2 && r.ymax >= a2;
          break;
        case 2:
          a2 = this.m_extent.xmax, e6 = r.xmin <= a2 && r.xmax >= a2;
          break;
        case 3:
          a2 = this.m_extent.ymax, e6 = r.ymin <= a2 && r.ymax >= a2;
      }
      if (e6) {
        I5 = true;
        for (let e7 = this.m_shape.getFirstPath(this.m_geometry); e7 !== bm; ) {
          let r2 = true, p3 = -1, l2 = -1;
          const _ = this.m_shape.getFirstVertex(e7);
          let u = _;
          do {
            this.progress_(), v3 = this.m_shape.getSegment(u);
            let e8 = v3;
            if (null === e8) {
              const t3 = this.m_shape.getNextVertex(u);
              if (t3 === bm) {
                n2(i2), 0 === p3 && P5.push(u);
                break;
              }
              this.m_shape.queryXY(u, o2), d2.setStartXY(o2), this.m_shape.queryXY(t3, c), d2.setEndXY(c), e8 = d2;
            }
            e8.queryLooseEnvelope(h2);
            let _2 = _E.checkSegmentIntersection(h2, t2, a2);
            e8.isCurve() && 0 === _2 && e8.isCurve() && (d2.setStartXY(e8.getStartXY()), d2.setEndXY(e8.getEndXY()), this.m_shape.replaceCurveWithLine(u), e8 = d2, d2.queryEnvelope(h2), _2 = _E.checkSegmentIntersection(h2, t2, a2));
            let V5 = 0, X4 = bm;
            if (-1 === _2) {
              const i3 = e8.intersectionWithAxis2D(s5, a2, g2, y2);
              if (i3 > 0) {
                let t3 = null;
                if (e8.isCurve()) {
                  t3 = f3, n2(i3 <= 9);
                  for (let e9 = 0; e9 < i3; e9++) s5 ? f3[e9].setCoords(g2[e9], a2) : f3[e9].setCoords(a2, g2[e9]);
                  V5 = this.m_shape.splitSegmentAxisAware(u, y2, i3, t3, s5 ? 1 : 0);
                } else V5 = this.m_shape.splitSegmentAxisAware(u, y2, i3, null, -1);
              } else V5 = 0;
              V5 += 1;
              let h3 = u, x4 = this.m_shape.getNextVertex(h3);
              e8 = null;
              for (let e9 = 0; e9 < V5; e9++) {
                this.m_shape.queryXY(h3, o2), this.m_shape.queryXY(x4, c), v3 = this.m_shape.getSegment(h3);
                let e10 = v3;
                null === e10 && (d2.setStartXY(o2), d2.setEndXY(c), e10 = d2), e10.queryEnvelope(m2);
                let i4 = _E.checkSegmentIntersection(m2, t2, a2);
                if (e10.isCurve() && 0 === i4 && (this.m_shape.replaceCurveWithLine(h3), d2.setStartXY(o2), d2.setEndXY(c), e10 = d2, e10.queryEnvelope(m2), i4 = _E.checkSegmentIntersection(m2, t2, a2)), -1 === i4) {
                  if (s5) {
                    Math.abs(o2.y - a2) < Math.abs(c.y - a2) ? (o2.y = a2, this.m_shape.setXY(h3, o2)) : (c.y = a2, this.m_shape.setXY(x4, c));
                  } else {
                    Math.abs(o2.x - a2) < Math.abs(c.x - a2) ? (o2.x = a2, this.m_shape.setXY(h3, o2)) : (c.x = a2, this.m_shape.setXY(x4, c));
                  }
                  v3 = this.m_shape.getSegment(h3), e10 = v3, null === e10 && (d2.setStartXY(o2), d2.setEndXY(c), e10 = d2), e10.queryEnvelope(m2), i4 = _E.checkSegmentIntersection(m2, t2, a2), -1 === i4 && (i4 = _E.checkSegmentIntersectionLoose(m2, t2, a2));
                }
                const n6 = p3;
                p3 = i4, -1 === l2 && (l2 = p3), 0 === n6 && 1 === p3 || 1 === n6 && 0 === p3 || 0 === n6 && 0 === p3 && P5.push(h3), 1 === p3 && (I5 = false, r2 = false), h3 = x4, X4 = h3, x4 = this.m_shape.getNextVertex(x4);
              }
            }
            if (0 === V5) {
              const e9 = p3;
              p3 = _2, -1 === l2 && (l2 = p3), 0 === e9 && p3 >= 1 || e9 >= 1 && 0 === p3 || 0 === e9 && 0 === p3 && P5.push(u), 1 === p3 && (I5 = false, r2 = false), X4 = this.m_shape.getNextVertex(u);
            }
            if (u = X4, P5.length >= 256) {
              for (let e9 = 1, t3 = P5.length - 1; e9 < t3; e9++) {
                const t4 = P5[e9];
                i2 ? this.m_shape.snapVertexForPoleClipping(t4, a2) : this.m_shape.removeVertex(t4, false);
              }
              P5[1] = P5.at(-1), P5.length = 2;
            }
          } while (u !== _);
          if (!r2) {
            0 !== l2 || !i2 && 0 !== p3 && 2 !== p3 || P5.push(_);
            for (let e8 = 0, t3 = P5.length; e8 < t3; e8++) {
              const t4 = P5[e8];
              i2 ? this.m_shape.snapVertexForPoleClipping(t4, a2) : this.m_shape.removeVertex(t4, false);
            }
          }
          P5.length = 0, e7 = r2 || 0 === this.m_shape.getPathSize(e7) ? this.m_shape.removePath(e7) : this.m_shape.getNextPath(e7);
        }
      }
    }
    if (I5) return e5.createInstance();
    v3 = null, i2 ? this.removeSpikesAlongPoles() : this.resolveBoundaryOverlaps(), s4 > 0 && this.densifyAlongClipExtent(s4);
    const V4 = this.m_shape.getGeometry(this.m_geometry);
    if (V4.getGeometryType() === a.enumPolygon) {
      V4.setFillRule(e5.getFillRule());
    }
    return V4;
  }
  clipPolyline(e5, t2) {
    const s4 = n4.constructEmpty(), i2 = n4.constructEmpty(), n6 = Lt(9, Number.NaN), r = Lt(9, Number.NaN), h2 = new nu();
    let m2 = e5;
    const o2 = n4.constructEmpty();
    e5.queryLooseEnvelope(o2);
    for (let a2 = 0; a2 < 4; a2++) {
      let t3 = false;
      const x4 = !!(1 & a2);
      let p3 = 0;
      switch (a2) {
        case 0:
          p3 = this.m_extent.xmin, t3 = o2.xmin <= p3 && o2.xmax >= p3;
          break;
        case 1:
          p3 = this.m_extent.ymin, t3 = o2.ymin <= p3 && o2.ymax >= p3;
          break;
        case 2:
          p3 = this.m_extent.xmax, t3 = o2.xmin <= p3 && o2.xmax >= p3;
          break;
        case 3:
          p3 = this.m_extent.ymax, t3 = o2.ymin <= p3 && o2.ymax >= p3;
      }
      if (!t3) continue;
      const c = m2;
      m2 = e5.createInstance();
      const l2 = c.getImpl().querySegmentIterator();
      l2.resetToFirstPath();
      const _ = new ei(), g2 = new ei();
      for (; l2.nextPath(); ) {
        let e6 = -1, t4 = true;
        for (; l2.hasNextSegment(); ) {
          this.progress_();
          const o3 = l2.nextSegment(), c2 = o3.isDegenerate(0);
          o3.queryLooseEnvelope(s4);
          const u = _E.checkSegmentIntersection(s4, a2, p3);
          if (-1 === u) {
            const s5 = o3.intersectionWithAxis2D(x4, p3, n6, r);
            let l3 = 0;
            _.assign(o3.getStartXY());
            for (let u2 = 0; u2 <= s5; u2++) {
              const y2 = u2 < s5 ? r[u2] : 1;
              if (l3 === y2) continue;
              o3.queryCut(l3, y2, h2, false);
              const f3 = h2.get();
              let v3 = false;
              if (f3.getStartXY().equals(_) || (f3.setStartXY(_), v3 = true), u2 < s5 && (x4 ? (g2.x = n6[u2], g2.y = p3) : (g2.x = p3, g2.y = n6[u2]), f3.getEndXY().equals(g2) || (f3.setEndXY(g2), v3 = true)), v3 && f3.normalizeAfterEndpointChange(), !c2 && f3.isDegenerate(0)) continue;
              f3.queryEnvelope(i2);
              let d2 = _E.checkSegmentIntersection(i2, a2, p3);
              if (-1 === d2) {
                const e7 = f3.getStartXY(), t5 = f3.getEndXY();
                if (v3 = false, x4) {
                  Math.abs(e7.y - p3) < Math.abs(t5.y - p3) ? (e7.y = p3, f3.setStartXY(e7), e7.equals(f3.getStartXY()) || (f3.setStartXY(e7), v3 = true)) : (t5.y = p3, t5.equals(f3.getEndXY()) || (f3.setEndXY(t5), v3 = true));
                } else {
                  Math.abs(e7.x - p3) < Math.abs(t5.x - p3) ? (e7.x = p3, e7.equals(f3.getStartXY()) || (f3.setStartXY(e7), v3 = true)) : (t5.x = p3, t5.equals(f3.getEndXY()) || (f3.setEndXY(t5), v3 = true));
                }
                v3 && f3.normalizeAfterEndpointChange(), f3.queryEnvelope(i2), d2 = _E.checkSegmentIntersection(i2, a2, p3), -1 === d2 && (d2 = _E.checkSegmentIntersectionLoose(i2, a2, p3));
              }
              _.assign(f3.getEndXY()), l3 = y2, e6 = d2, e6 >= 1 ? (m2.addSegment(f3, t4), t4 = false) : t4 = true;
            }
          } else e6 = u, e6 >= 1 ? (m2.addSegment(o3, t4), t4 = false) : t4 = true;
        }
      }
    }
    return m2;
  }
  static checkSegmentIntersection(e5, t2, s4) {
    switch (t2) {
      case 0:
        return e5.xmin < s4 && e5.xmax <= s4 ? 0 : e5.xmin >= s4 ? e5.xmax === s4 ? 2 : 1 : -1;
      case 1:
        return e5.ymin < s4 && e5.ymax <= s4 ? 0 : e5.ymin >= s4 ? e5.ymax === s4 ? 2 : 1 : -1;
      case 2:
        return e5.xmin >= s4 && e5.xmax > s4 ? 0 : e5.xmax <= s4 ? e5.xmin === s4 ? 2 : 1 : -1;
      case 3:
        return e5.ymin >= s4 && e5.ymax > s4 ? 0 : e5.ymax <= s4 ? e5.ymin === s4 ? 2 : 1 : -1;
    }
    return b(""), 0;
  }
  static checkSegmentIntersectionLoose(e5, t2, s4) {
    switch (t2) {
      case 0: {
        const t3 = Math.abs(e5.xmin - s4), i2 = Math.abs(e5.xmax - s4);
        return e5.xmin < s4 ? t3 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 1: {
        const t3 = Math.abs(e5.ymin - s4), i2 = Math.abs(e5.ymax - s4);
        return e5.ymin < s4 ? t3 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 2: {
        const t3 = Math.abs(e5.xmin - s4), i2 = Math.abs(e5.xmax - s4);
        return e5.xmax > s4 ? t3 < i2 ? 0 : 1 : (b(""), 1);
      }
      case 3: {
        const t3 = Math.abs(e5.ymin - s4), i2 = Math.abs(e5.ymax - s4);
        return e5.ymax > s4 ? t3 < i2 ? 0 : 1 : (b(""), 1);
      }
    }
    return b(""), 0;
  }
  resolveBoundaryOverlaps() {
    this.m_verticesOnExtentIndex = -1, this.splitSegments(false, this.m_extent.xmin), this.splitSegments(false, this.m_extent.xmax), this.splitSegments(true, this.m_extent.ymin), this.splitSegments(true, this.m_extent.ymax), this.m_verticesOnExtent.length = 0, this.m_verticesOnExtentIndex = this.m_shape.createUserIndex();
    const e5 = new ei();
    for (let t2 = this.m_shape.getFirstPath(this.m_geometry); t2 !== bm; t2 = this.m_shape.getNextPath(t2)) {
      let s4 = this.m_shape.getFirstVertex(t2);
      for (let i2 = 0, n6 = this.m_shape.getPathSize(t2); i2 < n6; i2++, s4 = this.m_shape.getNextVertex(s4)) this.progress_(), this.m_shape.queryXY(s4, e5), this.m_extent.xmin !== e5.x && this.m_extent.xmax !== e5.x && this.m_extent.ymin !== e5.y && this.m_extent.ymax !== e5.y || (this.m_shape.setUserIndex(s4, this.m_verticesOnExtentIndex, this.m_verticesOnExtent.length), this.m_verticesOnExtent.push(s4));
    }
    this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmin), this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmax), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymin), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymax), this.fixPaths();
  }
  densifyAlongClipExtent(e5) {
    const t2 = new ei(0, 0), s4 = new ei(0, 0), i2 = Lt(2048, Number.NaN);
    for (let h2 = this.m_shape.getFirstPath(this.m_geometry); h2 !== bm; h2 = this.m_shape.getNextPath(h2)) {
      const m2 = this.m_shape.getFirstVertex(h2);
      let a2 = m2;
      do {
        const h3 = this.m_shape.getNextVertex(a2);
        this.m_shape.queryXY(a2, t2);
        let m3 = -1;
        if (t2.x === this.m_extent.xmin ? (this.m_shape.queryXY(h3, s4), s4.x === this.m_extent.xmin && (m3 = 1)) : t2.x === this.m_extent.xmax && (this.m_shape.queryXY(h3, s4), s4.x === this.m_extent.xmax && (m3 = 1)), t2.y === this.m_extent.ymin ? (this.m_shape.queryXY(h3, s4), s4.y === this.m_extent.ymin && (m3 = 0)) : t2.y === this.m_extent.ymax && (this.m_shape.queryXY(h3, s4), s4.y === this.m_extent.ymax && (m3 = 0)), -1 === m3) {
          a2 = h3;
          continue;
        }
        if (this.isCurve(a2)) {
          a2 = h3;
          continue;
        }
        const o2 = t2.clone(), x4 = new ei(0, 0);
        if (m3) {
          const i3 = t2.y - this.m_extent.ymin;
          x4.y = X(s4.y - t2.y), o2.y = e5 * B2(Math.floor(Math.abs(i3) / e5), i3) + this.m_extent.ymin, x4.y < 0 && (o2.y += e5);
        } else {
          const i3 = t2.x - this.m_extent.xmin;
          x4.x = X(s4.x - t2.x), o2.x = e5 * B2(Math.floor(Math.abs(i3) / e5), i3) + this.m_extent.xmin, x4.x < 0 && (o2.x += e5);
        }
        const p3 = m3 ? s4.y - t2.y : s4.x - t2.x, c = Math.abs(p3);
        if (c / e5 > 65536 && b(""), c > 0) {
          const s5 = Math.trunc(c / e5) + 2;
          i2.length < s5 && (i2.length = s5);
          let r = 0;
          for (let h4 = 0; ; h4++) {
            const s6 = o2.add(x4.mul(h4 * e5)), a3 = (m3 ? s6.y - t2.y : s6.x - t2.x) / p3;
            if (a3 >= 1) break;
            a3 <= 0 || (n2(r <= i2.length), i2[r] = a3, r++);
          }
          0 !== r && this.m_shape.splitSegment(a2, i2, r);
        }
        a2 = h3;
      } while (a2 !== m2);
    }
  }
  splitSegments(e5, t2) {
    let s4 = -1;
    const i2 = new ei(), n6 = [];
    for (let _ = this.m_shape.getFirstPath(this.m_geometry); _ !== bm; _ = this.m_shape.getNextPath(_)) {
      let r2 = this.m_shape.getFirstVertex(_), h3 = bm;
      for (let m3 = 0, a3 = this.m_shape.getPathSize(_); m3 < a3; m3++, r2 = h3) if (this.progress_(), h3 = this.m_shape.getNextVertex(r2), this.m_shape.queryXY(r2, i2), (e5 ? i2.y === t2 : i2.x === t2) && (this.m_shape.queryXY(h3, i2), e5 ? i2.y === t2 : i2.x === t2)) {
        if (this.isCurve(r2)) continue;
        -1 === s4 && (s4 = this.m_shape.createUserIndex()), 1 !== this.m_shape.getUserIndex(r2, s4) && (n6.push(r2), this.m_shape.setUserIndex(r2, s4, 1)), 1 !== this.m_shape.getUserIndex(h3, s4) && (n6.push(h3), this.m_shape.setUserIndex(h3, s4, 1));
      }
    }
    if (-1 !== s4 && this.m_shape.removeUserIndex(s4), n6.length < 3) return;
    n6.sort((e6, t3) => this.compareVertices(e6, t3));
    const r = new ei(), h2 = new ei(), m2 = new ei();
    h2.setNAN();
    let a2 = -1;
    let o2 = [], p3 = [];
    const c = this.m_shape.createUserIndex(), l2 = this.m_shape.createUserIndex();
    for (let x4 = 0, _ = n6.length; x4 < _; x4++) {
      const s5 = n6[x4];
      if (this.m_shape.queryXY(s5, i2), !i2.isEqualPoint2D(h2)) {
        if (-1 === a2) {
          a2 = x4, h2.setCoordsPoint2D(i2);
          continue;
        }
        for (let i3 = a2; i3 < x4; i3++) {
          const s7 = n6[i3], m3 = this.m_shape.getNextVertex(s7), a3 = this.m_shape.getPrevVertex(s7);
          let x5 = false;
          this.m_shape.queryXY(m3, r), h2.compare(r) < 0 && (e5 ? r.y === t2 : r.x === t2) && (this.isCurve(s7) || (o2.push(s7), x5 = true, this.m_shape.setUserIndex(s7, l2, 1))), this.m_shape.queryXY(a3, r), h2.compare(r) < 0 && (e5 ? r.y === t2 : r.x === t2) && (this.isCurve(a3) || (x5 || o2.push(s7), this.m_shape.setUserIndex(s7, c, 1)));
        }
        for (let e6 = 0, t3 = o2.length; e6 < t3; e6++) {
          const t4 = o2[e6], s7 = this.m_shape.getUserIndex(t4, c), n7 = this.m_shape.getUserIndex(t4, l2);
          if (1 === s7) {
            const e7 = this.m_shape.getPrevVertex(t4);
            this.m_shape.queryXY(e7, m2);
            let s8 = 0;
            if (!m2.isEqualPoint2D(i2)) {
              const n8 = ei.distance(h2, m2);
              s8 = ei.distance(m2, i2) / n8, 0 === s8 ? s8 = Number.EPSILON : 1 === s8 && (s8 = 1 - Number.EPSILON), this.m_shape.splitSegment(e7, [s8], 1);
              const r2 = this.m_shape.getPrevVertex(t4);
              this.m_shape.setXY(r2, i2), p3.push(r2), this.m_shape.setUserIndex(r2, c, 1), this.m_shape.setUserIndex(r2, l2, -1);
            }
          }
          if (1 === n7) {
            const e7 = this.m_shape.getNextVertex(t4);
            this.m_shape.queryXY(e7, m2);
            let s8 = 0;
            if (!m2.isEqualPoint2D(i2)) {
              const e8 = ei.distance(h2, m2);
              s8 = ei.distance(h2, i2) / e8, 0 === s8 ? s8 = Number.EPSILON : 1 === s8 && (s8 = 1 - Number.EPSILON), this.m_shape.splitSegment(t4, [s8], 1);
              const n8 = this.m_shape.getNextVertex(t4);
              this.m_shape.setXY(n8, i2), p3.push(n8), this.m_shape.setUserIndex(n8, c, -1), this.m_shape.setUserIndex(n8, l2, 1);
            }
          }
        }
        const s6 = o2;
        o2 = p3, p3 = s6, p3.length = 0, a2 = x4, h2.setCoordsPoint2D(i2);
      }
    }
    this.m_shape.removeUserIndex(c), this.m_shape.removeUserIndex(l2);
  }
  resolveOverlaps(e5, t2) {
    const s4 = new ei(), i2 = [];
    let r = -1;
    for (let n6 = 0, o2 = this.m_verticesOnExtent.length; n6 < o2; n6++) {
      this.progress_();
      const h3 = this.m_verticesOnExtent[n6];
      if (h3 === bm) continue;
      const m3 = this.m_shape.getNextVertex(h3);
      if (this.m_shape.queryXY(h3, s4), (e5 ? s4.y === t2 : s4.x === t2) && (this.m_shape.queryXY(m3, s4), e5 ? s4.y === t2 : s4.x === t2)) {
        if (this.isCurve(h3)) continue;
        -1 === r && (r = this.m_shape.createUserIndex()), -2 !== this.m_shape.getUserIndex(h3, r) && (i2.push(h3), this.m_shape.setUserIndex(h3, r, -2)), -2 !== this.m_shape.getUserIndex(m3, r) && (i2.push(m3), this.m_shape.setUserIndex(m3, r, -2));
      }
    }
    if (0 === i2.length) return void (-1 !== r && this.m_shape.removeUserIndex(r));
    n2(-1 !== r), i2.sort((e6, t3) => this.compareVertices(e6, t3));
    for (let n6 = 0, o2 = i2.length; n6 < o2; n6++) {
      const e6 = i2[n6];
      this.m_shape.setUserIndex(e6, r, n6);
    }
    const h2 = new ei(), m2 = new ei();
    m2.setNAN();
    let a2 = -1;
    for (let n6 = 0, o2 = i2.length; n6 < o2; n6++) {
      this.progress_();
      const o3 = i2[n6];
      if (o3 !== bm && (this.m_shape.queryXY(o3, s4), !s4.isEqualPoint2D(m2))) {
        if (-1 !== a2) for (; ; ) {
          let s5 = false;
          const o4 = n6;
          for (let p3 = a2; p3 < o4; p3++) {
            const a3 = i2[p3];
            if (a3 === bm) continue;
            let o5 = bm;
            const c = this.m_shape.getNextVertex(a3);
            this.m_shape.queryXY(c, h2), m2.compare(h2) < 0 && (e5 ? h2.y === t2 : h2.x === t2) && (this.isCurve(a3) || (o5 = c));
            let l2 = bm;
            const _ = this.m_shape.getPrevVertex(a3);
            if (this.m_shape.queryXY(_, h2), m2.compare(h2) < 0 && (e5 ? h2.y === t2 : h2.x === t2) && (this.isCurve(_) || (l2 = _)), o5 === bm || l2 === bm) {
              if (o5 !== bm || l2 !== bm) {
                for (let c2 = p3 + 1; c2 < n6; c2++) {
                  const n7 = i2[c2];
                  if (n7 === bm) continue;
                  const p4 = this.m_shape.getNextVertex(n7);
                  let _2 = bm;
                  this.m_shape.queryXY(p4, h2), m2.compare(h2) < 0 && (e5 ? h2.y === t2 : h2.x === t2) && (this.isCurve(n7) || (_2 = p4));
                  const u = this.m_shape.getPrevVertex(n7);
                  let g2 = bm;
                  if (this.m_shape.queryXY(u, h2), m2.compare(h2) < 0 && (e5 ? h2.y === t2 : h2.x === t2) && (this.isCurve(u) || (g2 = u)), _2 !== bm && g2 !== bm) {
                    this.beforeRemoveVertex(n7, i2, r), this.m_shape.removeVertex(n7, false), this.beforeRemoveVertex(_2, i2, r), this.m_shape.removeVertex(_2, false), s5 = true;
                    break;
                  }
                  if (o5 !== bm && g2 !== bm) {
                    this.removeOverlap(i2, a3, o5, n7, g2, r), s5 = true;
                    break;
                  }
                  if (l2 !== bm && _2 !== bm) {
                    this.removeOverlap(i2, n7, _2, a3, l2, r), s5 = true;
                    break;
                  }
                }
                if (s5) break;
              }
            } else this.beforeRemoveVertex(a3, i2, r), this.m_shape.removeVertex(a3, false), this.beforeRemoveVertex(o5, i2, r), this.m_shape.removeVertex(o5, false), s5 = true;
          }
          if (!s5) break;
        }
        a2 = n6, m2.setCoordsPoint2D(s4);
      }
    }
    this.m_shape.removeUserIndex(r);
  }
  beforeRemoveVertex(e5, t2, s4) {
    let i2 = this.m_shape.getUserIndex(e5, s4);
    n2(i2 >= 0), t2[i2] = bm, i2 = this.m_shape.getUserIndex(e5, this.m_verticesOnExtentIndex), n2(i2 >= 0), this.m_verticesOnExtent[i2] = bm;
    const r = this.m_shape.getPathFromVertex(e5);
    if (r !== bm) {
      this.m_shape.getFirstVertex(r) === e5 && (this.m_shape.setFirstVertex(r, bm), this.m_shape.setLastVertex(r, bm));
    }
  }
  removeOverlap(e5, t2, s4, i2, n6, r) {
    this.m_shape.setNextVertex(t2, i2), this.m_shape.setPrevVertex(i2, t2), this.m_shape.setPrevVertex(s4, n6), this.m_shape.setNextVertex(n6, s4), this.beforeRemoveVertex(i2, e5, r), this.m_shape.removeVertexInternal(i2, false), this.beforeRemoveVertex(n6, e5, r), this.m_shape.removeVertexInternal(n6, true);
  }
  removeSpikesAlongPoles() {
    this.removeSpikesOnPole(this.m_extent.ymin), this.removeSpikesOnPole(this.m_extent.ymax);
  }
  removeSpikesOnPole(e5) {
    for (let t2 = this.m_shape.getFirstPath(this.m_geometry); t2 !== bm; t2 = this.m_shape.getNextPath(t2)) {
      const s4 = this.m_shape.getPathSize(t2);
      if (s4 < 3) continue;
      let i2 = this.m_shape.getFirstVertex(t2);
      const n6 = new ei();
      this.m_shape.queryXY(i2, n6);
      let r = n6.y === e5 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const h2 = new ei();
      this.m_shape.queryXY(i2, h2);
      let m2 = h2.y === e5 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const a2 = new ei();
      for (let t3 = 0, o2 = s4 - 2; t3 < o2; t3++, i2 = this.m_shape.getNextVertex(i2)) {
        this.progress_(), this.m_shape.queryXY(i2, a2);
        const t4 = a2.y === e5;
        if (m2 && r && t4) {
          if ((h2.x - n6.x) * (a2.x - h2.x) <= 0) {
            this.m_shape.removeVertex(this.m_shape.getPrevVertex(i2), false), h2.setCoordsPoint2D(a2), m2 = t4 && !this.isCurve(i2);
            continue;
          }
        }
        n6.setCoordsPoint2D(h2), r = m2, h2.setCoordsPoint2D(a2), m2 = t4 && !this.isCurve(i2);
      }
    }
  }
  fixPaths() {
    for (let n6 = 0, r = this.m_verticesOnExtent.length; n6 < r; n6++) {
      const e6 = this.m_verticesOnExtent[n6];
      e6 !== bm && this.m_shape.setPathToVertex(e6, bm);
    }
    const e5 = this.m_shape.hasCurves();
    let t2 = 0, s4 = 0;
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== bm; ) {
      const e6 = this.m_shape.getFirstVertex(n6);
      if (e6 === bm || n6 !== this.m_shape.getPathFromVertex(e6)) {
        const e7 = n6;
        n6 = this.m_shape.getNextPath(n6), this.m_shape.setFirstVertex(e7, bm), this.m_shape.removePathOnly(e7);
        continue;
      }
      let i3 = e6, r = 0;
      do {
        this.m_shape.setPathToVertex(i3, n6), r++, i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== e6);
      this.m_shape.setRingAreaValid(n6, false), this.m_shape.setLastVertex(n6, this.m_shape.getPrevVertex(e6)), this.m_shape.setPathSize(n6, r), s4 += r, t2++, n6 = this.m_shape.getNextPath(n6);
    }
    for (let r = 0, h2 = this.m_verticesOnExtent.length; r < h2; r++) {
      let i3 = this.m_verticesOnExtent[r];
      if (i3 === bm) continue;
      let h3 = this.m_shape.getPathFromVertex(i3);
      if (h3 !== bm) continue;
      h3 = this.m_shape.insertPath(this.m_geometry, bm);
      let m2 = false, a2 = 0;
      const o2 = i3;
      do {
        this.m_shape.setPathToVertex(i3, h3), a2++, e5 && a2 <= 2 && (m2 || (m2 = this.isCurve(i3))), i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== o2);
      if (m2 ? 0 === a2 : a2 <= 2) {
        let e6 = this.m_shape.getUserIndex(o2, this.m_verticesOnExtentIndex);
        n2(e6 >= 0), this.m_verticesOnExtent[e6] = bm;
        const t3 = this.m_shape.removeVertex(o2, false);
        2 === a2 && (e6 = this.m_shape.getUserIndex(t3, this.m_verticesOnExtentIndex), e6 >= 0 && (this.m_verticesOnExtent[e6] = bm), this.m_shape.removeVertex(t3, false));
        const s5 = h3;
        h3 = this.m_shape.getNextPath(h3), this.m_shape.setFirstVertex(s5, bm), this.m_shape.removePathOnly(s5);
      } else this.m_shape.setClosedPath(h3, true), this.m_shape.setPathSize(h3, a2), this.m_shape.setFirstVertex(h3, o2), this.m_shape.setLastVertex(h3, this.m_shape.getPrevVertex(o2)), this.m_shape.setRingAreaValid(h3, false), s4 += a2, t2++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, t2), this.m_shape.setGeometryVertexCount(this.m_geometry, s4);
    let i2 = 0;
    for (let n6 = this.m_shape.getFirstGeometry(); n6 !== bm; n6 = this.m_shape.getNextGeometry(n6)) i2 += this.m_shape.getPointCount(n6);
    this.m_shape.setTotalPointCount(i2);
  }
  dbgCheckPathFirst() {
  }
  isCurve(e5) {
    return null !== this.m_shape.getSegment(e5);
  }
  compareVertices(e5, t2) {
    const s4 = new ei();
    this.m_shape.queryXY(e5, s4);
    const i2 = new ei();
    this.m_shape.queryXY(t2, i2);
    return s4.compare(i2);
  }
  clipPolesOut(e5, t2) {
    return this.clipPolygonOrProjectedPolyline2(e5, t2);
  }
};
var I4 = class {
  getOperatorType() {
    return 10004;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t2, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t2, s4, i2) {
    return new V3(e5, t2, s4, i2);
  }
  execute(e5, t2, s4, i2) {
    return X3(e5, t2, s4, i2);
  }
};
var V3 = class extends t {
  constructor(e5, t2, s4, n6) {
    super(), this.m_progressTracker = n6, this.m_index = -1, e5 || P(""), this.m_envelope = t2, this.m_inputGeometryCursor = e5, this.m_spatialRefImpl = s4, this.m_tolerance = wt2(s4, t2, false).total();
  }
  next() {
    let e5;
    return (e5 = this.m_inputGeometryCursor.next()) ? (j(e5), this.m_index = this.m_inputGeometryCursor.getGeometryID(), f2(e5, this.m_envelope, this.m_tolerance, 0, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function X3(e5, t2, s4, i2) {
  return v2(e5, t2, s4, Number.NaN, 0, i2);
}

// node_modules/@arcgis/core/chunks/OperatorDensify.js
var n5 = ah;
var i = class extends t {
  constructor(e5, r, t2, s4, i2, o2) {
    super(), this.m_densificator = new n5(r, t2, s4, o2, false, i2), this.m_index = -1, this.m_inputGeoms = e5;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
  next() {
    let e5 = null;
    for (; e5 = this.m_inputGeoms.next(); ) return j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), this.densify(e5);
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  densify(e5) {
    return this.m_densificator.densify(e5);
  }
};
var o = class {
  getOperatorType() {
    return 10202;
  }
  accelerateGeometry(e5, r, t2) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  executeMany(e5, r, t2, s4, n6, o2 = 12e3) {
    return new i(e5, r, t2, s4, o2, n6);
  }
  execute(e5, r, s4, n6, i2, o2 = 12e3) {
    return sh(e5, r, s4, n6, i2, o2);
  }
};

// node_modules/@arcgis/core/chunks/ProjectionTransformation.js
var Jt2 = class _Jt {
  constructor(e5) {
    if (this.m_geom = this.m_sr = null, e5) {
      if (e5.move) return this.m_geom = e5.move.m_geom, e5.move.m_geom = null, this.m_sr = e5.move.m_sr, void (e5.move.m_sr = null);
      if (e5.copy) return this.m_geom = e5.copy.m_geom ? e5.copy.m_geom.clone() : null, void (this.m_sr = e5.copy.m_sr);
      e5.geom && (this.m_geom = e5.geom), e5.sr && (this.m_sr = e5.sr);
    }
  }
  getGeometry() {
    return this.m_geom;
  }
  getSpatialReference() {
    return this.m_sr;
  }
  setGeometry(e5) {
    this.m_geom = e5;
  }
  setSpatialReference(e5) {
    this.m_sr = e5;
  }
  equals(e5, t2) {
    const s4 = e5;
    return !(!this.m_sr && s4.m_sr) && (!(this.m_sr && !s4.m_sr) && (!(!this.m_geom && s4.m_geom) && (!(this.m_geom && !s4.m_geom) && (!(this.m_sr && s4.m_sr && !this.m_sr.equals(s4.m_sr)) && !(this.m_geom && s4.m_geom && !this.m_geom.equals(s4.m_geom, t2))))));
  }
  clone() {
    let e5 = null;
    return this.m_geom && (e5 = this.m_geom.clone()), new _Jt({ geom: e5, sr: this.m_sr });
  }
  hasGeom() {
    return !!this.m_geom;
  }
};
var $t2 = class {
  constructor(e5) {
    this.m_factor = 1, this.m_wkid = 0, this.m_peUnit = null, e5 && (this.m_peUnit = e5, this.m_factor = e5.getUnitFactor(), this.m_wkid = e5.getCode(), this.m_wkid < 0 && (this.m_wkid = 0));
  }
  getName() {
    return this.m_peUnit.getName();
  }
  getID() {
    return this.m_wkid;
  }
  getConversionFactor(e5) {
    return this.getUnitType() !== e5.getUnitType() && P("unit type mismatch"), this.getUnitToBaseFactor() / e5.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return this.m_factor;
  }
  getHashCode() {
    return gs(ws(this.getUnitType()), ws(this.getUnitToBaseFactor()));
  }
  equals(e5) {
    return !!e5 && (this.getUnitType() === e5.getUnitType() && this.getUnitToBaseFactor() === e5.getUnitToBaseFactor() && this.getID() === e5.getID() && this.getName() === e5.getName());
  }
  static isValidWkid(e5) {
    return false;
  }
};
var es2 = class {
  assign(e5) {
    this.m_reason = e5.m_reason, this.m_vertexIndex1 = e5.m_vertexIndex1, this.m_vertexIndex2 = e5.m_vertexIndex2;
  }
  constructor(e5, t2, s4) {
    void 0 !== e5 ? (this.m_reason = e5, this.m_vertexIndex1 = t2, this.m_vertexIndex2 = s4) : (this.m_reason = 0, this.m_vertexIndex1 = -1, this.m_vertexIndex2 = -2);
  }
  clear() {
    this.m_reason = 0, this.m_vertexIndex1 = -1, this.m_vertexIndex2 = -1;
  }
};
var ts2 = { 330: 104878, 500: 104879, 1300: 104899, 1450: 104986, 2230: 104988, 3800: 104978, 5e3: 104919, 6200: 104906, 8200: 104909, 9500: 104927, 9600: 104977, 1e4: [104911, 104936], 11e3: 104941, 11080: 104872, 11100: 104907, 12e3: 104920, 12400: 104995, 13e3: 104948, 14e3: [104923, 104989], 15e3: [104913, 104954], 15100: 104976, 16e3: [104926, 104931], 18e3: [104922, 104982], 21e3: 104947, 21500: 104877, 27e3: [104950, 104957], 29e3: 104964, 3e4: 104921, 31e3: 104949, 33e3: 104946, 4e4: [104914, 104967], 40600: 104897, 41900: 104937, 42e3: 104951, 43100: 104993, 49300: 104924, 50100: 104939, 54e3: 104955, 58200: 104981, 59500: 104930, 74e3: 104961, 77e3: 104956, 79e3: 104962, 83500: 104910, 85e3: 104917, 88800: 104934, 89200: 104985, 96e3: 104997, 104e3: 104963, 106500: 104898, 11e4: 104938, 133e3: 104932, 135e3: 104983, 17e4: 104965, 198200: 104987, 198630: 104935, 208e3: 104966, 235800: 104952, 249400: 104929, 252100: 104980, 255e3: 104973, 47e4: 104972, 529800: 104942, 531e3: 104996, 56e4: 104928, 561400: 104979, 578900: 104945, 584700: 104959, 593e3: 104970, 606e3: 104999, 718e3: 104933, 745700: 104984, 761400: 104953, 763500: 104994, 764e3: 104940, 788900: 104958, 1188300: 104998, 1195e3: 104969, 1352600: 104968, 1560800: 104874, 1562090: 104915, 1737400: 104903, 1821460: 104918, 1821490: 104876, 2409300: 104912, 2410300: 104873, 2439400: 104974, 2439700: 104900, 2575e3: 104943, 2631200: 104875, 2632345: 104916, 3393400: 104904, 3396190: [104905, 104971], 6051e3: 104901, 6051800: 104902, 637e4: 104128, 6370997: [4052, 37008], 6371e3: 4035, 6371007: 4047, 6371228: [4053, 10346], 6376045: [8042, 8043], 6376523: [4027, 4901, 4902], 6376896: 37007, 6378135: [4122, 4322, 4324, 4720, 4985, 4987], 6378136: [4740, 4923, 7678, 7680, 9474, 9475, 104017, 104018], 6378137: [3823, 3824, 3888, 3889, 4017, 4019, 4023, 4031, 4040, 4046, 4055, 4074, 4075, 4080, 4081, 4121, 4126, 4130, 4133, 4140, 4141, 4148, 4151, 4152, 4163, 4166, 4167, 4170, 4171, 4172, 4173, 4176, 4180, 4189, 4190, 4258, 4269, 4283, 4318, 4319, 4326, 4463, 4466, 4469, 4470, 4480, 4482, 4483, 4490, 4557, 4558, 4612, 4617, 4619, 4624, 4627, 4659, 4661, 4667, 4669, 4670, 4674, 4686, 4687, 4693, 4694, 4702, 4737, 4742, 4747, 4749, 4750, 4755, 4756, 4757, 4758, 4759, 4761, 4762, 4763, 4764, 4765, 4883, 4885, 4887, 4889, 4893, 4895, 4898, 4907, 4909, 4921, 4925, 4927, 4929, 4931, 4933, 4935, 4937, 4939, 4941, 4943, 4945, 4947, 4949, 4951, 4953, 4955, 4957, 4959, 4961, 4963, 4965, 4967, 4971, 4975, 4977, 4979, 4981, 4983, 4989, 4997, 4999, 5012, 5013, 5245, 5246, 5251, 5252, 5263, 5264, 5323, 5324, 5340, 5342, 5353, 5354, 5359, 5360, 5364, 5365, 5370, 5371, 5372, 5373, 5380, 5381, 5392, 5393, 5488, 5489, 5545, 5546, 5592, 5593, 5885, 5886, 6134, 6135, 6310, 6311, 6318, 6319, 6321, 6322, 6324, 6325, 6364, 6365, 6667, 6668, 6705, 6706, 6782, 6783, 6980, 6982, 6983, 6987, 6989, 6990, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7072, 7073, 7084, 7085, 7086, 7087, 7133, 7135, 7136, 7138, 7139, 7372, 7373, 7657, 7659, 7661, 7663, 7665, 7685, 7686, 7797, 7798, 7816, 7843, 7844, 7880, 7881, 7885, 7886, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 8085, 8086, 8231, 8232, 8235, 8237, 8239, 8240, 8244, 8246, 8248, 8249, 8251, 8252, 8254, 8255, 8399, 8403, 8426, 8427, 8449, 8542, 8544, 8545, 8684, 8685, 8698, 8699, 8817, 8818, 8860, 8888, 8899, 8900, 8901, 8902, 8906, 8907, 8916, 8918, 8920, 8922, 8924, 8926, 8928, 8930, 8932, 8934, 8936, 8938, 8940, 8942, 8944, 8946, 8948, 8949, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9e3, 9002, 9003, 9005, 9006, 9008, 9009, 9011, 9012, 9013, 9014, 9016, 9017, 9018, 9019, 9053, 9054, 9055, 9056, 9057, 9059, 9060, 9061, 9062, 9063, 9064, 9065, 9066, 9067, 9068, 9069, 9071, 9072, 9074, 9075, 9139, 9140, 9147, 9148, 9152, 9153, 9183, 9184, 9293, 9294, 9299, 9308, 9309, 9332, 9333, 9364, 9372, 9379, 9380, 9384, 9453, 9469, 9470, 9546, 9547, 9695, 9696, 9701, 9702, 9739, 9754, 9755, 9758, 9763, 9776, 9777, 9778, 9779, 9781, 9782, 9783, 9784, 9866, 9871, 9939, 9964, 9969, 9974, 9989, 9990, 10175, 10177, 10178, 10185, 10191, 10196, 10204, 10209, 10214, 10219, 10224, 10229, 10237, 10272, 10277, 10283, 10284, 10298, 10299, 10300, 10304, 10305, 10307, 10309, 10310, 10311, 10312, 10327, 10328, 10413, 10414, 10468, 10474, 10475, 10570, 10571, 10605, 10606, 10623, 10628, 20033, 20040, 20041, 20045, 20046, 104009, 104010, 104011, 104012, 104013, 104014, 104015, 104016, 104019, 104020, 104021, 104022, 104024, 104027, 104028, 104050, 104100, 104107, 104108, 104110, 104111, 104114, 104115, 104116, 104117, 104118, 104119, 104120, 104121, 104122, 104123, 104124, 104129, 104133, 104134, 104137, 104141, 104142, 104143, 104144, 104145, 104179, 104180, 104181, 104182, 104183, 104184, 104185, 104186, 104199, 104223, 104257, 104258, 104259, 104260, 104286, 104287, 104602, 104613, 104644, 104645, 104646, 104647, 104653, 104804, 104896, 104991], 6378140: 4610, 6378145: [4025, 4276, 4760, 4891, 37001], 6378150: 37003, 6378155: [37004, 37207], 6378160: [3821, 4003, 4021, 4036, 4202, 4203, 4237, 4238, 4291, 4618, 4708, 5527, 37231, 104023, 104136], 6378166: 37002, 6378200: [4020, 4229, 4286, 4303, 4706], 6378245: [4024, 4147, 4164, 4178, 4179, 4191, 4200, 4205, 4214, 4284, 4317, 4555, 4676, 4677, 4678, 4991, 4993, 5560, 5561, 37257, 104135], 6378270: [4732, 37005, 37229], 6378273: [4054, 10345], 6378300: [4029, 4168, 4174], 6378388: [4022, 4123, 4153, 4154, 4158, 4159, 4160, 4161, 4165, 4181, 4182, 4183, 4184, 4185, 4192, 4194, 4195, 4196, 4199, 4204, 4207, 4208, 4215, 4218, 4221, 4224, 4225, 4230, 4231, 4233, 4235, 4236, 4247, 4248, 4249, 4254, 4255, 4259, 4264, 4265, 4271, 4272, 4274, 4285, 4287, 4288, 4292, 4297, 4309, 4311, 4313, 4316, 4472, 4475, 4611, 4614, 4615, 4616, 4621, 4622, 4623, 4625, 4626, 4628, 4629, 4630, 4631, 4632, 4633, 4636, 4637, 4639, 4641, 4642, 4643, 4644, 4645, 4646, 4658, 4660, 4662, 4663, 4664, 4665, 4668, 4672, 4673, 4684, 4688, 4689, 4690, 4691, 4692, 4698, 4704, 4705, 4707, 4709, 4710, 4711, 4712, 4714, 4715, 4716, 4718, 4719, 4721, 4722, 4724, 4725, 4727, 4728, 4729, 4730, 4733, 4734, 4735, 4739, 4741, 4753, 4754, 4802, 4803, 4806, 4809, 4810, 4823, 4824, 4900, 5524, 6883, 8428, 8430, 8431, 9248, 9251, 9253, 9403, 9893, 10158, 10249, 10252, 37201, 37204, 37205, 37212, 37213, 37214, 37215, 37216, 37217, 37218, 37219, 37221, 37222, 37224, 37226, 37227, 37230, 37232, 37233, 37234, 37235, 37237, 37238, 37241, 37242, 37245, 37246, 37247, 37249, 37250, 37251, 37253, 37259, 104104, 104106, 104125, 104126, 104127, 104130, 104138, 104248], 6378523: 104786, 24764e3: 104960, 25559e3: 104944, 60268e3: 104925, 71492e3: 104908, 6957e5: 104975, 6377397155e-3: [3819, 3906, 4004, 4120, 4124, 4125, 4149, 4150, 4156, 4162, 4211, 4219, 4257, 4262, 4280, 4289, 4294, 4295, 4301, 4306, 4308, 4312, 4314, 4613, 4666, 4745, 4746, 4801, 4804, 4805, 4808, 4813, 4814, 4815, 4818, 4820, 4904, 5132, 5228, 5229, 5681, 5830, 8351, 9267, 10268, 37255, 104101, 104102, 104105, 104131, 104648, 104696, 104697, 104990, 104992], 6377563396e-3: [4001, 4188, 4277, 4278, 4279], 6377340189e-3: [4002, 4299, 4300], 6377492018e-3: [4005, 4273, 4817], 6377483865280418e-9: [4006, 4293], 6378293645208759e-9: [4007, 4157, 4302, 4738, 5464], 63782064e-1: [4008, 4127, 4128, 4129, 4135, 4136, 4137, 4138, 4139, 4169, 4216, 4242, 4253, 4267, 4608, 4609, 4638, 4675, 4683, 4695, 4717, 4723, 4726, 4995, 5451, 5467, 37220, 37239, 37243, 37252, 37260, 104e3, 104109, 104112, 104113, 104132], 6378450047e-3: [4009, 4268], 6378300789e-3: [4010, 4281], 63782492e-1: [4011, 4014, 4155, 4193, 4206, 4213, 4223, 4226, 4227, 4228, 4252, 4261, 4266, 4275, 4282, 4296, 4304, 4310, 4315, 4671, 4807, 4811, 4816, 4821, 37223, 37225, 104139, 104140, 104261, 104304], 6378249145e-3: [4012, 4013, 4132, 4134, 4142, 4143, 4175, 4197, 4198, 4201, 4209, 4210, 4212, 4220, 4222, 4232, 4234, 4246, 4250, 4251, 4256, 4260, 4263, 4270, 4305, 4307, 4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4620, 4679, 4680, 4696, 4697, 4699, 4700, 4701, 4703, 4713, 4731, 4736, 4743, 4744, 4812, 4819, 6881, 6882, 6892, 6894, 8694, 37206, 37208, 37211, 37228, 37240, 37254, 104025, 104026, 104103, 104305], 6377276345e-3: [4015, 4131, 4144, 4239, 4240, 4244, 4682, 5233, 6207, 37202, 104256, 104664, 104693], 6377298556e-3: [4016, 4298], 6377304063e-3: [4018, 4245], 63782983e-1: [4028, 4903], 63781362e-1: 4032, 63781363e-1: 4033, 6378249144808011e-9: [4034, 4241], 209229318e-1: [4042, 4243], 6377301243e-3: [4044, 4145, 37203], 6377299151e-3: [4045, 4146], 637701927e-2: [4657, 10256, 10260, 10265], 63783063696e-4: [4748, 4752], 6377295664e-3: [4751, 37006], 63781365e-1: [7682, 7683], 63710087714e-4: 104047, 6378418941e-3: [104700, 104726, 104760], 6378586581e-3: [104701, 104743], 6378505809e-3: 104702, 6378544823e-3: 104703, 6378490569e-3: 104704, 6378470757e-3: [104705, 104776], 6378403701e-3: [104706, 104750], 6378434181e-3: [104707, 104724, 104739, 104764], 6378454907e-3: 104708, 6378400653e-3: 104709, 6378567378e-3: 104710, 6378546957e-3: [104711, 104717, 104780], 6378476853e-3: [104712, 104736], 6378411321e-3: [104713, 104728], 6378647541e-3: [104714, 104715], 6378514953e-3: [104716, 104782], 6378421989e-3: [104718, 104770], 6378481425e-3: [104719, 104753, 104774, 104781], 6378518001e-3: [104720, 104725], 6378521049e-3: [104721, 104723, 104731, 104745, 104748], 6378464661e-3: 104722, 6378436619e-3: 104727, 6378574389e-3: [104729, 104730], 6378472281e-3: [104732, 104756], 6378498189e-3: [104733, 104746], 6378449421e-3: [104734, 104766], 6378525621e-3: [104735, 104754], 6378466185e-3: 104737, 6378496665e-3: 104738, 6378643579e-3: 104740, 6378559758e-3: 104741, 6378414369e-3: [104742, 104763, 104772], 6378441801e-3: 104744, 6378502761e-3: [104747, 104759, 104773, 104775], 6378617061e-3: 104749, 6378624681e-3: [104751, 104765], 6378468623e-3: 104752, 6378445763e-3: [104755, 104758, 104761], 6378670401e-3: 104757, 6378438753e-3: 104762, 6378543909e-3: 104767, 6378605783e-3: 104768, 6378540861e-3: 104769, 6378443325e-3: [104771, 104784], 6378548481e-3: 104777, 6378463746e-3: 104778, 6378426561e-3: 104779, 6378453688e-3: 104783, 6378530193e-3: 104785, 6378376271e-3: [104800, 104828], 637847192e-2: 104801, 6378472931e-3: 104802, 6378411351e-3: 104803, 6378380991e-3: 104805, 637841496e-2: 104806, 637834509e-2: [104807, 104819, 104844, 104870], 6378412542e-3: 104808, 6378470401e-3: 104809, 6378376331e-3: 104810, 6378379031e-3: 104811, 6378407621e-3: 104812, 6378376811e-3: [104813, 104827], 637831392e-2: 104814, 637841493e-2: 104815, 6378413021e-3: 104816, 6378380381e-3: 104817, 6378530851e-3: 104818, 6378591521e-3: 104820, 6378378881e-3: 104821, 6378408481e-3: [104822, 104832], 6378375601e-3: [104823, 104838], 6378408041e-3: 104824, 6378655071e-3: 104825, 6378409151e-3: 104826, 63783157e-1: [104829, 104840, 104845, 104851], 637828586e-2: [104830, 104835, 104859], 6378379301e-3: 104831, 6378560121e-3: 104833, 6378531821e-3: 104834, 63785006e-1: 104836, 6378376041e-3: 104837, 6378406601e-3: 104839, 6378438991e-3: 104841, 637834542e-2: 104842, 637859386e-2: 104843, 6378381271e-3: [104846, 104847], 6378413671e-3: 104848, 6378344377e-3: 104849, 6378563891e-3: 104850, 6378408091e-3: 104852, 6378377671e-3: 104853, 6378472751e-3: 104854, 6378412511e-3: 104855, 6378407281e-3: 104856, 6378534451e-3: 104857, 6378406051e-3: 104858, 6378532921e-3: 104860, 6378380091e-3: 104861, 6378408941e-3: 104862, 6378624171e-3: 104863, 6378377411e-3: 104864, 6378474591e-3: 104865, 6378407141e-3: 104866, 6378376871e-3: 104867, 6378375251e-3: 104868, 6378405971e-3: 104869, 6378437651e-3: 104871 };
function ss2() {
  for (const e5 in ts2) delete ts2[e5];
}
var ns2 = class extends $t2 {
  constructor(e5) {
    if ("number" == typeof e5) return super(), this.m_factor = e5, void (this.m_wkid = 0);
    super(e5);
  }
  getUnitType() {
    return 1;
  }
  convertFromRadians(e5) {
    return e5 / this.getUnitToBaseFactor();
  }
  convertToRadians(e5) {
    return e5 * this.getUnitToBaseFactor();
  }
};
function rs3(e5) {
  return new Eu();
}
function is2(e5) {
  return e5.getType() === Ec.PE_TYPE_LINUNIT ? new Eu(e5) : e5.getType() === Ec.PE_TYPE_ANGUNIT ? new ns2(e5) : void P("peUnit");
}
function os3(e5) {
  const s4 = Gc(null);
  return e5.getType() === Ec.PE_TYPE_PROJCS || e5.getType() === Ec.PE_TYPE_GEOGCS ? s4.reset(e5.getUnit()) : P("PE_coord_sys"), s4.get() || b("cannot create units from coord sys"), is2(s4.get());
}
var as3 = class _as {
  constructor(e5, s4, n6) {
    void 0 === e5 ? (this.x = new p2(), this.y = new p2(), this.z = new p2()) : e5 instanceof X2 ? (this.x = new p2(e5.x), this.y = new p2(e5.y), this.z = new p2(e5.z)) : e5 instanceof p2 ? (this.x = e5.clone(), this.y = s4.clone(), this.z = n6.clone()) : P("EPoint3D constructor");
  }
  dotProduct(e5) {
    return this.x.mulE(e5.x).addE(this.y.mulE(e5.y)).addE(this.z.mulE(e5.z));
  }
  crossProduct(e5) {
    return new _as(this.y.mulE(e5.z).subE(this.z.mulE(e5.y)), this.z.mulE(e5.x).subE(this.x.mulE(e5.z)), this.x.mulE(e5.y).subE(this.y.mulE(e5.x)));
  }
  crossProductVector(e5) {
    const t2 = this.y.mulE(e5.z).subE(e5.y.mulE(this.z)), s4 = e5.x.mulE(this.z).subE(this.x.mulE(e5.z)), n6 = this.x.mulE(e5.y).subE(e5.x.mulE(this.y));
    return new _as(t2, s4, n6);
  }
  sqrLength() {
    return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z));
  }
  length() {
    return this.sqrLength().sqrt();
  }
  static distance(e5, t2) {
    return e5.sub(t2).length();
  }
  negate() {
    return new _as(this.x.negate(), this.y.negate(), this.z.negate());
  }
  add(e5) {
    return new _as(this.x.addE(e5.x), this.y.addE(e5.y), this.z.addE(e5.z));
  }
  sub(e5) {
    return new _as(this.x.subE(e5.x), this.y.subE(e5.y), this.z.subE(e5.z));
  }
  subThis(e5) {
    return this.x.subThisE(e5.x), this.y.subThisE(e5.y), this.z.subThisE(e5.z), this;
  }
  addThis(e5) {
    return this.x.addThisE(e5.x), this.y.addThisE(e5.y), this.z.addThisE(e5.z), this;
  }
  mul(e5) {
    return new _as(this.x.mulE(e5), this.y.mulE(e5), this.z.mulE(e5));
  }
  div(e5) {
    return new _as(this.x.divE(e5), this.y.divE(e5), this.z.divE(e5));
  }
  eq(e5) {
    return this.x.eq(e5.x) && this.y.eq(e5.y) && this.z.eq(e5.z);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero() && this.z.isZero();
  }
  value() {
    return X2.construct(this.x.value(), this.y.value(), this.z.value());
  }
};
var hs3 = class {
  constructor(e5) {
    if (this.m_origin = new X2(), this.m_normal = new X2(), this.m_axisX = new X2(), this.m_axisY = new X2(), !e5) return this.m_origin = new X2(), this.m_normal = new X2(0, 0, 1), this.m_axisX = new X2(1, 0, 0), void (this.m_axisY = new X2(0, 1, 0));
    e5.pt0 && e5.pt1 && e5.pt2 ? this.setFromPoints(e5.pt0, e5.pt1, e5.pt2) : n2(0, `unimplemented constructor options ${JSON.stringify(e5)}`);
  }
  assign(e5) {
    return n2(0), this;
  }
  set(e5, t2, n6, r) {
    n2(0);
  }
  setFromPoints(e5, t2, s4) {
    let n6 = t2.sub(e5);
    const r = s4.sub(e5);
    this.m_normal = n6.crossProductVector(r);
    let i2 = true;
    if (this.m_normal.isZero()) {
      if (i2 = false, n6.isZero() && (n6 = r), n6.isZero()) {
        const t3 = 0, s5 = 1;
        return this.m_normal.setCoords(t3, t3, s5), this.m_axisX.setCoords(s5, t3, t3), this.m_axisY.setCoords(t3, s5, t3), this.m_origin = e5, false;
      }
      this.m_axisX = n6.getUnitVector(), this.m_normal = this.m_axisX.createAPerpendicular();
    } else this.m_normal.normalizeThis(), this.m_axisX = n6.getUnitVector();
    return this.m_axisY = this.m_normal.crossProductVector(this.m_axisX), this.m_origin = e5, i2;
  }
  getCoord(e5, t2) {
    return n2(0), {};
  }
  getCoord2D(e5) {
    return n2(0), {};
  }
  getCoordX(e5, t2) {
    return n2(0), 0;
  }
  getCoordY(e5, t2) {
    return n2(0), 0;
  }
  getCoordZ(e5, t2) {
    return n2(0), 0;
  }
  setPreferredAxisX(e5) {
    n2(0);
  }
  getOrigin() {
    return n2(0), {};
  }
  getNormal() {
    return n2(0), {};
  }
  getAxisX() {
    return this.m_axisX.clone();
  }
  getAxisY() {
    return this.m_axisY.clone();
  }
  setAxisX(e5, t2 = false) {
    n2(0);
  }
  setAxisY(e5, t2 = false) {
    n2(0);
  }
  recalculateAxisY() {
    n2(0);
  }
  setOrigin(e5) {
    n2(0);
  }
  setNormal(e5, t2) {
    n2(0);
  }
  intersect(e5, t2) {
    return n2(0), false;
  }
  intersectLine(e5) {
    return n2(0), 0;
  }
  intersectLineEx(e5, t2) {
    return n2(0), 0;
  }
  closestCoordinate(e5) {
    const t2 = e5.sub(this.m_origin), s4 = new ei();
    return s4.x = t2.dotProduct(this.m_axisX), s4.y = t2.dotProduct(this.m_axisY), s4;
  }
  projectVector(e5) {
    return n2(0), {};
  }
  signedDistance(e5) {
    return n2(0), 0;
  }
  distance(e5) {
    return n2(0), 0;
  }
};
function ms3(e5, t2) {
  return false;
}
function ls3(e5, t2, n6, r, i2 = 100, o2 = ms3) {
  let a2, h2, m2, l2, g2, u, c, _, d2;
  n2(r > 0);
  let p3, f3, x4, y2 = 0, P5 = 0;
  const E2 = Rs();
  t2 > n6 && (n6 = Mt(t2, t2 = n6));
  const C2 = e5(t2), S3 = e5(n6);
  C2 < S3 ? (a2 = h2 = m2 = t2, l2 = g2 = u = C2) : (a2 = h2 = m2 = n6, l2 = g2 = u = S3);
  let I5 = 0;
  for (; I5 < i2 && (x4 = 0.5 * (n6 - t2), d2 = t2 + x4, p3 = r * (Math.abs(a2) + 0.25), f3 = 2 * p3, !(o2(a2, l2) || Math.abs(a2 - d2) <= f3 - x4)); ++I5) {
    if (Math.abs(P5) > p3) {
      const e6 = (a2 - h2) * (l2 - u);
      let s4 = (a2 - m2) * (l2 - g2), r2 = (a2 - m2) * s4 - (a2 - h2) * e6;
      s4 = 2 * (s4 - e6), s4 > 0 && (r2 = -r2), s4 = Math.abs(s4);
      const i3 = P5;
      P5 = y2, Math.abs(r2) >= Math.abs(s4 * i3 * 0.5) || r2 <= s4 * (t2 - a2) || r2 >= s4 * (n6 - a2) ? (P5 = a2 >= d2 ? t2 - a2 : n6 - a2, y2 = Rs() * P5) : (y2 = r2 / s4, _ = a2 + y2, (_ - t2 < f3 || n6 - _ < f3) && (y2 = d2 - a2 < 0 ? -Math.abs(p3) : Math.abs(p3)));
    } else P5 = a2 >= d2 ? t2 - a2 : n6 - a2, y2 = P5 * E2;
    _ = a2 + y2, c = e5(_), c < l2 ? (_ >= a2 ? t2 = a2 : n6 = a2, m2 = h2, h2 = a2, a2 = _, u = g2, g2 = l2, l2 = c) : (_ < a2 ? t2 = _ : n6 = _, c <= g2 || h2 === a2 ? (m2 = h2, h2 = _, u = g2, g2 = c) : (c <= u || m2 === a2 || m2 === h2) && (m2 = _, u = c));
  }
  return Qt(a2, l2);
}
function gs3(e5, t2, s4) {
  if (e5 > s4) {
    e5 -= Math.ceil((e5 - s4) / Ut) * Ut;
  } else if (e5 < t2) {
    e5 += Math.ceil((t2 - e5) / Ut) * Ut;
  }
  return e5;
}
function us3(e5, t2, s4) {
  return cs2(e5, t2, s4, 0);
}
function cs2(e5, t2, s4, n6) {
  const r = s4.x, i2 = s4.y;
  return ds2(e5, t2, Math.cos(r), Math.sin(r), Math.cos(i2), Math.sin(i2), n6);
}
function _s2(e5, t2, s4, n6, r, i2) {
  return ds2(e5, t2, s4, n6, r, i2, 0);
}
function ds2(e5, t2, s4, n6, r, i2, o2) {
  const a2 = e5 / Math.sqrt(1 - t2 * i2 * i2), h2 = a2 + o2, m2 = h2 * r * s4, l2 = h2 * r * n6, g2 = (a2 * (1 - t2) + o2) * i2;
  return X2.construct(m2, l2, g2);
}
function ps2(e5, t2, s4) {
  const n6 = new p2(), r = new p2(), i2 = new p2(), o2 = new p2();
  n6.setCos(s4.x), r.setSin(s4.x), i2.setCos(s4.y), o2.setSin(s4.y);
  const a2 = o2.negate().mulE(o2.mul(t2)).add(1).sqrt(), h2 = new p2(e5).divE(a2), m2 = h2.mulE(i2).mulE(n6), l2 = h2.mulE(i2).mulE(r), g2 = h2.mul(1 - t2).mulE(o2);
  return new as3(m2, l2, g2);
}
function fs2(e5, t2, s4) {
  const n6 = s4.x, r = s4.y, i2 = s4.z, o2 = Math.atan2(r, n6), a2 = Math.sqrt(n6 * n6 + r * r), h2 = Math.atan2(i2, (1 - t2) * a2);
  return ei.construct(o2, h2);
}
function xs2(e5, t2, s4) {
  const n6 = 1 - t2, r = e5 / Math.sqrt($(s4.x) + $(s4.y) + $(s4.z) / n6);
  return s4.mul(r);
}
function ys(e5, t2, s4, n6, r) {
  const i2 = us3(e5, t2, s4), o2 = us3(e5, t2, n6);
  return fs2(e5, t2, X2.lerp(i2, o2, r));
}
function Ps3(e5, t2, s4) {
  const n6 = new X2();
  return n6.setCrossProductVector(t2, s4), Math.abs(Math.atan2(n6.length(), t2.dotProduct(s4))) * e5;
}
function Es3(e5, t2, s4, n6, r) {
  const i2 = s4.getUnitVector(), o2 = n6.getUnitVector(), a2 = t2.getUnitVector(), h2 = new X2();
  if (h2.setCrossProductVector(i2, o2), !h2.isZero()) {
    h2.normalizeThis();
    const t3 = a2.sub(h2.mul(h2.dotProduct(a2)));
    if (!t3.isZero()) {
      t3.normalizeThis();
      const s5 = i2.add(o2).mul(0.5);
      if (s5.dotProduct(t3) > s5.dotProduct(i2)) {
        const s6 = Math.abs(h2.dotProduct(a2)), n7 = Math.asin(s6);
        return r.assign(t3.getUnitVector().mul(e5)), n7 * e5;
      }
    }
  }
  const m2 = Ps3(1, i2, a2), l2 = Ps3(1, o2, a2);
  return m2 <= l2 ? (r.assign(s4), m2 * e5) : (r.assign(n6), l2 * e5);
}
function Cs3(e5, t2, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = n(r, new yc(), false);
    return vc.geodeticDistance(e5, t2, s4.x, s4.y, n6.x, n6.y, i2, null, null, Ec.PE_LINETYPE_GEODESIC), i2.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function Ss3(e5, t2, n6, r, i2) {
  switch (n2(n6.isFinite() && r.isFinite()), i2) {
    case 0:
      return Cs3(e5, t2, n6, r);
    case 1:
      return ws3(e5, t2, n6);
    case 2:
    case 3: {
      const s4 = us3(e5, t2, n6), i3 = us3(e5, t2, r);
      return X2.distance(s4, i3);
    }
    default:
      z("");
  }
}
function Is3(e5, t2, s4, n6, r, i2 = 0, o2) {
  if (2 === i2 || 3 === i2) return bs2(e5, t2, s4, n6, r, 3 === i2, o2);
  const a2 = fs2(e5, t2, s4), h2 = (s5) => {
    const o3 = fs2(e5, t2, X2.lerp(n6, r, s5));
    return Ss3(e5, t2, a2, o3, i2);
  }, m2 = X2.distance(n6, r);
  if (m2 > 0) {
    const s5 = Us2(e5, m2), { first: i3, second: a3 } = ls3(h2, 0, 1, s5);
    return o2 && o2.assign(xs2(e5, t2, X2.lerp(n6, r, i3))), Qt(i3, a3);
  }
  {
    const e6 = h2(0);
    return o2 && o2.assign(n6), Qt(0.5, e6);
  }
}
function bs2(e5, t2, s4, n6, r, i2 = false, o2) {
  const a2 = xs2(e5, t2, s4);
  if (i2) {
    const i3 = new hs3({ pt0: new X2(0, 0, 0), pt1: n6, pt2: r }), h3 = i3.closestCoordinate(s4), m3 = i3.closestCoordinate(n6), l2 = i3.closestCoordinate(r), g2 = ei.getClosestCoordinate(m3, l2, h3), u = xs2(e5, t2, X2.lerp(n6, r, g2)), c = X2.distance(u, a2);
    return o2 && o2.assign(u), Qt(g2, c);
  }
  const h2 = (s5) => {
    const i3 = xs2(e5, t2, X2.lerp(n6, r, s5));
    return X2.distance(i3, a2);
  }, m2 = X2.distance(n6, r);
  if (m2 > 0) {
    const s5 = Us2(e5, m2), { first: i3, second: a3 } = ls3(h2, 0, 1, s5);
    return o2 && o2.assign(xs2(e5, t2, X2.lerp(n6, r, i3))), Qt(i3, a3);
  }
  {
    const e6 = X2.distance(s4, n6);
    return o2 && o2.assign(s4), Qt(0.5, e6);
  }
}
function ws3(e5, t2, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const n7 = n(r, new yc(), false);
    return vc.greatEllipticDistance(e5, t2, s4.x, s4.y, s4.x, s4.y, n7, null, null), n7.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function vs2(e5, t2, s4, n6, r) {
  if (Math.abs(s4.x - n6.x) > Math.PI) return Number.NaN;
  if (Math.abs(s4.y) > Yt || Math.abs(n6.y) > Yt) return Number.NaN;
  if ((Math.abs(s4.y) === Yt || Math.abs(n6.y) === Yt) && s4.x !== n6.x) return Number.NaN;
  const { first: i2, second: o2 } = R2(s4.x, n6.x);
  let a2 = r;
  a2 = gs3(a2, i2, o2);
  if (!x2.construct(s4.x, n6.x).containsCoordinate(a2)) return Number.NaN;
  const h2 = Se.constructPoint2D(s4), m2 = Se.constructPoint2D(n6), l2 = ps2(1, t2, h2), g2 = ps2(1, t2, m2), u = l2.crossProductVector(g2);
  if (u.z.isZero()) {
    return s4.y;
  }
  const c = u.x.divE(u.z.negate()), _ = u.y.divE(u.z.negate()), d2 = c.mulE(c).addE(_.mulE(_)).sqrt();
  if (d2.isZero() || c.isZero() && _.isZero()) {
    return s4.y;
  }
  const p3 = Math.atan2(_.value(), c.value());
  let f3 = Math.atan2(d2.value() * Math.cos(p3 - a2), 1 - t2);
  const x4 = us3(1, t2, ei.construct(a2, f3)), y2 = X2.construct(x4.x, x4.y, -x4.z), P5 = u.value().dotProduct(x4), E2 = u.value().dotProduct(y2);
  return Math.abs(E2) < Math.abs(P5) && (f3 = -f3), f3;
}
function Ns2(e5, t2, s4, n6, r, i2) {
  if (i2[0] = Number.NaN, i2[1] = Number.NaN, Math.abs(s4.x - n6.x) > Math.PI) return 0;
  if (Math.abs(s4.y) > Yt || Math.abs(n6.y) > Yt) return 0;
  if ((Math.abs(s4.y) === Yt || Math.abs(n6.y) === Yt) && s4.x !== n6.x) return 0;
  if (Math.abs(r) >= Yt) return 0;
  if (s4.y > 0 && n6.y > 0 && s4.y > r && n6.y > r || s4.y < 0 && n6.y < 0 && s4.y < r && n6.y < r) return 0;
  const o2 = Se.constructPoint2D(s4), a2 = Se.constructPoint2D(n6), h2 = ps2(1, t2, o2), m2 = ps2(1, t2, a2), l2 = h2.crossProductVector(m2);
  if (l2.z.isZero()) {
    return x2.construct(s4.y, n6.y).containsCoordinate(r) ? (i2[0] = s4.x, 1) : 0;
  }
  const g2 = l2.x.divE(l2.z.negate()), u = l2.y.divE(l2.z.negate()), c = g2.mulE(g2).addE(u.mulE(u)).sqrt();
  if (c.isZero() || g2.isZero() && u.isZero()) return 0 === r ? (i2[0] = s4.x, i2[1] = n6.x, 2) : 0;
  const _ = (1 - t2) * Math.tan(r) / c.value();
  if (Math.abs(_) > 1) return 0;
  const d2 = Math.acos(_), p3 = Math.atan2(u.value(), g2.value()), f3 = p3 - d2;
  let x4 = p3 + d2;
  const y2 = Math.min(s4.x, n6.x), P5 = Math.max(s4.x, n6.x);
  gs3(f3, y2, P5), 0 !== r ? gs3(x4, y2, P5) : x4 = f3;
  let E2 = 0;
  return y2 <= f3 && f3 <= P5 && (i2[E2] = f3, E2++), x4 !== f3 && y2 <= x4 && x4 <= P5 && (i2[E2] = x4, E2++), E2;
}
function Ts3(e5, t2) {
  t2[0] > 0.5 * Math.PI ? (e5[0] += Math.PI, t2[0] = Math.PI - t2[0]) : t2[0] < 0.5 * -Math.PI && (e5[0] -= Math.PI, t2[0] = -Math.PI - t2[0]), n2(t2[0] >= 0.5 * -Math.PI && t2[0] <= 0.5 * Math.PI);
}
function Gs3(e5, t2) {
  return e5 * Math.sqrt(1 - t2);
}
function Ds2(e5) {
  return 1 - e5;
}
function Vs3(e5, t2, s4, n6, r) {
  n6 = ks(n6, -Yt, Yt), r = ks(r, -Yt, Yt);
  const i2 = Yt - 0.03;
  let o2;
  o2 = n6 > i2 && r > i2 || n6 < -i2 && r < -i2 ? Fs3(e5, n6, r) : Hs3(e5, r) - Hs3(e5, n6);
  return 0.5 * (s4 - t2) * o2 * Ds2(e5);
}
function Fs3(e5, t2, s4) {
  let n6 = 1;
  if (t2 < 0 && (n6 = -1, t2 = -t2, s4 = -s4), 0 !== e5) {
    const r = e5 * e5, i2 = r * e5, o2 = [1, (1 + 11 * e5) / 12, (1 + 118 * e5 + 241 * r) / 360, (1 + 1089 * e5 + 10419 * r + 8651 * i2) / 20160, (1 + 9836 * e5 + 318246 * r + 1027436 * i2 + 458881 * (i2 * e5)) / 1814400], a2 = (t3) => {
      let s5 = 0;
      const n7 = $(t3) / (e5 - 1);
      for (let e6 = o2.length - 1; e6 >= 0; --e6) s5 = o2[e6] + s5 * n7;
      return s5 *= -$(t3 / (1 - e5)), s5;
    }, h2 = a2(Yt - t2);
    return (a2(Yt - s4) - h2) * n6;
  }
  {
    const e6 = Yt - t2, r = Yt - s4, i2 = -4 * $(Math.sin(e6 / 2));
    return (-4 * $(Math.sin(r / 2)) - i2) * n6;
  }
}
function Hs3(e5, t2) {
  if (0 === t2) return 0;
  const s4 = Math.sin(t2);
  let n6 = s4, r = s4;
  if (0 !== e5) {
    n6 /= 1 - e5 * s4 * s4;
    const t3 = Math.sqrt(e5);
    r = s4 * z2(t3 * s4);
  }
  return n6 + r;
}
function ks3(e5, t2) {
  return e5 / Math.sqrt(1 - t2);
}
function As2(e5, t2) {
  return (1 - t2) * e5;
}
function Ms3(e5, t2, s4) {
  const n6 = s4 / (2 * As2(e5, t2)), r = n6 * n6;
  return s4 * (1 - r * (0.16666666666666666 - 0.008333333333333333 * r));
}
function Us2(e5, t2) {
  if (0 !== t2) {
    const s4 = e5 * Kt() / t2;
    return Math.min(s4, 1e-10);
  }
  return 0;
}
var qs3 = class _qs {
  constructor(e5) {
    this.m_currentShift = 63n, this.m_currentElt = 0n, this.m_iCurrentElt = -1, this.m_parent = e5, this.m_aiSetElts = e5.m_bits.flatMap((e6, t2) => t2);
  }
  next() {
    if (this.m_currentShift++, 64n === this.m_currentShift) {
      if (this.m_iCurrentElt++, this.m_iCurrentElt === this.m_aiSetElts.length) return _qs.npos();
      this.m_currentShift = 0n, this.m_currentElt = this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]];
    }
    for (; this.m_currentShift < 63n && !(this.m_currentElt & 1n << this.m_currentShift); ) this.m_currentShift++;
    return this.m_currentElt & 1n << this.m_currentShift ? 64 * this.m_aiSetElts[this.m_iCurrentElt] + Number(this.m_currentShift) : this.next();
  }
  static npos() {
    return Number.MAX_SAFE_INTEGER;
  }
};
function Os3(e5) {
  return 1n << (0x3fn & BigInt(e5));
}
function Bs3(e5) {
  return e5 >> 6;
}
var Rs3 = class {
  constructor(e5) {
    this.m_bits = [], void 0 !== e5 && e5.copy && (this.m_bits = e5.copy.m_bits.slice());
  }
  assignMove() {
    return this;
  }
  assignCopy() {
    return this;
  }
  hasBit(e5) {
    const t2 = Os3(e5), s4 = Bs3(e5);
    return void 0 !== this.m_bits[s4] && !!(this.m_bits[s4] & t2);
  }
  setBit(e5) {
    const t2 = Os3(e5), s4 = Bs3(e5);
    void 0 === this.m_bits[s4] && (this.m_bits[s4] = 0n), this.m_bits[s4] |= t2;
  }
  clearBit(e5) {
  }
  flipBit(e5) {
    const t2 = Os3(e5), s4 = Bs3(e5);
    return void 0 === this.m_bits[s4] && (this.m_bits[s4] = 0n), this.m_bits[s4] ^= t2, 0n !== (this.m_bits[s4] & t2);
  }
  clear() {
    this.m_bits.length = 0;
  }
  isZero() {
    let e5 = 0;
    return this.m_bits.forEach((t2) => {
      e5 |= t2 ? 2 : 1;
    }), !(2 & e5);
  }
  equals(e5) {
    if (this === e5) return true;
    if (this.m_bits.length !== e5.m_bits.length) return false;
    let t2 = 0;
    return this.m_bits.forEach((s4, n6) => {
      t2 |= s4 === e5.m_bits[n6] ? 2 : 1;
    }), !(1 & t2) && (e5.m_bits.forEach((e6, s4) => {
      t2 |= e6 === this.m_bits[s4] ? 2 : 1;
    }), !(1 & t2));
  }
  notEquals(e5) {
    return !this.equals(e5);
  }
  assignOr(e5) {
    return e5.m_bits.forEach((e6, t2) => {
      void 0 === this.m_bits[t2] ? this.m_bits[t2] = e6 : this.m_bits[t2] |= e6;
    }), this;
  }
  assignSubtract(e5) {
    return e5.m_bits.forEach((e6, t2) => {
      void 0 !== this.m_bits[t2] && (this.m_bits[t2] &= ~e6);
    }), this;
  }
  assignAnd(e5) {
    return e5.m_bits.forEach((e6, t2) => {
      void 0 !== this.m_bits[t2] && (this.m_bits[t2] &= e6);
    }), this;
  }
  assignXor(e5) {
    return e5.m_bits.forEach((e6, t2) => {
      void 0 === this.m_bits[t2] ? this.m_bits[t2] = e6 : this.m_bits[t2] ^= e6;
    }), this;
  }
  getHashCode() {
    return this.m_bits.reduce((e5, t2) => Ms(e5, t2), ws(0));
  }
  getUnorderedBitIterator() {
    return new qs3(this);
  }
};
var Ys3 = class {
  constructor(e5, t2) {
    this.m_map = /* @__PURE__ */ new Map(), this.m_hf = e5, this.m_ef = t2;
  }
  add(e5) {
    const t2 = this.m_hf(e5);
    if (!this.m_map.has(t2)) return this.m_map.set(t2, e5), this;
    const s4 = this.m_map.get(t2);
    return s4 instanceof Array ? s4.find((t3) => this.m_ef(t3, e5)) || s4.push(e5) : this.m_ef(s4, e5) || this.m_map.set(t2, [s4, e5]), this;
  }
  clear() {
    this.m_map.clear();
  }
  delete(e5) {
    return false;
  }
  has(e5) {
    const t2 = this.m_hf(e5);
    if (!this.m_map.has(t2)) return false;
    const s4 = this.m_map.get(t2);
    return s4 instanceof Array ? void 0 !== s4.find((t3) => this.m_ef(t3, e5)) : this.m_ef(s4, e5);
  }
  get(e5) {
    const t2 = this.m_hf(e5), s4 = this.m_map.get(t2);
    if (void 0 !== s4) return s4 instanceof Array ? s4.find((t3) => this.m_ef(t3, e5)) : s4;
  }
  get size() {
    let e5 = 0;
    for (const t2 of this.m_map.values()) e5 += t2 instanceof Array ? t2.length : 1;
    return e5;
  }
  forEach(e5, t2) {
  }
  [Symbol.iterator]() {
    return (/* @__PURE__ */ new Set())[Symbol.iterator]();
  }
  entries() {
    return (/* @__PURE__ */ new Set()).entries();
  }
  keys() {
    return (/* @__PURE__ */ new Set()).keys();
  }
  values() {
    return (/* @__PURE__ */ new Set()).values();
  }
  get [Symbol.toStringTag]() {
    return "ValueSet";
  }
};
var Xs3 = class extends dt {
  constructor(e5) {
    super(), this.m_bufferLeft = new nu(), this.m_bufferRight = new nu(), this.m_intervalLeft = x2.constructEmpty(), this.m_intervalRight = x2.constructEmpty(), this.m_yScanline = Number.NaN, this.m_helper = e5;
  }
  compare(e5, t2, s4) {
    const n6 = t2, r = e5.getElement(s4);
    this.m_helper.querySegmentXY(n6, this.m_bufferLeft), this.m_helper.querySegmentXY(r, this.m_bufferRight);
    const i2 = this.m_bufferLeft.get(), o2 = this.m_bufferRight.get();
    if (this.m_intervalLeft.setCoords(i2.getStartX(), i2.getEndX()), this.m_intervalRight.setCoords(o2.getStartX(), o2.getEndX()), this.m_intervalLeft.vmax < this.m_intervalRight.vmin) return -1;
    if (this.m_intervalLeft.vmin > this.m_intervalRight.vmax) return 1;
    const a2 = i2.getStartY() === i2.getEndY(), h2 = o2.getStartY() === o2.getEndY();
    if (a2 || h2) {
      if (a2 && h2) return 0;
      if (i2.getStartY() === o2.getStartY() && i2.getStartX() === o2.getStartX()) return a2 ? 1 : -1;
      if (i2.getEndY() === o2.getEndY() && i2.getEndX() === o2.getEndX()) return a2 ? -1 : 1;
    }
    let m2 = i2.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalLeft.vmin), l2 = o2.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalRight.vmin);
    if (m2 === l2) {
      const e6 = i2.getEndY(), t3 = o2.getEndY(), s5 = Math.min(e6, t3);
      let n7 = 0.5 * (s5 + this.m_yScanline);
      n7 === this.m_yScanline && (n7 = s5), m2 = i2.intersectionOfYMonotonicWithAxisX(n7, this.m_intervalLeft.vmin), l2 = o2.intersectionOfYMonotonicWithAxisX(n7, this.m_intervalRight.vmin);
    }
    return m2 < l2 ? -1 : m2 > l2 ? 1 : 0;
  }
  setY(e5) {
    this.m_yScanline = e5;
  }
};
var Ls3 = class {
  constructor(e5) {
    this.m_segmentBuffer = new nu(), this.m_point = ei.getNAN(), this.m_parent = e5;
  }
  setPointXY(e5) {
    this.m_point.assign(e5);
  }
  compare(e5, t2) {
    const s4 = e5.getElement(t2);
    this.m_parent.querySegmentXY(s4, this.m_segmentBuffer);
    const n6 = this.m_segmentBuffer.get(), r = new x2();
    if (r.setCoords(n6.getStartX(), n6.getEndX()), this.m_point.x < r.vmin) return -1;
    if (this.m_point.x > r.vmax) return 1;
    const i2 = n6.intersectionOfYMonotonicWithAxisX(this.m_point.y, this.m_point.x);
    return this.m_point.x < i2 ? -1 : this.m_point.x > i2 ? 1 : 0;
  }
};
var zs2;
var Ws3;
function js3(e5, t2) {
  return { parentage: e5, rank: t2 };
}
function Zs2(e5, t2) {
  const s4 = e5.length;
  if (s4 !== t2.length) return false;
  const n6 = e5[0].parentage;
  if (n6 !== t2[0].parentage) return false;
  if (-1 === n6) return true;
  for (let r = 1; r < s4; ++r) if (e5[r].parentage !== t2[r].parentage) return false;
  return true;
}
function Ks2(e5, t2, s4) {
  s4.length = 0;
  let n6 = false;
  {
    let r = e5.getHalfEdgeVertexIterator(t2);
    for (; r !== bm; ) {
      const t3 = e5.getVertexFromVertexIterator(r), i2 = e5.getShape().getSegmentRank(t3), o2 = e5.getShape().getSegmentParentage(t3);
      n6 || (n6 = o2 >= 0), s4.push(js3(o2, i2)), r = e5.incrementVertexIterator(r);
    }
  }
  {
    let r = e5.getHalfEdgeVertexIterator(e5.getHalfEdgeTwin(t2));
    for (; r !== bm; ) {
      const t3 = e5.getVertexFromVertexIterator(r), i2 = e5.getShape().getSegmentRank(t3), o2 = e5.getShape().getSegmentParentage(t3);
      n6 || (n6 = o2 >= 0), s4.push(js3(o2, i2)), r = e5.incrementVertexIterator(r);
    }
  }
  n6 && s4.sort((e6, t3) => e6.rank > t3.rank ? -1 : e6.rank < t3.rank ? 1 : e6.parentage < t3.parentage ? -1 : e6.parentage > t3.parentage ? 1 : 0), -1 === s4[0].parentage && (s4.length = 1);
}
function Qs3() {
  return new Ys3((e5) => e5.getHashCode(), (e5, t2) => e5.equals(t2));
}
!function(e5) {
  e5[e5.enumInputModeBuildGraph = 0] = "enumInputModeBuildGraph", e5[e5.enumInputModeSimplifyAlternate = 1] = "enumInputModeSimplifyAlternate", e5[e5.enumInputModeSimplifyWinding = 2] = "enumInputModeSimplifyWinding";
}(zs2 || (zs2 = {})), function(e5) {
  e5[e5.enumSegmentParentageBreakNode = 1] = "enumSegmentParentageBreakNode", e5[e5.enumPathBreakNode = 2] = "enumPathBreakNode";
}(Ws3 || (Ws3 = {}));
var Js2 = class _Js {
  constructor() {
    this.m_shape = null, this.m_clusterData = new at(8), this.m_clusterVertices = new at(2), this.m_firstCluster = bm, this.m_lastCluster = bm, this.m_halfEdgeData = new at(8), this.m_chainData = new at(8), this.m_chainAreas = null, this.m_chainPerimeters = null, this.m_universeChain = -1, this.m_simplifiedGeometry = -1, this.m_edgeIndices = [], this.m_clusterIndices = [], this.m_chainIndices = [], this.m_bBuildGeometryParentageSets = false, this.m_chainBitSetIndex = -1, this.m_edgeBitSetIndex = -1, this.m_edgeBitSetIndexLeft = -1, this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_uniqueBitSets = null, this.m_chainBitSets = [], this.m_edgeBitSets = [], this.m_checkDirtyPlanesweepTolerance = Number.NaN, this.m_geometryIDIndex = -1, this.m_clusterIndex = -1, this.m_halfEdgeIndex = -1, this.m_tmpHalfEdgeParentageIndex = -1, this.m_tmpHalfEdgeParentageIndexLeft = -1, this.m_tmpHalfEdgeWindingNumberIndex = -1, this.m_tmpHalfEdgeOddEvenNumberIndex = -1, this.m_segmentParentageIndex = -1, this.m_segmentIndexHe = -1, this.m_clusterBreakNodeIndex = -1, this.m_universeGeomID = -1, this.m_pointCount = 0, this.m_progressCounter = 0, this.m_bBuildChains = true, this.m_bDirtyCheckFailed = false;
  }
  setCheckDirtyPlanesweepTolerance(e5) {
    this.m_checkDirtyPlanesweepTolerance = e5;
  }
  dirtyCheckFailed() {
    return this.m_bDirtyCheckFailed;
  }
  getShape() {
    return this.m_shape;
  }
  setEditShape(e5, t2, s4 = true, n6 = false) {
    n6 ? this.setEditShapeImpl3D_(e5, zs2.enumInputModeBuildGraph, null, t2, false) : this.setEditShapeImpl_(e5, zs2.enumInputModeBuildGraph, null, t2, s4);
  }
  setAndSimplifyEditShapeAlternate(e5, t2, s4 = null, n6 = false) {
    const r = [];
    r.push(t2), this.m_simplifiedGeometry = t2, n6 ? this.setEditShapeImpl3D_(e5, zs2.enumInputModeSimplifyAlternate, r, s4, false) : this.setEditShapeImpl_(e5, zs2.enumInputModeSimplifyAlternate, r, s4, e5.getGeometryType(t2) === a.enumPolygon);
  }
  setAndSimplifyEditShapeWinding(e5, t2, s4 = null) {
    const n6 = [];
    n6.push(t2), this.m_simplifiedGeometry = t2, this.setEditShapeImpl_(e5, zs2.enumInputModeSimplifyWinding, n6, s4, true);
  }
  removeShape() {
    null !== this.m_shape && (-1 !== this.m_geometryIDIndex && (this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex), this.m_geometryIDIndex = -1), -1 !== this.m_clusterIndex && (this.m_shape.removeUserIndex(this.m_clusterIndex), this.m_clusterIndex = -1), -1 !== this.m_halfEdgeIndex && (this.m_shape.removeUserIndex(this.m_halfEdgeIndex), this.m_halfEdgeIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1), -1 !== this.m_segmentParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), -1 !== this.m_segmentIndexHe && (this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe), this.m_segmentIndexHe = -1), -1 !== this.m_clusterBreakNodeIndex && (this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex), this.m_clusterBreakNodeIndex = -1), this.deleteEdgeBitSets_(), this.deleteChainBitSets_(), this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_shape = null, this.m_clusterData.deleteAll(true), this.m_clusterVertices.deleteAll(true), this.m_firstCluster = bm, this.m_lastCluster = bm, this.m_halfEdgeData.deleteAll(true), this.m_edgeIndices.length = 0, this.m_clusterIndices.length = 0, this.m_chainIndices.length = 0, this.m_chainData.deleteAll(true), this.m_universeChain = bm, this.m_chainAreas = null);
  }
  getClusterHalfEdge(e5) {
    return this.m_clusterData.getField(e5, 2);
  }
  queryXY(e5, t2) {
    const s4 = this.getClusterVertexIndex_(e5);
    t2.assign(this.m_shape.getXYWithIndex(s4));
  }
  queryXYZ(e5, t2) {
    n2(0);
  }
  getClusterParentage(e5) {
    return this.m_clusterData.getField(e5, 1);
  }
  getFirstCluster() {
    return this.m_firstCluster;
  }
  getPrevCluster(e5) {
    return this.m_clusterData.getField(e5, 3);
  }
  getNextCluster(e5) {
    return this.m_clusterData.getField(e5, 4);
  }
  getClusterChain(e5) {
    return this.m_clusterData.getField(e5, 6);
  }
  getClusterVertexIterator(e5) {
    return this.m_clusterData.getField(e5, 7);
  }
  incrementVertexIterator(e5) {
    return this.m_clusterVertices.getField(e5, 1);
  }
  getVertexFromVertexIterator(e5) {
    return this.m_clusterVertices.getField(e5, 0);
  }
  getClusterUserIndex(e5, t2) {
    const s4 = this.getClusterIndex_(e5), n6 = this.m_clusterIndices[t2];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setClusterUserIndex(e5, t2, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t2];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1), r.write(n6, s4);
  }
  hasClusterUserIndexFlags(e5, t2, s4) {
    if (-1 === t2) return false;
    const n6 = this.getClusterUserIndex(e5, t2);
    return -1 !== n6 && !!(s4 & n6);
  }
  setClusterUserIndexFlags(e5, t2, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t2];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n6);
    -1 === i2 && (i2 = 0), r.write(n6, s4 | i2);
  }
  clearClusterUserIndexFlags(e5, t2, s4) {
    const n6 = this.getClusterIndex_(e5), r = this.m_clusterIndices[t2];
    r.size() <= n6 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n6);
    -1 === i2 && (i2 = 0), r.write(n6, ~s4 & i2);
  }
  createUserIndexForClusters(e5 = -1) {
    const t2 = new st2(this.m_clusterData.capacity(), e5);
    for (let s4 = 0, n6 = this.m_clusterIndices.length; s4 < n6; s4++) if (null === this.m_clusterIndices[s4]) return this.m_clusterIndices[s4] = t2, s4;
    this.m_clusterIndices.push(t2);
    return this.m_clusterIndices.length - 1;
  }
  deleteUserIndexForClusters(e5) {
    this.m_clusterIndices[e5] = null;
  }
  getHalfEdgeOrigin(e5) {
    return this.m_halfEdgeData.getField(e5, 1);
  }
  getHalfEdgeTo(e5) {
    return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(e5));
  }
  getHalfEdgeTwin(e5) {
    return this.m_halfEdgeData.getField(e5, 4);
  }
  getHalfEdgePrev(e5) {
    return this.m_halfEdgeData.getField(e5, 5);
  }
  getHalfEdgeNext(e5) {
    return this.m_halfEdgeData.getField(e5, 6);
  }
  getHalfEdgeChain(e5) {
    return this.m_halfEdgeData.getField(e5, 2);
  }
  getHalfEdgeFaceParentage(e5) {
    return this.getChainParentage(this.getHalfEdgeChain(e5));
  }
  getHalfEdgeVertexIterator(e5) {
    return this.m_halfEdgeData.getField(e5, 7);
  }
  getHalfEdgeFromXY(e5, t2) {
    this.queryXY(this.getHalfEdgeOrigin(e5), t2);
  }
  getHalfEdgeToXY(e5, t2) {
    this.queryXY(this.getHalfEdgeTo(e5), t2);
  }
  isHalfEdgeCurve(e5) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
    }
    return false;
  }
  getHalfEdgeFromXYZ(e5, t2) {
    n2(0);
  }
  getHalfEdgeToXYZ(e5, t2) {
    n2(0);
  }
  getHalfEdgeParentage(e5) {
    return this.m_halfEdgeData.getField(e5, 3) & _Js.c_EdgeParentageMask;
  }
  getHalfEdgeUserIndex(e5, t2) {
    const s4 = this.getHalfEdgeIndex_(e5), n6 = this.m_edgeIndices[t2];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setHalfEdgeUserIndex(e5, t2, s4) {
    const n6 = this.getHalfEdgeIndex_(e5), r = this.m_edgeIndices[t2];
    r.size() <= n6 && r.resize(this.m_halfEdgeData.size(), -1), r.write(n6, s4);
  }
  createUserIndexForHalfEdges(e5) {
    void 0 === e5 && (e5 = -1);
    const t2 = new st2(this.m_halfEdgeData.capacity(), e5);
    for (let s4 = 0, r = this.m_edgeIndices.length; s4 < r; s4++) if (null === this.m_edgeIndices[s4]) return this.m_edgeIndices[s4] = t2, s4;
    this.m_edgeIndices.push(t2);
    const n6 = this.m_edgeIndices.length - 1;
    return n2(n6 >= 0 && n6 <= Number.MAX_SAFE_INTEGER), n6;
  }
  deleteUserIndexForHalfEdges(e5) {
    this.m_edgeIndices[e5] = null;
  }
  deleteEdgesBreakFaces_(e5) {
    for (let t2 = 0, s4 = e5.length; t2 < s4; t2++) {
      const s5 = e5[t2], n6 = this.getHalfEdgeChain(s5), r = this.getHalfEdgeTwin(s5), i2 = this.getHalfEdgeChain(r);
      this.setChainHalfEdge_(n6, bm), this.setChainHalfEdge_(i2, bm), this.updateVertexToHalfEdgeConnection_(s5, true), this.deleteEdgeImpl_(s5);
    }
  }
  doesHalfEdgeBelongToAPolygonInterior(e5, t2) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolygonExterior(e5, t2) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolygonBoundary(e5, t2) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolylineInterior(e5, t2) {
    return n2(0), false;
  }
  doesHalfEdgeBelongToAPolylineExterior(e5, t2) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonInterior(e5, t2) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonExterior(e5, t2) {
    return n2(0), false;
  }
  doesClusterBelongToAPolygonBoundary(e5, t2) {
    return n2(0), false;
  }
  getFirstChain() {
    return this.m_universeChain;
  }
  getChainHalfEdge(e5) {
    return this.m_chainData.getField(e5, 1);
  }
  getChainParentage(e5) {
    return this.m_chainData.getField(e5, 2);
  }
  getChainParent(e5) {
    return this.m_chainData.getField(e5, 3);
  }
  getChainFirstIsland(e5) {
    return this.m_chainData.getField(e5, 4);
  }
  getChainNextInParent(e5) {
    return this.m_chainData.getField(e5, 5);
  }
  getChainNext(e5) {
    return this.m_chainData.getField(e5, 7);
  }
  getChainArea(e5) {
    const t2 = this.getChainIndex_(e5);
    let s4 = this.m_chainAreas.read(t2);
    return Number.isNaN(s4) && (this.updateChainAreaAndPerimeter_(e5), s4 = this.m_chainAreas.read(t2)), s4;
  }
  getChainPerimeter(e5) {
    return n2(0), 0;
  }
  getChainUserIndex(e5, t2) {
    const s4 = this.getChainIndex_(e5), n6 = this.m_chainIndices[t2];
    return n6.size() <= s4 ? -1 : n6.read(s4);
  }
  setChainUserIndex(e5, t2, s4) {
    const n6 = this.getChainIndex_(e5), r = this.m_chainIndices[t2];
    r.size() <= n6 && r.resize(this.m_chainData.size(), -1), r.write(n6, s4);
  }
  createUserIndexForChains() {
    const e5 = new st2(this.m_chainData.capacity(), -1);
    for (let t2 = 0, s4 = this.m_chainIndices.length; t2 < s4; t2++) if (null === this.m_chainIndices[t2]) return this.m_chainIndices[t2] = e5, t2;
    this.m_chainIndices.push(e5);
    return this.m_chainIndices.length - 1;
  }
  deleteUserIndexForChains(e5) {
    this.m_chainIndices[e5] = null;
  }
  extractPolygonFromChainAndIslands(e5, t2, s4, n6) {
    const r = t2 === bm ? e5.createGeometry(a.enumPolygon) : t2, i2 = new nu();
    this.extractPolygonPathFromChain_(e5, r, s4, n6, i2);
    for (let o2 = this.getChainFirstIsland(s4); o2 !== bm; o2 = this.getChainNextInParent(o2)) this.extractPolygonPathFromChain_(e5, r, o2, n6, i2);
    return r;
  }
  getGeometryID(e5) {
    const t2 = this.m_shape.getGeometryUserIndex(e5, this.m_geometryIDIndex);
    return n2(t2 >= 0), 1 << Math.min(t2, 31);
  }
  getClusterFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_clusterIndex);
  }
  getHalfEdgeFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_halfEdgeIndex);
  }
  buildGeometryParentageSets() {
    this.m_bBuildGeometryParentageSets = true;
  }
  getChainBitSet(e5) {
    if (n2(this.m_bBuildGeometryParentageSets), -1 === this.m_chainBitSetIndex) return this.getEmptySet();
    const t2 = this.getChainUserIndex(e5, this.m_chainBitSetIndex);
    n2(t2 >= 0);
    let n6 = this.m_chainBitSets.at(t2);
    return n6 || (n6 = this.getEmptySet()), n6;
  }
  getChainBoundaryBitSet(e5) {
    n2(this.m_bBuildGeometryParentageSets);
    const t2 = new Rs3(), n6 = (e6) => {
      const s4 = this.getChainHalfEdge(e6);
      let n7 = s4;
      do {
        const e7 = this.getEdgeBitSet_(n7);
        null !== e7 && t2.assignOr(e7);
        const s5 = this.getEdgeBitSet_(this.getHalfEdgeTwin(n7));
        null !== s5 && t2.assignOr(s5), n7 = this.getHalfEdgeNext(n7);
      } while (n7 !== s4);
    };
    n6(e5);
    for (let s4 = this.getChainFirstIsland(e5); s4 !== bm; s4 = this.getChainNextInParent(s4)) n6(e5);
    return t2;
  }
  getChainPolygons(e5) {
    return n2(0), [];
  }
  getGeometriesFromBits(e5) {
    if (!this.m_bBuildGeometryParentageSets || null === e5) return [];
    if (null === this.m_geometryMapID) {
      this.m_geometryMapID = /* @__PURE__ */ new Map();
      for (let e6 = this.m_shape.getFirstGeometry(); e6 !== bm; e6 = this.m_shape.getNextGeometry(e6)) this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(e6, this.m_geometryIDIndex), e6);
    }
    const t2 = [], n6 = e5.getUnorderedBitIterator();
    for (let r = n6.next(); r !== qs3.npos(); r = n6.next()) n2(this.m_geometryMapID.has(r)), t2.push(this.m_geometryMapID.get(r));
    return t2;
  }
  getVertexDominant(e5, t2) {
    if (t2 === bm) return e5;
    const s4 = this.getClusterFromVertex(e5);
    return this.getVertexDominantFromCluster(s4, t2);
  }
  getVertexDominantFromCluster(e5, t2) {
    if (t2 !== bm) {
      let s4 = bm;
      for (let n6 = this.getClusterVertexIterator(e5); n6 !== bm; n6 = this.incrementVertexIterator(n6)) {
        const e6 = this.getVertexFromVertexIterator(n6);
        s4 === bm && (s4 = e6);
        const r = this.m_shape.getPathFromVertex(e6);
        if (this.m_shape.getGeometryFromPath(r) === t2) {
          s4 = e6;
          break;
        }
      }
      return s4;
    }
    {
      const t3 = this.getClusterVertexIterator(e5);
      if (t3 !== bm) {
        return this.getVertexFromVertexIterator(t3);
      }
      return bm;
    }
  }
  isBreakNode(e5) {
    return this.hasClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumSegmentParentageBreakNode);
  }
  setBreakNode(e5, t2) {
    n2(-1 !== this.m_clusterBreakNodeIndex), t2 ? this.setClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumSegmentParentageBreakNode) : this.clearClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumSegmentParentageBreakNode);
  }
  isStrongPathNode(e5) {
    return this.hasClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumPathBreakNode);
  }
  setStrongPathNode(e5, t2) {
    if (-1 === this.m_clusterBreakNodeIndex) {
      if (!t2) return;
      this.m_clusterBreakNodeIndex = this.createUserIndexForClusters();
    }
    t2 ? this.setClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumPathBreakNode) : this.clearClusterUserIndexFlags(e5, this.m_clusterBreakNodeIndex, Ws3.enumPathBreakNode);
  }
  getSegmentParentage(e5) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const t2 = this.getHalfEdgeUserIndex(e5, this.m_segmentParentageIndex);
    return t2 >= 0 ? t2 : -1;
  }
  isCrossroadAhead(e5) {
    const t2 = this.getHalfEdgeNext(e5);
    if (this.isStrongPathNode(this.getHalfEdgeOrigin(t2))) return true;
    const s4 = this.getHalfEdgeTwin(t2), n6 = this.getHalfEdgeNext(s4);
    return e5 !== this.getHalfEdgeTwin(n6);
  }
  isCrossroadBehind(e5) {
    return n2(0), false;
  }
  getHalfEdgeConnector(e5, t2) {
    const s4 = this.getClusterHalfEdge(e5);
    if (s4 === bm) return bm;
    let n6 = s4, r = bm, i2 = bm;
    do {
      if (this.getHalfEdgeTo(n6) === t2) return n6;
      if (r === bm) {
        if (r = this.getClusterHalfEdge(t2), r === bm) return bm;
        i2 = r;
      }
      if (this.getHalfEdgeTo(i2) === e5) return n6 = this.getHalfEdgeTwin(i2), n6;
      n6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n6)), i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (n6 !== s4 && i2 !== r);
    return bm;
  }
  querySegmentXY(e5, t2) {
    if (-1 !== this.m_segmentIndexHe) {
      let s5 = this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
      if (-1 !== s5) {
        if (-2 !== s5) {
          const e6 = this.m_shape.getSegmentFromIndex(s5);
          t2.copyFrom(e6, true);
        } else {
          s5 = this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(e5), this.m_segmentIndexHe);
          const n7 = this.m_shape.getSegmentFromIndex(s5);
          t2.copyFrom(n7, true), t2.get().reverse();
        }
        return;
      }
    }
    t2.createLine();
    const s4 = t2.get(), n6 = ei.getNAN();
    this.getHalfEdgeFromXY(e5, n6), s4.setStartXY(n6), this.getHalfEdgeToXY(e5, n6), s4.setEndXY(n6);
  }
  isCurveEdge(e5) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
    }
    return false;
  }
  compareEdgeAnglesCurveHelper_(e5, t2, n6) {
    const r = new nu(), i2 = new nu();
    this.querySegmentXY(e5, r), this.querySegmentXY(t2, i2);
    const o2 = r.get(), a2 = i2.get();
    if (o2.equals(a2)) return 0;
    const h2 = new ei();
    this.getHalfEdgeFromXY(e5, h2);
    const m2 = new ei();
    this.getHalfEdgeToXY(e5, m2);
    const l2 = new ei();
    this.getHalfEdgeToXY(t2, l2), n2(!m2.isEqualPoint2D(l2));
    const g2 = o2.getTangent(0), u = a2.getTangent(0);
    return ei.compareVectors(g2, u);
  }
  compareEdgeAnglesHelper_(e5, t2, s4) {
    if (e5 === t2) return 0;
    if (this.isHalfEdgeCurve(e5) || this.isHalfEdgeCurve(t2)) return this.compareEdgeAnglesCurveHelper_(e5, t2, s4);
    const n6 = ei.getNAN();
    this.getHalfEdgeToXY(e5, n6);
    const r = ei.getNAN();
    if (this.getHalfEdgeToXY(t2, r), n6.isEqualPoint2D(r)) return 0;
    const i2 = ei.getNAN();
    this.getHalfEdgeFromXY(e5, i2);
    const o2 = ei.getNAN();
    o2.setSub(n6, i2);
    const a2 = ei.getNAN();
    if (a2.setSub(r, i2), !s4 || a2.y >= 0 && o2.y > 0) {
      return ei.compareVectors(o2, a2);
    }
    return 0;
  }
  compareEdgeAngles_(e5, t2) {
    return this.compareEdgeAnglesHelper_(e5, t2, false);
  }
  compareEdgeAnglesForPair_(e5, t2) {
    return this.compareEdgeAnglesHelper_(e5, t2, true);
  }
  compareEdgeAngles3D_(e5, t2) {
    return n2(0), 0;
  }
  compareEdgeAnglesForPair3D_(e5, t2) {
    return n2(0), 0;
  }
  dbgDumpChains_() {
  }
  dbgDumpChainToPolygon_(e5, t2) {
  }
  deleteEdgeInternal_(e5) {
    const t2 = this.getHalfEdgeChain(e5), n6 = this.getHalfEdgeTwin(e5), r = this.getHalfEdgeChain(n6);
    n2(r === t2), n2(e5 === this.getHalfEdgeNext(n6) || n6 === this.getHalfEdgeNext(e5));
    let i2 = this.getHalfEdgeNext(e5);
    i2 === n6 && (i2 = this.getHalfEdgeNext(i2), i2 === e5 && (i2 = bm));
    const o2 = this.getChainIndex_(t2), a2 = this.m_chainAreas.read(o2);
    Number.isNaN(a2) || (this.setChainArea_(t2, Number.NaN), this.setChainPerimeter_(t2, Number.NaN));
    const h2 = this.getChainHalfEdge(t2);
    h2 !== e5 && h2 !== n6 || this.setChainHalfEdge_(t2, i2), this.updateVertexToHalfEdgeConnection_(e5, true), this.deleteEdgeImpl_(e5);
  }
  getFirstUnvisitedHalfEdgeOnCluster_(e5, t2, s4) {
    let n6 = t2 !== bm ? t2 : this.getClusterHalfEdge(e5);
    if (n6 === bm) return bm;
    const r = n6;
    for (; ; ) {
      if (1 !== this.getHalfEdgeUserIndex(n6, s4)) return n6;
      const e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n6));
      if (e6 === r) return bm;
      n6 = e6;
    }
  }
  removeSpikes_() {
    let e5 = false;
    const t2 = this.createUserIndexForHalfEdges();
    for (let s4 = this.getFirstCluster(); s4 !== bm; s4 = this.getNextCluster(s4)) {
      let n6 = bm;
      for (; ; ) {
        let r = this.getFirstUnvisitedHalfEdgeOnCluster_(s4, n6, t2);
        if (r === bm) break;
        n6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        let i2 = r;
        for (; ; ) {
          const s5 = this.getHalfEdgeNext(i2), o2 = this.getHalfEdgePrev(i2), a2 = this.getHalfEdgeTwin(i2);
          if (o2 === a2) {
            if (this.deleteEdgeInternal_(i2), e5 = true, n6 !== i2 && n6 !== a2 || (n6 = bm), i2 === r || o2 === r) {
              if (r = s5, i2 === r || o2 === r) break;
              i2 = s5;
              continue;
            }
          } else this.setHalfEdgeUserIndex(i2, t2, 1);
          if (i2 = s5, i2 === r) break;
        }
      }
    }
    return this.deleteUserIndexForHalfEdges(t2), e5;
  }
  progress_(e5, t2 = false) {
  }
  newCluster_() {
    const e5 = this.m_clusterData.newElement();
    return this.m_clusterData.setField(e5, 1, 0), e5;
  }
  newHalfEdgePair_() {
    const e5 = this.m_halfEdgeData.newElement();
    this.m_halfEdgeData.setField(e5, 2, 0), this.m_halfEdgeData.setField(e5, 3, 0);
    const t2 = this.m_halfEdgeData.newElement();
    return this.m_halfEdgeData.setField(t2, 2, 0), this.m_halfEdgeData.setField(t2, 3, 0), this.setHalfEdgeTwin_(e5, t2), this.setHalfEdgeTwin_(t2, e5), e5;
  }
  newChain_() {
    const e5 = this.m_chainData.newElement();
    return this.m_chainData.setField(e5, 2, 0), e5;
  }
  deleteChain_(e5) {
    return n2(0), 0;
  }
  getClusterIndex_(e5) {
    return this.m_clusterData.elementToIndex(e5);
  }
  setClusterVertexIterator_(e5, t2) {
    this.m_clusterData.setField(e5, 7, t2);
  }
  setClusterHalfEdge_(e5, t2) {
    this.m_clusterData.setField(e5, 2, t2);
  }
  setClusterParentage_(e5, t2) {
    this.m_clusterData.setField(e5, 1, t2);
  }
  setPrevCluster_(e5, t2) {
    this.m_clusterData.setField(e5, 3, t2);
  }
  setNextCluster_(e5, t2) {
    this.m_clusterData.setField(e5, 4, t2);
  }
  setClusterVertexIndex_(e5, t2) {
    this.m_clusterData.setField(e5, 5, t2);
  }
  getClusterVertexIndex_(e5) {
    return this.m_clusterData.getField(e5, 5);
  }
  setClusterChain_(e5, t2) {
    this.m_clusterData.setField(e5, 6, t2);
  }
  addClusterToExteriorChain_(e5, t2) {
    this.setClusterChain_(t2, e5);
  }
  getHalfEdgeIndex_(e5) {
    return this.m_halfEdgeData.elementToIndex(e5);
  }
  setHalfEdgeOrigin_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 1, t2);
  }
  setHalfEdgeTwin_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 4, t2);
  }
  setHalfEdgePrev_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 5, t2);
  }
  setHalfEdgeNext_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 6, t2);
  }
  setHalfEdgeChain_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 2, t2);
  }
  setHalfEdgeParentage_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 3, t2);
  }
  getHalfEdgeParentageMask_(e5) {
    return this.m_halfEdgeData.getField(e5, 3);
  }
  setHalfEdgeVertexIterator_(e5, t2) {
    this.m_halfEdgeData.setField(e5, 7, t2);
  }
  updateVertexToHalfEdgeConnectionHelper_(e5, t2) {
    const s4 = t2 ? bm : e5;
    for (let n6 = this.getHalfEdgeVertexIterator(e5); n6 !== bm; n6 = this.incrementVertexIterator(n6)) {
      const e6 = this.getVertexFromVertexIterator(n6);
      this.m_shape.setUserIndex(e6, this.m_halfEdgeIndex, s4);
    }
  }
  updateVertexToHalfEdgeConnection_(e5, t2) {
    e5 !== bm && (this.updateVertexToHalfEdgeConnectionHelper_(e5, t2), this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(e5), t2));
  }
  getChainIndex_(e5) {
    return this.m_chainData.elementToIndex(e5);
  }
  setChainHalfEdge_(e5, t2) {
    this.m_chainData.setField(e5, 1, t2);
  }
  setChainParentage_(e5, t2) {
    this.m_chainData.setField(e5, 2, t2);
  }
  setChainParent_(e5, t2) {
    this.m_chainData.setField(e5, 3, t2);
    const s4 = this.getChainFirstIsland(t2);
    this.setChainNextInParent_(e5, s4), this.setChainFirstIsland_(t2, e5);
  }
  setChainFirstIsland_(e5, t2) {
    this.m_chainData.setField(e5, 4, t2);
  }
  setChainNextInParent_(e5, t2) {
    this.m_chainData.setField(e5, 5, t2);
  }
  setChainPrev_(e5, t2) {
    this.m_chainData.setField(e5, 6, t2);
  }
  setChainNext_(e5, t2) {
    this.m_chainData.setField(e5, 7, t2);
  }
  setChainArea_(e5, t2) {
    const s4 = this.getChainIndex_(e5);
    this.m_chainAreas.write(s4, t2);
  }
  setChainPerimeter_(e5, t2) {
    const s4 = this.getChainIndex_(e5);
    this.m_chainPerimeters.write(s4, t2);
  }
  updateChainAreaAndPerimeter_(e5) {
    const t2 = this.m_shape.hasCurves(), s4 = new n3(0), n6 = new n3(0), r = this.getChainHalfEdge(e5), i2 = ei.getNAN(), o2 = ei.getNAN(), a2 = ei.getNAN();
    this.getHalfEdgeFromXY(r, i2), o2.setCoordsPoint2D(i2);
    let h2 = r;
    do {
      this.getHalfEdgeToXY(h2, a2), t2 && this.isCurveEdge(h2) || n6.pe(ei.distance(o2, a2));
      this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e5 && s4.pe((a2.x - i2.x - (o2.x - i2.x)) * (a2.y - i2.y + (o2.y - i2.y)) * 0.5), o2.setCoordsPoint2D(a2), h2 = this.getHalfEdgeNext(h2);
    } while (h2 !== r);
    if (t2) {
      const t3 = new nu();
      h2 = r;
      do {
        this.getHalfEdgeToXY(h2, a2);
        const r2 = this.isCurveEdge(h2);
        r2 && (this.querySegmentXY(h2, t3), n6.pe(t3.get().calculateLength2D()));
        if (this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e5 && r2) {
          const e6 = t3.get().calculateArea2DHelper();
          s4.pe(e6);
        }
        h2 = this.getHalfEdgeNext(h2);
      } while (h2 !== r);
    }
    const m2 = this.getChainIndex_(e5);
    this.m_chainAreas.write(m2, s4.getResult()), this.m_chainPerimeters.write(m2, n6.getResult());
  }
  getChainTopmostEdge_(e5) {
    return n2(0), 0;
  }
  planeSweepParentage_(e5, t2) {
    const s4 = new Xs3(this), n6 = new ct2();
    n6.setCapacity(Math.trunc(this.m_pointCount / 2)), n6.setComparator(s4);
    const r = [], i2 = this.createUserIndexForHalfEdges();
    let o2 = null;
    const a2 = ei.getNAN();
    for (let h2 = this.getFirstCluster(); h2 !== bm; h2 = this.getNextCluster(h2)) {
      this.progress_(t2);
      const m2 = this.getClusterHalfEdge(h2);
      if (m2 !== bm) {
        if (r.length = 0, !this.tryOptimizedInsertion_(n6, i2, r, h2, m2)) {
          this.queryXY(h2, a2), s4.setY(a2.y);
          let e6 = m2;
          do {
            const t3 = this.getHalfEdgeUserIndex(e6, i2);
            -1 !== t3 && (n6.deleteNode(t3), this.setHalfEdgeUserIndex(e6, i2, at.impossibleIndex2())), e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e6));
          } while (m2 !== e6);
          e6 = m2;
          do {
            if (-1 === this.getHalfEdgeUserIndex(e6, i2)) {
              const t3 = n6.addElement(e6);
              r.push(t3);
            }
            e6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e6));
          } while (m2 !== e6);
        }
        for (let t3 = r.length - 1; t3 >= 0; t3--) {
          const s5 = r[t3], o3 = n6.getElement(s5), a3 = this.getHalfEdgeTwin(o3);
          this.setHalfEdgeUserIndex(a3, i2, s5), this.planeSweepParentagePropagateParentage_(n6, s5, e5);
        }
      } else if (this.getClusterChain(h2) === bm) {
        null === o2 && (o2 = new Ls3(this)), this.queryXY(h2, a2), o2.setPointXY(a2);
        const e6 = n6.searchLowerBound(o2);
        let t3 = this.m_universeChain;
        if (-1 !== e6) {
          let s5 = n6.getElement(e6);
          this.getHalfEdgeChain(s5) === this.getHalfEdgeChain(this.getHalfEdgeTwin(s5)) && (s5 = this.getLeftSkipPolylines_(n6, e6)), s5 !== bm && (t3 = this.getHalfEdgeChain(s5));
        }
        this.addClusterToExteriorChain_(t3, h2);
      }
    }
    this.deleteUserIndexForHalfEdges(i2);
  }
  planeSweepParentagePropagateParentage_(e5, t2, n6) {
    const r = e5.getElement(t2), i2 = this.getHalfEdgeChain(r);
    if (this.getChainParent(i2) !== bm) return;
    const o2 = this.getLeftSkipPolylines_(e5, t2), a2 = this.getHalfEdgeTwin(r), h2 = this.getHalfEdgeChain(a2);
    let m2 = this.getChainParent(i2), l2 = this.getChainParent(h2);
    if (o2 === bm) m2 === bm && (h2 === i2 ? (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain, m2 = l2) : (l2 === bm && (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain), this.setChainParent_(i2, h2), m2 = h2));
    else {
      const e6 = this.getHalfEdgeChain(o2);
      if (l2 === bm) {
        if (this.getChainArea(e6) <= 0) {
          const t3 = this.getChainParent(e6);
          this.setChainParent_(h2, t3), l2 = t3;
        } else this.setChainParent_(h2, e6), l2 = e6;
        h2 === i2 && (m2 = l2);
      }
    }
    m2 === bm && (this.trySetChainParentFromTwin_(i2, h2), m2 = this.getChainParent(i2)), n2(m2 !== bm), n6 === zs2.enumInputModeBuildGraph ? this.propagateParentageBuildGraph_(e5, t2, r, o2) : n6 === zs2.enumInputModeSimplifyWinding ? this.propagateParentageWinding_(e5, t2, r, o2, a2, i2, h2) : n6 === zs2.enumInputModeSimplifyAlternate && this.propagateParentageAlternate_(e5, t2, r, o2, a2, i2, h2);
  }
  propagateParentageBuildGraph_(e5, t2, s4, n6) {
    let r, i2 = t2;
    n6 === bm ? (i2 = e5.getNext(i2), r = this.getHalfEdgeChain(s4)) : r = this.getHalfEdgeChain(n6);
    let o2 = null, a2 = this.getChainParentage(r);
    for (this.m_bBuildGeometryParentageSets && (o2 = this.getChainBitSet(r)); -1 !== i2; i2 = e5.getNext(i2)) {
      const t3 = e5.getElement(i2), s5 = this.getHalfEdgeTwin(t3);
      r = this.getHalfEdgeChain(t3);
      const n7 = this.getHalfEdgeChain(s5);
      if (this.m_bBuildGeometryParentageSets) {
        let e6 = this.getChainBitSet(n7);
        e6 = new Rs3({ copy: e6 }), e6.assignOr(o2), this.setChainBitSet_(n7, e6);
        let s6 = this.getChainBitSet(r);
        const i3 = this.getLeftEdgeBitSet_(t3), a3 = new Rs3({ copy: o2 });
        if (a3.assignSubtract(i3), a3.isZero()) break;
        s6 = new Rs3({ copy: s6 }), s6.assignOr(a3), this.setChainBitSet_(r, s6), o2 = s6;
      }
      const h2 = this.getChainParentage(n7), m2 = h2 | a2;
      m2 !== h2 && this.setChainParentage_(n7, m2);
      let l2 = this.getChainParentage(r);
      const g2 = a2 & ~this.getHalfEdgeUserIndex(t3, this.m_tmpHalfEdgeParentageIndexLeft);
      if (g2 && (l2 |= g2, this.setChainParentage_(r, l2)), 0 === g2) break;
      a2 = l2;
    }
  }
  propagateParentageWinding_(e5, t2, n6, r, i2, o2, a2) {
    if (o2 === a2) return;
    let h2 = this.getHalfEdgeUserIndex(n6, this.m_tmpHalfEdgeWindingNumberIndex);
    h2 += this.getHalfEdgeUserIndex(i2, this.m_tmpHalfEdgeWindingNumberIndex);
    let m2 = 0;
    const l2 = [], g2 = [];
    g2.push(0);
    for (let u = e5.getFirst(); u !== t2; u = e5.getNext(u)) {
      const t3 = e5.getElement(u), n7 = this.getHalfEdgeTwin(t3), r2 = this.getHalfEdgeChain(t3), i3 = this.getHalfEdgeChain(n7);
      if (r2 !== i3) {
        let e6 = this.getHalfEdgeUserIndex(t3, this.m_tmpHalfEdgeWindingNumberIndex);
        e6 += this.getHalfEdgeUserIndex(n7, this.m_tmpHalfEdgeWindingNumberIndex), m2 += e6;
        let o3 = false;
        0 !== l2.length && l2.at(-1) === i3 && (g2.pop(), l2.pop(), o3 = true), n2(this.getChainParent(i3) !== bm), o3 && this.getChainParent(i3) === r2 || (g2.push(m2), l2.push(r2));
      }
    }
    if (m2 += h2, 0 !== l2.length && l2.at(-1) === a2 && (g2.pop(), l2.pop()), 0 !== m2) {
      if (0 === g2.at(-1)) {
        const e6 = this.m_simplifiedGeometry, t3 = this.getGeometryID(e6);
        this.setChainParentage_(o2, t3);
      }
    } else if (0 !== g2.at(-1)) {
      const e6 = this.m_simplifiedGeometry, t3 = this.getGeometryID(e6);
      this.setChainParentage_(o2, t3);
    }
  }
  propagateParentageAlternate_(e5, t2, s4, n6, r, i2, o2) {
    const a2 = this.m_simplifiedGeometry, h2 = this.getGeometryID(a2);
    if (n6 === bm) {
      this.setChainParentage_(o2, this.m_universeGeomID);
      1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, h2) : this.setChainParentage_(i2, this.m_universeGeomID);
    } else {
      const e6 = this.getChainParentage(o2);
      if (0 === e6) {
        const e7 = this.getHalfEdgeChain(n6), t3 = this.getChainParentage(e7);
        this.setChainParentage_(o2, t3);
        1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, t3 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, t3);
      } else {
        1 & this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, e6 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, e6);
      }
    }
  }
  tryOptimizedInsertion_(e5, t2, s4, n6, r) {
    let i2 = r, o2 = -1, a2 = bm, h2 = 0;
    do {
      if (2 === h2) return false;
      const e6 = this.getHalfEdgeUserIndex(i2, t2);
      if (-1 !== e6) {
        if (-1 !== o2) return false;
        o2 = e6;
      } else {
        if (a2 !== bm) return false;
        a2 = i2;
      }
      h2++, i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (r !== i2);
    return a2 !== bm && -1 !== o2 && (this.setHalfEdgeUserIndex(e5.getElement(o2), t2, at.impossibleIndex2()), e5.setElement(o2, a2), s4.push(o2), true);
  }
  trySetChainParentFromTwin_(e5, t2) {
    const s4 = this.getChainArea(e5);
    if (0 === s4) return false;
    const n6 = this.getChainArea(t2);
    if (s4 > 0 && n6 < 0 || s4 < 0 && n6 > 0) return this.setChainParent_(e5, t2), true;
    {
      const s5 = this.getChainParent(t2);
      if (s5 !== bm) return this.setChainParent_(e5, s5), true;
    }
    return false;
  }
  createHalfEdges_(e5, t2) {
    this.m_halfEdgeIndex = this.m_shape.createUserIndex();
    for (let s4 = 0, n6 = t2.size(); s4 < n6; s4++) {
      const n7 = t2.read(s4), r = this.m_shape.getUserIndex(n7, this.m_clusterIndex), i2 = this.m_shape.getPathFromVertex(n7), a2 = this.m_shape.getGeometryFromPath(i2), m2 = this.m_shape.getGeometryType(a2);
      if (h(m2)) {
        const t3 = this.m_shape.getNextVertex(n7);
        if (t3 === bm) continue;
        const s5 = this.m_shape.getUserIndex(t3, this.m_clusterIndex);
        if (r === s5) continue;
        const i3 = this.newHalfEdgePair_(), h2 = this.getHalfEdgeTwin(i3), l2 = this.m_clusterVertices.newElement();
        this.m_clusterVertices.setField(l2, 0, n7), this.m_clusterVertices.setField(l2, 1, -1), this.setHalfEdgeVertexIterator_(i3, l2), this.m_shape.setUserIndex(n7, this.m_halfEdgeIndex, i3), this.setHalfEdgeOrigin_(i3, r);
        const g2 = this.getClusterHalfEdge(r);
        if (g2 === bm) this.setClusterHalfEdge_(r, i3), this.setHalfEdgePrev_(i3, h2), this.setHalfEdgeNext_(h2, i3);
        else {
          const e6 = this.getHalfEdgePrev(g2);
          this.setHalfEdgePrev_(g2, h2), this.setHalfEdgeNext_(h2, g2), this.setHalfEdgeNext_(e6, i3), this.setHalfEdgePrev_(i3, e6);
        }
        this.setHalfEdgeOrigin_(h2, s5);
        const u = this.getClusterHalfEdge(s5);
        if (u === bm) this.setClusterHalfEdge_(s5, h2), this.setHalfEdgeNext_(i3, h2), this.setHalfEdgePrev_(h2, i3);
        else {
          const e6 = this.getHalfEdgePrev(u);
          this.setHalfEdgePrev_(u, i3), this.setHalfEdgeNext_(i3, u), this.setHalfEdgeNext_(e6, h2), this.setHalfEdgePrev_(h2, e6);
        }
        const c = this.getGeometryID(a2);
        if (e5 === zs2.enumInputModeBuildGraph) {
          const e6 = m2 === a.enumPolygon ? c : 0;
          if (this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex, 0), this.setHalfEdgeUserIndex(i3, this.m_tmpHalfEdgeParentageIndex, e6), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft, e6), this.setHalfEdgeUserIndex(i3, this.m_tmpHalfEdgeParentageIndexLeft, 0), this.m_bBuildGeometryParentageSets) {
            const e7 = new Rs3(), t4 = this.m_shape.getGeometryUserIndex(a2, this.m_geometryIDIndex);
            e7.setBit(t4), this.setEdgeBitSet_(i3, e7), this.setEdgeBitSet_(h2, null), this.setLeftEdgeBitSet_(h2, e7), this.setLeftEdgeBitSet_(i3, null);
          }
        } else if (e5 === zs2.enumInputModeSimplifyWinding) {
          const e6 = this.m_shape.getXY(n7), s6 = this.m_shape.getXY(t3);
          let r2 = 0, o2 = 0;
          e6.compare(s6) < 0 ? r2 = 1 : o2 = -1, this.setHalfEdgeUserIndex(i3, this.m_tmpHalfEdgeWindingNumberIndex, r2), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex, o2);
        } else e5 === zs2.enumInputModeSimplifyAlternate && (this.setHalfEdgeUserIndex(i3, this.m_tmpHalfEdgeOddEvenNumberIndex, 1), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex, 1));
        const _ = m2 === a.enumPolygon ? _Js.c_EdgeBitMask : 0;
        this.setHalfEdgeParentage_(i3, c | _), this.setHalfEdgeParentage_(h2, c | _);
      }
    }
    if (this.m_shape.hasCurves()) {
      this.m_segmentIndexHe = this.createUserIndexForHalfEdges();
      for (let e6 = 0, s4 = t2.size(); e6 < s4; e6++) {
        const s5 = t2.read(e6);
        if (this.m_shape.getSegment(s5)) {
          const e7 = this.m_shape.getUserIndex(s5, this.m_halfEdgeIndex);
          e7 !== bm && (this.setHalfEdgeUserIndex(e7, this.m_segmentIndexHe, this.m_shape.getVertexIndex(s5)), this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(e7), this.m_segmentIndexHe, -2));
        }
      }
    }
  }
  mergeVertexListsOfEdges_(e5, t2) {
    {
      const s5 = this.getHalfEdgeVertexIterator(t2);
      if (s5 !== bm) {
        const n7 = this.getHalfEdgeVertexIterator(e5);
        this.m_clusterVertices.setField(s5, 1, n7), this.setHalfEdgeVertexIterator_(e5, s5), this.setHalfEdgeVertexIterator_(t2, bm);
      }
    }
    const s4 = this.getHalfEdgeTwin(e5), n6 = this.getHalfEdgeTwin(t2);
    {
      const e6 = this.getHalfEdgeVertexIterator(n6);
      if (e6 !== bm) {
        const t3 = this.getHalfEdgeVertexIterator(s4);
        this.m_clusterVertices.setField(e6, 1, t3), this.setHalfEdgeVertexIterator_(s4, e6), this.setHalfEdgeVertexIterator_(n6, bm);
      }
    }
    if (-1 !== this.m_segmentIndexHe) {
      let r = this.getHalfEdgeUserIndex(e5, this.m_segmentIndexHe);
      if (-1 !== r) {
        if (-2 === r) {
          const s5 = this.getHalfEdgeUserIndex(t2, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(e5, this.m_segmentIndexHe, s5);
        }
        if (r = this.getHalfEdgeUserIndex(s4, this.m_segmentIndexHe), -2 === r) {
          const e6 = this.getHalfEdgeUserIndex(n6, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(s4, this.m_segmentIndexHe, e6);
        }
      }
    }
  }
  sortHalfEdgesByAngle_(e5) {
    const t2 = [];
    for (let s4 = this.getFirstCluster(); s4 !== bm; s4 = this.getNextCluster(s4)) {
      t2.length = 0;
      const n6 = this.getClusterHalfEdge(s4);
      if (n6 !== bm) {
        let r = n6;
        do {
          t2.push(r), r = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        } while (r !== n6);
        if (t2.length > 1) {
          let r2 = true;
          t2.length > 2 ? (t2.sort((e6, t3) => this.compareEdgeAngles_(e6, t3)), t2.push(t2[0])) : this.compareEdgeAnglesForPair_(t2[0], t2[1]) > 0 ? t2[1] = Mt(t2[0], t2[0] = t2[1]) : r2 = false;
          let i2 = t2[0], o2 = i2, a2 = this.getHalfEdgeTo(o2), h2 = this.getHalfEdgeTwin(o2), m2 = bm;
          for (let s5 = 1, n7 = t2.length; s5 < n7; s5++) {
            const n8 = t2[s5], r3 = this.getHalfEdgeTwin(n8), l2 = this.getHalfEdgeOrigin(r3);
            if (l2 !== a2 || n8 === o2) this.updateVertexToHalfEdgeConnection_(m2, false), m2 = bm, o2 = n8, a2 = l2, h2 = r3;
            else {
              if (e5 === zs2.enumInputModeBuildGraph) {
                const e6 = this.getHalfEdgeParentageMask_(o2) | this.getHalfEdgeParentageMask_(n8);
                if (this.setHalfEdgeParentage_(o2, e6), this.setHalfEdgeParentage_(h2, e6), this.setHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeParentageIndexLeft)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndexLeft)), this.m_bBuildGeometryParentageSets) {
                  let e7, t3, s6;
                  e7 = this.getEdgeBitSet_(o2), t3 = this.getEdgeBitSet_(n8), s6 = new Rs3({ copy: e7 }), s6.assignOr(t3), this.setEdgeBitSet_(o2, s6), e7 = this.getEdgeBitSet_(h2), t3 = this.getEdgeBitSet_(r3), s6 = new Rs3({ copy: e7 }), s6.assignOr(t3), this.setEdgeBitSet_(h2, s6), e7 = this.getLeftEdgeBitSet_(o2), t3 = this.getLeftEdgeBitSet_(n8), s6 = new Rs3({ copy: e7 }), s6.assignOr(t3), this.setLeftEdgeBitSet_(o2, s6), e7 = this.getLeftEdgeBitSet_(h2), t3 = this.getLeftEdgeBitSet_(r3), s6 = new Rs3({ copy: e7 }), s6.assignOr(t3), this.setLeftEdgeBitSet_(h2, s6);
                }
              } else if (-1 !== this.m_tmpHalfEdgeWindingNumberIndex) {
                const e6 = this.getHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeWindingNumberIndex), t3 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeWindingNumberIndex);
                this.setHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeWindingNumberIndex, e6), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex, t3);
              } else if (-1 !== this.m_tmpHalfEdgeOddEvenNumberIndex) {
                const e6 = this.getHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(n8, this.m_tmpHalfEdgeOddEvenNumberIndex), t3 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeOddEvenNumberIndex);
                this.setHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeOddEvenNumberIndex, e6), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex, t3);
              }
              this.mergeVertexListsOfEdges_(o2, n8), this.deleteEdgeImpl_(n8), m2 = o2, t2[s5] = bm, n8 === i2 && (t2[0] = bm, i2 = bm);
            }
          }
          if (this.updateVertexToHalfEdgeConnection_(m2, false), m2 = bm, !r2) {
            i2 = bm;
            for (let e6 = 0, s5 = t2.length; e6 < s5; e6++) {
              const s6 = t2[e6];
              if (s6 !== bm) {
                i2 = s6;
                break;
              }
            }
            n6 !== i2 && this.setClusterHalfEdge_(s4, i2);
            continue;
          }
          i2 = bm;
          for (let e6 = 0, s5 = t2.length; e6 < s5; e6++) {
            const s6 = t2[e6];
            if (s6 === bm) continue;
            if (i2 === bm) {
              i2 = s6, o2 = i2, a2 = this.getHalfEdgeTo(o2), h2 = this.getHalfEdgeTwin(o2);
              continue;
            }
            if (s6 === o2) continue;
            const n7 = this.getHalfEdgeTwin(s6), r3 = this.getHalfEdgeOrigin(n7);
            this.setHalfEdgeNext_(h2, s6), this.setHalfEdgePrev_(s6, h2), o2 = s6, a2 = r3, h2 = n7;
          }
          this.setClusterHalfEdge_(s4, i2);
        }
      }
    }
  }
  sortHalfEdgesByAngle3D_(e5) {
    n2(0);
  }
  buildChains_(e5) {
    this.m_universeChain = this.newChain_(), this.setChainHalfEdge_(this.m_universeChain, bm);
    let t2 = this.m_universeChain;
    const s4 = this.createUserIndexForHalfEdges();
    for (let n6 = this.getFirstCluster(); n6 !== bm; n6 = this.getNextCluster(n6)) {
      const e6 = this.getClusterHalfEdge(n6);
      if (e6 !== bm) {
        let n7 = e6;
        do {
          if (1 !== this.getHalfEdgeUserIndex(n7, s4)) {
            const e7 = this.newChain_();
            this.setChainHalfEdge_(e7, n7), this.setChainPrev_(e7, t2), this.setChainNext_(t2, e7);
            let r = null;
            this.m_bBuildGeometryParentageSets && (r = new Rs3()), t2 = e7;
            let i2 = 0, o2 = n7;
            do {
              -1 !== this.m_tmpHalfEdgeParentageIndex && (i2 |= this.getHalfEdgeUserIndex(o2, this.m_tmpHalfEdgeParentageIndex)), this.m_bBuildGeometryParentageSets && r.assignOr(this.getEdgeBitSet_(o2)), this.setHalfEdgeChain_(o2, e7), this.setHalfEdgeUserIndex(o2, s4, 1), o2 = this.getHalfEdgeNext(o2);
            } while (o2 !== n7);
            this.m_bBuildGeometryParentageSets && this.setChainBitSet_(e7, r), this.setChainParentage_(e7, i2);
          }
          n7 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n7));
        } while (n7 !== e6);
      }
    }
    this.m_chainAreas = new nt(this.m_chainData.size(), Number.NaN), this.m_chainPerimeters = new nt(this.m_chainData.size(), Number.NaN), this.setChainArea_(this.m_universeChain, Number.POSITIVE_INFINITY), this.setChainPerimeter_(this.m_universeChain, Number.POSITIVE_INFINITY), this.deleteUserIndexForHalfEdges(s4);
  }
  simplify_(e5) {
    n2(0);
  }
  simplifyAlternate_() {
    n2(0);
  }
  simplifyWinding_() {
    n2(0);
  }
  setEditShapeImpl_(e5, t2, s4, n6, r) {
    this.removeShape(), this.m_bBuildChains = r, this.m_shape = e5, this.m_geometryIDIndex = this.m_shape.createGeometryUserIndex();
    let o2 = this.m_shape.getTotalPointCount();
    if (s4) {
      o2 = 0;
      for (let e6 = 0, t3 = s4.length; e6 < t3; e6++) o2 += this.m_shape.getPointCount(s4[e6]);
    }
    const a2 = new st2(0);
    let h2 = 0, m2 = 0;
    {
      let e6 = null != s4 ? s4[0] : this.m_shape.getFirstGeometry(), t3 = 1;
      for (; e6 !== bm; ) {
        this.m_shape.setGeometryUserIndex(e6, this.m_geometryIDIndex, m2++);
        for (let t4 = this.m_shape.getFirstPath(e6); t4 !== bm; t4 = this.m_shape.getNextPath(t4)) {
          let e7 = this.m_shape.getFirstVertex(t4);
          for (let s5 = 0, n7 = this.m_shape.getPathSize(t4); s5 < n7; s5++) a2.add(e7), e7 = this.m_shape.getNextVertex(e7);
        }
        l(this.m_shape.getGeometryType(e6)) || (h2 += this.m_shape.getPathCount(e6)), null != s4 ? (e6 = t3 < s4.length ? s4[t3] : bm, t3++) : e6 = this.m_shape.getNextGeometry(e6);
      }
    }
    this.m_universeGeomID = 1 << Math.min(m2, 31), this.m_pointCount = a2.size(), this.m_shape.sortVerticesSimpleByY(a2, 0, this.m_pointCount), this.m_clusterVertices.setCapacity(this.m_pointCount), this.progress_(n6, true), this.m_clusterData.setCapacity(this.m_pointCount + 10), this.m_halfEdgeData.setCapacity(2 * this.m_pointCount + 32), this.m_chainData.setCapacity(Math.max(32, h2)), this.m_clusterIndex = this.m_shape.createUserIndex();
    const l2 = ei.getNAN();
    let g2 = 0;
    const u = ei.getNAN();
    for (let i2 = 0; i2 <= this.m_pointCount; i2++) {
      if (i2 < this.m_pointCount) {
        const e6 = a2.read(i2);
        this.m_shape.queryXY(e6, u);
      } else u.setNAN();
      if (!l2.isEqualPoint2D(u)) {
        if (g2 < i2) {
          const e6 = this.newCluster_();
          let t3 = bm, s5 = -1;
          for (let n7 = g2; n7 < i2; n7++) {
            s5 = a2.read(n7), this.m_shape.setUserIndex(s5, this.m_clusterIndex, e6);
            const r2 = this.m_clusterVertices.newElement();
            this.m_clusterVertices.setField(r2, 0, s5), this.m_clusterVertices.setField(r2, 1, t3), t3 = r2;
            const i3 = this.m_shape.getPathFromVertex(s5), o3 = this.m_shape.getGeometryFromPath(i3), h3 = this.getGeometryID(o3);
            this.setClusterParentage_(e6, this.getClusterParentage(e6) | h3);
          }
          this.setClusterVertexIterator_(e6, t3), this.setClusterVertexIndex_(e6, this.m_shape.getVertexIndex(s5)), this.m_lastCluster !== bm && this.setNextCluster_(this.m_lastCluster, e6), this.setPrevCluster_(e6, this.m_lastCluster), this.m_lastCluster = e6, this.m_firstCluster === bm && (this.m_firstCluster = e6);
        }
        g2 = i2, l2.setCoordsPoint2D(u);
      }
    }
    if (this.m_shape.hasSegmentParentage()) {
      -1 === this.m_clusterBreakNodeIndex && (this.m_clusterBreakNodeIndex = this.createUserIndexForClusters());
      for (let e6 = 0; e6 < this.m_pointCount; e6++) {
        const t3 = a2.read(e6);
        if (this.m_shape.getSegmentParentageBreakVertex(t3)) {
          const e7 = this.getClusterFromVertex(t3);
          this.setBreakNode(e7, true);
        }
      }
    }
    this.progress_(n6, true);
    {
      let e6 = null != s4 ? s4[0] : this.m_shape.getFirstGeometry(), t3 = 1;
      for (; e6 !== bm; ) {
        for (let t4 = this.m_shape.getFirstPath(e6); t4 !== bm; t4 = this.m_shape.getNextPath(t4)) {
          if (this.m_shape.isStrongPathStart(t4)) {
            const e7 = this.m_shape.getFirstVertex(t4), s5 = this.getClusterFromVertex(e7);
            this.setStrongPathNode(s5, true);
          }
          if (this.m_shape.isStrongPathEnd(t4)) {
            const e7 = this.m_shape.isClosedPath(t4) ? this.m_shape.getFirstVertex(t4) : this.m_shape.getLastVertex(t4), s5 = this.getClusterFromVertex(e7);
            this.setStrongPathNode(s5, true);
          }
        }
        null != s4 ? (e6 = t3 < s4.length ? s4[t3] : bm, t3++) : e6 = this.m_shape.getNextGeometry(e6);
      }
    }
    if (t2 === zs2.enumInputModeBuildGraph && (this.m_tmpHalfEdgeParentageIndex = this.createUserIndexForHalfEdges(), this.m_tmpHalfEdgeParentageIndexLeft = this.createUserIndexForHalfEdges()), t2 === zs2.enumInputModeSimplifyWinding && (this.m_tmpHalfEdgeWindingNumberIndex = this.createUserIndexForHalfEdges()), t2 === zs2.enumInputModeSimplifyAlternate && (this.m_tmpHalfEdgeOddEvenNumberIndex = this.createUserIndexForHalfEdges()), this.createHalfEdges_(t2, a2), this.dbgNavigate_(), this.sortHalfEdgesByAngle_(t2), !Number.isNaN(this.m_checkDirtyPlanesweepTolerance) && !this.checkStructureAfterDirtySweep_()) return this.m_bDirtyCheckFailed = true, void this.cleanSetEditShapeImpl_();
    this.buildChains_(t2), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), this.m_bBuildChains && this.planeSweepParentage_(t2, n6), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), this.dbgChkChainParents_(), this.dbgDumpChains_(), this.mergeSegmentParentage_(), this.dbgNavigate_(), this.dbgDumpChains_(), this.cleanSetEditShapeImpl_();
  }
  setEditShapeImpl3D_(e5, t2, n6, r, i2) {
    n2(0);
  }
  cleanSetEditShapeImpl_() {
    -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1);
  }
  cleanSetEditShapeImpl3D_() {
    n2(0);
  }
  dbgNavigate_() {
  }
  dbgChkChainParents_() {
  }
  deleteEdgeImpl_(e5) {
    const t2 = this.getHalfEdgeNext(e5), s4 = this.getHalfEdgePrev(e5), n6 = this.getHalfEdgeTwin(e5), r = this.getHalfEdgeNext(n6), i2 = this.getHalfEdgePrev(n6);
    t2 !== n6 && (this.setHalfEdgeNext_(i2, t2), this.setHalfEdgePrev_(t2, i2)), s4 !== n6 && (this.setHalfEdgeNext_(s4, r), this.setHalfEdgePrev_(r, s4));
    const o2 = this.getHalfEdgeOrigin(e5);
    this.getClusterHalfEdge(o2) === e5 && (r !== e5 ? this.setClusterHalfEdge_(o2, r) : this.setClusterHalfEdge_(o2, bm));
    const a2 = this.getHalfEdgeOrigin(n6);
    this.getClusterHalfEdge(a2) === n6 && (t2 !== n6 ? this.setClusterHalfEdge_(a2, t2) : this.setClusterHalfEdge_(a2, bm)), this.m_halfEdgeData.deleteElement(e5), this.m_halfEdgeData.deleteElement(n6);
  }
  getLeftSkipPolylines_(e5, t2) {
    let s4 = t2;
    for (; ; ) {
      if (s4 = e5.getPrev(s4), -1 === s4) return bm;
      {
        const t3 = e5.getElement(s4);
        if (this.getHalfEdgeChain(t3) !== this.getHalfEdgeChain(this.getHalfEdgeTwin(t3))) return t3;
      }
    }
  }
  checkStructureAfterDirtySweep_() {
    const e5 = $(this.m_checkDirtyPlanesweepTolerance), t2 = new ei(), s4 = new ei(), n6 = new ei(), r = new ei(), i2 = new ei();
    for (let o2 = this.getFirstCluster(); o2 !== bm; o2 = this.getNextCluster(o2)) {
      const a2 = this.getClusterHalfEdge(o2);
      if (a2 !== bm) {
        let o3 = a2;
        this.getHalfEdgeFromXY(o3, t2), this.getHalfEdgeToXY(o3, s4), n6.setSub(s4, t2);
        let h2 = n6.sqrLength();
        do {
          const a3 = o3;
          if (o3 = this.getHalfEdgeNext(this.getHalfEdgeTwin(o3)), o3 !== a3) {
            this.getHalfEdgeToXY(o3, r), i2.setSub(r, t2);
            const a4 = i2.sqrLength(), m2 = i2.crossProduct(n6), l2 = m2 * m2 / (a4 * h2);
            if (Math.min(a4, h2) * l2 <= e5) {
              if (i2.dotProduct(n6) >= 0) return false;
            }
            n6.assign(i2), h2 = a4, s4.assign(r);
          }
        } while (o3 !== a2);
      }
    }
    return true;
  }
  extractPolygonPathFromChain_(e5, t2, s4, n6, r) {
    const i2 = this.m_shape.hasSegmentParentage(), o2 = this.getChainHalfEdge(s4);
    let a2 = o2, h2 = bm;
    const m2 = new ee();
    do {
      const o3 = this.getHalfEdgeTwin(a2);
      if (this.getHalfEdgeChain(o3) !== s4) {
        let s5 = bm;
        const o4 = this.getHalfEdgeOrigin(a2);
        if (n6 === bm) {
          const e6 = this.getClusterVertexIterator(o4);
          s5 = this.getVertexFromVertexIterator(e6);
        } else for (let e6 = this.getClusterVertexIterator(o4); e6 !== bm; e6 = this.incrementVertexIterator(e6)) {
          const t3 = this.getVertexFromVertexIterator(e6);
          s5 === bm && (s5 = t3);
          const r2 = this.m_shape.getPathFromVertex(t3);
          if (this.m_shape.getGeometryFromPath(r2) === n6) {
            s5 = t3;
            break;
          }
        }
        let l2;
        if (h2 === bm && (h2 = e5.insertPath(t2, bm), e5.setClosedPath(h2, true)), this.m_shape === e5 ? l2 = e5.addVertex(h2, s5) : (this.m_shape.queryPoint(s5, m2), l2 = e5.addPoint(h2, m2)), this.isHalfEdgeCurve(a2) && (this.querySegmentXY(a2, r), e5.setSegmentToIndex(e5.getVertexIndex(l2), r.get().clone())), i2) {
          const t3 = this.getSegmentParentage(a2);
          e5.setSegmentParentageAndBreak(l2, t3, this.isBreakNode(o4));
        }
      }
      a2 = this.getHalfEdgeNext(a2);
    } while (a2 !== o2);
  }
  mergeSegmentParentage_() {
    if (!this.m_shape.hasSegmentParentage()) return;
    n2(-1 !== this.m_clusterBreakNodeIndex), n2(-1 === this.m_segmentParentageIndex);
    for (let s4 = this.getFirstCluster(); s4 !== bm; s4 = this.getNextCluster(s4)) {
      let e6 = 0;
      const t3 = this.getClusterHalfEdge(s4);
      if (t3 !== bm) {
        let s5 = t3;
        do {
          e6++, s5 = this.getHalfEdgeNext(this.getHalfEdgeTwin(s5));
        } while (s5 !== t3 && e6 < 3);
      }
      2 !== e6 && this.setBreakNode(s4, true);
    }
    let e5 = [], t2 = [];
    this.m_segmentParentageIndex = this.createUserIndexForHalfEdges();
    const n6 = this.createUserIndexForHalfEdges();
    for (let s4 = this.getFirstCluster(); s4 !== bm; s4 = this.getNextCluster(s4)) {
      const r = this.getClusterHalfEdge(s4);
      if (r !== bm) {
        let s5 = false, i2 = r;
        do {
          let r2 = i2;
          for (; -1 === this.getHalfEdgeUserIndex(r2, n6); ) {
            const i3 = this.getHalfEdgeNext(r2), o2 = this.getHalfEdgeTwin(r2);
            Ks2(this, r2, t2);
            const a2 = t2.at(-1).parentage;
            if (!s5) {
              const t3 = this.getHalfEdgeOrigin(r2);
              if (!this.isBreakNode(t3)) {
                const t4 = this.getHalfEdgePrev(r2);
                r2 !== t4 && (Ks2(this, t4, e5), s5 = true);
              }
            }
            if (s5 && !Zs2(t2, e5)) {
              const e6 = this.getHalfEdgeOrigin(r2);
              this.setBreakNode(e6, true);
            }
            e5 = Mt(t2, t2 = e5), s5 = true;
            const h2 = this.getHalfEdgeOrigin(i3);
            this.isBreakNode(h2) && (s5 = false), this.setHalfEdgeUserIndex(r2, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(o2, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(r2, n6, 1), this.setHalfEdgeUserIndex(o2, n6, 1), r2 = i3;
          }
          i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
        } while (i2 !== r);
      }
    }
    this.deleteUserIndexForHalfEdges(n6);
  }
  registerNewBitSet(e5) {
    if (null === this.m_uniqueBitSets && (this.m_uniqueBitSets = Qs3(), this.m_uniqueBitSets.add(this.getEmptySet())), null === e5) return this.getEmptySet();
    return this.m_uniqueBitSets.has(e5) ? this.m_uniqueBitSets.get(e5) : (this.m_uniqueBitSets.add(e5), e5);
  }
  getLeftEdgeBitSet_(e5) {
    const t2 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft);
    return n2(t2 >= 0), n2(this.m_edgeBitSets.at(t2)), this.m_edgeBitSets.at(t2);
  }
  getEdgeBitSet_(e5) {
    const t2 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex);
    return n2(t2 >= 0), this.m_edgeBitSets.at(t2);
  }
  setEdgeBitSet_(e5, t2) {
    n2(this.m_bBuildGeometryParentageSets), t2 = this.registerNewBitSet(t2), -1 === this.m_edgeBitSetIndex && (this.m_edgeBitSetIndex = this.createUserIndexForHalfEdges());
    const n6 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex);
    -1 !== n6 ? this.m_edgeBitSets[n6] = t2 : (this.setHalfEdgeUserIndex(e5, this.m_edgeBitSetIndex, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t2));
  }
  setLeftEdgeBitSet_(e5, t2) {
    n2(this.m_bBuildGeometryParentageSets), t2 = this.registerNewBitSet(t2), -1 === this.m_edgeBitSetIndexLeft && (this.m_edgeBitSetIndexLeft = this.createUserIndexForHalfEdges());
    const n6 = this.getHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft);
    -1 !== n6 ? this.m_edgeBitSets[n6] = t2 : (this.setHalfEdgeUserIndex(e5, this.m_edgeBitSetIndexLeft, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t2));
  }
  setChainBitSet_(e5, t2) {
    n2(this.m_bBuildGeometryParentageSets), t2 = this.registerNewBitSet(t2), -1 === this.m_chainBitSetIndex && (this.m_chainBitSetIndex = this.createUserIndexForChains());
    const n6 = this.getChainUserIndex(e5, this.m_chainBitSetIndex);
    -1 !== n6 ? this.m_chainBitSets[n6] = t2 : (this.setChainUserIndex(e5, this.m_chainBitSetIndex, this.m_chainBitSets.length), this.m_chainBitSets.push(t2));
  }
  getEmptySet() {
    return this.m_emptyBitSet || (this.m_emptyBitSet = new Rs3()), this.m_emptyBitSet;
  }
  deleteEdgeBitSets_() {
    -1 !== this.m_edgeBitSetIndex && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex), this.m_edgeBitSetIndex = -1), -1 !== this.m_edgeBitSetIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft), this.m_edgeBitSetIndexLeft = -1), this.m_edgeBitSets.length = 0, this.m_uniqueBitSets = null;
  }
  deleteChainBitSets_() {
    -1 !== this.m_chainBitSetIndex && (this.deleteUserIndexForChains(this.m_chainBitSetIndex), this.m_chainBitSetIndex = -1, this.m_chainBitSets.length = 0);
  }
  dbgPrintEdge_(e5) {
  }
  dbgVerifyEdgeSegment(e5) {
  }
};
Js2.c_EdgeParentageMask = ~(1 << 31), Js2.c_EdgeBitMask = 1 << 31;
var $s2 = class _$s {
  freeNode_(e5) {
    this.m_listNodes.deleteElement(e5);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(e5) {
    this.m_lists.deleteElement(e5);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  Init_(e5) {
    n2(0);
  }
  constructor(e5) {
    this.m_listNodes = new at(2), this.m_listOfLists = _$s.st_nullNode(), this.m_bAllowNavigationBetweenLists = true, void 0 === e5 && (e5 = true), this.m_bAllowNavigationBetweenLists = e5, this.m_lists = new at(this.m_bAllowNavigationBetweenLists ? 4 : 2);
  }
  createList() {
    const e5 = this.newList_();
    return this.m_bAllowNavigationBetweenLists && (this.m_lists.setField(e5, 3, this.m_listOfLists), this.m_listOfLists !== _$s.st_nullNode() && this.m_lists.setField(this.m_listOfLists, 2, e5), this.m_listOfLists = e5), e5;
  }
  deleteList(e5) {
    let t2 = this.getFirst(e5);
    for (; t2 !== _$s.st_nullNode(); ) {
      const e6 = t2;
      t2 = this.getNext(t2), this.freeNode_(e6);
    }
    if (this.m_bAllowNavigationBetweenLists) {
      const t3 = this.m_lists.getField(e5, 2), s4 = this.m_lists.getField(e5, 3);
      t3 !== _$s.st_nullNode() ? this.m_lists.setField(t3, 3, s4) : this.m_listOfLists = s4, s4 !== _$s.st_nullNode() && this.m_lists.setField(s4, 2, t3);
    }
    this.freeList_(e5);
  }
  reserveLists(e5) {
    this.m_lists.setCapacity(e5);
  }
  addElement(e5, t2) {
    this.m_lists.getField(e5, 0);
    const s4 = this.m_lists.getField(e5, 1), n6 = this.newNode_();
    return s4 !== _$s.st_nullNode() ? (this.m_listNodes.setField(s4, 1, n6), this.m_lists.setField(e5, 1, n6)) : (this.m_lists.setField(e5, 0, n6), this.m_lists.setField(e5, 1, n6)), this.m_listNodes.setField(n6, 0, t2), n6;
  }
  reserveNodes(e5) {
    this.m_listNodes.setCapacity(e5);
  }
  deleteElementDirect(e5, t2, s4) {
    t2 !== _$s.st_nullNode() ? (this.m_listNodes.setField(t2, 1, this.m_listNodes.getField(s4, 1)), this.m_lists.getField(e5, 1) === s4 && this.m_lists.setField(e5, 1, t2)) : (this.m_lists.setField(e5, 0, this.m_listNodes.getField(s4, 1)), this.m_lists.getField(e5, 1) === s4 && this.m_lists.setField(e5, 1, _$s.st_nullNode())), this.freeNode_(s4);
  }
  deleteElementSearch(e5, t2) {
    let s4 = -1, n6 = this.getFirst(e5);
    for (; n6 !== t2; ) s4 = n6, n6 = this.getNext(n6);
    this.deleteElementDirect(e5, s4, t2);
  }
  concatenateLists(e5, t2) {
    const s4 = this.m_lists.getField(e5, 1), n6 = this.m_lists.getField(t2, 0);
    if (n6 !== _$s.st_nullNode() && (s4 !== _$s.st_nullNode() ? (this.m_listNodes.setField(s4, 1, n6), this.m_lists.setField(e5, 1, this.m_lists.getField(t2, 1))) : (this.m_lists.setField(e5, 0, n6), this.m_lists.setField(e5, 1, this.m_lists.getField(t2, 1)))), this.m_bAllowNavigationBetweenLists) {
      const e6 = this.m_lists.getField(t2, 2), s5 = this.m_lists.getField(t2, 3);
      e6 !== _$s.st_nullNode() ? this.m_lists.setField(e6, 3, s5) : this.m_listOfLists = s5, s5 !== _$s.st_nullNode() && this.m_lists.setField(s5, 2, e6);
    }
    return this.freeList_(t2), e5;
  }
  getElement(e5) {
    return this.m_listNodes.getField(e5, 0);
  }
  getData(e5) {
    return this.getElement(e5);
  }
  setElement(e5, t2) {
    n2(0);
  }
  getNext(e5) {
    return this.m_listNodes.getField(e5, 1);
  }
  getFirst(e5) {
    return this.m_lists.getField(e5, 0);
  }
  getFirstElement(e5) {
    const t2 = this.getFirst(e5);
    return this.getElement(t2);
  }
  static st_nullNode() {
    return -1;
  }
  clear() {
    this.m_listNodes.deleteAll(true), this.m_lists.deleteAll(true), this.m_listOfLists = _$s.st_nullNode();
  }
  isEmpty(e5) {
    return n2(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(e5) {
    return this.m_lists.getField(e5, 3);
  }
};
function en2(e5 = -1) {
  return { m_value: e5, m_line: new su(), m_segment: null, m_segmentInfo: new Am(-1), m_env: new x2(0, 0), m_dxdy: 55555555, m_bHorizontal: false, m_bCurve: false };
}
var tn2 = 67;
var sn2 = class extends dt {
  constructor(e5, t2, s4) {
    super(true), this.m_bIntersectionDetected = false, this.m_nonSimpleResult = new es2(), this.m_tempSimpleEdge1 = en2(), this.m_tempSimpleEdge2 = en2(), this.m_prev1 = bm, this.m_prev2 = bm, this.m_vertex1 = bm, this.m_vertex2 = bm, this.m_currentNode = -1, this.m_prevX1 = Number.NaN, this.m_prevX2 = Number.NaN, this.m_prevY = Number.NaN, this.m_prevX = 0, this.m_sweepY = Number.NaN, this.m_sweepX = 0, this.m_ptSweep = new ei(), this.m_simpleEdgesCache = [], this.m_simpleEdgesRecycle = [], this.m_cOutstandingConstructedEdges = 0, this.m_shape = e5, this.m_bShapeHasSegments = this.m_shape.hasCurves(), this.m_tolerance = t2, this.m_tolerance10 = 10 * t2, this.m_bIsSimple = s4;
    const n6 = Math.trunc(Math.min(3 * e5.getTotalPointCount() / 2, tn2)), r = Math.min(7, n6);
    this.m_simpleEdgesCache.length = r;
  }
  tryGetCachedEdge_(e5) {
    const t2 = this.m_simpleEdgesCache[(e5 & os()) % this.m_simpleEdgesCache.length];
    return t2 && t2.m_value === e5 ? t2 : null;
  }
  tryDeleteCachedEdge_(e5) {
    const t2 = (e5 & os()) % this.m_simpleEdgesCache.length, s4 = this.m_simpleEdgesCache[t2];
    s4 && s4.m_value === e5 && (this.m_simpleEdgesRecycle.push(s4), this.m_simpleEdgesCache[t2] = null);
  }
  tryCreateCachedEdge_(e5) {
    const t2 = (e5 & os()) % this.m_simpleEdgesCache.length;
    let s4 = this.m_simpleEdgesCache[t2];
    return s4 ? null : (0 === this.m_simpleEdgesRecycle.length ? (s4 = en2(), this.m_cOutstandingConstructedEdges++) : s4 = this.m_simpleEdgesRecycle.pop(), s4.m_value = e5, this.m_simpleEdgesCache[t2] = s4, s4);
  }
  initSimpleEdge_(e5, t2) {
    this.m_bShapeHasSegments && this.initSimpleEdgeHelper_(e5, t2) || e5.m_bCurve || (this.m_shape.queryLineConnector(t2, e5.m_line, true), e5.m_segment = e5.m_line, e5.m_env.setCoordsNoNAN(e5.m_line.getStartX(), e5.m_line.getEndX()), e5.m_env.vmax += this.m_tolerance, e5.m_line.orientBottomUp(), e5.m_bHorizontal = e5.m_line.getEndY() === e5.m_line.getStartY(), e5.m_bHorizontal || (e5.m_dxdy = (e5.m_line.getEndX() - e5.m_line.getStartX()) / (e5.m_line.getEndY() - e5.m_line.getStartY())));
  }
  initSimpleEdgeHelper_(e5, t2) {
    if (e5.m_segment = this.m_shape.getSegment(t2), e5.m_segmentInfo = this.m_shape.getOriginalSegmentInfo(t2), e5.m_bCurve = null !== e5.m_segment, e5.m_bCurve) {
      const t3 = e5.m_segment.clone();
      return t3.orientBottomUp(), e5.m_segment = t3, e5.m_env = e5.m_segment.queryInterval(0, 0), e5.m_env.vmax += this.m_tolerance, true;
    }
    return false;
  }
  compareTwoSegments_(e5, t2) {
    const s4 = e5.getStartXY(), n6 = e5.getEndXY(), r = t2.getStartXY(), i2 = t2.getEndXY();
    if (this.m_ptSweep.setCoords(this.m_sweepX, this.m_sweepY), s4.isEqualPoint2D(r) && this.m_sweepY === s4.y) {
      this.m_ptSweep.assign(n6.compare(i2) < 0 ? n6 : i2);
      const s5 = e5.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = t2.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x);
      if (Math.abs(s5 - r2) > this.m_tolerance) return s5 < r2 ? -1 : 1;
    }
    const o2 = s4.compare(r) < 0 ? r : s4, a2 = n6.compare(i2) < 0 ? n6 : i2;
    let h2 = 0, m2 = 0;
    for (let l2 = 1; l2 < 5; l2++) {
      Y(o2, a2, l2 / 5, this.m_ptSweep);
      const s5 = e5.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), n7 = t2.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = Math.abs(s5 - n7);
      r2 > h2 && (h2 = r2, m2 = s5 < n7 ? -1 : 1);
    }
    return 0 === m2 ? this.errorCracking() : m2;
  }
  compareNonHorizontal_(e5, t2) {
    if (e5.m_line.getStartY() === t2.m_line.getStartY() && e5.m_line.getStartX() === t2.m_line.getStartX()) return e5.m_line.getEndY() === t2.m_line.getEndY() && e5.m_line.getEndX() === t2.m_line.getEndX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.compareNonHorizontalUpperEnd_(e5, t2);
    if (e5.m_line.getEndY() === t2.m_line.getEndY() && e5.m_line.getEndX() === t2.m_line.getEndX()) return this.compareNonHorizontalLowerEnd_(e5, t2);
    const s4 = this.compareNonHorizontalLowerEnd_(e5, t2), n6 = this.compareNonHorizontalUpperEnd_(e5, t2);
    return s4 < 0 && n6 < 0 ? -1 : s4 > 0 && n6 > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1Case1_(e5, t2) {
    if (e5.getEndX() > t2.getEndX()) {
      if (t2.getEndX() > t2.getStartX() && t2.getEndY() - t2.getStartY() < 2 * this.m_tolerance && e5.isIntersectingPoint(t2.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t2.getEndY() - t2.getStartY()) / (t2.getEndX() - t2.getStartX()) * (e5.getEndX() - e5.getStartX()) < this.m_tolerance10 && t2.isIntersectingPoint(e5.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return 1;
  }
  compareHorizontal1Case2_(e5, t2) {
    if (e5.getStartX() < t2.getStartX()) {
      if (t2.getEndX() > t2.getStartX() && t2.getEndY() - t2.getStartY() < 2 * this.m_tolerance && e5.isIntersectingPoint(t2.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t2.getEndY() - t2.getStartY()) / (t2.getEndX() - t2.getStartX()) * (e5.getStartX() - e5.getEndX()) < this.m_tolerance10 && t2.isIntersectingPoint(e5.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return -1;
  }
  compareHorizontal1Case3_(e5, t2) {
    const s4 = ei.getNAN();
    s4.setSub(t2.getEndXY(), t2.getStartXY()), s4.rightPerpendicularThis(), s4.normalize();
    const n6 = ei.getNAN();
    n6.setSub(e5.getStartXY(), t2.getStartXY());
    const r = ei.getNAN();
    r.setSub(e5.getEndXY(), t2.getStartXY());
    const i2 = n6.dotProduct(s4), o2 = r.dotProduct(s4), a2 = Math.abs(i2), h2 = Math.abs(o2);
    if (a2 < h2) {
      if (a2 < this.m_tolerance10 && t2.isIntersectingPoint(e5.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    } else if (h2 < this.m_tolerance10 && t2.isIntersectingPoint(e5.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    return i2 < 0 && o2 < 0 ? -1 : i2 > 0 && o2 > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1_(e5, t2) {
    return e5.getStartY() === t2.getStartY() && e5.getStartX() === t2.getStartX() ? this.compareHorizontal1Case1_(e5, t2) : e5.getEndY() === t2.getEndY() && e5.getEndX() === t2.getEndX() ? this.compareHorizontal1Case2_(e5, t2) : this.compareHorizontal1Case3_(e5, t2);
  }
  compareHorizontal2_(e5, t2) {
    return e5.getEndY() === t2.getEndY() && e5.getEndX() === t2.getEndX() && e5.getStartY() === t2.getStartY() && e5.getStartX() === t2.getStartX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.errorCracking();
  }
  compareNonHorizontalLowerEnd_(e5, t2) {
    let s4 = 1;
    if (e5.m_line.getStartY() < t2.m_line.getStartY()) {
      s4 = -1;
      const n7 = e5;
      e5 = t2, t2 = n7;
    }
    const n6 = e5.m_line, r = t2.m_line, i2 = n6.getStartX() - r.getStartX(), o2 = t2.m_dxdy * (n6.getStartY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o2 - a2 ? -s4 : i2 > o2 + a2 ? s4 : r.isIntersectingPoint(n6.getStartXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o2 ? -s4 : s4;
  }
  compareNonHorizontalUpperEnd_(e5, t2) {
    let s4 = 1;
    if (t2.m_line.getEndY() < e5.m_line.getEndY()) {
      s4 = -1;
      const n7 = e5;
      e5 = t2, t2 = n7;
    }
    const n6 = e5.m_line, r = t2.m_line, i2 = n6.getEndX() - r.getStartX(), o2 = t2.m_dxdy * (n6.getEndY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o2 - a2 ? -s4 : i2 > o2 + a2 ? s4 : r.isIntersectingPoint(n6.getEndXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o2 ? -s4 : s4;
  }
  errorCoincident() {
    this.m_bIntersectionDetected = true;
    const e5 = 7;
    return this.m_nonSimpleResult = new es2(e5, this.m_vertex1, this.m_vertex2), -1;
  }
  errorCracking() {
    if (this.m_bIntersectionDetected = true, this.m_bIsSimple) {
      const e5 = 6;
      this.m_nonSimpleResult = new es2(e5, this.m_vertex1, this.m_vertex2);
    } else this.m_prev1 = bm, this.m_prev2 = bm, this.m_vertex1 = bm, this.m_vertex2 = bm;
    return -1;
  }
  compareSegments_(e5, t2, s4, n6) {
    if (s4.m_env.vmax < n6.m_env.vmin) return -1;
    if (n6.m_env.vmax < s4.m_env.vmin) return 1;
    if (!s4.m_bCurve && !n6.m_bCurve) {
      let e6 = s4.m_bHorizontal ? 1 : 0;
      return e6 |= n6.m_bHorizontal ? 2 : 0, 0 === e6 ? this.compareNonHorizontal_(s4, n6) : 1 === e6 ? this.compareHorizontal1_(s4.m_line, n6.m_line) : 2 === e6 ? -1 * this.compareHorizontal1_(n6.m_line, s4.m_line) : this.compareHorizontal2_(s4.m_line, n6.m_line);
    }
    if (this.m_bIntersectionDetected) return -1;
    const r = this.m_prevY === this.m_sweepY && this.m_prevX === this.m_sweepX;
    let i2, o2;
    if (r && e5 === this.m_prev1 ? i2 = this.m_prevX1 : (i2 = Number.NaN, this.m_prev1 = bm), r && t2 === this.m_prev2 ? o2 = this.m_prevX2 : (o2 = Number.NaN, this.m_prev2 = bm), this.m_prevY = this.m_sweepY, this.m_prevX = this.m_sweepX, Number.isNaN(i2)) {
      this.m_prev1 = e5;
      const t3 = s4.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      i2 = t3, this.m_prevX1 = t3;
    }
    if (Number.isNaN(o2)) {
      this.m_prev2 = t2;
      const e6 = n6.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      o2 = e6, this.m_prevX2 = e6;
    }
    const a2 = Zm(true, true, s4.m_segment, n6.m_segment, this.m_tolerance, true);
    return 0 !== a2 ? 2 === a2 ? this.m_bIsSimple ? this.errorCoincident() : s4.m_segmentInfo.equals(n6.m_segmentInfo) ? 0 : this.errorCracking() : this.errorCracking() : Math.abs(i2 - o2) <= this.m_tolerance ? this.compareTwoSegments_(s4.m_segment, n6.m_segment) : i2 < o2 ? -1 : i2 > o2 ? 1 : 0;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  getLastComparedNode() {
    return this.m_currentNode;
  }
  getResult() {
    return this.m_nonSimpleResult;
  }
  setSweepY(e5, t2) {
    this.m_sweepY = e5, this.m_sweepX = t2, this.m_prev1 = bm, this.m_prev2 = bm, this.m_vertex1 = bm, this.m_vertex2 = bm;
  }
  compare(e5, t2, s4) {
    if (this.m_bIntersectionDetected) return -1;
    const n6 = e5.getElement(s4), r = t2;
    return this.m_currentNode = s4, this.compareSegments(r, r, n6, n6);
  }
  compareSegments(e5, t2, s4, n6) {
    let r = this.tryGetCachedEdge_(e5);
    null === r ? this.m_vertex1 === t2 ? r = this.m_tempSimpleEdge1 : (this.m_vertex1 = t2, r = this.tryCreateCachedEdge_(e5), null === r && (r = this.m_tempSimpleEdge1, this.m_tempSimpleEdge1.m_value = e5), this.initSimpleEdge_(r, t2)) : this.m_vertex1 = t2;
    let i2 = this.tryGetCachedEdge_(s4);
    return null === i2 ? this.m_vertex2 === n6 ? i2 = this.m_tempSimpleEdge2 : (this.m_vertex2 = n6, i2 = this.tryCreateCachedEdge_(s4), null === i2 && (i2 = this.m_tempSimpleEdge2, this.m_tempSimpleEdge2.m_value = s4), this.initSimpleEdge_(i2, n6)) : this.m_vertex2 = n6, this.compareSegments_(t2, n6, r, i2);
  }
  onDelete(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onSet(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onEndSearch(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
  onAddUniqueElementFailed(e5) {
    this.tryDeleteCachedEdge_(e5);
  }
};
var nn2 = class {
  constructor(e5, t2) {
    this.m_bIntersectionDetected = false, this.m_pointOfInterest = ei.getNAN(), this.m_line1 = new su(), this.m_seg1 = null, this.m_env = x2.constructEmpty(), this.m_vertex1 = -1, this.m_currentNode = -1, this.m_minDist = Number.MAX_VALUE, this.m_shape = e5, this.m_tolerance = t2;
  }
  getCurrentNode() {
    return this.m_currentNode;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false, this.m_minDist = Number.MAX_VALUE;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  setPoint(e5) {
    this.m_pointOfInterest.assign(e5);
  }
  compare(e5, t2) {
    const s4 = e5.getElement(t2);
    return this.compareVertex(e5, t2, s4);
  }
  compareVertex(t2, s4, n6) {
    let r, i2 = this.m_shape.getSegment(n6), o2 = true;
    if (null == i2) this.m_shape.queryLineConnector(n6, this.m_line1, true), this.m_env.setCoordsNoNAN(this.m_line1.getStartX(), this.m_line1.getEndX()), i2 = this.m_line1, r = this.m_line1.getStartY() === this.m_line1.getEndY();
    else {
      const t3 = n4.constructEmpty();
      i2.queryLooseEnvelope(t3), t3.queryIntervalX(this.m_env), r = 0 === t3.height(), o2 = false;
    }
    if (this.m_pointOfInterest.x + this.m_tolerance < this.m_env.vmin) return -1;
    if (this.m_pointOfInterest.x - this.m_tolerance > this.m_env.vmax) return 1;
    if (r) return this.m_currentNode = s4, this.m_bIntersectionDetected = true, 0;
    let a2 = 0;
    if (o2) {
      ds(this.m_line1);
      const e5 = this.m_line1.getStartXY(), t3 = new ei();
      t3.setSub(this.m_line1.getEndXY(), e5), t3.rightPerpendicularThis();
      const s5 = new ei();
      s5.setSub(this.m_pointOfInterest, e5), a2 = t3.dotProduct(s5), a2 /= t3.length();
    } else {
      a2 = i2.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y, this.m_pointOfInterest.x) - this.m_pointOfInterest.x;
    }
    if (a2 < 10 * -this.m_tolerance) return -1;
    if (a2 > 10 * this.m_tolerance) return 1;
    if (i2.isIntersectingPoint(this.m_pointOfInterest, this.m_tolerance)) {
      Math.abs(a2) < this.m_minDist && (this.m_currentNode = s4, this.m_minDist = a2), this.m_bIntersectionDetected = true;
    }
    return a2 < 0 ? -1 : a2 > 0 ? 1 : 0;
  }
};
var rn2 = class _rn {
  constructor(e5, t2) {
    this.m_lists = new $s2(false), this.m_hash = t2, this.m_hashBuckets = new Int32Array(e5), this.m_hashBuckets.fill(_rn.st_nullNode()), this.m_bitFilter = new Int32Array(10 * e5 + 31 >> 5);
  }
  reserveElements(e5) {
    this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length, e5)), this.m_lists.reserveNodes(e5);
  }
  addElement(e5, t2) {
    void 0 === t2 && (t2 = this.m_hash.getHash(e5));
    const s4 = t2 % (this.m_bitFilter.length << 5);
    this.m_bitFilter[s4 >> 5] |= 1 << (31 & s4);
    const n6 = t2 % this.m_hashBuckets.length;
    let r = this.m_hashBuckets[n6];
    r === $s2.st_nullNode() && (r = this.m_lists.createList(), this.m_hashBuckets[n6] = r);
    return this.m_lists.addElement(r, e5);
  }
  deleteElement(e5, s4) {
    void 0 === s4 && (s4 = this.m_hash.getHash(e5));
    const n6 = s4 % this.m_hashBuckets.length, r = this.m_hashBuckets[n6];
    r === $s2.st_nullNode() && P("");
    let i2 = this.m_lists.getFirst(r), o2 = $s2.st_nullNode();
    for (; i2 !== $s2.st_nullNode(); ) {
      const t2 = this.m_lists.getData(i2), s5 = this.m_lists.getNext(i2);
      t2 === e5 ? (this.m_lists.deleteElementDirect(r, o2, i2), this.m_lists.getFirst(r) === $s2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n6] = $s2.st_nullNode())) : o2 = i2, i2 = s5;
    }
  }
  getFirstInBucket(e5) {
    const t2 = e5 % (this.m_bitFilter.length << 5);
    if (!(this.m_bitFilter[t2 >> 5] & 1 << (31 & t2))) return $s2.st_nullNode();
    const s4 = e5 % this.m_hashBuckets.length, n6 = this.m_hashBuckets[s4];
    return n6 === $s2.st_nullNode() ? $s2.st_nullNode() : this.m_lists.getFirst(n6);
  }
  getNextInBucket(e5) {
    return this.m_lists.getNext(e5);
  }
  findNode(e5) {
    const t2 = this.m_hash.getHash(e5);
    let s4 = this.getFirstInBucket(t2);
    for (; s4 !== $s2.st_nullNode(); ) {
      const t3 = this.m_lists.getData(s4);
      if (this.m_hash.equal(t3, e5)) return s4;
      s4 = this.m_lists.getNext(s4);
    }
    return $s2.st_nullNode();
  }
  deleteNode(e5) {
    const s4 = this.getElement(e5), n6 = this.m_hash.getHash(s4) % this.m_hashBuckets.length, r = this.m_hashBuckets[n6];
    r === $s2.st_nullNode() && P(""), this.m_lists.deleteElementSearch(r, e5), this.m_lists.getFirst(r) === $s2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n6] = $s2.st_nullNode());
  }
  getElement(e5) {
    return this.m_lists.getData(e5);
  }
  static st_nullNode() {
    return $s2.st_nullNode();
  }
  clear() {
    n2(0);
  }
  size() {
    return this.m_lists.getNodeCount();
  }
  dbgPrintBucketHistogram() {
  }
};
function on2(e5, t2, s4, n6, r) {
  const i2 = new _n2(r);
  return i2.m_shape = e5, i2.m_sqrTolerance = t2 * t2, i2.m_cellSize = 2 * t2, i2.m_invCellSize = 1 / i2.m_cellSize, i2.m_geometry = s4, i2.m_bTrackChanges = n6, i2.m_bHasSegmentParentage = e5.hasSegmentParentage(), i2.clusterNonReciprocal();
}
function an2(e5, t2, s4, n6, r) {
  const i2 = e5 - s4, o2 = t2 - n6;
  return i2 * i2 + o2 * o2 <= r;
}
function hn2() {
  return { pt: new ei(), weight: 0, rank: 0, bMerged: false };
}
function mn2(e5, t2, s4, n6, r, i2) {
  const o2 = hn2(), a2 = s4 + r;
  let h2 = false, m2 = e5.x;
  e5.x !== t2.x && (n6 === i2 && (m2 = (e5.x * s4 + t2.x * r) / a2), h2 = true);
  let l2 = e5.y;
  return e5.y !== t2.y && (n6 === i2 && (l2 = (e5.y * s4 + t2.y * r) / a2), h2 = true), n6 !== i2 ? n6 > i2 ? (o2.rank = n6, o2.weight = s4, o2.pt = e5) : (o2.rank = i2, o2.weight = r, o2.pt = t2) : (o2.pt.setCoords(m2, l2), o2.weight = a2, o2.rank = n6), o2.bMerged = h2, o2;
}
function ln2(e5, t2, s4, n6, r, i2, o2, a2, h2) {
  const m2 = e5.equals(t2);
  if (n6 > i2) return o2.assignCopy(e5), h2[0] = n6, a2[0] = s4, m2;
  if (i2 > n6) return o2 = t2, h2[0] = i2, a2[0] = r, m2;
  o2.assignCopy(e5);
  const l2 = mn2(e5.getXY(), t2.getXY(), s4, n6, r, i2);
  return o2.setXY(l2.pt), a2[0] = l2.weight, h2[0] = l2.rank, m2;
}
function gn2(e5, t2, s4, n6, r) {
  const i2 = new _n2(r);
  return i2.m_shape = e5, i2.m_sqrTolerance = t2 * t2, i2.m_cellSize = 2 * t2, i2.m_invCellSize = 1 / i2.m_cellSize, i2.m_geometry = s4, i2.m_bTrackChanges = false, i2.needsClustering();
}
function un2(e5, t2) {
  const s4 = Es(e5);
  return Is(s4, t2);
}
var cn2 = class {
  constructor(e5, t2, s4, n6, r) {
    this.m_workPt = new ei(), this.m_shape = e5, this.m_sqrTolerance = s4, this.m_invCellSize = n6, this.m_origin = t2.clone(), this.m_hashValues = r;
  }
  getHash(e5) {
    return this.m_shape.getUserIndex(e5, this.m_hashValues);
  }
  calculateHashFromVertex(e5) {
    this.m_shape.queryXY(e5, this.m_workPt);
    const t2 = this.m_workPt.x - this.m_origin.x, s4 = Math.trunc(t2 * this.m_invCellSize + 0.5), n6 = this.m_workPt.y - this.m_origin.y;
    return un2(s4, Math.trunc(n6 * this.m_invCellSize + 0.5));
  }
  equal(e5, t2) {
    return n2(0), false;
  }
};
var _n2 = class {
  constructor(e5) {
    this.m_origin = ei.getNAN(), this.m_sqrTolerance = 0, this.m_cellSize = 0, this.m_invCellSize = 0, this.m_geometry = bm, this.m_bucketArray = Lt(4, Number.NaN), this.m_bucketHash = Lt(4, Number.NaN), this.m_dbgCandidateCheckCount = 0, this.m_nsr = new es2(), this.m_hashValues = -1, this.m_newClusters = -1, this.m_bTrackChanges = false, this.m_bHasSegmentParentage = false, this.m_shape = null, this.m_clusters = new $s2(), this.m_hashFunction = null, this.m_hashTable = null, this.m_progressCounter = 0, this.m_progressTracker = e5;
  }
  progress_() {
  }
  collectClusterCandidates(e5, t2) {
    const s4 = ei.getNAN();
    this.m_shape.queryXY(e5, s4);
    const n6 = (s4.x - this.m_origin.x) * this.m_invCellSize, r = (s4.y - this.m_origin.y) * this.m_invCellSize, i2 = Math.trunc(n6), o2 = Math.trunc(r);
    let a2 = 0;
    for (let h2 = 0; h2 <= 1; h2 += 1) for (let e6 = 0; e6 <= 1; e6 += 1) {
      const t3 = un2(i2 + h2, o2 + e6), s5 = this.m_hashTable.getFirstInBucket(t3);
      s5 !== rn2.st_nullNode() && (this.m_bucketArray[a2] = s5, this.m_bucketHash[a2] = t3, a2++);
    }
    for (let h2 = a2 - 1; h2 >= 1; h2--) {
      const e6 = this.m_bucketArray[h2];
      for (let t3 = h2 - 1; t3 >= 0; t3--) if (e6 === this.m_bucketArray[t3]) {
        this.m_bucketHash[t3] = -1, a2--, h2 !== a2 && (this.m_bucketHash[h2] = this.m_bucketHash[a2], this.m_bucketArray[h2] = this.m_bucketArray[a2]);
        break;
      }
    }
    for (let h2 = 0; h2 < a2; h2++) this.collectNearestNeighbourCandidates(e5, this.m_bucketHash[h2], s4, this.m_bucketArray[h2], t2);
  }
  collectNearestNeighbourCandidates(e5, t2, s4, n6, r) {
    const i2 = ei.getNAN();
    for (let o2 = n6; o2 !== rn2.st_nullNode(); o2 = this.m_hashTable.getNextInBucket(o2)) {
      const n7 = this.m_hashTable.getElement(o2);
      e5 === n7 || -1 !== t2 && this.m_shape.getUserIndex(n7, this.m_hashValues) !== t2 || (this.m_shape.queryXY(n7, i2), an2(s4.x, s4.y, i2.x, i2.y, this.m_sqrTolerance) && r.push(o2));
    }
  }
  mergeClusters(e5, t2, s4) {
    let n6 = this.m_shape.getUserIndex(e5, this.m_newClusters);
    const r = this.m_shape.getUserIndex(t2, this.m_newClusters);
    -1 === n6 && (n6 = this.m_clusters.createList(), this.m_clusters.addElement(n6, e5), this.m_shape.setUserIndex(e5, this.m_newClusters, n6)), -1 === r ? this.m_clusters.addElement(n6, t2) : this.m_clusters.concatenateLists(n6, r), this.m_shape.setUserIndex(t2, this.m_newClusters, at.impossibleIndex2());
    const i2 = this.mergeVertices(e5, t2);
    if (s4) {
      const t3 = this.m_hashFunction.calculateHashFromVertex(e5);
      this.m_shape.setUserIndex(e5, this.m_hashValues, t3);
    }
    return i2;
  }
  mergeVertices(e5, t2) {
    const s4 = ei.getNAN();
    this.m_shape.queryXY(e5, s4);
    const n6 = ei.getNAN();
    this.m_shape.queryXY(t2, n6);
    const r = this.m_shape.getRank(e5), i2 = this.m_shape.getRank(t2), o2 = this.m_shape.getWeight(e5), a2 = this.m_shape.getWeight(t2);
    let h2, m2, l2, g2, u = false;
    if (r === i2 ? (h2 = r, m2 = o2 + a2, l2 = s4.x, s4.x !== n6.x && (l2 = (s4.x * o2 + n6.x * a2) / m2, u = true), g2 = s4.y, s4.y !== n6.y && (g2 = (s4.y * o2 + n6.y * a2) / m2, u = true)) : (r > i2 ? (l2 = s4.x, g2 = s4.y, m2 = o2, h2 = r) : (l2 = n6.x, g2 = n6.y, m2 = a2, h2 = i2), u = !s4.equals(n6)), u && (this.m_shape.setXYMonotonic(e5, l2, g2), this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(e5, true), this.m_bHasSegmentParentage)) {
      const s5 = this.m_shape.getSegmentParentageBreakVertex(e5) || this.m_shape.getSegmentParentageBreakVertex(t2);
      this.m_shape.setSegmentParentageBreakVertex(e5, s5), this.m_shape.setSegmentParentageBreakVertex(t2, s5);
    }
    return this.m_shape.setWeight(e5, m2), this.m_shape.setRank(e5, h2), u;
  }
  needsClustering() {
    const e5 = { stack: [], error: void 0, hasError: false };
    try {
      n(e5, zt(() => {
        this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters);
      }), false);
      const t2 = this.m_shape.getSelectedCount(), s4 = this.m_shape.getEnvelope2D(this.m_progressTracker);
      this.m_origin.assign(s4.getLowerLeft());
      const n6 = Math.max(s4.height(), s4.width()) / (ls() - 1);
      this.m_cellSize < n6 && (this.m_cellSize = n6, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(this.m_shape.getSelectedCount() / 3 + 1), this.m_clusters.reserveNodes(this.m_shape.getSelectedCount() / 3 + 1), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new cn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new rn2(4 * t2 / 3, this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
      let r = false;
      for (let e6 = 0; e6 < 2; e6++) {
        const t3 = [], s5 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
        for (let n7 = s5.next(); n7 !== bm; n7 = s5.next()) {
          if (this.progress_(), e6 > 0 && this.m_shape.getUserIndex(n7, this.m_newClusters) === at.impossibleIndex2()) continue;
          let s6;
          if (0 === e6 ? (s6 = this.m_hashFunction.calculateHashFromVertex(n7), this.m_shape.setUserIndex(n7, this.m_hashValues, s6)) : s6 = this.m_shape.getUserIndex(n7, this.m_hashValues), this.collectClusterCandidates(n7, t3), 0 !== t3.length) {
            for (let e7 = 0, s7 = t3.length; e7 < s7; e7++) {
              this.progress_();
              const s8 = t3[e7], i2 = this.m_hashTable.getElement(s8);
              if (this.m_hashTable.deleteNode(s8), !this.m_shape.isEqualXY(n7, i2)) return this.m_nsr = new es2(5, this.m_shape.getVertexIndex(n7), this.m_shape.getVertexIndex(i2)), r = true, r;
              this.mergeClusters(n7, i2, false);
            }
            t3.length = 0;
          }
          0 === e6 && this.m_hashTable.addElement(n7, s6);
        }
      }
      return r;
    } catch (t2) {
      e5.error = t2, e5.hasError = true;
    } finally {
      s(e5);
    }
  }
  clusterNonReciprocal() {
    const e5 = this.m_shape.getSelectedCount(), t2 = this.m_shape.getEnvelope2D(this.m_progressTracker);
    this.m_origin = t2.getLowerLeft();
    const s4 = Math.max(t2.height(), t2.width()) / (ls() - 1);
    this.m_cellSize < s4 && (this.m_cellSize = s4, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new cn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new rn2(Math.trunc(4 * e5 / 3), this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
    let n6 = false;
    {
      const e6 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let t3 = e6.next(); t3 !== bm; t3 = e6.next()) {
        this.progress_();
        const e7 = this.m_hashFunction.calculateHashFromVertex(t3);
        this.m_shape.setUserIndex(t3, this.m_hashValues, e7), this.m_hashTable.addElement(t3, e7);
      }
    }
    {
      const e6 = [], t3 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let s5 = t3.next(); s5 !== bm; s5 = t3.next()) {
        if (this.m_shape.getUserIndex(s5, this.m_newClusters) === at.impossibleIndex2()) continue;
        let t4 = this.m_shape.getUserIndex(s5, this.m_hashValues);
        this.m_hashTable.deleteElement(s5, t4);
        let r = false;
        for (; this.collectClusterCandidates(s5, e6), 0 !== e6.length; ) {
          let t5 = 0;
          for (let n7 = 0, r2 = e6.length; n7 < r2; n7++) {
            this.progress_();
            const i2 = e6[n7], o2 = this.m_hashTable.getElement(i2);
            this.m_hashTable.deleteNode(i2);
            const a2 = n7 + 1 === r2;
            t5 |= this.mergeClusters(s5, o2, a2) ? 1 : 0;
          }
          if (r || (r = 0 !== t5), n6 || (n6 = 0 !== t5), e6.length = 0, !t5) break;
        }
        r && (t4 = this.m_shape.getUserIndex(s5, this.m_hashValues)), this.m_hashTable.addElement(s5, t4);
      }
      e6.length = 0;
    }
    return n6 && this.applyClusterPositions_(), this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters), n6;
  }
  applyClusterPositions_() {
    const e5 = ei.getNAN();
    for (let t2 = this.m_clusters.getFirstList(); t2 !== $s2.st_nullNode(); t2 = this.m_clusters.getNextList(t2)) {
      let s4 = this.m_clusters.getFirst(t2);
      const n6 = this.m_clusters.getElement(s4);
      this.m_shape.queryXY(n6, e5);
      const r = this.m_shape.getRank(n6), i2 = this.m_shape.getWeight(n6);
      for (s4 = this.m_clusters.getNext(s4); s4 !== $s2.st_nullNode(); s4 = this.m_clusters.getNext(s4)) {
        const t3 = this.m_clusters.getElement(s4);
        if (this.m_bTrackChanges ? this.m_shape.isEqualXYPoint2D(t3, e5) || (this.m_shape.setXYMonotonicPoint2D(t3, e5), this.m_shape.setGeometryModifiedWithVertex(t3, true)) : this.m_shape.setXYMonotonicPoint2D(t3, e5), this.m_bHasSegmentParentage) {
          const e6 = this.m_shape.getSegmentParentageBreakVertex(n6) || this.m_shape.getSegmentParentageBreakVertex(t3);
          this.m_shape.setSegmentParentageBreakVertex(n6, e6), this.m_shape.setSegmentParentageBreakVertex(t3, e6);
        }
        this.m_shape.setWeight(t3, i2), this.m_shape.setRank(t3, r);
      }
    }
  }
};
var dn2 = class _dn {
  constructor() {
    this.m_inputParts = [], this.m_resultParts1 = [], this.m_resultParts2 = [], this.m_resultSegments = [], this.m_freeSegments = [], this.m_inputSegments = [], this.m_param1 = [], this.m_param2 = [], this.m_tolerance = 0, this.m_toleranceZ = 0, this.m_point = new ee(), this.m_pointWeight = 1, this.m_maxDensifyLimit = 0, this.m_pointRank = 0, this.m_changed1 = false, this.m_changed2 = false, this.m_adaptiveDensify = false;
  }
  clear() {
    this.freeAllResultSegments(), this.m_inputSegments.length = 0, this.m_inputParts.length = 0, this.m_resultParts1.length = 0, this.m_resultParts2.length = 0, this.m_param1.length = 0, this.m_param2.length = 0, this.m_adaptiveDensify = false, this.m_changed1 = false, this.m_changed2 = false;
  }
  newIntersectionPart_(e5, t2, s4, n6, r, i2, o2, a2, h2, m2) {
    return fn2(e5, t2, s4, n6, r, i2, o2, a2, h2, m2);
  }
  pushSegment(e5, t2, s4, n6, r, i2, o2, a2, h2, m2) {
    return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length, t2, s4, n6, r, i2, o2, a2, h2, m2)), this.m_inputSegments.push(e5), this.m_inputParts.length - 1;
  }
  getResultSegmentCount(e5) {
    return this.m_adaptiveDensify ? 0 === e5 ? this.m_param1.length - 1 : this.m_param2.length - 1 : 0 === e5 ? this.m_resultParts1.length : this.m_resultParts2.length;
  }
  getResultPart_(e5, t2) {
    return 0 === e5 ? this.m_resultParts1[t2] : this.m_resultParts2[t2];
  }
  getResultSegment(e5, t2) {
    return this.m_resultSegments[this.getResultPart_(e5, t2).segmentIndex].get();
  }
  getSegmentChanged(e5) {
    return 0 === e5 ? this.m_changed1 : this.m_changed2;
  }
  getResultSegmentStartPointWeight(e5, t2) {
    return this.getResultPart_(e5, t2).weightStart;
  }
  getResultSegmentStartPointRank(e5, t2) {
    return this.getResultPart_(e5, t2).rankStart;
  }
  getResultSegmentSegmentParentage(e5, t2) {
    return this.getResultPart_(e5, t2).segmentParentage;
  }
  getResultSegmentStartPointIsBreak(e5, t2) {
    return this.getResultPart_(e5, t2).u.bBreakStart;
  }
  getResultSegmentEndPointWeight(e5, t2) {
    return this.getResultPart_(e5, t2).weightEnd;
  }
  getResultSegmentEndPointRank(e5, t2) {
    return this.getResultPart_(e5, t2).rankEnd;
  }
  getResultSegmentEndPointIsBreak(e5, t2) {
    return this.getResultPart_(e5, t2).u.bBreakEnd;
  }
  getResultSegmentInteriorRank(e5, t2) {
    return this.getResultPart_(e5, t2).rankInterior;
  }
  getResultSegmentInteriorWeight(e5, t2) {
    return this.getResultPart_(e5, t2).weightInterior;
  }
  getResultPoint() {
    return this.m_point;
  }
  getResultPointWeight() {
    return this.m_pointWeight;
  }
  getResultPointRank() {
    return this.m_pointRank;
  }
  getResultPointChanged() {
    return this.m_changed2;
  }
  intersectLines(e5, t2) {
    2 !== this.m_inputSegments.length && b(""), this.m_changed1 = false, this.m_changed2 = false, this.m_tolerance = e5;
    const s4 = $(e5 * _dn.c_smallToleranceFactor);
    let n6 = false;
    const r = this.m_inputParts[0], i2 = this.m_inputParts[1], o2 = this.m_inputSegments[r.segmentIndex], a2 = this.m_inputSegments[i2.segmentIndex];
    if (t2 || 5 & jm(true, o2, a2, e5, true)) {
      const t3 = Om(true, o2, a2, null, this.m_param1, this.m_param2, e5);
      0 === t3 && b("");
      const h2 = new Array(t3);
      for (let e6 = 0; e6 < t3; ++e6) h2[e6] = ei.getNAN();
      const m2 = new Float64Array(t3), l2 = new Int32Array(t3), u = new Array(t3), c = new Array(t3);
      for (let e6 = 0; e6 < t3; ++e6) u[e6] = xn2(), c[e6] = xn2();
      for (let e6 = 0; e6 < t3; e6++) {
        const t4 = this.m_param1[e6], g2 = this.m_param2[e6];
        let _2, d3 = r.rankInterior, p4 = r.weightInterior;
        0 === t4 ? (d3 = r.rankStart, p4 = r.weightStart, _2 = r.u.bBreakStart) : 1 === t4 ? (d3 = r.rankEnd, p4 = r.weightEnd, _2 = r.u.bBreakEnd) : (this.m_changed1 = true, _2 = false);
        let f4, x5 = i2.rankInterior, y3 = i2.weightInterior;
        0 === g2 ? (x5 = i2.rankStart, y3 = i2.weightStart, f4 = i2.u.bBreakStart) : 1 === g2 ? (x5 = i2.rankEnd, y3 = i2.weightEnd, f4 = i2.u.bBreakEnd) : (this.m_changed2 = true, f4 = false);
        const P6 = d3, E2 = x5;
        let C2 = 1, S3 = 0, I5 = ei.getNAN();
        if (P6 === E2) {
          const n7 = o2.getCoord2D(t4), r2 = a2.getCoord2D(g2);
          C2 = p4 + y3;
          S3 = d3, Y(n7, r2, y3 / C2, I5);
          const i3 = ei.sqrDistance(I5, n7), h3 = ei.sqrDistance(I5, r2);
          u[e6].bBigMove = i3 > s4, c[e6].bBigMove = h3 > s4, this.m_changed1 || n7.equals(I5) || (this.m_changed1 = true), this.m_changed2 || r2.equals(I5) || (this.m_changed2 = true);
        } else if (P6 > E2) {
          I5 = o2.getCoord2D(t4);
          const n7 = a2.getCoord2D(g2);
          C2 = p4, S3 = d3;
          const r2 = ei.sqrDistance(I5, n7);
          u[e6].bBigMove = false, c[e6].bBigMove = r2 > s4, this.m_changed2 || n7.equals(I5) || (this.m_changed2 = true);
        } else {
          I5 = a2.getCoord2D(g2), C2 = y3, S3 = x5;
          const n7 = o2.getCoord2D(t4), r2 = ei.sqrDistance(I5, n7);
          u[e6].bBigMove = r2 > s4, c[e6].bBigMove = false, this.m_changed1 || n7.equals(I5) || (this.m_changed1 = true);
        }
        h2[e6].assign(I5), m2[e6] = C2, l2[e6] = S3, u[e6].bIsBreak = _2 || f4, c[e6].bIsBreak = _2 || f4, n6 || (n6 = u[e6].bBigMove || c[e6].bBigMove);
      }
      const _ = r.rankInterior, d2 = r.weightInterior;
      let p3 = 0, f3 = -1;
      for (let s5 = 0; s5 <= t3; s5++) {
        const n7 = s5 < t3 ? this.m_param1[s5] : 1;
        if (n7 !== p3) {
          const i3 = this.allocResultSegment(), a3 = this.m_resultSegments[i3];
          let g2, c2, x5, y3;
          o2.queryCut(p3, n7, a3, false), a3.get().snapControlPoints(e5 * e5);
          let P6 = false, E2 = false, C2 = false, S3 = false, I5 = false, b2 = ei.getNAN(), w4 = ei.getNAN();
          -1 !== f3 ? (c2 = l2[f3], g2 = m2[f3], P6 = u[f3].bBigMove, b2.assign(h2[f3]), C2 = u[f3].bIsBreak, I5 = true) : (g2 = r.weightStart, c2 = r.rankStart, b2 = a3.get().getStartXY(), C2 = r.u.bBreakStart), s5 < t3 ? (y3 = l2[s5], x5 = m2[s5], E2 = u[s5].bBigMove, w4.assign(h2[s5]), S3 = u[s5].bIsBreak, I5 = true) : (x5 = r.weightEnd, y3 = r.rankEnd, w4 = a3.get().getEndXY(), S3 = r.u.bBreakEnd), I5 && a3.get().setCoordsForIntersector(b2, w4, true), this.m_resultParts1.push(this.newIntersectionPart_(i3, g2, c2, x5, y3, d2, _, C2, S3, r.segmentParentage));
          const v3 = this.m_resultParts1.at(-1);
          v3.u.bBigMoveStart = P6, v3.u.bBigMoveEnd = E2, p3 = n7, f3 = s5;
        } else -1 === f3 && (f3 = s5);
      }
      const x4 = Lt(t3, 0);
      for (let e6 = 0; e6 < t3; e6++) x4[e6] = e6;
      t3 > 2 ? (x4.sort((e6, t4) => this.m_param2[e6] < this.m_param2[t4] ? -1 : this.m_param2[e6] > this.m_param2[t4] ? 1 : 0), Et(this.m_param2)) : 2 === t3 && this.m_param2[0] > this.m_param2[1] && (this.m_param2[1] = Mt(this.m_param2[0], this.m_param2[0] = this.m_param2[1]), x4[1] = Mt(x4[0], x4[0] = x4[1]));
      const y2 = i2.rankInterior, P5 = i2.weightInterior;
      p3 = 0, f3 = -1;
      for (let s5 = 0; s5 <= t3; s5++) {
        const n7 = s5 < t3 ? this.m_param2[s5] : 1;
        if (n7 !== p3) {
          const r2 = this.allocResultSegment(), o3 = this.m_resultSegments[r2];
          let g2, u2, _2, d3;
          a2.queryCut(p3, n7, o3, false), o3.get().snapControlPoints(e5 * e5);
          let E2 = ei.getNAN(), C2 = ei.getNAN(), S3 = false, I5 = false, b2 = false, w4 = false, v3 = false;
          if (-1 !== f3) {
            const e6 = x4[f3];
            g2 = m2[e6], u2 = l2[e6], E2.assign(h2[e6]), b2 = c[e6].bBigMove, S3 = c[e6].bIsBreak, v3 = true;
          } else g2 = i2.weightStart, u2 = i2.rankStart, E2 = o3.get().getStartXY(), S3 = i2.u.bBreakStart;
          if (s5 !== t3) {
            const e6 = x4[s5];
            _2 = m2[e6], d3 = l2[e6], C2.assign(h2[e6]), w4 = c[e6].bBigMove, I5 = c[e6].bIsBreak, v3 = true;
          } else _2 = i2.weightEnd, d3 = i2.rankEnd, C2 = o3.get().getEndXY(), I5 = i2.u.bBreakEnd;
          v3 && o3.get().setCoordsForIntersector(E2, C2, true), this.m_resultParts2.push(this.newIntersectionPart_(r2, g2, u2, _2, d3, P5, y2, S3, I5, i2.segmentParentage));
          const N2 = this.m_resultParts2.at(-1);
          N2.u.bBigMoveStart = b2, N2.u.bBigMoveEnd = w4, p3 = n7, f3 = s5;
        } else -1 === f3 && (f3 = s5);
      }
      return n6 ? 3 : 2;
    }
    return 0;
  }
  intersectLines3D(e5, t2, n6, r) {
    return n2(0), 1;
  }
  intersect2D(e5, t2) {
    const s4 = this.m_inputParts[0], n6 = this.m_inputParts[1], r = this.m_inputSegments[s4.segmentIndex].getGeometryType(), i2 = this.m_inputSegments[n6.segmentIndex].getGeometryType();
    if (r !== a.enumLine || i2 !== a.enumLine) {
      return new Cn2(this).intersectCurves(e5, t2);
    }
    return this.intersectLines(e5, t2);
  }
  intersect2DEx(e5, t2, s4, n6, r) {
    this.m_point.assignCopy(t2), 1 !== this.m_inputSegments.length && b(""), this.m_tolerance = e5, this.m_changed1 = false, this.m_changed2 = false;
    const i2 = $(e5 * _dn.c_smallToleranceFactor);
    let o2 = false;
    const a2 = this.m_inputParts[0], h2 = this.m_inputSegments[a2.segmentIndex];
    if (r || h2.isIntersectingPoint(t2.getXY(), e5, true)) {
      this.m_param1 = Lt(16, Number.NaN);
      const r2 = h2.getClosestCoordinate(t2.getXY(), false);
      this.m_param1[0] = r2;
      let m2 = a2.rankInterior, l2 = a2.weightInterior;
      0 === r2 ? (m2 = a2.rankStart, l2 = a2.weightStart) : 1 === r2 ? (m2 = a2.rankEnd, l2 = a2.weightEnd) : this.m_changed1 = true;
      let g2 = m2;
      const u = s4, c = n6;
      g2 === u && h2.isCurve() && (g2 = u + 1);
      let _ = 1, d2 = 0;
      const p3 = new ei();
      if (g2 === u) {
        const e6 = h2.getCoord2D(r2), s5 = t2.getXY();
        _ = l2 + c, d2 = m2;
        Y(e6, s5, c / _, p3), this.m_changed1 || e6.equals(p3) || (this.m_changed1 = true), this.m_changed2 || s5.equals(p3) || (this.m_changed2 = true);
        o2 = ei.sqrDistance(p3, e6) > i2;
      } else if (g2 > u) p3.assign(h2.getCoord2D(r2)), _ = l2, d2 = m2, this.m_changed2 || p3.equals(t2.getXY()) || (this.m_changed2 = true);
      else {
        p3.assign(h2.getCoord2D(r2)), _ = c, d2 = u, this.m_changed1 || p3.equals(t2.getXY()) || (this.m_changed1 = true);
        o2 = ei.sqrDistance(p3, t2.getXY()) > i2;
      }
      let f3 = 0, x4 = -1;
      const y2 = 1;
      for (let t3 = 0; t3 <= y2; t3++) {
        const s5 = t3 < y2 ? this.m_param1[0] : 1;
        if (s5 !== f3) {
          const n7 = this.allocResultSegment(), r3 = this.m_resultSegments[n7];
          h2.queryCut(f3, s5, r3), r3.get().snapControlPoints(e5 * e5);
          let i3 = a2.weightStart, o3 = a2.weightEnd, m3 = a2.rankStart, l3 = a2.rankEnd;
          const g3 = a2.rankInterior, u2 = a2.weightInterior;
          let c2 = a2.u.bBreakStart, P5 = a2.u.bBreakEnd;
          -1 !== x4 && (i3 = _, m3 = d2, c2 = true, r3.get().setCoordsForIntersector(p3, r3.get().getEndXY(), true)), t3 !== y2 && (o3 = _, l3 = d2, P5 = true, r3.get().setCoordsForIntersector(r3.get().getStartXY(), p3, true)), f3 = s5, this.m_resultParts1.push(this.newIntersectionPart_(n7, i3, m3, o3, l3, u2, g3, c2, P5, a2.segmentParentage));
        }
        x4 = t3;
      }
      return this.m_point.setXY(p3), this.m_pointWeight = _, this.m_pointRank = d2, o2 ? 3 : 2;
    }
    return 0;
  }
  intersect3D(e5, t2, n6, r) {
    return n2(0), 1;
  }
  intersect3DEx(e5, t2, n6, r, i2, o2, a2) {
    return n2(0), 1;
  }
  getTolerance() {
    return this.m_tolerance;
  }
  freeAllResultSegments() {
    this.m_resultSegments.length = 0, this.m_freeSegments.length = 0;
  }
  freeResultSegment(e5) {
    this.m_freeSegments.push(e5);
  }
  allocResultSegment() {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const e5 = new nu(), t2 = this.m_resultSegments.length;
    return this.m_resultSegments.push(e5), t2;
  }
  allocResultSegmentFromBuffer(e5) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t2 = new nu({ copy: e5 }), s4 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t2), s4;
  }
  allocResultSegmentFromSegment(e5) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t2 = new nu({ segment: e5 }), s4 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t2), s4;
  }
};
function pn2(e5, t2) {
  return { bBigMoveStart: false, bBigMoveEnd: false, bBreakStart: e5, bBreakEnd: t2 };
}
function fn2(e5, t2, s4, n6, r, i2, o2, a2, h2, m2) {
  return { segmentIndex: e5, weightStart: t2, rankStart: s4, weightEnd: n6, rankEnd: r, weightInterior: i2, rankInterior: o2, segmentParentage: m2, u: pn2(a2, h2) };
}
function xn2() {
  return { bBigMove: false, bIsBreak: false };
}
dn2.maxWeight = 0.1 * Number.MAX_VALUE, dn2.c_smallToleranceFactor = 0.01, dn2.c_maxGeometryTypeToRankDelta = 8;
var yn2 = class {
  constructor() {
    this.start = null, this.end = null, this.equalEdge = null, this.segmentIndex = -1, this.segmentParentage = -1, this.weight = 0, this.rank = 0;
  }
  hasSegment() {
    return this.segmentIndex >= 0;
  }
  transferAttributes(e5, t2, s4) {
    if (1 === t2.getDescription().getAttributeCount()) return;
    const n6 = e5.parent.m_resultSegments[this.segmentIndex].get().getStartXY(), r = e5.parent.m_resultSegments[this.segmentIndex].get().getEndXY(), i2 = new ee();
    t2.queryStart(i2), s4 ? (i2.setXY(n6), e5.parent.m_resultSegments[this.segmentIndex].get().setStart(i2)) : (i2.setXY(r), e5.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)), t2.queryEnd(i2), s4 ? (i2.setXY(r), e5.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)) : (i2.setXY(n6), e5.parent.m_resultSegments[this.segmentIndex].get().setStart(i2));
  }
  copyFromWhenOverlap(e5, t2, s4) {
    this.equalEdge = t2, t2.equalEdge = this, this.segmentIndex = e5.parent.allocResultSegmentFromBuffer(e5.parent.m_resultSegments[t2.segmentIndex]), this.segmentParentage = t2.segmentParentage, this.weight = t2.weight, this.rank = t2.rank, s4 ? (this.start.copyFrom(t2.start), this.end.copyFrom(t2.end)) : (this.start.copyFrom(t2.end), this.end.copyFrom(t2.start), e5.parent.m_resultSegments[this.segmentIndex].get().reverse());
  }
  getEnd() {
    return this.end;
  }
  getNextInChain() {
    return this.end.nextInChain;
  }
  getPrevInChain() {
    return this.start.prevInChain;
  }
};
var Pn2 = class {
  constructor() {
    this.hash = 0, this.pt = new ei(), this.prevInChain = null, this.nextInChain = null, this.prevInHash = null, this.nextInHash = null, this.prevEqual = null, this.nextEqual = null, this.weight = 0, this.rank = 0, this.bBigMove = false, this.bIsBreak = false;
  }
  copyFrom(e5) {
    this.pt.assign(e5.pt), this.weight = e5.weight, this.rank = e5.rank, this.bBigMove = e5.bBigMove, this.bIsBreak = e5.bIsBreak;
  }
  nextNode() {
    return this.nextInChain ? this.nextInChain.end : null;
  }
  prevNode() {
    return this.prevInChain ? this.prevInChain.start : null;
  }
  equalListHead() {
    let e5 = this;
    for (; null !== e5.prevEqual; e5 = e5.prevEqual) ;
    return e5;
  }
};
function En2(e5, t2, s4, n6) {
  return { edge1: e5, edge2: t2, recursion: s4, bIsIntersecting: n6 };
}
var Cn2 = class {
  constructor(e5) {
    this.m_pairs = [], this.m_chainOrigin1 = null, this.m_chainOrigin2 = null, this.m_newNodes = [], this.m_hashTableOfEquals = [], this.m_hashTableOfEqualsSize = 0, this.m_origin = new ei(), this.m_cell = new ei(), this.parent = e5;
  }
  addSegment(e5, t2, n6, r, i2, o2, a2, h2, m2, l2, g2) {
    const u = this.newNode(this.parent.m_resultSegments[e5].get().getStartXY(), n6, r, m2), c = this.newNode(this.parent.m_resultSegments[e5].get().getEndXY(), i2, o2, l2);
    this.newEdge(u, c, e5, a2, h2, g2), null === this.m_chainOrigin1 ? this.m_chainOrigin1 = u : null === this.m_chainOrigin2 ? this.m_chainOrigin2 = u : n2(0);
  }
  intersectCurvesHelper(e5, t2, n6, r, i2) {
    var _a3, _b, _c2, _d, _e, _f, _g2, _h2, _i3, _j, _k, _l2, _m3, _n3, _o3, _p, _q, _r3;
    const a2 = this.getSegment(e5).get(), h2 = this.getSegment(t2).get();
    if (a2.isDegenerate(0) || h2.isDegenerate(0)) return 0;
    const m2 = this.tryOverlapIntersectCurves(e5, t2, n6, r);
    if (0 !== m2) return m2;
    const l2 = $(0.01 * n6);
    let u = false, c = this.processSharpCorners(a2, h2, n6, i2 > 4);
    const _ = c > 0;
    if (!_) {
      if (!(r || 5 & Zm(true, false, a2, h2, n6, true))) return 0;
      c = Om(true, a2, h2, null, this.parent.m_param1, this.parent.m_param2, n6);
    }
    0 === c && b("");
    const d2 = a2.getGeometryType(), p3 = h2.getGeometryType(), f3 = Rt(ei, c), x4 = Rt(ei, c), y2 = Lt(c, Number.NaN), P5 = Lt(c, Number.NaN), E2 = Lt(c, Number.NaN), C2 = Lt(c, Number.NaN), S3 = kt(xn2, c), I5 = kt(xn2, c);
    let b2 = false, w4 = false;
    for (let s4 = 0; s4 < c; s4++) {
      const r2 = this.parent.m_param1[s4], i3 = this.parent.m_param2[s4];
      let o2 = e5.rank, m3 = e5.weight, g2 = true, c2 = false;
      0 === r2 ? (o2 = e5.start.rank, m3 = e5.start.weight, c2 = e5.start.bIsBreak) : 1 === r2 ? (o2 = e5.end.rank, m3 = e5.end.weight, c2 = e5.end.bIsBreak) : (b2 = true, g2 = false);
      let v4 = t2.rank, N3 = t2.weight, T4 = false, G5 = true;
      0 === i3 ? (v4 = t2.start.rank, N3 = t2.start.weight, T4 = t2.start.bIsBreak) : 1 === i3 ? (v4 = t2.end.rank, N3 = t2.end.weight, T4 = t2.end.bIsBreak) : (w4 = true, G5 = false);
      let D4 = o2, V5 = v4;
      if (D4 === V5 && (D4 *= dn2.c_maxGeometryTypeToRankDelta, V5 *= dn2.c_maxGeometryTypeToRankDelta, D4 += Sn2(d2, a2, false), V5 += Sn2(p3, h2, false)), g2 && G5 && V5 === D4) {
        const e6 = a2.getCoord2D(r2), t3 = h2.getCoord2D(i3);
        e6.equals(t3) && (V5 = D4 - 1);
      }
      let F4 = 1, H4 = 0, k5 = 1, A5 = 0;
      const M2 = new ei(), U4 = new ei(), q2 = a2.getCoord2D(r2), O3 = h2.getCoord2D(i3);
      if (_ && ei.distance(q2, O3) > n6) M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(O3), F4 = m3, k5 = N3, H4 = o2, A5 = v4, S3[s4].bBigMove = false, I5[s4].bBigMove = false, c2 = true, T4 = true;
      else if (D4 === V5) {
        k5 = F4 = m3 + N3, A5 = H4 = o2;
        Y(q2, O3, N3 / F4, M2), U4.setCoordsPoint2D(M2);
        const e6 = ei.sqrDistance(M2, q2), t3 = ei.sqrDistance(M2, O3);
        S3[s4].bBigMove = e6 > l2, I5[s4].bBigMove = t3 > l2, b2 || q2.equals(M2) || (b2 = true), w4 || O3.equals(U4) || (w4 = true);
      } else if (D4 > V5) {
        M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(M2), k5 = F4 = m3, A5 = H4 = o2;
        const e6 = ei.sqrDistance(M2, O3);
        S3[s4].bBigMove = false, I5[s4].bBigMove = e6 > l2, w4 || O3.equals(U4) || (w4 = true);
      } else {
        U4.setCoordsPoint2D(O3), M2.setCoordsPoint2D(U4), k5 = F4 = N3, A5 = H4 = v4;
        const e6 = ei.sqrDistance(M2, q2);
        S3[s4].bBigMove = e6 > l2, I5[s4].bBigMove = false, b2 || q2.equals(M2) || (b2 = true);
      }
      f3[s4].assign(M2), x4[s4].assign(U4), y2[s4] = F4, P5[s4] = k5, E2[s4] = H4, C2[s4] = A5, S3[s4].bIsBreak = c2 || T4, I5[s4].bIsBreak = c2 || T4, u || (u = S3[s4].bBigMove || I5[s4].bBigMove), s4 > 0 && (r2 !== this.parent.m_param1[s4 - 1] && i3 !== this.parent.m_param2[s4 - 1] || (E2[s4] <= E2[s4 - 1] ? (f3[s4].assign(x4[s4 - 1]), y2[s4] = P5[s4 - 1], E2[s4] = C2[s4 - 1], x4[s4].assign(x4[s4 - 1]), P5[s4] = P5[s4 - 1], C2[s4] = C2[s4 - 1], (_a3 = S3[s4]).bBigMove || (_a3.bBigMove = S3[s4 - 1].bBigMove), (_b = I5[s4]).bBigMove || (_b.bBigMove = I5[s4 - 1].bBigMove), (_c2 = S3[s4]).bIsBreak || (_c2.bIsBreak = S3[s4 - 1].bIsBreak), (_d = I5[s4]).bIsBreak || (_d.bIsBreak = I5[s4 - 1].bIsBreak)) : (f3[s4 - 1].assign(f3[s4]), y2[s4 - 1] = y2[s4], E2[s4 - 1] = E2[s4], x4[s4 - 1].assign(x4[s4]), P5[s4 - 1] = P5[s4], C2[s4 - 1] = C2[s4], (_e = S3[s4 - 1]).bBigMove || (_e.bBigMove = S3[s4].bBigMove), (_f = I5[s4 - 1]).bBigMove || (_f.bBigMove = I5[s4].bBigMove), (_g2 = S3[s4 - 1]).bIsBreak || (_g2.bIsBreak = S3[s4].bIsBreak), (_h2 = I5[s4 - 1]).bIsBreak || (_h2.bIsBreak = I5[s4].bIsBreak))));
    }
    if (!(b2 || w4 || 2 !== c || d2 === a.enumLine && p3 === a.enumLine)) {
      if (this.processDoublyConnectedEdges(e5, t2, i2 + 1, n6)) return this.parent.m_changed1 = true, this.parent.m_changed2 = true, 2;
      n2(0);
    }
    (_i3 = this.parent).m_changed1 || (_i3.m_changed1 = b2), (_j = this.parent).m_changed2 || (_j.m_changed2 = w4);
    let v3 = e5, N2 = e5.end.weight, T3 = e5.end.rank, G4 = e5.end.bBigMove, D3 = e5.end.bIsBreak, V4 = 0, F3 = -1;
    for (let s4 = 0; s4 <= c; s4++) {
      const t3 = s4 < c ? this.parent.m_param1[s4] : 1;
      if (t3 !== V4) {
        const r2 = this.parent.allocResultSegment(), i3 = this.parent.m_resultSegments[r2];
        let o2, h3, m3, l3;
        a2.queryCut(V4, t3, i3, false), i3.get().snapControlPoints(n6 * n6);
        let g2 = false, u2 = false, _2 = false, d3 = false;
        const p4 = new ei(), x5 = new ei();
        -1 !== F3 ? (h3 = E2[F3], o2 = y2[F3], _2 = S3[F3].bBigMove, g2 = S3[F3].bIsBreak, p4.assign(f3[F3])) : (o2 = e5.start.weight, h3 = e5.start.rank, _2 = e5.start.bBigMove, g2 = e5.start.bIsBreak, p4.assign(i3.get().getStartXY())), s4 < c ? (l3 = E2[s4], m3 = y2[s4], d3 = S3[s4].bBigMove, u2 = S3[s4].bIsBreak, x5.assign(f3[s4])) : (m3 = N2, l3 = T3, d3 = G4, u2 = D3, x5.assign(i3.get().getEndXY()));
        let P6 = v3;
        t3 < 1 && (this.splitEdgeInPlace(v3), P6 = v3.getNextInChain()), this.updateSegmentOnly(v3, r2), 0 === v3.start.hash || v3.start.pt.equals(p4) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(x5) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(p4), v3.end.pt.assign(x5), (_k = v3.start).bBigMove || (_k.bBigMove = _2), (_l2 = v3.end).bBigMove || (_l2.bBigMove = d3), (_m3 = v3.start).bIsBreak || (_m3.bIsBreak = g2), (_n3 = v3.end).bIsBreak || (_n3.bIsBreak = u2), v3.start.weight = o2, v3.start.rank = h3, v3.end.weight = m3, v3.end.rank = l3, v3 = P6, V4 = t3, F3 = s4;
      } else -1 === F3 && (F3 = s4);
    }
    const H3 = v3.getNextInChain(), k4 = [];
    k4.length = c;
    for (let s4 = 0; s4 < c; s4++) k4[s4] = s4;
    c > 2 ? (k4.sort((e6, t3) => Dt(this.parent.m_param2[e6], this.parent.m_param2[t3])), this.parent.m_param2.sort(Dt)) : 2 === c && this.parent.m_param2[0] > this.parent.m_param2[1] && (this.parent.m_param2[1] = Mt(this.parent.m_param2[0], this.parent.m_param2[0] = this.parent.m_param2[1]), k4[1] = Mt(k4[0], k4[0] = k4[1])), v3 = t2, N2 = t2.end.weight, T3 = t2.end.rank, G4 = t2.end.bBigMove, D3 = t2.end.bIsBreak, V4 = 0, F3 = -1;
    for (let s4 = 0; s4 <= c; s4++) {
      const e6 = s4 < c ? this.parent.m_param2[s4] : 1;
      if (e6 !== V4) {
        const r2 = this.parent.allocResultSegment(), i3 = this.parent.m_resultSegments[r2];
        let o2, a3, m3, l3;
        h2.queryCut(V4, e6, i3, false), i3.get().snapControlPoints(n6 * n6);
        const g2 = new ei(), u2 = new ei();
        let _2 = false, d3 = false, p4 = false, f4 = false;
        if (-1 !== F3) {
          const e7 = k4[F3];
          o2 = P5[e7], a3 = C2[e7], g2.assign(x4[e7]), p4 = I5[e7].bBigMove, _2 = I5[e7].bIsBreak;
        } else o2 = t2.start.weight, a3 = t2.start.rank, p4 = t2.start.bBigMove, _2 = t2.start.bIsBreak, g2.assign(i3.get().getStartXY());
        if (s4 !== c) {
          const e7 = k4[s4];
          m3 = P5[e7], l3 = C2[e7], u2.assign(x4[e7]), f4 = I5[e7].bBigMove, d3 = I5[e7].bIsBreak;
        } else m3 = N2, l3 = T3, f4 = G4, d3 = D3, u2.assign(i3.get().getEndXY());
        let y3 = v3;
        e6 < 1 && (this.splitEdgeInPlace(v3), y3 = v3.getNextInChain()), this.updateSegmentOnly(v3, r2), 0 === v3.start.hash || v3.start.pt.equals(g2) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(u2) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(g2), v3.end.pt.assign(u2), (_o3 = v3.start).bBigMove || (_o3.bBigMove = p4), (_p = v3.end).bBigMove || (_p.bBigMove = f4), (_q = v3.start).bIsBreak || (_q.bIsBreak = _2), (_r3 = v3.end).bIsBreak || (_r3.bIsBreak = d3), v3.start.weight = o2, v3.start.rank = a3, v3.end.weight = m3, v3.end.rank = l3, v3 = y3, V4 = e6, F3 = s4;
      } else -1 === F3 && (F3 = s4);
    }
    const A4 = v3.getNextInChain();
    return this.postProcessResultPartsForCurves(e5, H3, t2, A4, i2 + 1), u ? 3 : 2;
  }
  intersectCurves(t2, n6) {
    2 !== this.parent.m_inputSegments.length && b(""), this.parent.m_changed1 = false, this.parent.m_changed2 = false, this.parent.m_tolerance = t2, this.m_hashTableOfEqualsSize = 0, this.m_hashTableOfEquals = Ft(16);
    const r = n4.constructEmpty();
    for (let s4 = 0; s4 < 2; s4++) {
      const t3 = this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[s4].segmentIndex]), n7 = n4.constructEmpty();
      this.parent.m_inputSegments[this.parent.m_inputParts[s4].segmentIndex].queryLooseEnvelope(n7), r.mergeEnvelope2D(n7);
      const i3 = this.parent.m_inputParts[s4];
      this.addSegment(t3, 0, i3.weightStart, i3.rankStart, i3.weightEnd, i3.rankEnd, i3.weightInterior, i3.rankInterior, i3.u.bBreakStart, i3.u.bBreakEnd, i3.segmentParentage);
    }
    r.inflateCoords(100 * t2, 100 * t2), this.m_origin.assign(r.getLowerLeft()), this.m_cell.setCoords(2 * t2, 2 * t2), this.m_pairs.push(En2(this.m_chainOrigin1.nextInChain, this.m_chainOrigin2.nextInChain, 0, n6));
    let i2 = 0, o2 = true;
    for (; this.m_pairs.length; ) {
      const e5 = this.m_pairs.at(-1);
      this.m_pairs.pop(), n2(e5.recursion >= 0), n2(e5.recursion <= 256), this.clusterNodes(t2);
      const n7 = this.intersectCurvesHelper(e5.edge1, e5.edge2, t2, e5.bIsIntersecting, e5.recursion);
      o2 && (o2 = false, i2 = n7);
    }
    for (let e5 = 0; e5 < 2; e5++) {
      const t3 = 0 === e5 ? this.parent.m_resultParts1 : this.parent.m_resultParts2;
      for (let s4 = (0 === e5 ? this.m_chainOrigin1 : this.m_chainOrigin2).nextInChain; null != s4; s4 = s4.getNextInChain()) t3.push(this.parent.newIntersectionPart_(s4.segmentIndex, s4.start.weight, s4.start.rank, s4.end.weight, s4.end.rank, s4.weight, s4.rank, s4.start.bIsBreak, s4.end.bIsBreak, s4.segmentParentage)), t3.at(-1).u.bBigMoveStart = s4.start.bBigMove, t3.at(-1).u.bBigMoveEnd = s4.end.bBigMove;
    }
    return i2;
  }
  tryOverlapIntersectCurves(e5, t2, n6, r) {
    const i2 = this.parent.m_resultSegments[e5.segmentIndex].get(), o2 = this.parent.m_resultSegments[t2.segmentIndex].get(), a2 = i2.getStartXY().equals(o2.getStartXY()) && i2.getEndXY().equals(o2.getEndXY()), h2 = i2.getStartXY().equals(o2.getEndXY()) && i2.getEndXY().equals(o2.getStartXY());
    if (!a2 && !h2) return 0;
    const m2 = Hm(i2, o2, true);
    if (0 !== m2 && Um(i2, o2) && e5.segmentParentage === t2.segmentParentage) {
      let e6 = false;
      if (m2 > 0) e6 = i2.equals(o2);
      else {
        n2(-1 === m2);
        const t3 = new nu({ segment: o2 });
        t3.get().reverse(), e6 = i2.equals(t3.get());
      }
      if (e6) return 1;
    }
    const l2 = n6 * dn2.c_smallToleranceFactor;
    let g2 = false;
    if (0 === m2) {
      const e6 = [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 0.5625, 0.3125];
      for (let t3 = 0, s4 = e6.length; t3 < s4; ++t3) {
        const s5 = e6[t3], r2 = new ei();
        i2.queryCoord2D(s5, r2);
        const a3 = o2.getClosestCoordinate(r2, false), h3 = new ei();
        o2.queryCoord2D(a3, h3);
        const m3 = ei.distance(r2, h3);
        if (m3 > n6) return 0;
        g2 || (g2 = m3 > l2);
      }
      for (let t3 = 0, s4 = e6.length; t3 < s4; ++t3) {
        const s5 = e6[t3], r2 = new ei();
        o2.queryCoord2D(s5, r2);
        const a3 = i2.getClosestCoordinate(r2, false), h3 = new ei();
        i2.queryCoord2D(a3, h3);
        const m3 = ei.distance(r2, h3);
        if (m3 > n6) return 0;
        g2 || (g2 = m3 > l2);
      }
    }
    let u = e5.rank, c = t2.rank;
    return u === c && (u *= dn2.c_maxGeometryTypeToRankDelta, c *= dn2.c_maxGeometryTypeToRankDelta, u += Sn2(i2.getGeometryType(), i2, true), c += Sn2(o2.getGeometryType(), o2, true)), u > c ? (t2.copyFromWhenOverlap(this, e5, a2), t2.transferAttributes(this, i2, a2)) : c > u ? (e5.copyFromWhenOverlap(this, t2, a2), e5.transferAttributes(this, o2, a2)) : e5.segmentParentage <= t2.segmentParentage ? (e5.weight = e5.weight + t2.weight, t2.copyFromWhenOverlap(this, e5, a2), t2.transferAttributes(this, i2, a2)) : (t2.weight = e5.weight + t2.weight, e5.copyFromWhenOverlap(this, t2, a2), e5.transferAttributes(this, o2, a2)), g2 ? 3 : 2;
  }
  postProcessResultPartsForCurves(e5, t2, s4, n6, r) {
    r === ms() && b("curve_helper");
    for (let i2 = e5; i2 !== t2; i2 = i2.getNextInChain()) this.updateSegmentToNodes(i2);
    for (let i2 = s4; i2 !== n6; i2 = i2.getNextInChain()) this.updateSegmentToNodes(i2);
    for (let i2 = e5; i2 !== t2; i2 = i2.getNextInChain()) {
      const e6 = i2.end.pt.sub(i2.start.pt);
      for (let t3 = s4; t3 !== n6; t3 = t3.getNextInChain()) {
        let s5 = 0;
        if (i2.start.pt.equals(t3.start.pt) && i2.end.pt.equals(t3.end.pt) ? s5 = 1 : i2.start.pt.equals(t3.end.pt) && i2.end.pt.equals(t3.start.pt) && (s5 = -1), !s5) {
          let s6 = i2.start.pt.equals(t3.start.pt) ? 1 : 0;
          if (s6 || (s6 = i2.end.pt.equals(t3.end.pt) ? 2 : 0, s6 || (s6 = i2.end.pt.equals(t3.start.pt) ? 3 : 0, s6 || (s6 = i2.start.pt.equals(t3.end.pt) ? 4 : 0))), s6) {
            const n8 = t3.end.pt.sub(t3.start.pt), o3 = e6.dotProduct(n8);
            let a3;
            switch (s6) {
              case 1:
              case 2:
                a3 = o3 > 0;
                break;
              case 3:
              case 4:
                a3 = o3 < 0;
                break;
              default:
                b("post_process_result_parts_for_curves_");
            }
            a3 && this.m_pairs.push(En2(i2, t3, r, false));
          }
          continue;
        }
        const n7 = this.parent.m_resultSegments[i2.segmentIndex], o2 = this.parent.m_resultSegments[t3.segmentIndex], a2 = [0.5, 0.25, 0.75];
        for (let e7 = 0, t4 = a2.length; e7 < t4; ++e7) {
          const t5 = a2[e7], r2 = new ei();
          n7.get().queryCoord2D(t5, r2);
          const i3 = o2.get().getClosestCoordinate(r2, false), h3 = new ei();
          o2.get().queryCoord2D(i3, h3);
          if (ei.distance(r2, h3) > this.parent.m_tolerance) {
            s5 = 0;
            break;
          }
        }
        if (!s5) {
          this.m_pairs.push(En2(i2, t3, r, false));
          continue;
        }
        for (let e7 = 0, t4 = a2.length; e7 < t4; ++e7) {
          const t5 = a2[e7], r2 = new ei();
          o2.get().queryCoord2D(t5, r2);
          const i3 = n7.get().getClosestCoordinate(r2, false), h3 = new ei();
          n7.get().queryCoord2D(i3, h3);
          if (ei.distance(r2, h3) > this.parent.m_tolerance) {
            s5 = 0;
            break;
          }
        }
        if (!s5) {
          this.m_pairs.push(En2(i2, t3, r, false));
          continue;
        }
        i2.equalEdge = t3, t3.equalEdge = i2;
        let h2 = i2.rank, m2 = t3.rank;
        h2 === m2 && (h2 *= dn2.c_maxGeometryTypeToRankDelta, m2 *= dn2.c_maxGeometryTypeToRankDelta, h2 += Sn2(n7.get().getGeometryType(), n7.get(), true), m2 += Sn2(o2.get().getGeometryType(), o2.get(), true)), h2 > m2 || h2 === m2 && i2.segmentParentage <= t3.segmentParentage ? (n7.copyTo(o2, false), t3.segmentParentage = i2.segmentParentage, -1 === s5 && o2.get().reverse()) : (o2.copyTo(n7, false), i2.segmentParentage = t3.segmentParentage, -1 === s5 && n7.get().reverse());
        break;
      }
    }
    this.updateAttachedEdgesAfterNodeChange(e5.start), t2 && this.updateAttachedEdgesAfterNodeChange(t2.start), this.updateAttachedEdgesAfterNodeChange(s4.start), n6 && this.updateAttachedEdgesAfterNodeChange(n6.start);
  }
  processDoublyConnectedEdges(e5, t2, s4, n6) {
    s4 === ms() && b("curve_helper");
    const r = this.getSegment(e5).get(), i2 = this.getSegment(t2).get(), o2 = r.getStartXY().equals(i2.getStartXY()) && r.getEndXY().equals(i2.getEndXY()) ? 1 : r.getEndXY().equals(i2.getStartXY()) && r.getStartXY().equals(i2.getEndXY()) ? -1 : 0;
    if (0 !== o2) {
      const a2 = new nu();
      r.queryCut(0, 0.5, a2), a2.get().snapControlPoints(n6 * n6);
      const h2 = new nu();
      r.queryCut(0.5, 1, h2), h2.get().snapControlPoints(n6 * n6), this.splitEdgeInPlace(e5), e5.end.pt = a2.get().getEndXY(), e5.segmentIndex = this.parent.allocResultSegmentFromBuffer(a2), e5.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2);
      let m2 = i2.getClosestCoordinate(e5.end.pt, false);
      return Math.abs(m2 - 0.5) > 0.2 && (m2 = 0.5), i2.queryCut(0, m2, a2), a2.get().snapControlPoints(n6 * n6), i2.queryCut(m2, 1, h2), h2.get().snapControlPoints(n6 * n6), this.splitEdgeInPlace(t2), t2.end.pt = a2.get().getEndXY(), t2.segmentIndex = this.parent.allocResultSegmentFromBuffer(a2), t2.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2), o2 > 0 ? (this.m_pairs.push(En2(e5, t2, s4, false)), this.m_pairs.push(En2(e5.getNextInChain(), t2.getNextInChain(), s4, false))) : (this.m_pairs.push(En2(e5, t2.getNextInChain(), s4, false)), this.m_pairs.push(En2(e5.getNextInChain(), t2, s4, false))), true;
    }
    return false;
  }
  newNode(e5, t2, s4, n6) {
    const r = new Pn2();
    return this.m_newNodes.push(r), r.pt = e5, r.rank = s4, r.weight = t2, r.bIsBreak = n6, r;
  }
  newEdge(e5, t2, s4, n6, r, i2) {
    const o2 = new yn2();
    return o2.start = e5, o2.end = t2, e5.nextInChain = o2, t2.prevInChain = o2, o2.segmentIndex = s4, o2.segmentParentage = i2, o2.rank = r, o2.weight = n6, o2;
  }
  splitEdgeInPlace(e5) {
    e5.segmentIndex = -1;
    const t2 = new yn2(), s4 = new Pn2();
    this.m_newNodes.push(s4), s4.pt.setNAN(), s4.nextInChain = t2, s4.prevInChain = e5, s4.prevInHash = null, s4.nextInHash = null, s4.prevEqual = null, s4.nextEqual = null, s4.weight = e5.weight, s4.rank = e5.rank, s4.bIsBreak = false, s4.bBigMove = false, t2.start = s4, t2.segmentIndex = -1, t2.end = e5.end, t2.end.prevInChain = t2, t2.rank = e5.rank, t2.weight = e5.weight, t2.segmentParentage = e5.segmentParentage, e5.end = s4, e5.equalEdge && (e5.equalEdge.equalEdge = null), e5.equalEdge = null;
  }
  updateSegmentOnly(e5, t2) {
    e5.segmentIndex = t2;
  }
  updateAttachedEdgesAfterNodeChange(e5) {
    for (let t2 = e5.equalListHead(); null !== t2; t2 = t2.nextEqual) this.updateAttachedEdgesAfterNodeChangeImpl(t2);
  }
  updateAttachedEdgesAfterNodeChangeImpl(e5) {
    const t2 = e5.prevInChain;
    if (t2 && t2.hasSegment()) {
      const s5 = this.getSegment(t2).get();
      e5.pt.equals(s5.getEndXY()) || (s5.setCoordsForIntersector(t2.start.pt, t2.end.pt, false), s5.ensureXYMonotone());
    }
    const s4 = e5.nextInChain;
    if (s4 && s4.hasSegment()) {
      const t3 = this.getSegment(s4).get();
      e5.pt.equals(t3.getStartXY()) || (t3.setCoordsForIntersector(s4.start.pt, s4.end.pt, false), t3.ensureXYMonotone());
    }
  }
  updateSegmentToNodes(e5) {
    const t2 = this.getSegment(e5).get();
    e5.start.pt.equals(t2.getStartXY()) && e5.end.pt.equals(t2.getEndXY()) || (t2.setCoordsForIntersector(e5.start.pt, e5.end.pt, false), t2.ensureXYMonotone()), this.updateAttachedEdgesAfterNodeChange(e5.start), this.updateAttachedEdgesAfterNodeChange(e5.end);
  }
  getSegment(e5) {
    return this.parent.m_resultSegments[e5.segmentIndex];
  }
  clusterNodes(e5) {
    let t2 = false;
    const s4 = [], n6 = [], r = [];
    for (let i2 = 0, o2 = this.m_newNodes.length; i2 < o2; i2++) {
      const e6 = this.m_newNodes[i2];
      if (null === e6) continue;
      let t3 = e6;
      for (let s5 = i2 + 1; s5 < o2; s5++) {
        const n7 = this.m_newNodes[s5];
        null !== n7 && (e6.pt.equals(n7.pt) && (t3.nextInHash = n7, n7.prevInHash = t3, t3 = n7, this.m_newNodes[s5] = null));
      }
    }
    for (let i2 = 0, o2 = this.m_newNodes.length; i2 < o2; i2++) {
      const o3 = this.m_newNodes[i2];
      if (null == o3) continue;
      for (o3.hash = this.calculateHash(o3.pt); ; ) {
        const i3 = Ft(4), a3 = this.hashTableBinsToCheck(o3, i3);
        for (let t3 = 0; t3 < a3; t3++) if (null !== i3[t3]) for (let a4 = i3[t3]; null !== a4; ) {
          const t4 = a4.nextInHash;
          ei.distance(o3.pt, a4.pt) <= e5 && (s4.push(a4), this.removeNodeFromHash(a4), a4.hash = 0, r.push(a4), n6.push(a4)), a4 = t4;
        }
        let h3 = false;
        for (const e6 of s4) if (!o3.pt.equals(e6.pt)) {
          const s5 = mn2(o3.pt, e6.pt, o3.weight, o3.rank, e6.weight, e6.rank);
          o3.pt.assign(s5.pt), o3.weight = s5.weight, o3.rank = s5.rank, h3 = true, t2 = true;
        }
        if (s4.length = 0, !h3) break;
        o3.hash = this.calculateHash(o3.pt);
      }
      r.push(o3), n6.push(o3);
      for (let e6 = o3.nextInHash; null !== e6; ) {
        e6.prevInHash = null;
        const t3 = e6.nextInHash;
        e6.nextInHash = null, r.push(e6), n6.push(e6), e6 = t3;
      }
      const a2 = o3.hash;
      let h2 = null, m2 = null;
      for (const e6 of n6) o3 !== e6 && (e6.hash = a2, e6.pt.assign(o3.pt), e6.rank = o3.rank, e6.weight = o3.weight), e6.prevInHash = h2, h2 && (h2.nextInHash = e6), e6.prevEqual = m2, e6.nextEqual = null, m2 && (m2.nextEqual = e6), m2 = e6, h2 = e6;
      const l2 = a2 % this.m_hashTableOfEquals.length;
      h2.nextInHash = this.m_hashTableOfEquals[l2], null !== this.m_hashTableOfEquals[l2] && (this.m_hashTableOfEquals[l2].prevInHash = h2), this.m_hashTableOfEquals[l2] = n6[0], this.m_hashTableOfEqualsSize += n6.length, n6.length = 0, this.rehashIfNeeded();
    }
    if (this.m_newNodes.length = 0, t2) for (const i2 of r) this.updateAttachedEdgesAfterNodeChange(i2);
  }
  rehashIfNeeded() {
    if (2 * this.m_hashTableOfEqualsSize > this.m_hashTableOfEquals.length) {
      const e5 = this.m_hashTableOfEquals;
      this.m_hashTableOfEquals = Ft(2 * e5.length), this.m_hashTableOfEqualsSize = 0;
      for (const t2 of e5) {
        let e6 = t2;
        for (; e6; ) {
          const t3 = e6.nextInHash;
          e6.nextInHash = null, e6.prevInHash = null, this.addNodeToHashImpl(e6), e6 = t3;
        }
      }
    }
  }
  addNodeToHashImpl(e5) {
    const t2 = e5.hash % this.m_hashTableOfEquals.length, s4 = this.m_hashTableOfEquals[t2];
    e5.nextInHash = s4, null !== s4 && (s4.prevInHash = e5), this.m_hashTableOfEquals[t2] = e5, this.m_hashTableOfEqualsSize++;
  }
  removeNodeFromHash(e5) {
    const t2 = e5.hash % this.m_hashTableOfEquals.length, s4 = e5.prevInHash, n6 = e5.nextInHash;
    s4 ? s4.nextInHash = n6 : this.m_hashTableOfEquals[t2] = n6, n6 && (n6.prevInHash = s4), this.m_hashTableOfEqualsSize--, e5.prevInHash = null, e5.nextInHash = null;
  }
  hashTableBinsToCheck(e5, t2) {
    const s4 = (e5.pt.x - this.m_origin.x) / this.m_cell.x, n6 = (e5.pt.y - this.m_origin.y) / this.m_cell.y, r = ls() - 1, i2 = Math.round(ks(s4, -2147483646, r)), o2 = Math.round(ks(n6, -2147483646, r));
    let a2 = i2 | o2 << 32;
    a2 = ws(a2), t2[0] = this.m_hashTableOfEquals[a2 % this.m_hashTableOfEquals.length];
    let h2 = i2 + 1 | o2 << 32;
    h2 = ws(h2);
    let m2 = 1;
    t2[1] = this.m_hashTableOfEquals[h2 % this.m_hashTableOfEquals.length], t2[1] !== t2[0] && (m2 = 2);
    let l2 = i2 + 1 | o2 + 1 << 32;
    l2 = ws(l2), t2[m2] = this.m_hashTableOfEquals[l2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m2; u++) if (t2[m2] === t2[u]) {
      m2--;
      break;
    }
    m2++;
    let g2 = i2 | o2 + 1 << 32;
    g2 = ws(g2), t2[m2] = this.m_hashTableOfEquals[g2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m2; u++) if (t2[m2] === t2[u]) {
      m2--;
      break;
    }
    return m2++, m2;
  }
  calculateHash(e5) {
    const t2 = (e5.x - this.m_origin.x) / this.m_cell.x, s4 = (e5.y - this.m_origin.y) / this.m_cell.y, n6 = ls() - 1;
    let r = Math.round(ks(t2, -2147483646, n6)) | Math.round(ks(s4, -2147483646, n6)) << 32;
    return r = ws(r), 0 === r && (r = 1), r;
  }
  processSharpCorners(e5, t2, s4, n6) {
    if (this.parent.m_param1.length = 0, this.parent.m_param2.length = 0, e5.getStartXY().equals(t2.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o2 = $m(e5, t2, 0, 0, s4, 2, r, i2, n6);
      if (o2) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(0);
        for (let e6 = 0; e6 < o2; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return o2 + 1;
      }
    }
    if (e5.getEndXY().equals(t2.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o2 = $m(e5, t2, 1, 1, s4, 2, r, i2, n6);
      if (o2) {
        for (let e6 = 0; e6 < o2; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(1), o2 + 1;
      }
    }
    if (e5.getStartXY().equals(t2.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o2 = $m(e5, t2, 0, 1, s4, 2, r, i2, n6);
      if (o2) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(1);
        for (let e6 = 0; e6 < o2; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return o2 + 1;
      }
    }
    if (e5.getEndXY().equals(t2.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o2 = $m(e5, t2, 1, 0, s4, 2, r, i2, n6);
      if (o2) {
        for (let e6 = 0; e6 < o2; e6++) this.parent.m_param1.push(r[e6]), this.parent.m_param2.push(i2[e6]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(0), o2 + 1;
      }
    }
    return 0;
  }
};
function Sn2(e5, t2, s4) {
  let n6 = 0;
  switch (e5) {
    case a.enumLine:
      n6 = 0;
      break;
    case a.enumBezier:
      n6 = 2;
      break;
    case a.enumRationalBezier2:
      n6 = 3;
      break;
    case a.enumBezier2:
      n6 = 1;
      break;
    case a.enumEllipticArc:
      n6 = 0 === t2.projectionBehavior() ? 5 : 4;
      break;
    default:
      b("");
  }
  return s4 ? 5 - n6 : n6;
}
var In2 = class extends sn2 {
  constructor(e5) {
    super(e5.m_shape, e5.m_tolerance, false), this.m_parent = e5;
  }
  compare(e5, t2, s4) {
    if (this.m_bIntersectionDetected) return -1;
    const n6 = e5.getElement(s4), r = this.m_parent.getEdgeOriginVertices(t2), i2 = this.m_parent.m_edgeVertices.getFirstElement(r), o2 = this.m_parent.getEdgeOriginVertices(n6), a2 = this.m_parent.m_edgeVertices.getFirstElement(o2);
    return this.m_currentNode = s4, this.compareSegments(t2, i2, n6, a2);
  }
};
var bn2 = class extends nn2 {
  constructor(e5) {
    super(e5.m_shape, e5.m_tolerance), this.m_parent = e5;
  }
  compare(e5, t2) {
    if (this.m_bIntersectionDetected) return -1;
    const s4 = e5.getElement(t2), n6 = this.m_parent.getEdgeOriginVertices(s4), r = this.m_parent.m_edgeVertices.getFirstElement(n6);
    return this.m_currentNode = t2, this.compareVertex(e5, t2, r);
  }
};
var wn2 = class extends dt {
  constructor(e5) {
    super(), this.pt1 = ei.getNAN(), this.pt2 = ei.getNAN(), this.m_shape = e5;
  }
  compare(e5, t2, s4) {
    this.m_shape.queryXY(t2, this.pt1);
    const n6 = e5.getElement(s4);
    return this.m_shape.queryXY(n6, this.pt2), this.pt1.compare(this.pt2);
  }
};
var vn2 = class {
  constructor(e5) {
    this.m_point = ei.getNAN(), this.m_pt = ei.getNAN(), this.m_shape = e5;
  }
  setPoint(e5) {
    this.m_point.setCoordsPoint2D(e5);
  }
  compare(e5, t2) {
    const s4 = e5.getElement(t2);
    return this.m_shape.queryXY(s4, this.m_pt), this.m_point.compare(this.m_pt);
  }
};
var Nn2 = class {
  constructor(e5, t2) {
    this.m_shape = null, this.m_progressTracker = null, this.m_edges = new at(8), this.m_clusters = new at(5), this.m_clusterVertices = new $s2(false), this.m_edgeVertices = new $s2(false), this.m_helperPoint = new ee(), this.m_eventQ = new ct2(), this.m_sweepStructure = new ct2(), this.m_bComplications = false, this.m_sweepComparator = null, this.m_tempEdgeBuffer = [], this.m_modifiedClusters = [], this.m_edgesToInsertInSweepStructure = [], this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false, this.m_progressCounter = 0, this.m_segmentIntersector = new dn2(), this.m_segBuf1 = new nu(), this.m_segBuf2 = new nu(), this.m_sweepPoint = new ei(0, 0), this.m_tolerance = 0, this.m_toleranceSqr = 0, this.m_sweepPointCluster = -1, this.m_vertexClusterIndex = -1, this.m_bCracked = false, this.m_bSweepPointClusterWasModified = false, this.m_progressTracker = e5, this.m_bTrackChanges = t2;
  }
  hadComplications() {
    return this.m_bComplications;
  }
  sweep(e5, t2) {
    const s4 = new x3();
    s4.setSwapCoordinates(), e5.applyTransformation(s4), this.setEditShape_(e5), this.m_bCracked = false, this.m_tolerance = t2, this.m_toleranceSqr = t2 * t2;
    let n6 = this.sweepImpl_();
    return e5.applyTransformation(s4), n6 || (this.fillEventQueuePass2(), n6 = this.sweepImpl_() || n6), this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_shape = null, this.m_bCracked;
  }
  sweepVertical(e5, t2) {
    this.setEditShape_(e5), this.m_bCracked = false, this.m_tolerance = t2, this.m_toleranceSqr = t2 * t2, this.m_bComplications = false;
    let s4 = this.sweepImpl_();
    if (!this.m_bComplications) {
      const n6 = e5.filterClosePoints(t2, true, false, this.m_bTrackChanges, bm);
      this.m_bComplications = 1 === n6, s4 || (s4 = 1 === n6);
    }
    return -1 !== this.m_vertexClusterIndex && (this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_vertexClusterIndex = -1), this.m_shape = null, s4;
  }
  getEdgeCluster(e5, t2) {
    return this.m_edges.getField(e5, 0 + t2);
  }
  setEdgeCluster_(e5, t2, s4) {
    this.m_edges.setField(e5, 0 + t2, s4);
  }
  getEdgeOriginVertices(e5) {
    return this.m_edges.getField(e5, 2);
  }
  setEdgeOriginVertices_(e5, t2) {
    this.m_edges.setField(e5, 2, t2);
  }
  getNextEdgeEx(e5, t2) {
    return this.m_edges.getField(e5, 3 + t2);
  }
  setNextEdgeEx_(e5, t2, s4) {
    this.m_edges.setField(e5, 3 + t2, s4);
  }
  getEdgeSweepNode(e5) {
    return this.m_edges.getField(e5, 7);
  }
  setEdgeSweepNode_(e5, t2) {
    this.m_edges.setField(e5, 7, t2);
  }
  getNextEdge(e5, t2) {
    const s4 = this.getEdgeEnd(e5, t2);
    return this.m_edges.getField(e5, 3 + s4);
  }
  setNextEdge_(e5, t2, s4) {
    const n6 = this.getEdgeEnd(e5, t2);
    this.m_edges.setField(e5, 3 + n6, s4);
  }
  getPrevEdge(e5, t2) {
    const s4 = this.getEdgeEnd(e5, t2);
    return this.m_edges.getField(e5, 5 + s4);
  }
  setPrevEdge_(e5, t2, s4) {
    const n6 = this.getEdgeEnd(e5, t2);
    this.m_edges.setField(e5, 5 + n6, s4);
  }
  getClusterVertices(e5) {
    return this.m_clusters.getField(e5, 0);
  }
  setClusterVertices_(e5, t2) {
    this.m_clusters.setField(e5, 0, t2);
  }
  getClusterSweepEdgeList(e5) {
    return this.m_clusters.getField(e5, 2);
  }
  setClusterSweepEdgeList_(e5, t2) {
    this.m_clusters.setField(e5, 2, t2);
  }
  getClusterFirstEdge(e5) {
    return this.m_clusters.getField(e5, 1);
  }
  setClusterFirstEdge_(e5, t2) {
    this.m_clusters.setField(e5, 1, t2);
  }
  getClusterEventQNode(e5) {
    return this.m_clusters.getField(e5, 3);
  }
  setClusterEventQNode_(e5, t2) {
    this.m_clusters.setField(e5, 3, t2);
  }
  newCluster_(e5) {
    const t2 = this.m_clusters.newElement(), s4 = this.m_clusterVertices.createList();
    return this.setClusterVertices_(t2, s4), e5 !== bm && (this.m_clusterVertices.addElement(s4, e5), this.m_shape.setUserIndex(e5, this.m_vertexClusterIndex, t2)), t2;
  }
  deleteCluster_(e5) {
    this.m_clusters.deleteElement(e5);
  }
  addVertexToCluster_(e5, t2) {
    const s4 = this.getClusterVertices(e5);
    this.m_clusterVertices.addElement(s4, t2), this.m_shape.setUserIndex(t2, this.m_vertexClusterIndex, e5);
  }
  newEdge_(e5) {
    const t2 = this.m_edges.newElement(), s4 = this.m_edgeVertices.createList();
    return this.setEdgeOriginVertices_(t2, s4), -1 !== e5 && this.m_edgeVertices.addElement(s4, e5), t2;
  }
  addVertexToEdge_(e5, t2) {
    const s4 = this.getEdgeOriginVertices(e5);
    this.m_edgeVertices.addElement(s4, t2);
  }
  deleteEdge_(e5) {
    this.m_edges.deleteElement(e5);
    const t2 = this.m_edgesToInsertInSweepStructure.findIndex((t3) => t3 === e5);
    t2 >= 0 && qt(this.m_edgesToInsertInSweepStructure, t2);
  }
  addEdgeToCluster(e5, t2) {
    -1 === this.getEdgeCluster(e5, 0) ? this.setEdgeCluster_(e5, 0, t2) : -1 === this.getEdgeCluster(e5, 1) ? this.setEdgeCluster_(e5, 1, t2) : b(""), this.addEdgeToClusterImpl_(e5, t2);
  }
  addEdgeToClusterImpl_(e5, t2) {
    const s4 = this.getClusterFirstEdge(t2);
    if (-1 !== s4) {
      const n6 = this.getNextEdge(s4, t2);
      this.setPrevEdge_(n6, t2, e5), this.setNextEdge_(e5, t2, n6), this.setNextEdge_(s4, t2, e5), this.setPrevEdge_(e5, t2, s4);
    } else this.setPrevEdge_(e5, t2, e5), this.setNextEdge_(e5, t2, e5), this.setClusterFirstEdge_(t2, e5);
  }
  getEdgeEnd(e5, t2) {
    return this.getEdgeCluster(e5, 0) === t2 ? 0 : 1;
  }
  mergeClusters_(e5, t2) {
    this.dbgCheckCluster_(e5), this.dbgCheckCluster_(t2);
    const s4 = this.getClusterEventQNode(t2);
    -1 !== s4 && (this.m_eventQ.deleteNode(s4), this.setClusterEventQNode_(t2, -1));
    let n6 = this.getClusterFirstEdge(e5), r = this.getClusterFirstEdge(t2);
    if (-1 !== r) {
      let s5 = r, i3 = r, o3 = false;
      do {
        this.dbgCheckEdge_(s5), o3 = false;
        const n7 = this.getEdgeEnd(s5, t2), a2 = this.getNextEdgeEx(s5, n7);
        if (this.getEdgeCluster(s5, n7 + 1 & 1) === e5) {
          this.disconnectEdge_(s5);
          const e6 = this.getEdgeOriginVertices(s5);
          if (this.m_edgeVertices.deleteList(e6), this.deleteEdge_(s5), s5 === a2) {
            r = -1;
            break;
          }
          r === s5 && (r = this.getClusterFirstEdge(t2), i3 = a2, o3 = true);
        }
        s5 = a2;
      } while (s5 !== i3 || o3);
      if (-1 !== r) {
        do {
          const n7 = this.getEdgeEnd(s5, t2), r2 = this.getNextEdgeEx(s5, n7);
          this.setEdgeCluster_(s5, n7, e5), s5 = r2;
        } while (s5 !== i3);
        if (n6 = this.getClusterFirstEdge(e5), -1 !== n6) {
          const t3 = this.getNextEdge(n6, e5), s6 = this.getNextEdge(r, e5);
          t3 === n6 ? (this.setClusterFirstEdge_(e5, r), this.addEdgeToClusterImpl_(n6, e5), this.setClusterFirstEdge_(e5, n6)) : s6 === r && this.addEdgeToClusterImpl_(r, e5), this.setNextEdge_(r, e5, t3), this.setPrevEdge_(t3, e5, r), this.setNextEdge_(n6, e5, s6), this.setPrevEdge_(s6, e5, n6);
        } else this.setClusterFirstEdge_(e5, r);
      }
    }
    const i2 = this.getClusterVertices(e5), o2 = this.getClusterVertices(t2);
    for (let a2 = this.m_clusterVertices.getFirst(o2); -1 !== a2; a2 = this.m_clusterVertices.getNext(a2)) {
      const t3 = this.m_clusterVertices.getElement(a2);
      this.m_shape.setUserIndex(t3, this.m_vertexClusterIndex, e5);
    }
    this.m_clusterVertices.concatenateLists(i2, o2), this.deleteCluster_(t2), this.dbgCheckCluster_(e5);
  }
  mergeEdges_(e5, t2) {
    this.dbgCheckEdge_(e5), this.dbgCheckEdge_(t2);
    const s4 = this.getEdgeCluster(e5, 0), n6 = this.getEdgeCluster(e5, 1), r = this.getEdgeCluster(t2, 0), i2 = this.getEdgeCluster(t2, 1), o2 = this.getEdgeOriginVertices(e5), a2 = this.getEdgeOriginVertices(t2);
    if (this.m_edgeVertices.concatenateLists(o2, a2), t2 === this.getClusterFirstEdge(s4) && this.setClusterFirstEdge_(s4, e5), t2 === this.getClusterFirstEdge(n6) && this.setClusterFirstEdge_(n6, e5), this.disconnectEdge_(t2), this.deleteEdge_(t2), !(s4 === r && n6 === i2 || n6 === r && s4 === i2)) {
      const e6 = this.getClusterXY(s4), t3 = this.getClusterXY(r);
      e6.isEqualPoint2D(t3) ? (s4 !== r && this.mergeClusters_(s4, r), n6 !== i2 && this.mergeClusters_(n6, i2)) : (n6 !== r && this.mergeClusters_(n6, r), s4 !== i2 && this.mergeClusters_(s4, i2));
    }
    this.dbgCheckEdge_(e5);
  }
  disconnectEdge_(e5) {
    const t2 = this.getEdgeCluster(e5, 0), s4 = this.getEdgeCluster(e5, 1);
    this.disconnectEdgeFromCluster_(e5, t2), this.disconnectEdgeFromCluster_(e5, s4);
  }
  disconnectEdgeFromCluster_(e5, t2) {
    const s4 = this.getNextEdge(e5, t2), n6 = this.getPrevEdge(e5, t2), r = this.getClusterFirstEdge(t2);
    s4 !== e5 ? (this.setNextEdge_(n6, t2, s4), this.setPrevEdge_(s4, t2, n6), r === e5 && this.setClusterFirstEdge_(t2, s4)) : this.setClusterFirstEdge_(t2, -1);
  }
  applyIntersectorToEditShape_(e5, t2, s4) {
    let n6 = this.m_edgeVertices.getFirst(e5);
    const r = this.m_edgeVertices.getElement(n6), i2 = this.getClusterFromVertex(r), o2 = this.m_shape.getNextVertex(r), a2 = this.getClusterFromVertex(o2), h2 = this.m_shape.getXY(r), m2 = this.m_shape.getXY(o2);
    let l2 = false, g2 = false;
    const u = t2.getResultSegment(s4, 0).getStartXY(), c = t2.getResultSegment(s4, t2.getResultSegmentCount(s4) - 1).getEndXY();
    h2.equals(u) || (l2 = true), m2.equals(c) || (g2 = true), this.m_shape.splitSegmentWithIntersector(r, t2, s4, true, true);
    const _ = this.m_bTrackChanges && t2.getSegmentChanged(s4);
    for (_ && this.m_shape.setGeometryModifiedWithVertex(r, true), n6 = this.m_edgeVertices.getNext(n6); -1 !== n6; n6 = this.m_edgeVertices.getNext(n6)) {
      const e6 = this.m_edgeVertices.getElement(n6), r2 = this.getClusterFromVertex(e6) === i2;
      this.m_shape.splitSegmentWithIntersector(e6, t2, s4, r2, true), _ && this.m_shape.setGeometryModifiedWithVertex(e6, true);
    }
    if (l2 && this.updateClusterXY(true, i2, u, t2.getResultSegmentStartPointWeight(s4, 0), t2.getResultSegmentStartPointRank(s4, 0)), g2) {
      const e6 = t2.getResultSegmentCount(s4) - 1;
      this.updateClusterXY(true, a2, c, t2.getResultSegmentEndPointWeight(s4, e6), t2.getResultSegmentEndPointRank(s4, e6));
    }
  }
  createEdgesAndClustersFromSplitEdge_(e5, t2, s4) {
    this.dbgCheckNewEdgesArray_();
    const n6 = this.getEdgeOriginVertices(e5), r = this.getEdgeCluster(e5, 0), i2 = this.getEdgeCluster(e5, 1);
    let o2 = this.newEdge_(-1);
    this.m_edgesToInsertInSweepStructure.push(o2);
    const a2 = at.impossibleIndex3();
    this.setEdgeSweepNode_(o2, a2), this.m_tempEdgeBuffer.push(o2), this.addEdgeToCluster(o2, r);
    const h2 = t2.getResultSegmentCount(s4);
    for (let m2 = 1; m2 < h2; m2++) {
      const e6 = this.newCluster_(-1);
      this.m_modifiedClusters.push(e6), this.m_tempEdgeBuffer.push(e6), this.addEdgeToCluster(o2, e6);
      const t3 = this.newEdge_(-1);
      this.m_edgesToInsertInSweepStructure.push(t3), this.setEdgeSweepNode_(t3, a2), this.m_tempEdgeBuffer.push(t3), this.addEdgeToCluster(t3, e6), o2 = t3;
    }
    this.addEdgeToCluster(o2, i2);
    for (let m2 = this.m_edgeVertices.getFirst(n6); -1 !== m2; m2 = this.m_edgeVertices.getNext(m2)) {
      let e6 = this.m_edgeVertices.getElement(m2);
      if (this.getClusterFromVertex(e6) === r) {
        let t3 = 0;
        const s5 = this.m_tempEdgeBuffer.length;
        do {
          if (t3 > 0) {
            const s7 = this.m_tempEdgeBuffer[t3 - 1];
            this.addVertexToCluster_(s7, e6);
          }
          const s6 = this.m_tempEdgeBuffer[t3];
          t3 += 2, this.addVertexToEdge_(s6, e6), e6 = this.m_shape.getNextVertex(e6);
        } while (t3 < s5);
      } else {
        let t3 = this.m_tempEdgeBuffer.length - 1;
        do {
          if (t3 < this.m_tempEdgeBuffer.length - 2) {
            const s6 = this.m_tempEdgeBuffer[t3 + 1];
            this.addVertexToCluster_(s6, e6);
          }
          const s5 = this.m_tempEdgeBuffer[t3];
          t3 -= 2, this.addVertexToEdge_(s5, e6), e6 = this.m_shape.getNextVertex(e6);
        } while (t3 >= 0);
      }
    }
    this.m_tempEdgeBuffer.length = 0, this.dbgCheckNewEdgesArray_();
  }
  getVertexFromClusterIndex(e5) {
    const t2 = this.getClusterVertices(e5);
    return this.m_clusterVertices.getFirstElement(t2);
  }
  getClusterFromVertex(e5) {
    return this.m_shape.getUserIndex(e5, this.m_vertexClusterIndex);
  }
  processSplitHelper1_(e5, t2, s4) {
    const n6 = this.getEdgeCluster(t2, 0), r = this.getClusterXY(n6), i2 = this.getEdgeCluster(t2, 1), o2 = this.getClusterXY(i2), a2 = s4.getResultSegmentCount(e5);
    let h2 = s4.getResultSegment(e5, 0);
    const m2 = h2.getStartXY();
    if (!r.isEqualPoint2D(m2)) {
      if (!this.m_bComplications) {
        r.compare(this.m_sweepPoint) * m2.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(n6, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(n6);
    }
    if (!this.m_bComplications && a2 > 1) {
      const e6 = r.compare(o2), t3 = h2.getEndXY();
      (r.compare(t3) !== e6 || t3.compare(o2) !== e6 || t3.compare(this.m_sweepPoint) < 0) && (this.m_bComplications = true);
    }
    h2 = s4.getResultSegment(e5, a2 - 1);
    const l2 = h2.getEndXY();
    if (!o2.isEqualPoint2D(l2)) {
      if (!this.m_bComplications) {
        o2.compare(this.m_sweepPoint) * l2.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(i2, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(i2);
    }
    this.m_tempEdgeBuffer.push(t2);
    for (let g2 = 0, u = this.m_tempEdgeBuffer.length; g2 < u; g2++) {
      const e6 = this.m_tempEdgeBuffer[g2], s5 = this.getEdgeSweepNode(e6);
      at.isValidElement(s5) && (this.m_sweepStructure.deleteNode(s5), this.setEdgeSweepNode_(e6, -1));
      const n7 = at.impossibleIndex3();
      e6 !== t2 && this.getEdgeSweepNode(e6) !== n7 && (this.m_edgesToInsertInSweepStructure.push(e6), this.setEdgeSweepNode_(e6, n7));
    }
    this.m_tempEdgeBuffer.length = 0;
  }
  checkAndFixIntersection_(e5, t2) {
    const s4 = this.m_sweepStructure.getElement(e5);
    return this.m_sweepComparator.compare(this.m_sweepStructure, s4, t2), !!this.m_sweepComparator.intersectionDetected() && (this.m_sweepComparator.clearIntersectionDetectedFlag(), this.fixIntersection_(e5, t2), true);
  }
  fixIntersection_(e5, t2) {
    this.m_bCracked = true;
    const n6 = this.m_sweepStructure.getElement(e5), r = this.m_sweepStructure.getElement(t2);
    let i2 = null, o2 = null;
    const a2 = this.getEdgeOriginVertices(n6), h2 = this.m_edgeVertices.getFirstElement(a2), m2 = this.getEdgeOriginVertices(r), l2 = this.m_edgeVertices.getFirstElement(m2), g2 = this.m_shape.querySegment(h2, this.m_segBuf1, false, false);
    n2(g2), i2 = this.m_segBuf1.get();
    const u = this.m_shape.getNextVertex(h2), c = this.m_shape.getWeight(h2), _ = this.m_shape.getSegmentParentageBreakVertex(h2), d2 = this.m_shape.getWeight(u), p3 = this.m_shape.getSegmentParentageBreakVertex(u), f3 = this.m_shape.getSegmentWeight(h2), x4 = this.m_shape.getRank(h2), y2 = this.m_shape.getRank(u), P5 = this.m_shape.getSegmentRank(h2), E2 = this.m_shape.getSegmentParentage(h2), C2 = this.m_shape.querySegment(l2, this.m_segBuf2, false, false);
    n2(C2), o2 = this.m_segBuf2.get();
    const S3 = this.m_shape.getNextVertex(l2), I5 = this.m_shape.getWeight(l2), b2 = this.m_shape.getSegmentParentageBreakVertex(l2), w4 = this.m_shape.getWeight(S3), v3 = this.m_shape.getSegmentParentageBreakVertex(S3), N2 = this.m_shape.getSegmentWeight(l2), T3 = this.m_shape.getRank(l2), G4 = this.m_shape.getRank(S3), D3 = this.m_shape.getSegmentRank(l2), V4 = this.m_shape.getSegmentParentage(l2);
    this.m_segmentIntersector.pushSegment(i2, c, x4, d2, y2, f3, P5, _, p3, E2), this.m_segmentIntersector.pushSegment(o2, I5, T3, w4, G4, N2, D3, b2, v3, V4), 3 === this.m_segmentIntersector.intersect2D(this.m_tolerance, true) && (this.m_bComplications = true), this.splitEdge_(n6, r, -1, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  fixIntersectionPointSegment_(e5, t2) {
    this.m_bCracked = true;
    const n6 = this.m_sweepStructure.getElement(t2);
    let r = null;
    const i2 = this.getEdgeOriginVertices(n6), o2 = this.m_edgeVertices.getFirstElement(i2), a2 = this.m_shape.querySegment(o2, this.m_segBuf1, false, false);
    n2(a2), r = this.m_segBuf1.get();
    const h2 = this.m_shape.getNextVertex(o2), m2 = this.m_shape.getWeight(o2), l2 = this.m_shape.getSegmentParentageBreakVertex(o2), g2 = this.m_shape.getWeight(h2), u = this.m_shape.getSegmentParentageBreakVertex(h2), c = this.m_shape.getSegmentWeight(o2), _ = this.m_shape.getRank(o2), d2 = this.m_shape.getRank(h2), p3 = this.m_shape.getSegmentRank(o2), f3 = this.m_shape.getSegmentParentage(o2), x4 = this.getClusterFirstVertex(e5);
    this.m_segmentIntersector.pushSegment(r, m2, _, g2, d2, c, p3, l2, u, f3), this.m_shape.queryPoint(x4, this.m_helperPoint);
    const y2 = this.m_shape.getWeight(x4), P5 = this.m_shape.getRank(x4);
    this.m_segmentIntersector.intersect2DEx(this.m_tolerance, this.m_helperPoint, P5, y2, true), this.splitEdge_(n6, -1, e5, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  insertNewEdges_() {
    if (0 === this.m_edgesToInsertInSweepStructure.length) return true;
    this.dbgCheckNewEdgesArray_();
    let e5 = true, t2 = 0;
    const s4 = this.m_edgesToInsertInSweepStructure.length, n6 = Math.max(2 * s4 + 200, this.m_sweepStructure.size() + 200);
    for (; this.m_edgesToInsertInSweepStructure.length; ) {
      if (this.m_edgesToInsertInSweepStructure.length > Math.max(100, this.m_shape.getTotalPointCount()) || t2 > n6) {
        this.m_edgesToInsertInSweepStructure.length = 0, this.m_bComplications = true, e5 = false;
        break;
      }
      const s5 = this.m_edgesToInsertInSweepStructure.at(-1);
      this.m_edgesToInsertInSweepStructure.pop(), this.setEdgeSweepNode_(s5, -1);
      const r = this.isEdgeOnSweepLine_(s5);
      at.isValidElement(r) ? (this.insertNewEdgeToSweepStructure_(s5, r), t2++) : r !== at.impossibleIndex2() && (e5 = false), this.m_bContinuingSegmentChainOptimization = false;
    }
    return e5;
  }
  insertNewEdgeToSweepStructure_(e5, t2) {
    let s4;
    if (this.m_bContinuingSegmentChainOptimization ? (s4 = this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour, this.m_nextNeighbour, e5, true, true), this.m_bContinuingSegmentChainOptimization = false) : s4 = this.m_sweepStructure.addUniqueElement(e5), -1 === s4) {
      const t3 = this.m_sweepStructure.getDuplicateElement(), s5 = this.m_sweepStructure.getElement(t3);
      return this.mergeEdges_(s5, e5), false;
    }
    if (this.setEdgeSweepNode_(e5, s4), this.m_sweepComparator.intersectionDetected()) {
      this.m_sweepComparator.clearIntersectionDetectedFlag();
      const e6 = this.m_sweepComparator.getLastComparedNode();
      return this.m_prevNeighbour === e6 && (this.m_prevNeighbour = -1), this.m_nextNeighbour === e6 && (this.m_nextNeighbour = -1), this.fixIntersection_(e6, s4), true;
    }
    return false;
  }
  isEdgeOnSweepLine_(e5) {
    const t2 = this.getEdgeCluster(e5, 0), s4 = this.getEdgeCluster(e5, 1), n6 = this.getClusterXY(t2), r = this.getClusterXY(s4);
    if (ei.sqrDistance(n6, r) <= this.m_toleranceSqr) return this.m_bComplications = true, -1;
    const i2 = n6.compare(this.m_sweepPoint), o2 = r.compare(this.m_sweepPoint);
    return i2 <= 0 && o2 > 0 ? s4 : o2 <= 0 && i2 > 0 ? t2 : i2 > 0 && o2 > 0 ? at.impossibleIndex2() : -1;
  }
  fillEventQueue() {
    const e5 = new st2(0), t2 = this.m_shape.queryVertexIteratorOnSelection();
    for (let r = t2.next(); r !== bm; r = t2.next()) -1 !== this.m_shape.getUserIndex(r, this.m_vertexClusterIndex) && e5.add(r);
    this.m_shape.sortVerticesSimpleByY(e5, 0, e5.size()), this.progress_(true), this.m_eventQ.clear(), this.m_eventQ.setCapacity(e5.size()), this.m_eventQ.setComparator(new wn2(this.m_shape));
    const s4 = ei.getNAN();
    s4.setNAN();
    let n6 = -1;
    for (let r = 0, i2 = e5.size(); r < i2; r++) {
      const t3 = e5.read(r);
      if (this.m_shape.getXY(t3).isEqualPoint2D(s4)) {
        const e6 = this.m_shape.getUserIndex(t3, this.m_vertexClusterIndex);
        this.mergeClusters_(n6, e6);
        continue;
      }
      n6 = this.getClusterFromVertex(t3), this.m_shape.queryXY(t3, s4);
      const i3 = this.m_eventQ.addBiggestElement(t3);
      this.setClusterEventQNode_(n6, i3);
    }
  }
  fillEventQueuePass2() {
    const e5 = new st2(0);
    for (let t2 = this.m_eventQ.getFirst(); -1 !== t2; t2 = this.m_eventQ.getNext(t2)) {
      const s4 = this.m_eventQ.getElement(t2);
      e5.add(s4);
    }
    this.m_eventQ.clear(), this.m_shape.sortVerticesSimpleByY(e5, 0, e5.size()), this.progress_(true);
    for (let t2 = 0, s4 = e5.size(); t2 < s4; t2++) {
      const s5 = e5.read(t2), n6 = this.getClusterFromVertex(s5), r = this.m_eventQ.addBiggestElement(s5);
      this.setClusterEventQNode_(n6, r);
    }
  }
  getAffectedEdges(e5, t2) {
    const s4 = this.getClusterFirstEdge(e5);
    if (-1 === s4) return;
    let n6 = s4;
    do {
      const s5 = this.getEdgeSweepNode(n6);
      at.isValidElement(s5) && t2.push(n6), n6 = this.getNextEdge(n6, e5);
    } while (n6 !== s4);
  }
  updateClusterXY(e5, t2, s4, n6, r) {
    const i2 = this.getClusterVertices(t2);
    for (let o2 = this.m_clusterVertices.getFirst(i2); -1 !== o2; o2 = this.m_clusterVertices.getNext(o2)) {
      const t3 = this.m_clusterVertices.getElement(o2);
      this.m_shape.setXYMonotonicPoint2D(t3, s4), this.m_shape.setWeight(t3, n6), this.m_shape.setRank(t3, r), e5 && this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(t3, true), this.m_shape.setSegmentParentageBreakVertex(t3, true);
    }
  }
  splitEdge_(e5, t2, s4, n6) {
    this.dbgCheckEdge_(e5), -1 !== t2 && this.dbgCheckEdge_(t2), this.disconnectEdge_(e5), -1 !== t2 && this.disconnectEdge_(t2), this.processSplitHelper1_(0, e5, n6), -1 !== t2 && this.processSplitHelper1_(1, t2, n6), -1 !== s4 && n6.getResultPointChanged() && this.m_modifiedClusters.push(s4);
    for (let o2 = 0, a2 = this.m_modifiedClusters.length; o2 < a2; o2++) {
      const e6 = this.m_modifiedClusters[o2], t3 = this.getClusterEventQNode(e6);
      -1 !== t3 && (this.m_eventQ.deleteNode(t3), this.setClusterEventQNode_(e6, -1));
    }
    const r = this.getEdgeOriginVertices(e5), i2 = -1 !== t2 ? this.getEdgeOriginVertices(t2) : -1;
    if (this.applyIntersectorToEditShape_(r, n6, 0), -1 !== i2) this.applyIntersectorToEditShape_(i2, n6, 1);
    else {
      const e6 = n6.getResultPoint().getXY();
      this.updateClusterXY(n6.getResultPointChanged(), s4, e6, n6.getResultPointWeight(), n6.getResultPointRank());
    }
    this.createEdgesAndClustersFromSplitEdge_(e5, n6, 0), -1 !== t2 && this.createEdgesAndClustersFromSplitEdge_(t2, n6, 1), this.m_edgeVertices.deleteList(r), this.deleteEdge_(e5), -1 !== t2 && (this.m_edgeVertices.deleteList(i2), this.deleteEdge_(t2));
    for (let o2 = 0, a2 = this.m_modifiedClusters.length; o2 < a2; o2++) {
      const e6 = this.m_modifiedClusters[o2];
      e6 === this.m_sweepPointCluster && (this.m_bSweepPointClusterWasModified = true);
      let t3 = this.getClusterEventQNode(e6);
      if (-1 === t3) {
        const s5 = this.getClusterFirstVertex(e6);
        if (t3 = this.m_eventQ.addUniqueElement(s5), -1 === t3) {
          const t4 = this.m_eventQ.getDuplicateElement(), s6 = this.m_eventQ.getElement(t4), n7 = this.getClusterFromVertex(s6);
          this.mergeClusters_(n7, e6);
        } else this.setClusterEventQNode_(e6, t3);
      }
    }
    this.m_modifiedClusters.length = 0;
  }
  getClusterXY(e5) {
    const t2 = this.getClusterFirstVertex(e5);
    return this.m_shape.getXY(t2);
  }
  getClusterFirstVertex(e5) {
    const t2 = this.getClusterVertices(e5);
    return this.m_clusterVertices.getFirstElement(t2);
  }
  dbgCheckEdge_(e5) {
  }
  dbgCheckCluster_(e5) {
  }
  dbgCheckNewEdgesArray_() {
  }
  dbgSaveSweepStructure_(e5) {
  }
  sweepImpl_() {
    this.progress_(true), this.m_bSweepPointClusterWasModified = false, this.m_sweepPointCluster = -1, null === this.m_sweepComparator && (this.m_sweepStructure.disableBalancing(), this.m_sweepComparator = new In2(this), this.m_sweepStructure.setComparator(this.m_sweepComparator));
    const e5 = [];
    let t2 = null, s4 = null;
    this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false;
    const n6 = at.impossibleIndex2(), r = at.impossibleIndex3();
    for (let i2 = this.m_eventQ.getFirst(); -1 !== i2; ) {
      this.progress_(), this.dbgCheckSweepStructure_(), this.m_bContinuingSegmentChainOptimization = false, this.m_prevNeighbour = -1, this.m_nextNeighbour = -1;
      const o2 = this.m_eventQ.getElement(i2);
      this.m_sweepPointCluster = this.getClusterFromVertex(o2), this.m_shape.queryXY(o2, this.m_sweepPoint), this.m_sweepComparator.setSweepY(this.m_sweepPoint.y, this.m_sweepPoint.x);
      let a2 = false;
      {
        const t3 = this.getClusterFirstEdge(this.m_sweepPointCluster);
        if (a2 = -1 === t3, !a2) {
          let s5 = t3;
          do {
            const t4 = this.getEdgeSweepNode(s5);
            -1 === t4 ? (this.m_edgesToInsertInSweepStructure.push(s5), this.setEdgeSweepNode_(s5, r)) : t4 !== r && e5.push(t4), s5 = this.getNextEdge(s5, this.m_sweepPointCluster);
          } while (s5 !== t3);
        }
      }
      if (!this.m_sweepStructure.isAutoBalancing() && (this.m_sweepStructure.getMaxDepthEver() > 4 || this.m_edgesToInsertInSweepStructure.length > 10) && this.m_sweepStructure.enableBalancing(), e5.length > 0) {
        this.m_bContinuingSegmentChainOptimization = 1 === e5.length && 1 === this.m_edgesToInsertInSweepStructure.length;
        for (let r2 = 0, i3 = e5.length; r2 < i3; r2++) {
          const t4 = this.m_sweepStructure.getElement(e5[r2]);
          this.setEdgeSweepNode_(t4, n6);
        }
        let t3 = n6, s5 = n6;
        for (let r2 = 0, i3 = e5.length; r2 < i3; r2++) {
          const i4 = e5[r2];
          if (t3 === n6) {
            const e6 = this.m_sweepStructure.getPrev(i4);
            if (-1 !== e6) {
              const s6 = this.m_sweepStructure.getElement(e6);
              this.getEdgeSweepNode(s6) !== n6 && (t3 = e6);
            } else t3 = -1;
          }
          if (s5 === n6) {
            const e6 = this.m_sweepStructure.getNext(i4);
            if (-1 !== e6) {
              const t4 = this.m_sweepStructure.getElement(e6);
              this.getEdgeSweepNode(t4) !== n6 && (s5 = e6);
            } else s5 = -1;
          }
          if (t3 !== n6 && s5 !== n6) break;
        }
        for (let n7 = 0, r2 = e5.length; n7 < r2; n7++) {
          const t4 = e5[n7], s6 = this.m_sweepStructure.getElement(t4);
          this.m_sweepStructure.deleteNode(t4), this.setEdgeSweepNode_(s6, -1);
        }
        e5.length = 0, this.m_prevNeighbour = t3, this.m_nextNeighbour = s5, -1 !== t3 && -1 !== s5 ? this.m_bContinuingSegmentChainOptimization || this.checkAndFixIntersection_(t3, s5) : -1 === t3 && -1 === s5 && (this.m_bContinuingSegmentChainOptimization = false);
      } else a2 && (null === t2 && (t2 = new bn2(this)), t2.setPoint(this.m_sweepPoint), this.m_sweepStructure.searchUpperBound(t2), t2.intersectionDetected() && (t2.clearIntersectionDetectedFlag(), this.fixIntersectionPointSegment_(this.m_sweepPointCluster, t2.getCurrentNode())));
      const h2 = this.m_bContinuingSegmentChainOptimization;
      !this.insertNewEdges_() && h2 && -1 !== this.m_prevNeighbour && -1 !== this.m_nextNeighbour && this.checkAndFixIntersection_(this.m_prevNeighbour, this.m_nextNeighbour), this.m_bSweepPointClusterWasModified ? (this.m_bSweepPointClusterWasModified = false, null === s4 && (s4 = new vn2(this.m_shape)), s4.setPoint(this.m_sweepPoint), i2 = this.m_eventQ.searchUpperBound(s4)) : i2 = this.m_eventQ.getNext(i2);
    }
    return this.m_bCracked;
  }
  setEditShape_(e5) {
    this.m_shape = e5, this.m_vertexClusterIndex = this.m_shape.createUserIndex(), this.m_edges.setCapacity(e5.getSelectedCount() + 32), this.m_clusters.setCapacity(e5.getSelectedCount()), this.m_clusterVertices.reserveLists(e5.getSelectedCount()), this.m_clusterVertices.reserveNodes(e5.getSelectedCount()), this.m_edgeVertices.reserveLists(e5.getSelectedCount() + 32), this.m_edgeVertices.reserveNodes(e5.getSelectedCount() + 32);
    for (let t2 = this.m_shape.getFirstGeometry(); t2 !== bm; t2 = this.m_shape.getNextGeometry(t2)) {
      if (h(this.m_shape.getGeometryType(t2))) for (let s4 = this.m_shape.getFirstPath(t2); s4 !== bm; s4 = this.m_shape.getNextPath(s4)) {
        const t3 = this.m_shape.getPathSize(s4), n6 = this.m_shape.getFirstVertex(s4);
        if (n6 === bm) continue;
        let r = this.m_shape.getNextVertex(n6);
        if (r === bm || r === n6) continue;
        let i2 = -1;
        e5.selected(n6) && (i2 = this.newCluster_(n6));
        let o2 = -1;
        -1 !== i2 && e5.selected(r) && (o2 = this.newEdge_(n6), this.addEdgeToCluster(o2, i2));
        let a2 = o2;
        for (let e6 = 0, s5 = t3 - 2; e6 < s5; e6++) {
          const e7 = this.m_shape.getNextVertex(r);
          let t4 = -1;
          if (this.m_shape.selected(r)) {
            const s6 = this.newCluster_(r);
            -1 !== a2 && this.addEdgeToCluster(a2, s6), this.m_shape.selected(e7) && (t4 = this.newEdge_(r), this.addEdgeToCluster(t4, s6));
          }
          a2 = t4, r = e7;
        }
        if (this.m_shape.isClosedPath(s4)) {
          const e6 = this.m_shape.getNextVertex(r);
          if (this.m_shape.selected(r)) {
            const t4 = this.newCluster_(r);
            if (-1 !== a2 && this.addEdgeToCluster(a2, t4), this.m_shape.selected(e6)) {
              const e7 = this.newEdge_(r);
              this.addEdgeToCluster(e7, t4), this.addEdgeToCluster(e7, i2);
            }
          }
        } else {
          let e6 = -1;
          this.m_shape.selected(r) && (e6 = this.newCluster_(r), -1 !== a2 && this.addEdgeToCluster(a2, e6));
        }
      }
      else for (let e6 = this.m_shape.getFirstPath(t2); e6 !== bm; e6 = this.m_shape.getNextPath(e6)) {
        let t3 = this.m_shape.getFirstVertex(e6);
        for (let s4 = 0, n6 = this.m_shape.getPathSize(e6); s4 < n6; s4++) this.m_shape.selected(t3) && this.newCluster_(t3), t3 = this.m_shape.getNextVertex(t3);
      }
    }
    this.fillEventQueue();
  }
  progress_(e5 = false) {
  }
  dbgCheckSweepStructure_() {
  }
};
function Tn2(e5, t2, s4, n6) {
  s4 > 0 && on2(e5, s4, t2, false, n6);
  new Dn2(n6).executeImpl_(e5, t2);
}
function Gn2(e5, t2, s4) {
  return { vertex0: e5, vertex1: t2, dir: s4 };
}
var Dn2 = class {
  constructor(e5) {
    this.m_shape = null, this.m_spikes = [], this.m_points = new st2(0), this.m_pointsIndex = -1, this.m_dissolvedEdges = 0, this.m_progressTracker = e5;
  }
  executeImpl_(e5, t2) {
    if (this.m_shape = e5, e5.getPathCount(t2) < 2 && e5.getPointCount(t2) < 6) return;
    this.m_points.resize(0);
    for (let s4 = e5.getFirstPath(t2); s4 !== bm; s4 = e5.getNextPath(s4)) {
      let t3 = e5.getFirstVertex(s4);
      for (let n7 = 0, r2 = e5.getPathSize(s4); n7 < r2; n7++, t3 = e5.getNextVertex(t3)) this.m_points.add(t3);
    }
    this.m_pointsIndex = e5.createUserIndex();
    for (let s4 = 0, g2 = this.m_points.size(); s4 < g2; ++s4) e5.setUserIndex(this.m_points.read(s4), this.m_pointsIndex, s4);
    e5.sortVerticesSimpleByY(this.m_points, 0, this.m_points.size());
    let n6 = this.m_points.read(0);
    const r = e5.getXY(n6);
    let i2 = 1, o2 = 0;
    const a2 = [];
    for (let s4 = 1; s4 < this.m_points.size(); s4++) {
      const t3 = this.m_points.read(s4);
      if (t3 === bm) continue;
      if (-1 === e5.getUserIndex(t3, this.m_pointsIndex)) continue;
      const h3 = e5.getXY(t3);
      if (h3.isEqualPoint2D(r)) i2++;
      else {
        if (i2 > 1) {
          for (let t4 = o2; t4 < s4; t4++) {
            const s5 = this.m_points.read(t4);
            if (-1 === e5.getUserIndex(s5, this.m_pointsIndex)) continue;
            const n7 = e5.getNextVertex(s5), i3 = e5.getPrevVertex(s5);
            if (s5 !== n7 && !e5.isEqualXYPoint2D(n7, r)) {
              const e6 = Gn2(s5, n7, 1);
              a2.push(e6);
            }
            if (s5 !== i3 && i3 !== n7 && !e5.isEqualXYPoint2D(i3, r)) {
              const e6 = Gn2(s5, i3, -1);
              a2.push(e6);
            }
          }
          a2.length > 0 && this.processBunch_(a2, r);
        }
        n6 = t3, r.assign(h3), i2 = 1, o2 = s4;
      }
    }
    if (0 === this.m_dissolvedEdges) return e5.removeUserIndex(this.m_pointsIndex), void (this.m_pointsIndex = -1);
    let h2 = e5.getPointCount(t2);
    for (let s4 = 0; s4 < this.m_points.size(); s4++) {
      const t3 = this.m_points.read(s4);
      if (t3 === bm) continue;
      if (-1 !== e5.getUserIndex(t3, this.m_pointsIndex)) {
        e5.setUserIndex(t3, this.m_pointsIndex, -1);
        continue;
      }
      const n7 = e5.getPathFromVertex(t3);
      e5.getFirstVertex(n7) === t3 && e5.setFirstVertex(n7, bm), e5.freeVertex(t3), this.m_points.write(s4, bm), h2--;
    }
    const m2 = e5.createPathUserIndex();
    let l2 = e5.getPathCount(t2);
    for (let g2 = 0, u = this.m_points.size(); g2 < u; ++g2) {
      if (this.m_points.read(g2) === bm) continue;
      let n7 = this.m_points.read(g2);
      if (-1 !== e5.getUserIndex(n7, this.m_pointsIndex)) continue;
      let r2 = e5.getPathFromVertex(n7), i3 = -1;
      if (2 === e5.getPathUserIndex(r2, m2)) {
        r2 = bm;
        for (let t3 = e5.getNextVertex(n7); t3 !== n7; t3 = e5.getNextVertex(t3)) {
          const s4 = e5.getPathFromVertex(t3);
          if (2 !== e5.getPathUserIndex(s4, m2)) {
            r2 = s4, n7 = t3;
            break;
          }
        }
        r2 === bm && (r2 = e5.insertPath(t2, bm), e5.setClosedPath(r2, true), l2++), n2(r2 !== bm);
      }
      e5.setPathUserIndex(r2, m2, 2), i3 = e5.getFirstVertex(r2);
      let o3 = 0, a3 = false, h3 = n7;
      do {
        i3 === h3 && (a3 = true), e5.setUserIndex(h3, this.m_pointsIndex, 1);
        const t3 = e5.getPathFromVertex(h3);
        t3 !== r2 && (2 !== e5.getPathUserIndex(t3, m2) && (e5.setPathUserIndex(t3, m2, 1), e5.setFirstVertex(t3, bm)), e5.setPathToVertex(h3, r2)), o3++, h3 = e5.getNextVertex(h3);
      } while (h3 !== n7);
      a3 || e5.setFirstVertex(r2, n7), e5.setPathSize(r2, o3);
    }
    for (let s4 = e5.getFirstPath(t2); s4 !== bm; ) {
      const t3 = e5.getNextPath(s4);
      1 !== e5.getPathUserIndex(s4, m2) && e5.getFirstVertex(s4) !== bm || (e5.removePathOnly(s4), l2--), s4 = t3;
    }
    e5.setGeometryVertexCount(t2, h2), e5.setGeometryPathCount(t2, l2), e5.removePathUserIndex(m2), e5.removeUserIndex(this.m_pointsIndex), this.m_pointsIndex = -1, e5.dbgVerifyVertexCounts(), e5.filterClosePoints(0, true, false, false, t2);
  }
  processBunch_(e5, t2) {
    e5.sort((e6, s5) => {
      const n7 = this.m_shape.getXY(e6.vertex1).sub(t2), r2 = this.m_shape.getXY(s5.vertex1).sub(t2), i3 = ei.compareVectors(n7, r2);
      return 0 === i3 ? e6.dir < s5.dir ? -1 : 1 : i3;
    });
    let s4 = 0;
    const n6 = this.m_shape.getXY(e5[0].vertex1);
    let r = 1;
    const i2 = this.m_shape.hasCurves();
    for (let o2 = 1, a2 = e5.length; o2 < a2; o2++) {
      const t3 = this.m_shape.getXY(e5[o2].vertex1);
      if (!(t3.isEqualPoint2D(n6) && (r++, o2 + 1 < a2))) {
        if (2 === r) {
          const t4 = e5[s4], n7 = e5[s4 + 1], r2 = t4.dir;
          if (r2 !== n7.dir) {
            let e6 = true;
            if (i2 && (e6 = !this.m_shape.isCurve(1 === t4.dir ? t4.vertex0 : t4.vertex1) && !this.m_shape.isCurve(1 === n7.dir ? n7.vertex0 : n7.vertex1)), e6) {
              if (1 === r2) {
                const e7 = t4.vertex0, s5 = n7.vertex0;
                this.m_shape.setNextVertex(e7, s5), this.m_shape.setPrevVertex(s5, e7), this.m_shape.getPrevVertex(e7) === s5 && (this.m_shape.setUserIndex(e7, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s5, this.m_pointsIndex, -1));
                const r3 = t4.vertex1, i3 = n7.vertex1;
                this.m_shape.setPrevVertex(r3, i3), this.m_shape.setNextVertex(i3, r3), this.m_shape.getNextVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              } else {
                const e7 = t4.vertex0, s5 = n7.vertex0;
                this.m_shape.setPrevVertex(e7, s5), this.m_shape.setNextVertex(s5, e7), this.m_shape.getNextVertex(e7) === s5 && (this.m_shape.setUserIndex(e7, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s5, this.m_pointsIndex, -1));
                const r3 = t4.vertex1, i3 = n7.vertex1;
                this.m_shape.setNextVertex(r3, i3), this.m_shape.setPrevVertex(i3, r3), this.m_shape.getPrevVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              }
              this.m_dissolvedEdges += 2;
            }
          }
        }
        n6.assign(t3), s4 = o2, r = 1;
      }
    }
    e5.length = 0;
  }
};
function Vn2(e5) {
  for (let t2 = e5.getFirstGeometry(); t2 !== bm; t2 = e5.getNextGeometry(t2)) if (h(e5.getGeometryType(t2))) return true;
  return false;
}
function Fn2(e5, t2, s4, n6) {
  if (!Vn2(e5)) return false;
  const r = new Mn2(n6);
  r.m_shape = e5, r.m_tolerance = t2, r.m_bTrackChanges = s4;
  let i2 = false;
  const o2 = e5.hasCurves() ? 5 : 15;
  return i2 = e5.getTotalPointCount() < o2 ? r.crackBruteForce_() : r.crackerPlaneSweep_(), i2;
}
function Hn2(e5, t2, s4, n6, r) {
  if (!Vn2(t2)) return false;
  let i2 = new Mn2(r);
  if (i2.m_shape = t2, i2.m_tolerance = s4, i2.m_bAllowCoincident = e5, i2.m_bNeedsNonSimpleResult = null !== n6, i2.needsCrackingImpl_()) return n6 && n6.assign(i2.m_nonSimpleResult), true;
  const o2 = new x3();
  o2.setSwapCoordinates(), t2.applyTransformation(o2), i2 = new Mn2(r), i2.m_shape = t2, i2.m_tolerance = s4, i2.m_bAllowCoincident = e5, i2.m_bNeedsNonSimpleResult = null !== n6;
  const a2 = i2.needsCrackingImpl_();
  return t2.applyTransformation(o2), !!a2 && (n6 && n6.assign(i2.m_nonSimpleResult), true);
}
function kn2(e5, t2, s4, n6) {
  const r = t2.getGeometryType();
  if (h(r)) {
    return new Mn2(n6).crackAWithBMultiPath_(e5, t2, s4);
  }
  z("crack_A_with_B");
}
function An2(e5, t2) {
  return { t: e5, index: t2 };
}
var Mn2 = class _Mn {
  crackBruteForce_() {
    let e5 = this.crackBruteForceImpl_();
    if (!e5 && this.m_shape.hasCurves()) {
      const t2 = new x3();
      t2.setSwapCoordinates(), this.m_shape.applyTransformation(t2), e5 = this.crackBruteForceImpl_(), this.m_shape.applyTransformation(t2);
    }
    return e5;
  }
  crackBruteForceImpl_() {
    let t2 = false;
    const n6 = new nu(), r = new nu(), o2 = n4.constructEmpty(), a2 = n4.constructEmpty(), h2 = false, m2 = new ee(), l2 = new dn2(), g2 = this.m_shape.getTotalPointCount(), u = g2 * g2 * 2, c = this.m_shape.queryVertexIteratorOnSelection();
    for (let e5 = c.next(); e5 !== bm; e5 = c.next()) {
      const g3 = this.m_shape.getGeometryType(c.currentGeometry());
      let _ = 1, d2 = 1, p3 = 1, f3 = 0, x4 = 0, y2 = 0;
      const P5 = this.m_shape.getSegmentParentage(e5);
      let E2 = false, C2 = false, S3 = null, I5 = false;
      if (l(g3)) _ = this.m_shape.getWeight(e5), f3 = this.m_shape.getRank(e5);
      else {
        if (S3 = this.getSegment_(e5, n6), null === S3) continue;
        const t3 = this.m_shape.getVertexIndex(e5);
        _ = this.m_shape.getWeightWithIndex(t3), f3 = this.m_shape.getRankWithIndex(t3), p3 = this.m_shape.getSegmentWeightWithIndex(t3), y2 = this.m_shape.getSegmentRankWithIndex(t3), E2 = this.m_shape.getSegmentParentageBreakVertex(e5);
        {
          const t4 = this.m_shape.getNextVertex(e5);
          d2 = this.m_shape.getWeight(t4), x4 = this.m_shape.getRank(t4), C2 = this.m_shape.getSegmentParentageBreakVertex(t4);
        }
        if (S3.queryLooseEnvelope(o2), o2.inflateCoords(this.m_tolerance, this.m_tolerance), S3.isDegenerate(this.m_tolerance)) {
          if (!S3.isDegenerate(0)) continue;
          I5 = true, S3 = null;
        }
      }
      const b2 = new wm({ copy: c });
      let w4 = b2.next();
      w4 !== bm && (w4 = b2.next());
      let v3 = 0;
      for (; w4 !== bm; w4 = b2.next()) {
        if (0 !== v3) {
          v3--;
          continue;
        }
        if (this.m_shape.getTotalPointCount() > u) return t2;
        this.progress_();
        const g4 = this.m_shape.getGeometryType(b2.currentGeometry());
        let N2 = null, T3 = false, G4 = 0, D3 = 0, F3 = 0, H3 = 0, k4 = 0, A4 = 0, M2 = false, U4 = false;
        const q2 = this.m_shape.getSegmentParentage(w4);
        if (l(g4)) G4 = this.m_shape.getWeight(w4), H3 = this.m_shape.getRank(w4);
        else {
          if (N2 = this.getSegment_(w4, r), null === N2) continue;
          const e6 = this.m_shape.getVertexIndex(w4);
          G4 = this.m_shape.getWeightWithIndex(e6), H3 = this.m_shape.getRankWithIndex(e6), F3 = this.m_shape.getSegmentWeightWithIndex(e6), A4 = this.m_shape.getSegmentRankWithIndex(e6), M2 = this.m_shape.getSegmentParentageBreakVertex(w4);
          {
            const e7 = this.m_shape.getNextVertex(w4);
            D3 = this.m_shape.getWeight(e7), k4 = this.m_shape.getRank(e7), U4 = this.m_shape.getSegmentParentageBreakVertex(e7);
          }
          if (N2.queryLooseEnvelope(a2), N2.isDegenerate(this.m_tolerance)) {
            if (!N2.isDegenerate(0)) continue;
            T3 = true, N2 = null;
          }
        }
        let O3 = 0, B4 = 0;
        if (null !== S3 && null !== N2) {
          if (o2.isIntersectingNe(a2)) {
            0 !== Zm(true, true, S3, N2, this.m_tolerance, true) && (l2.pushSegment(S3, _, f3, d2, x4, p3, y2, E2, C2, P5), l2.pushSegment(N2, G4, H3, D3, k4, F3, A4, M2, U4, q2), l2.intersect2D(this.m_tolerance, true), t2 || (t2 = l2.getSegmentChanged(0) || l2.getSegmentChanged(1)), O3 = l2.getResultSegmentCount(0), B4 = l2.getResultSegmentCount(1), O3 + B4 > 0 && (this.m_shape.splitSegmentWithIntersector(e5, l2, 0, true, true), this.m_shape.splitSegmentWithIntersector(w4, l2, 1, true, true), this.m_bTrackChanges && (l2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(e5, true), l2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true))), B4 > 1 && (v3 += B4 - 1), l2.clear());
          }
        } else if (null !== S3) {
          const s4 = this.m_shape.getXY(w4);
          if (o2.contains(s4)) {
            if (l2.pushSegment(S3, _, f3, d2, x4, p3, y2, E2, C2, P5), this.m_shape.queryPoint(w4, m2), l2.intersect2DEx(this.m_tolerance, m2, H3, G4, h2), t2 || (t2 = l2.getSegmentChanged(0) || l2.getResultPointChanged()), O3 = l2.getResultSegmentCount(0), O3 > 0) if (this.m_bTrackChanges && (l2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(e5, true), l2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true)), this.m_shape.splitSegmentWithIntersector(e5, l2, 0, true, true), T3) {
              let e6 = bm;
              for (let t3 = this.m_shape.getNextVertex(w4); t3 !== bm && t3 !== w4 && (N2 = this.getSegment_(t3, r), e6 = t3, null != N2 && N2.isDegenerate(0)); t3 = this.m_shape.getNextVertex(t3)) ;
              for (let t3 = w4; t3 !== bm && (this.m_shape.setPoint(t3, l2.getResultPoint(), true), t3 !== e6); t3 = this.m_shape.getNextVertex(t3)) ;
            } else this.m_shape.setPoint(w4, l2.getResultPoint(), true);
            l2.clear();
          }
        } else {
          if (null === N2) continue;
          {
            const s4 = this.m_shape.getXY(e5);
            if (a2.inflateCoords(this.m_tolerance, this.m_tolerance), a2.contains(s4)) {
              if (l2.pushSegment(N2, G4, H3, D3, k4, F3, A4, M2, U4, q2), this.m_shape.queryPoint(e5, m2), l2.intersect2DEx(this.m_tolerance, m2, f3, _, h2), t2 || (t2 = l2.getSegmentChanged(0) || l2.getResultPointChanged()), B4 = l2.getResultSegmentCount(0), B4 > 0) if (this.m_bTrackChanges && (l2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(w4, true), l2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(e5, true)), this.m_shape.splitSegmentWithIntersector(w4, l2, 0, true, true), v3 += B4 - 1, I5) {
                let t3 = bm;
                for (let s5 = this.m_shape.getNextVertex(e5); s5 !== bm && s5 !== e5 && (N2 = this.getSegment_(s5, r), t3 = s5, null != N2 && N2.isDegenerate(0)); s5 = this.m_shape.getNextVertex(s5)) ;
                for (let s5 = e5; s5 !== bm && (this.m_shape.setPoint(s5, l2.getResultPoint(), true), s5 !== t3); s5 = this.m_shape.getNextVertex(s5)) ;
              } else this.m_shape.setPoint(e5, l2.getResultPoint(), true);
              l2.clear();
            }
          }
        }
        if (O3 + B4 !== 0 && 0 !== O3) {
          let t3 = false;
          for (; S3 = this.getSegment_(e5, n6), null != S3 && (S3.queryEnvelope(o2), S3.isDegenerate(this.m_tolerance)); ) {
            if (!(O3 > 1)) {
              t3 = true;
              break;
            }
            e5 = c.next(), O3--, n2(e5 !== bm);
          }
          if (t3) break;
        }
      }
    }
    return t2;
  }
  crackerPlaneSweep_() {
    return this.planesweep_();
  }
  planesweep_() {
    return new Nn2(this.m_progressTracker, this.m_bTrackChanges).sweep(this.m_shape, this.m_tolerance);
  }
  needsCrackingImpl_() {
    let e5 = false;
    const t2 = new st2(0);
    t2.resize(this.m_shape.getSelectedCount());
    const s4 = this.m_shape.queryVertexIteratorOnSelection();
    for (let l2 = 0, g2 = s4.next(); g2 !== bm; ++l2, g2 = s4.next()) t2.write(l2, g2);
    this.m_shape.sortVerticesSimpleByY(t2, 0, t2.size()), t2.add(bm);
    const n6 = this.m_shape.createUserIndex(), r = this.m_shape.createUserIndex();
    this.m_sweepComparator = new sn2(this.m_shape, this.m_tolerance, !this.m_bAllowCoincident), this.m_sweepStructure.setComparator(this.m_sweepComparator);
    let i2 = null;
    const o2 = [], a2 = [];
    let h2 = 0;
    const m2 = new ei();
    for (let l2 = t2.read(h2++); l2 !== bm; ) {
      this.m_shape.queryXY(l2, m2);
      let s5 = false;
      do {
        let e6 = this.m_shape.getNextVertex(l2), i3 = this.m_shape.getPrevVertex(l2);
        s5 || (s5 = e6 !== bm || i3 !== bm), e6 === bm || this.m_shape.selected(e6) || (e6 = bm), i3 === bm || this.m_shape.selected(i3) || (i3 = bm), e6 !== bm && this.m_shape.compareVerticesSimpleY(l2, e6) < 0 && (a2.push(l2), a2.push(e6)), i3 !== bm && this.m_shape.compareVerticesSimpleY(l2, i3) < 0 && (a2.push(i3), a2.push(i3));
        const m3 = this.m_shape.getUserIndex(l2, n6);
        -1 !== m3 && (o2.push(m3), this.m_shape.setUserIndex(l2, n6, -1));
        const g2 = this.m_shape.getUserIndex(l2, r);
        -1 !== g2 && (o2.push(g2), this.m_shape.setUserIndex(l2, r, -1)), l2 = t2.read(h2++);
      } while (l2 !== bm && this.m_shape.isEqualXYPoint2D(l2, m2));
      if (!s5 && (null === i2 && (i2 = new nn2(this.m_shape, this.m_tolerance)), i2.setPoint(m2), this.m_sweepStructure.searchUpperBound(i2), i2.intersectionDetected())) {
        e5 = true, this.m_bNeedsNonSimpleResult && (b("needsCrackingIMpl_"), this.m_nonSimpleResult = new es2(6, -1, -1));
        break;
      }
      let u = 1 === o2.length && 2 === a2.length;
      const c = 32;
      o2.length > c && Et(o2);
      let _ = -1, d2 = -1;
      if (!u) for (let t3 = 0, n7 = o2.length; t3 < n7; t3++) {
        const s6 = o2[t3], n8 = this.m_sweepStructure.getPrev(s6);
        if (-1 !== n8 && -1 === o2.indexOf(n8)) if (-1 === _) _ = n8;
        else {
          if (e5 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new es2(6, -1, -1);
        }
        const r2 = this.m_sweepStructure.getNext(s6);
        if (-1 !== r2 && -1 === o2.indexOf(r2)) if (-1 === d2) d2 = r2;
        else {
          if (e5 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new es2(6, -1, -1);
        }
        if (-1 !== _ && -1 !== d2) break;
      }
      if (e5 && !this.m_bNeedsNonSimpleResult) break;
      if (this.m_sweepComparator.setSweepY(m2.y, m2.x), !u) {
        for (let e6 = 0, t3 = o2.length; e6 < t3; e6++) {
          const t4 = o2[e6];
          this.m_sweepStructure.deleteNode(t4);
        }
        o2.length = 0;
      }
      if (!u && -1 !== _ && -1 !== d2 && this.checkForIntersections_(_, d2)) {
        e5 = true, this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult());
        break;
      }
      for (let t3 = 0, i3 = a2.length; t3 < i3; t3 += 2) {
        const s6 = a2[t3], i4 = a2[t3 + 1];
        let h3;
        if (u ? (h3 = this.m_sweepStructure.replaceElementAtPosition(o2[0], s6, true, true), o2.length = 0, u = false) : h3 = this.m_sweepStructure.addElement(s6), this.m_sweepComparator.intersectionDetected()) {
          this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult()), e5 = true;
          break;
        }
        -1 === this.m_shape.getUserIndex(i4, n6) ? this.m_shape.setUserIndex(i4, n6, h3) : this.m_shape.setUserIndex(i4, r, h3);
      }
      if (e5) break;
      a2.length = 0;
    }
    return this.m_shape.removeUserIndex(n6), this.m_shape.removeUserIndex(r), e5;
  }
  checkForIntersections_(e5, t2) {
    const s4 = this.m_sweepStructure.getElement(e5);
    this.m_sweepComparator.compare(this.m_sweepStructure, s4, t2);
    const n6 = this.m_sweepComparator.intersectionDetected();
    return this.m_sweepComparator.clearIntersectionDetectedFlag(), n6;
  }
  getSegment_(e5, t2) {
    return _Mn.st_getSegment(this.m_shape, e5, t2);
  }
  static st_getSegment(e5, t2, s4) {
    return e5.querySegment(t2, s4, false, false) ? s4.get() : null;
  }
  dbgPrintSweepEdge(e5) {
  }
  dbgPrintSweepStructure() {
  }
  dbgSaveSweepStructure(e5 = null) {
  }
  dbgCheckSweepStructure() {
  }
  progress_(e5 = false) {
    this.m_progressCounter++;
  }
  crackAWithBMultiPath_(t2, n6, r) {
    const i2 = n4.constructEmpty();
    t2.queryLooseEnvelope(i2);
    const a2 = n4.constructEmpty();
    if (n6.queryLooseEnvelope(a2), a2.inflateCoords(r, r), !a2.isIntersecting(i2)) return t2;
    const h2 = t2.getImpl(), m2 = h2.getAccelerators();
    let l2 = null, g2 = null;
    m2 && (g2 = m2.getQuadTree()), Un2(t2, w(n6)) && (l2 = Wt(h2, a2), g2 = l2);
    const c = g2 ? g2.getIteratorForQT() : null, _ = n6.querySegmentIterator(), d2 = t2.querySegmentIterator(), p3 = Lt(15, Number.NaN), f3 = [];
    for (; _.nextPath(); ) for (; _.hasNextSegment(); ) {
      const t3 = _.nextSegment();
      if (g2) {
        c.resetIterator(t3, r);
        for (let e5 = c.next(); -1 !== e5; e5 = c.next()) {
          this.progress_();
          const s4 = g2.getElement(e5);
          if (d2.resetToVertex(s4, -1), d2.hasNextSegment()) {
            const e6 = d2.nextSegment().intersect(t3, null, p3, null, r);
            for (let t4 = 0; t4 < e6; t4++) {
              const e7 = p3[t4];
              if (0 === e7 || 1 === e7) continue;
              const s5 = An2(e7, d2.getStartPointIndex());
              f3.push(s5);
            }
          }
        }
      } else {
        const s4 = n4.constructEmpty();
        if (t3.queryLooseEnvelope(s4), s4.inflateCoords(r, r), !i2.isIntersecting(s4)) continue;
        for (d2.resetToFirstPath(); d2.nextPath(); ) for (; d2.hasNextSegment(); ) {
          const n7 = d2.nextSegment(), i3 = n4.constructEmpty();
          if (n7.queryLooseEnvelope(i3), !i3.isIntersecting(s4)) continue;
          const o2 = n7.intersect(t3, null, p3, null, r);
          for (let e5 = 0; e5 < o2; e5++) {
            const t4 = p3[e5];
            if (0 === t4 || 1 === t4) continue;
            const s5 = An2(t4, d2.getStartPointIndex());
            f3.push(s5);
          }
        }
      }
    }
    if (0 === f3.length) return t2;
    f3.sort((e5, t3) => e5.index < t3.index ? -1 : e5.index > t3.index ? 1 : e5.t < t3.t ? -1 : e5.t > t3.t ? 1 : 0);
    const x4 = t2.createInstance();
    if (x4.getGeometryType() === a.enumPolygon) {
      x4.setFillRule(t2.getFillRule());
    }
    for (d2.resetToFirstPath(); d2.nextPath() && !d2.hasNextSegment(); ) ;
    n2(d2.hasNextSegment());
    let y2 = d2.nextSegment();
    const P5 = new nu();
    let E2 = -1;
    for (let e5 = 0, o2 = f3.length; e5 < o2; ) {
      const t3 = f3[e5].index;
      let n7 = e5 + 1;
      for (; n7 < o2 && f3[n7].index === t3; ) ++n7;
      for (; d2.getStartPointIndex() < t3; ) {
        this.progress_();
        const e6 = d2.hasNextSegment(), t4 = d2.getPathIndex();
        if ((e6 || !d2.isClosingSegment() || d2.isCurve()) && (n2(null !== y2), x4.addSegment(y2, E2 !== t4)), E2 = t4, !e6) {
          for (d2.isPathClosed(); d2.nextPath() && !d2.hasNextSegment(); ) ;
          n2(d2.hasNextSegment());
        }
        y2 = d2.nextSegment();
      }
      let r2 = 0;
      for (let o3 = e5; o3 < n7; o3++) {
        const e6 = f3[o3].t;
        if (e6 === r2) continue;
        n2(null !== y2), y2.queryCut(r2, e6, P5), r2 = e6;
        const t4 = d2.getPathIndex();
        x4.addSegment(P5.get(), E2 !== t4), E2 = t4;
      }
      const i3 = d2.hasNextSegment();
      if ((i3 || !d2.isClosingSegment() || d2.isCurve()) && (n2(null != y2), y2.queryCut(r2, 1, P5), x4.addSegment(P5.get(), false)), i3) y2 = d2.nextSegment();
      else {
        for (; d2.nextPath() && !d2.hasNextSegment(); ) ;
        y2 = d2.hasNextSegment() ? d2.nextSegment() : null;
      }
      e5 = n7;
    }
    if (null !== y2) {
      const e5 = d2.getPathIndex();
      (d2.hasNextSegment() || !d2.isClosingSegment() || d2.isCurve()) && x4.addSegment(y2, E2 !== e5), E2 = e5;
    }
    let C2 = d2.hasNextSegment();
    for (; ; ) {
      if (!C2) {
        for (; d2.nextPath() && (C2 = d2.hasNextSegment(), !C2); ) ;
        if (!C2) break;
      }
      y2 = d2.nextSegment();
      const e5 = d2.getPathIndex();
      C2 = d2.hasNextSegment();
      (C2 || !d2.isClosingSegment() || d2.isCurve()) && x4.addSegment(y2, E2 !== e5), E2 = e5;
    }
    return x4;
  }
  constructor(e5) {
    this.m_shape = null, this.m_progressTracker = null, this.m_nonSimpleResult = new es2(), this.m_tolerance = 0, this.m_sweepComparator = null, this.m_progressCounter = 0, this.m_bTrackChanges = false, this.m_bNeedsNonSimpleResult = false, this.m_bAllowCoincident = true, this.m_sweepStructure = new ct2(), this.m_progressTracker = e5;
  }
};
function Un2(e5, t2) {
  const s4 = e5.getPointCount();
  if (s4 < 16) return false;
  const n6 = 1;
  return 2 * s4 + 1 * (Math.log(s4) / Math.log(2)) * t2 < n6 * s4 * t2;
}
Mn2.s_bForceBruteForce = true;
var qn2 = class {
  constructor(e5, t2) {
    this.m_monotoneParts = Rt(nu, 16), this.m_xOrds = Lt(16, Number.NaN), this.m_inputPoint = ei.getNAN(), this.m_miny = 0, this.m_maxy = 0, this.m_windnum = 0, this.m_bAlternate = e5, this.m_tolerance = t2, this.m_toleranceSqr = t2 * t2, this.m_bTestBorder = !!t2, this.m_bBreak = false;
  }
  _DoOne(e5) {
    if (!this.m_bTestBorder && (this.m_bAlternate && this.m_inputPoint.equals(e5.getStartXY()) || this.m_inputPoint.equals(e5.getEndXY()))) return void (this.m_bBreak = true);
    if (e5.getStartY() === this.m_inputPoint.y && e5.getStartY() === e5.getEndY()) {
      if (this.m_bAlternate && !this.m_bTestBorder) {
        const t3 = Math.min(e5.getStartX(), e5.getEndX()), s5 = Math.max(e5.getStartX(), e5.getEndX());
        this.m_inputPoint.x > t3 && this.m_inputPoint.x < s5 && (this.m_bBreak = true);
      }
      return;
    }
    let t2 = false;
    const s4 = Math.max(e5.getStartX(), e5.getEndX());
    if (this.m_inputPoint.x > s4) t2 = true;
    else if (this.m_inputPoint.x >= Math.min(e5.getStartX(), e5.getEndX())) {
      const n6 = e5.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y, s4);
      t2 = !Number.isNaN(n6) && n6 <= this.m_inputPoint.x;
    }
    if (t2) {
      if (this.m_inputPoint.y === e5.getStartY()) {
        if (this.m_inputPoint.y < e5.getEndY()) return;
      } else if (this.m_inputPoint.y === e5.getEndY() && this.m_inputPoint.y < e5.getStartY()) return;
      this.m_bAlternate ? this.m_windnum ^= 1 : this.m_windnum += e5.getStartY() > e5.getEndY() ? 1 : -1;
    }
  }
  _Result() {
    return !!this.m_windnum;
  }
  testBorder(e5) {
    const t2 = e5.getClosestCoordinate(this.m_inputPoint, false), s4 = e5.getCoord2D(t2);
    return ei.sqrDistance(s4, this.m_inputPoint) <= this.m_toleranceSqr;
  }
  setInputPoint(e5) {
    this.m_inputPoint.setCoordsPoint2D(e5), this.m_miny = e5.y - this.m_tolerance, this.m_maxy = e5.y + this.m_tolerance;
  }
  processSegment(e5) {
    const t2 = e5.queryInterval(0, 1);
    if (t2.vmin > this.m_maxy || t2.vmax < this.m_miny) return false;
    if (this.m_bTestBorder && this.testBorder(e5)) return true;
    if (t2.vmin > this.m_inputPoint.y || t2.vmax < this.m_inputPoint.y) return false;
    let n6 = 0;
    if (e5.isCurve() && (0 === this.m_monotoneParts.length && (this.m_monotoneParts.length = 128), n6 = e5.getMonotonicParts(this.m_monotoneParts, true), n2(this.m_monotoneParts.length >= n6)), n6 > 0) for (let s4 = 0; s4 < n6; s4++) {
      const e6 = this.m_monotoneParts[s4].get(), t3 = x2.construct(e6.getStartY(), e6.getEndY());
      if (!(t3.vmin > this.m_inputPoint.y || t3.vmax < this.m_inputPoint.y) && (this._DoOne(e6), this.m_bBreak)) return true;
    }
    else if (this._DoOne(e5), this.m_bBreak) return true;
    return false;
  }
  result() {
    return n2(0), 2;
  }
};
function On2(t2, s4, n6, r) {
  const i2 = new n4();
  t2.queryLooseEnvelope(i2), i2.inflateCoords(r, r);
  const o2 = 0 === t2.getFillRule(), a2 = new qn2(o2, r);
  a2.setInputPoint(n6);
  const h2 = i2.clone();
  h2.xmax = n6.x + r, h2.ymin = n6.y - r, h2.ymax = n6.y + r;
  const m2 = t2.getImpl().querySegmentIterator(), l2 = s4.getIterator(h2, r);
  for (let e5 = l2.next(); -1 !== e5; e5 = l2.next()) if (m2.resetToVertex(s4.getElement(e5), -1), m2.hasNextSegment()) {
    const e6 = m2.nextSegment();
    if (a2.processSegment(e6)) return -1;
  }
  return a2._Result() ? 1 : 0;
}
function Bn2(e5, t2, s4) {
  const n6 = 0 === e5.getFillRule(), r = new qn2(n6, s4);
  r.setInputPoint(t2);
  const i2 = e5.getImpl().querySegmentIterator();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e6 = i2.nextSegment();
    if (r.processSegment(e6)) return -1;
  }
  return r._Result() ? 1 : 0;
}
function Rn2(e5, t2, s4) {
  return t2.isEmpty() ? 0 : Yn2(e5, t2.getXY(), s4);
}
function Yn2(t2, n6, r) {
  if (t2.isEmpty()) return 0;
  const i2 = n4.constructEmpty();
  if (t2.queryLooseEnvelope(i2), i2.inflateCoords(r, r), !i2.contains(n6)) return 0;
  const o2 = t2.getImpl().getAccelerators();
  if (o2) {
    o2.getRasterizedGeometry() && n2(0);
    const e5 = o2.getQuadTree();
    if (e5) return On2(t2, e5, n6, r);
  }
  return Bn2(t2, n6, r);
}
function Xn2(e5, t2) {
  const s4 = e5.getPointCount();
  if (s4 < 16) return false;
  const n6 = 1;
  return 2 * s4 + 1 * (Math.log(s4) / Math.log(2)) * t2 < n6 * s4 * t2;
}
function Ln2(e5, t2, s4, n6, r) {
  const i2 = new Kn2(r);
  return i2.m_shape = e5, i2.m_geometry = t2, i2.m_sortedVertices = s4, i2.m_bFixSelfTangency = n6, i2.fixRingOrientation_();
}
function zn2(e5, t2, s4) {
  const n6 = new Kn2(s4);
  return n6.m_shape = e5, n6.m_geometry = t2, n6.m_sortedVertices = null, n6.m_bFixSelfTangency = false, n6.fixRingOrientationForMp2sp_();
}
var Wn2 = class {
  getDirection_(e5) {
    return this.m_shape.getNextVertex(this.getEnd1(e5)) === this.getEnd2(e5);
  }
  getEnd_(e5) {
    const t2 = this.getEnd1(e5), s4 = this.getEnd2(e5);
    return this.m_shape.getNextVertex(t2) === s4 ? s4 : t2;
  }
  constructor(e5) {
    this.m_end1Nodes = [], this.m_end2Nodes = [], this.m_directions = [], this.m_shape = e5, this.m_firstFree = -1;
  }
  getSegment(e5) {
    return this.m_shape.getSegment(this.getStart(e5));
  }
  isBottomUp(e5) {
    let t2 = this.getEnd1(e5), n6 = this.getEnd2(e5);
    this.m_shape.getPrevVertex(t2) === n6 && (n6 = Mt(t2, t2 = n6));
    const r = ei.getNAN(), i2 = ei.getNAN();
    return this.m_shape.queryXY(t2, r), this.m_shape.queryXY(n6, i2), n2(!r.equals(i2)), r.y < i2.y;
  }
  getStart(e5) {
    const t2 = this.getEnd1(e5), s4 = this.getEnd2(e5);
    return this.m_shape.getNextVertex(t2) === s4 ? t2 : s4;
  }
  getEnd1(e5) {
    return this.m_end1Nodes[e5];
  }
  getEnd2(e5) {
    return this.m_end2Nodes[e5];
  }
  freeEdge(e5) {
    this.m_end1Nodes[e5] = this.m_firstFree, this.m_firstFree = e5;
  }
  newEdge(e5) {
    if (-1 !== this.m_firstFree) {
      const t3 = this.m_firstFree;
      return this.m_firstFree = this.m_end1Nodes[t3], this.m_end1Nodes[t3] = e5, this.m_end2Nodes[t3] = this.m_shape.getNextVertex(e5), t3;
    }
    const t2 = this.m_end1Nodes.length;
    return this.m_end1Nodes.push(e5), this.m_end2Nodes.push(this.m_shape.getNextVertex(e5)), t2;
  }
  getShape() {
    return this.m_shape;
  }
  getPath(e5) {
    return this.m_shape.getPathFromVertex(this.getEnd1(e5));
  }
};
var jn2 = class extends dt {
  constructor(e5) {
    super(), this.m_line1 = new su(), this.m_line2 = new su(), this.m_leftElm = -1, this.m_leftx = 0, this.m_seg1 = null, this.m_helper = e5;
  }
  compare(e5, t2, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_edges;
    let i2;
    if (this.m_leftElm === t2) i2 = this.m_leftx;
    else {
      if (this.m_seg1 = r.getSegment(t2), this.m_seg1) i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      else {
        r.getShape().queryLineConnector(r.getStart(t2), this.m_line1, true), this.m_seg1 = this.m_line1, i2 = this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      }
      this.m_leftx = i2, this.m_leftElm = t2;
    }
    let o2, a2 = r.getSegment(n6);
    if (a2) o2 = a2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    else {
      r.getShape().queryLineConnector(r.getStart(n6), this.m_line2, true), a2 = this.m_line2, o2 = this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    }
    if (i2 === o2) {
      const e6 = r.isBottomUp(t2), s5 = r.isBottomUp(n6), h2 = e6 ? this.m_seg1.getEndY() : this.m_seg1.getStartY(), m2 = s5 ? a2.getEndY() : a2.getStartY(), l2 = Math.min(h2, m2);
      let g2 = 0.5 * (l2 + this.m_helper.m_yScanline);
      g2 === this.m_helper.m_yScanline && (g2 = l2), i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(g2, 0), o2 = a2.intersectionOfYMonotonicWithAxisX(g2, 0), i2 === o2 && k("");
    }
    return i2 < o2 ? -1 : i2 > o2 ? 1 : 0;
  }
  reset() {
    this.m_leftElm = -1;
  }
};
var Zn2 = class {
  constructor(e5) {
    this.m_node = -1, this.m_index = 0, this.m_sortedVertices = e5.m_sortedVertices, this.m_sortedVerticesArray = e5.m_sortedVerticesArray, this.m_sortedVertices && (this.m_node = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()));
  }
  next() {
    if (this.m_sortedVertices) {
      const e5 = this.m_node;
      if (-1 === e5) return bm;
      const t2 = this.m_sortedVertices.getData(e5);
      return this.m_node = this.m_sortedVertices.getNext(e5), t2;
    }
    if (this.m_index < this.m_sortedVerticesArray.size()) {
      const e5 = this.m_sortedVerticesArray.read(this.m_index);
      return this.m_index++, e5;
    }
    return bm;
  }
};
var Kn2 = class {
  constructor(e5) {
    this.m_edges = null, this.m_shape = null, this.m_AET = new ct2(), this.m_yScanline = 0, this.m_geometry = bm, this.m_unknownRingOrientationCount = -1, this.m_sortedVertices = null, this.m_sortedVerticesArray = null, this.m_unknownNodes = [], this.m_node1UserIndex = -1, this.m_node2UserIndex = -1, this.m_pathOrientationIndex = -1, this.m_pathParentageIndex = -1, this.m_pathParentsIndex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_progressTracker = e5, this.m_AET.disableBalancing(), this.m_sweepComparator = new jn2(this), this.m_AET.setComparator(this.m_sweepComparator);
  }
  fixRingOrientation_() {
    const e5 = this.fixRingOrientationImplMain_();
    return -1 === this.m_pathOrientationIndex || this.fixRingOrientationImplSimplify_(), e5;
  }
  fixRingOrientationForMp2sp_() {
    return this.fixRingOrientationImplMain_(), -1 === this.m_pathOrientationIndex ? -1 : this.fixRingOrientationImplMp2sp_();
  }
  processBunchForRingOrientationTest_(e5) {
    return this.processBunchForRingOrientationTestOddEven_(e5);
  }
  processBunchForRingOrientationTestOddEven_(e5) {
    let t2 = false;
    if (this.m_edges || (this.m_edges = new Wn2(this.m_shape)), this.m_unknownNodes.length = 0, this.processBunchForRingOrientationRemoveEdges_(e5), !this.m_AET.isAutoBalancing()) {
      let t3 = 0;
      for (let s4 = 0, n6 = e5.length; s4 < n6; s4++) {
        -1 !== e5[s4] && t3++;
      }
      (t3 > 10 || this.m_AET.getMaxDepthEver() > 4) && this.m_AET.enableBalancing();
    }
    for (let s4 = 0, n6 = e5.length; s4 < n6; s4++) {
      const t3 = e5[s4];
      t3 !== bm && this.insertEdge_(t3, -1);
    }
    for (let n6 = 0; n6 < this.m_unknownNodes.length && this.m_unknownRingOrientationCount > 0; n6++) {
      const e6 = this.m_unknownNodes[n6], r = this.m_AET.getElement(e6), i2 = this.m_edges.getPath(r), o2 = this.m_shape.getPathUserIndex(i2, this.m_pathOrientationIndex);
      let a2 = bm;
      if (0 === o2) {
        let n7 = this.m_AET.getPrev(e6), r2 = e6, i3 = false;
        for (; n7 !== ct2.st_nullNode(); ) {
          const e7 = this.m_AET.getElement(n7), t3 = this.m_edges.getPath(e7);
          if (0 !== this.m_shape.getPathUserIndex(t3, this.m_pathOrientationIndex)) {
            a2 = t3;
            break;
          }
          r2 = n7, n7 = this.m_AET.getPrev(n7);
        }
        if (n7 === ct2.st_nullNode()) i3 = true, n7 = r2;
        else {
          const e7 = this.m_AET.getElement(n7);
          i3 = this.m_edges.isBottomUp(e7), n7 = this.m_AET.getNext(n7), i3 = !i3;
        }
        do {
          const e7 = this.m_AET.getElement(n7), o3 = this.m_edges.getPath(e7);
          if (0 === this.m_shape.getPathUserIndex(o3, this.m_pathOrientationIndex)) {
            if (i3 !== this.m_edges.isBottomUp(e7)) {
              const e8 = this.m_shape.getFirstVertex(o3);
              this.m_shape.reverseRingInternal(e8), this.m_shape.setLastVertex(o3, this.m_shape.getPrevVertex(e8)), t2 = true;
            }
            if (this.m_shape.setPathUserIndex(o3, this.m_pathOrientationIndex, i3 ? 3 : 2), !i3) {
              let e8 = this.m_shape.getPathUserIndex(a2, this.m_pathOrientationIndex);
              2 === e8 ? (a2 = this.m_shape.getPathUserIndex(a2, this.m_pathParentsIndex), e8 = this.m_shape.getPathUserIndex(a2, this.m_pathOrientationIndex), n2(3 === e8)) : n2(3 === e8);
              const t3 = this.m_shape.getPathUserIndex(a2, this.m_pathParentageIndex);
              this.m_shape.setPathUserIndex(a2, this.m_pathParentageIndex, o3), this.m_shape.setPathUserIndex(o3, this.m_pathParentageIndex, t3), this.m_shape.setPathUserIndex(o3, this.m_pathParentsIndex, a2);
            }
            if (this.m_unknownRingOrientationCount--, !this.m_unknownRingOrientationCount) return t2;
          }
          a2 = o3, r2 = n7, n7 = this.m_AET.getNext(n7), i3 = !i3;
        } while (r2 !== e6);
      }
    }
    return t2;
  }
  processBunchForRingOrientationRemoveEdges_(e5) {
    for (let t2 = 0, s4 = e5.length; t2 < s4; t2++) {
      const s5 = e5[t2], n6 = this.m_shape.getUserIndex(s5, this.m_node1UserIndex), r = this.m_shape.getUserIndex(s5, this.m_node2UserIndex);
      if (-1 !== n6) {
        const e6 = this.m_AET.getElement(n6);
        this.m_edges.freeEdge(e6), this.m_shape.setUserIndex(s5, this.m_node1UserIndex, -1);
      }
      if (-1 !== r) {
        const e6 = this.m_AET.getElement(r);
        this.m_edges.freeEdge(e6), this.m_shape.setUserIndex(s5, this.m_node2UserIndex, -1);
      }
      let i2 = -1;
      -1 !== n6 && -1 !== r ? (this.m_AET.deleteNode(n6), this.m_AET.deleteNode(r), e5[t2] = bm) : i2 = -1 !== n6 ? n6 : r, -1 !== i2 && (this.insertEdge_(s5, i2) || this.m_AET.deleteNode(i2), e5[t2] = bm);
    }
  }
  dbgVerifyRingOrientation_() {
  }
  insertEdge_(e5, t2) {
    const s4 = ei.getNAN(), n6 = ei.getNAN();
    this.m_shape.queryXY(e5, s4);
    const r = this.m_shape.getNextVertex(e5);
    this.m_shape.queryXY(r, n6);
    let i2 = false;
    if (s4.y < n6.y) {
      i2 = true;
      const s5 = this.m_edges.newEdge(e5);
      let n7;
      -1 === t2 ? n7 = this.m_AET.addElement(s5) : (n7 = t2, this.m_AET.setElement(n7, s5));
      -1 === this.m_shape.getUserIndex(r, this.m_node1UserIndex) ? this.m_shape.setUserIndex(r, this.m_node1UserIndex, n7) : this.m_shape.setUserIndex(r, this.m_node2UserIndex, n7);
      const o3 = this.m_shape.getPathFromVertex(e5);
      0 === this.m_shape.getPathUserIndex(o3, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n7);
    }
    const o2 = this.m_shape.getPrevVertex(e5);
    if (this.m_shape.queryXY(o2, n6), s4.y < n6.y) {
      i2 = true;
      const s5 = this.m_edges.newEdge(o2);
      let n7;
      -1 === t2 ? n7 = this.m_AET.addElement(s5) : (n7 = t2, this.m_AET.setElement(n7, s5));
      -1 === this.m_shape.getUserIndex(o2, this.m_node1UserIndex) ? this.m_shape.setUserIndex(o2, this.m_node1UserIndex, n7) : this.m_shape.setUserIndex(o2, this.m_node2UserIndex, n7);
      const r2 = this.m_shape.getPathFromVertex(e5);
      0 === this.m_shape.getPathUserIndex(r2, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n7);
    }
    return i2;
  }
  fixRingSelfTangency_() {
    const e5 = [], t2 = [];
    let n6 = -1, r = -1;
    const i2 = new ei();
    let o2 = bm, a2 = bm, h2 = -1;
    const m2 = new Zn2(this);
    for (let s4 = m2.next(); s4 !== bm; s4 = m2.next()) {
      const m3 = new ei();
      this.m_shape.queryXY(s4, m3);
      const l2 = this.m_shape.getPathFromVertex(s4);
      if (i2.equals(m3) && a2 === l2) {
        if (-1 === r && (n6 = this.m_shape.createPathUserIndex(), this.m_shape.fillPathUserIndexForGeometry(this.m_geometry, n6, -1), r = this.m_shape.createUserIndex(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, r, -1)), -1 === h2) {
          h2 = t2.length, this.m_shape.setUserIndex(o2, r, h2), t2.push(1);
          -1 === this.m_shape.getPathUserIndex(l2, n6) && (this.m_shape.setPathUserIndex(l2, n6, o2), e5.push(l2));
        }
        this.m_shape.setUserIndex(s4, r, h2), t2[t2.length - 1]++;
      } else h2 = -1, i2.assign(m3);
      o2 = s4, a2 = l2;
    }
    if (0 === e5.length) return false;
    n2(-1 !== n6);
    for (let s4 = 0, l2 = e5.length; s4 < l2; s4++) {
      const i3 = e5[s4];
      let o3 = this.m_shape.getPathUserIndex(i3, n6);
      const a3 = this.m_shape.getUserIndex(o3, r), h3 = [], m3 = [];
      h3.push(o3), m3.push(a3);
      for (let e6 = this.m_shape.getNextVertex(o3); e6 !== o3; e6 = this.m_shape.getNextVertex(e6)) {
        const s5 = e6, n7 = this.m_shape.getUserIndex(s5, r);
        if (-1 !== n7) {
          if (0 === m3.length) {
            m3.push(n7), h3.push(s5);
            continue;
          }
          if (m3.at(-1) === n7) {
            const i4 = h3.at(-1);
            this.m_shape.peelALoopIntoAPath(i4, s5), this.m_shape.setUserIndex(e6, r, -1), t2[n7]--, 1 === t2[n7] && (t2[n7] = 0, m3.pop(), h3.pop()), o3 = i4, e6 = i4;
          } else h3.push(e6), m3.push(n7);
        }
      }
    }
    return this.m_shape.removePathUserIndex(n6), this.m_shape.removeUserIndex(r), this.m_shape.dbgVerifyVertexCounts(), true;
  }
  progress_(e5 = false) {
  }
  fixRingOrientationImplMain_() {
    const e5 = { stack: [], error: void 0, hasError: false };
    try {
      let t2, s4 = false;
      const n6 = n(e5, zt(() => {
        this.m_sortedVerticesArray = null;
      }), false);
      if (null === this.m_sortedVertices) {
        const e6 = this.m_shape.getPointCount(this.m_geometry);
        t2 = new st2(0);
        for (let s5 = this.m_shape.getFirstPath(this.m_geometry); s5 !== bm; s5 = this.m_shape.getNextPath(s5)) {
          let e7 = this.m_shape.getFirstVertex(s5);
          for (let n7 = 0, r2 = this.m_shape.getPathSize(s5); n7 < r2; n7++) t2.add(e7), e7 = this.m_shape.getNextVertex(e7);
        }
        this.m_shape.sortVerticesSimpleByY(t2, 0, e6), this.progress_(true), this.m_sortedVerticesArray = t2;
      } else n6.bForget = true;
      if (this.m_bFixSelfTangency && (s4 = this.fixRingSelfTangency_()), 1 === this.m_shape.getPathCount(this.m_geometry)) {
        const e6 = this.m_shape.getFirstPath(this.m_geometry), t3 = this.m_shape.getRingArea(e6);
        if (this.m_shape.setExterior(e6, true), t3 < 0) {
          const t4 = this.m_shape.getFirstVertex(e6);
          return this.m_shape.reverseRingInternal(t4), this.m_shape.setLastVertex(e6, this.m_shape.getPrevVertex(t4)), true;
        }
        return false;
      }
      this.m_shape.dbgVerifyCurves(), this.m_pathOrientationIndex = this.m_shape.createPathUserIndex(), this.m_pathParentageIndex = this.m_shape.createPathUserIndex(), this.m_pathParentsIndex = this.m_shape.createPathUserIndex();
      for (let e6 = this.m_shape.getFirstPath(this.m_geometry); e6 !== bm; e6 = this.m_shape.getNextPath(e6)) this.m_shape.setPathUserIndex(e6, this.m_pathOrientationIndex, 0), this.m_shape.setPathUserIndex(e6, this.m_pathParentageIndex, -1), this.m_shape.setPathUserIndex(e6, this.m_pathParentsIndex, -1);
      const r = [];
      this.m_yScanline = Number.NaN;
      const i2 = ei.getNAN();
      this.m_unknownRingOrientationCount = this.m_shape.getPathCount(this.m_geometry), this.m_node1UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node1UserIndex, -1), this.m_node2UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node2UserIndex, -1);
      const o2 = new Zn2(this);
      for (let e6 = o2.next(); e6 !== bm && (this.progress_(), this.m_shape.queryXY(e6, i2), i2.y !== this.m_yScanline && r.length && (s4 = this.processBunchForRingOrientationTest_(r) || s4, this.m_sweepComparator.reset(), r.length = 0), r.push(e6), this.m_yScanline = i2.y, 0 !== this.m_unknownRingOrientationCount); e6 = o2.next()) ;
      return this.m_unknownRingOrientationCount > 0 && (s4 = this.processBunchForRingOrientationTest_(r) || s4, r.length = 0), this.m_shape.removeUserIndex(this.m_node1UserIndex), this.m_shape.removeUserIndex(this.m_node2UserIndex), this.dbgVerifyRingOrientation_(), s4;
    } catch (t2) {
      e5.error = t2, e5.hasError = true;
    } finally {
      s(e5);
    }
  }
  fixRingOrientationImplSimplify_() {
    const e5 = [];
    for (let t2 = this.m_shape.getFirstPath(this.m_geometry); t2 !== bm; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(t2, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(t2, true);
      for (let r = this.m_shape.getPathUserIndex(t2, this.m_pathParentageIndex); r !== bm; ) {
        const s5 = this.m_shape.getPathUserIndex(r, this.m_pathParentageIndex);
        e5.push(r), this.m_shape.setExterior(r, false), this.m_shape.setPathUserIndex(r, this.m_pathParentageIndex, t2), r = s5;
      }
      let s4 = t2, n6 = e5.length;
      for (let e6 = this.m_shape.getNextPath(t2); n6 > 0 && e6 !== bm; e6 = this.m_shape.getNextPath(e6), --n6) {
        if (this.m_shape.getPathUserIndex(e6, this.m_pathParentageIndex) !== t2) {
          s4 = bm;
          break;
        }
        s4 = e6;
      }
      if (0 !== n6) {
        s4 = t2;
        for (let t3 = 0, n7 = e5.length; t3 < n7; t3++) {
          const n8 = e5[t3];
          this.m_shape.setPathUserIndex(n8, this.m_pathParentageIndex, G3), this.m_shape.movePath(this.m_geometry, this.m_shape.getNextPath(s4), n8), s4 = n8;
        }
      }
      e5.length = 0, t2 = this.m_shape.getNextPath(s4);
    } else t2 = this.m_shape.getNextPath(t2);
    this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex);
  }
  fixRingOrientationImplMp2sp_() {
    const e5 = this.m_shape.createPathUserIndex();
    let t2 = 0;
    const s4 = [];
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== bm; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(n6, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(n6, true), this.m_shape.setPathUserIndex(n6, e5, t2), t2++;
      for (let e6 = this.m_shape.getPathUserIndex(n6, this.m_pathParentageIndex); e6 !== bm; ) {
        const t3 = this.m_shape.getPathUserIndex(e6, this.m_pathParentageIndex);
        s4.push(e6), this.m_shape.setExterior(e6, false), this.m_shape.setPathUserIndex(e6, this.m_pathParentageIndex, n6), e6 = t3;
      }
      let r = n6, i2 = s4.length, o2 = t2;
      for (let t3 = this.m_shape.getNextPath(n6); i2 > 0 && t3 !== bm; t3 = this.m_shape.getNextPath(t3), --i2) {
        if (this.m_shape.getPathUserIndex(t3, this.m_pathParentageIndex) !== n6) {
          r = bm;
          break;
        }
        r = t3, this.m_shape.setPathUserIndex(t3, e5, -o2), o2++;
      }
      if (0 !== i2) {
        r = n6, o2 = t2;
        for (let t3 = 0, n7 = s4.length; t3 < n7; t3++) {
          const n8 = s4[t3];
          this.m_shape.setPathUserIndex(n8, e5, -o2), o2++, this.m_shape.setPathUserIndex(n8, this.m_pathParentageIndex, G3);
        }
        r = n6;
      }
      t2 = o2, s4.length = 0, n6 = this.m_shape.getNextPath(r);
    } else n6 = this.m_shape.getNextPath(n6);
    return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex), e5;
  }
};
function Qn2(e5, t2, s4, n6, r, i2) {
  const o2 = new Jn2(i2);
  return o2.m_shape = e5, o2.m_geometry = t2, o2.m_knownSimpleResult = s4, o2.m_bFixSelfTangency = n6, o2.m_polylineDegeneracies = r, o2.m_bHasSegmentParentage = e5.hasSegmentParentage(), o2.m_bHasSegments = e5.hasCurves(), o2.simplify_();
}
var Jn2 = class {
  constructor(e5) {
    this.m_shape = null, this.m_geometry = bm, this.m_sortedVertices = new pt2(), this.m_bunchEdgeEndPoints = [], this.m_bunchEdgeCenterPoints = [], this.m_bunchEdgeIndices = [], this.m_knownSimpleResult = -1, this.m_sortedVerticesListIndex = -1, this.m_polylineDegeneracies = bm, this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_bHasSegmentParentage = false, this.m_bHasSegments = false, this.m_progressTracker = e5;
  }
  compareAngles_(e5, t2) {
    if (this.m_bHasSegments) return this.compareAnglesCurves_(e5, t2);
    const s4 = this.m_bunchEdgeEndPoints[e5], n6 = new ei();
    this.m_shape.queryXY(s4, n6);
    const r = new ei(), i2 = this.m_bunchEdgeEndPoints[t2];
    if (this.m_shape.queryXY(i2, r), n6.equals(r)) return 0;
    const o2 = this.m_bunchEdgeCenterPoints[e5], a2 = new ei();
    this.m_shape.queryXY(o2, a2);
    const h2 = this.m_bunchEdgeCenterPoints[t2], m2 = new ei();
    this.m_shape.queryXY(h2, m2);
    const l2 = new ei();
    l2.setSub(n6, a2);
    const g2 = new ei();
    g2.setSub(r, m2), (l2.isZero() || g2.isZero()) && k("");
    return ei.compareVectors(l2, g2);
  }
  compareAnglesCurves_(e5, t2) {
    const s4 = this.m_bunchEdgeEndPoints[e5], n6 = this.m_bunchEdgeEndPoints[t2], r = this.m_bunchEdgeCenterPoints[e5], i2 = this.m_bunchEdgeCenterPoints[t2], o2 = this.m_shape.getNextVertex(r) === s4, a2 = this.m_shape.getNextVertex(i2) === n6, h2 = new nu(), m2 = new ei();
    o2 ? (this.m_shape.querySegment(r, h2, false, true), m2.assign(h2.get().getTangent(0))) : (this.m_shape.querySegment(s4, h2, false, true), m2.assign(h2.get().getTangent(1)), m2.negateThis());
    const l2 = new ei();
    a2 ? (this.m_shape.querySegment(i2, h2, false, true), l2.assign(h2.get().getTangent(0))) : (this.m_shape.querySegment(n6, h2, false, true), l2.assign(h2.get().getTangent(1)), l2.negateThis()), (m2.isZero() || l2.isZero()) && k("");
    return ei.compareVectors(m2, l2);
  }
  beforeRemoveVertex_(e5, t2) {
    const s4 = this.m_shape.getUserIndex(e5, this.m_userIndexSortedIndexToVertex);
    if (this.m_nextVertexToProcess === s4 && (this.m_nextVertexToProcess = this.m_sortedVertices.getNext(this.m_nextVertexToProcess)), this.m_firstCoincidentVertex === s4 && (this.m_firstCoincidentVertex = this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)), this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex, s4), this.removeAngleSortInfo_(e5), t2) {
      const t3 = this.m_shape.getPathFromVertex(e5);
      if (t3 !== bm) {
        if (this.m_shape.getFirstVertex(t3) === e5) {
          const s5 = this.m_shape.getNextVertex(e5);
          if (s5 !== e5) {
            if (this.m_shape.getPathFromVertex(s5) === t3) return void this.m_shape.setFirstVertex(t3, s5);
            {
              const s6 = this.m_shape.getPrevVertex(e5);
              if (s6 !== e5) {
                if (this.m_shape.getPathFromVertex(s6) === t3) return void this.m_shape.setFirstVertex(t3, s6);
              }
            }
          }
          this.m_shape.setFirstVertex(t3, bm), this.m_shape.setLastVertex(t3, bm);
        }
      }
    }
  }
  processBunch_() {
    let e5 = false;
    const t2 = new ei(0, 0);
    for (; ; ) {
      this.m_bunchEdgeEndPoints.length = 0, this.m_bunchEdgeCenterPoints.length = 0, this.m_bunchEdgeIndices.length = 0;
      let s4 = this.m_firstCoincidentVertex, n6 = 0, r = true;
      for (; s4 !== this.m_nextVertexToProcess; ) {
        const e6 = this.m_sortedVertices.getData(s4);
        r && (this.m_shape.queryXY(e6, t2), r = false);
        const i3 = this.m_shape.getPrevVertex(e6), o2 = this.m_shape.getNextVertex(e6);
        this.m_shape.getUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex) !== G3 && (this.m_bunchEdgeEndPoints.push(i3), this.m_shape.setUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex, G3), this.m_bunchEdgeCenterPoints.push(e6), this.m_bunchEdgeIndices.push(n6++));
        this.m_shape.getUserIndex(o2, this.m_userIndexSortedAngleIndexToVertex) !== G3 && (this.m_bunchEdgeEndPoints.push(o2), this.m_shape.setUserIndex(o2, this.m_userIndexSortedAngleIndexToVertex, G3), this.m_bunchEdgeCenterPoints.push(e6), this.m_bunchEdgeIndices.push(n6++)), s4 = this.m_sortedVertices.getNext(s4);
      }
      if (this.m_bunchEdgeEndPoints.length < 2) {
        1 === this.m_bunchEdgeEndPoints.length && this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0], this.m_userIndexSortedAngleIndexToVertex, -1);
        break;
      }
      this.m_bunchEdgeIndices.sort((e6, t3) => this.compareAngles_(e6, t3));
      for (let e6 = 0, t3 = this.m_bunchEdgeIndices.length; e6 < t3; e6++) {
        const t4 = this.m_bunchEdgeIndices[e6], s5 = this.m_bunchEdgeEndPoints[t4];
        this.m_shape.setUserIndex(s5, this.m_userIndexSortedAngleIndexToVertex, e6);
      }
      const i2 = this.processCrossOvers_(t2);
      for (let e6 = 0, t3 = this.m_bunchEdgeIndices.length; e6 < t3; e6++) {
        const t4 = this.m_bunchEdgeIndices[e6];
        if (-1 === t4) continue;
        const s5 = this.m_bunchEdgeEndPoints[t4];
        this.m_shape.setUserIndex(s5, this.m_userIndexSortedAngleIndexToVertex, -1);
      }
      if (!i2) break;
      e5 = true;
    }
    return e5;
  }
  processCrossOvers_(e5) {
    let t2 = false, s4 = true;
    for (; s4; ) {
      s4 = false;
      let n6 = 0;
      -1 === this.m_bunchEdgeIndices[n6] && (n6 = this.getNextEdgeIndex_(n6));
      let r = this.getNextEdgeIndex_(n6);
      for (let i2 = 0, o2 = this.m_bunchEdgeIndices.length; i2 < o2 && -1 !== n6 && -1 !== r && n6 !== r; i2++) {
        const i3 = this.m_bunchEdgeIndices[n6], o3 = this.m_bunchEdgeIndices[r], a2 = this.m_bunchEdgeEndPoints[i3], h2 = this.m_bunchEdgeEndPoints[o3];
        let m2 = this.m_shape.getNextVertex(a2), l2 = false;
        this.m_shape.isEqualXYPoint2D(m2, e5) || (m2 = this.m_shape.getPrevVertex(a2), l2 = true);
        let g2 = this.m_shape.getNextVertex(h2), u = false;
        this.m_shape.isEqualXYPoint2D(g2, e5) || (g2 = this.m_shape.getPrevVertex(h2), u = true);
        const c = l2 ? this.m_shape.getPrevVertex(m2) : this.m_shape.getNextVertex(m2), _ = u ? this.m_shape.getPrevVertex(g2) : this.m_shape.getNextVertex(g2);
        let d2 = false;
        (this.removeSpike_(m2) || this.removeSpike_(g2) || this.removeSpike_(a2) || this.removeSpike_(h2) || this.removeSpike_(c) || this.removeSpike_(_)) && (d2 = true), m2 !== g2 && (!d2 && this.m_shape.isEqualXY(a2, h2) && (d2 = this.resolveOverlap_(l2, u, m2, a2, g2, h2)), !d2 && this.m_shape.isEqualXY(c, _) && (d2 = this.resolveOverlap_(!l2, !u, m2, c, g2, _)), !d2 && this.m_shape.isEqualXY(a2, _) && (d2 = this.resolveOverlap_(l2, !u, m2, a2, g2, _)), !d2 && this.m_shape.isEqualXY(c, h2) && (d2 = this.resolveOverlap_(!l2, u, m2, c, g2, h2))), d2 && (t2 = true), s4 || (s4 = d2), n6 = d2 ? this.getNextEdgeIndex_(n6) : r, r = this.getNextEdgeIndex_(n6);
      }
    }
    if (!t2) {
      let s5 = 0;
      -1 === this.m_bunchEdgeIndices[s5] && (s5 = this.getNextEdgeIndex_(s5));
      let n6 = this.getNextEdgeIndex_(s5);
      for (let r = 0, i2 = this.m_bunchEdgeIndices.length; r < i2 && -1 !== s5 && -1 !== n6 && s5 !== n6; r++) {
        const r2 = this.m_bunchEdgeIndices[s5], i3 = this.m_bunchEdgeIndices[n6], o2 = this.m_bunchEdgeEndPoints[r2], a2 = this.m_bunchEdgeEndPoints[i3];
        let h2 = this.m_shape.getNextVertex(o2);
        this.m_shape.isEqualXYPoint2D(h2, e5) || (h2 = this.m_shape.getPrevVertex(o2));
        let m2 = this.m_shape.getNextVertex(a2);
        this.m_shape.isEqualXYPoint2D(m2, e5) || (m2 = this.m_shape.getPrevVertex(a2));
        const l2 = this.getDirection_(h2, o2), g2 = this.getDirection_(m2, a2), u = l2 ? this.m_shape.getPrevVertex(h2) : this.m_shape.getNextVertex(h2), c = g2 ? this.m_shape.getPrevVertex(m2) : this.m_shape.getNextVertex(m2), _ = this.detectAndResolveCrossOver_(l2, g2, o2, h2, u, a2, m2, c);
        1 !== _ ? 0 === _ ? (s5 = this.getNextEdgeIndex_(s5), n6 = this.getNextEdgeIndex_(s5)) : (s5 = this.getPrevEdgeIndex_(s5), n6 = this.getNextEdgeIndex_(s5)) : t2 = true;
      }
    }
    return t2;
  }
  simplify_() {
    if (this.m_shape.getGeometryType(this.m_geometry) === a.enumPolygon && 1 === this.m_shape.getFillRule(this.m_geometry)) {
      new za2(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency, this.m_shape, this.m_geometry, 0);
    }
    let e5 = false;
    this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = this.m_shape.createUserIndexUninitialized();
    const t2 = this.m_shape.getPointCount(this.m_geometry), s4 = new st2(0);
    this.m_shape.dbgVerifyMonotone();
    for (let i2 = this.m_shape.getFirstPath(this.m_geometry); i2 !== bm; i2 = this.m_shape.getNextPath(i2)) {
      let e6 = this.m_shape.getFirstVertex(i2);
      for (let t3 = 0, n7 = this.m_shape.getPathSize(i2); t3 < n7; t3++) this.m_shape.setUserIndex(e6, this.m_userIndexSortedAngleIndexToVertex, -1), s4.add(e6), e6 = this.m_shape.getNextVertex(e6);
    }
    this.m_shape.sortVerticesSimpleByY(s4, 0, t2), this.progress_(true), this.m_userIndexSortedIndexToVertex = this.m_shape.createUserIndexUninitialized(), this.m_sortedVertices.reserveNodes(t2), this.m_sortedVerticesListIndex = this.m_sortedVertices.createList(0);
    for (let i2 = 0; i2 < t2; i2++) {
      const e6 = s4.read(i2), t3 = this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex, e6);
      this.m_shape.setUserIndex(e6, this.m_userIndexSortedIndexToVertex, t3);
    }
    this.m_nextVertexToProcess = -1, this.cleanupSpikes_() && (e5 = true);
    let n6 = 0, r = false;
    do {
      r = false, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);
      const t3 = new ei(0, 0);
      this.m_firstCoincidentVertex !== pt2.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex), t3);
      let s5 = 0, i2 = this.m_firstCoincidentVertex;
      for (; i2 !== pt2.st_nullNode() && (i2 = this.m_sortedVertices.getNext(i2), i2 !== pt2.st_nullNode()); ) {
        this.progress_();
        const e6 = this.m_sortedVertices.getData(i2), n7 = ei.getNAN();
        if (this.m_shape.queryXY(e6, n7), t3.equals(n7)) s5++;
        else {
          if (s5 > 0) {
            this.m_nextVertexToProcess = i2;
            const e7 = this.processBunch_();
            i2 = this.m_nextVertexToProcess, i2 !== pt2.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(i2), n7), e7 && (r = true);
          }
          t3.setCoordsPoint2D(n7), this.m_firstCoincidentVertex = i2, s5 = 0;
        }
      }
      if (this.m_nextVertexToProcess = -1, s5 > 0) {
        this.processBunch_() && (r = true);
      }
      n6++ > 10 && b(""), r && this.fixOrphanVertices_(), this.cleanupSpikes_() && (r = true), e5 || (e5 = r);
    } while (r);
    return this.m_shape.dbgVerifyMonotone(), this.m_shape.dbgVerifyCurves(), this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex), this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex), e5 = Ln2(this.m_shape, this.m_geometry, this.m_sortedVertices, this.m_bFixSelfTangency, this.m_progressTracker) || e5, this.m_shape.dbgVerifyCurves(), e5;
  }
  getDirection_(e5, t2) {
    return this.m_shape.getNextVertex(t2) !== e5;
  }
  detectAndResolveCrossOver_(e5, t2, s4, n6, r, i2, o2, a2) {
    if (n6 === o2) return this.removeAngleSortInfo_(s4), this.removeAngleSortInfo_(i2), -1;
    const h2 = this.m_shape.getUserIndex(s4, this.m_userIndexSortedAngleIndexToVertex), m2 = this.m_shape.getUserIndex(r, this.m_userIndexSortedAngleIndexToVertex), l2 = this.m_shape.getUserIndex(i2, this.m_userIndexSortedAngleIndexToVertex), g2 = this.m_shape.getUserIndex(a2, this.m_userIndexSortedAngleIndexToVertex), u = Lt(8, Number.NaN), c = Lt(4, Number.NaN);
    u[0] = 0, c[0] = h2, u[1] = 0, c[1] = m2, u[2] = 1, c[2] = l2, u[3] = 1, c[3] = g2;
    for (let d2 = 1; d2 < 4; d2++) {
      const e6 = c[d2], t3 = u[d2];
      let s5 = d2 - 1;
      for (; s5 >= 0 && c[s5] > e6; ) c[s5 + 1] = c[s5], u[s5 + 1] = u[s5], s5--;
      c[s5 + 1] = e6, u[s5 + 1] = t3;
    }
    let _ = 0;
    if (u[0] && (_ |= 1), u[1] && (_ |= 2), u[2] && (_ |= 4), u[3] && (_ |= 8), 5 !== _ && 10 !== _) return 0;
    if (e5 !== t2 && (a2 = Mt(i2, i2 = a2)), e5) this.m_shape.setNextVertex(a2, n6), this.m_shape.setPrevVertex(n6, a2), this.m_shape.setNextVertex(r, o2), this.m_shape.setPrevVertex(o2, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(o2, true));
    else {
      if (this.m_shape.setPrevVertex(a2, n6), this.m_shape.setNextVertex(n6, a2), this.m_shape.setPrevVertex(r, o2), this.m_shape.setNextVertex(o2, r), this.m_bHasSegmentParentage) {
        const e6 = this.m_shape.getSegmentParentage(n6), t3 = this.m_shape.getSegmentParentage(o2);
        this.m_shape.setSegmentParentageAndBreak(n6, t3, true), this.m_shape.setSegmentParentageAndBreak(o2, e6, true);
      }
      if (this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(n6), t3 = this.m_shape.getVertexIndex(o2), s5 = this.m_shape.getSegmentFromIndex(e6);
        this.m_shape.setSegmentToIndex(e6, null);
        const r2 = this.m_shape.getSegmentFromIndex(t3);
        this.m_shape.setSegmentToIndex(t3, null), this.m_shape.setSegmentToIndex(e6, r2), this.m_shape.setSegmentToIndex(t3, s5);
      }
    }
    return 1;
  }
  resolveOverlap_(e5, t2, s4, n6, r, i2) {
    return this.resolveOverlapOddEven_(e5, t2, s4, n6, r, i2);
  }
  resolveOverlapOddEven_(e5, t2, s4, n6, r, i2) {
    if (e5 !== t2) {
      e5 || (r = Mt(s4, s4 = r), i2 = Mt(n6, n6 = i2));
      const t3 = this.m_shape.getNextVertex(r), o2 = this.m_shape.getNextVertex(s4);
      if (this.m_shape.setNextVertex(s4, t3), this.m_shape.setPrevVertex(t3, s4), this.m_shape.setNextVertex(r, o2), this.m_shape.setPrevVertex(o2, r), this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(s4), t4 = this.m_shape.getVertexIndex(r), n7 = this.m_shape.getSegmentFromIndex(e6);
        this.m_shape.setSegmentToIndex(e6, null);
        const i3 = this.m_shape.getSegmentFromIndex(t4);
        this.m_shape.setSegmentToIndex(t4, null), this.m_shape.setSegmentToIndex(e6, i3), this.m_shape.setSegmentToIndex(t4, n7);
      }
      if (this.m_bHasSegmentParentage) {
        const e6 = this.m_shape.getSegmentParentage(s4), t4 = this.m_shape.getSegmentParentage(r);
        this.m_shape.setSegmentParentageAndBreak(s4, t4, true), this.m_shape.setSegmentParentageAndBreak(r, e6, true), this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(i2, true);
      }
      this.removeSpike_(r);
    } else {
      const o2 = e5 ? s4 : n6, a2 = t2 ? r : i2, h2 = e5 ? n6 : s4, m2 = t2 ? i2 : r;
      let l2 = null;
      if (this.m_bHasSegments) {
        const e6 = this.m_shape.getVertexIndex(m2);
        l2 = this.m_shape.getSegmentFromIndex(e6), this.m_shape.setSegmentToIndex(e6, null);
        const t3 = this.m_shape.getVertexIndex(a2);
        this.m_shape.setSegmentToIndex(t3, null);
        const s5 = this.m_shape.getVertexIndex(o2);
        this.m_shape.setSegmentToIndex(s5, null);
      }
      let g2 = -1;
      this.m_bHasSegmentParentage && (g2 = this.m_shape.getSegmentParentage(m2));
      let u = false;
      this.m_shape.setNextVertex(o2, a2), this.m_shape.setNextVertex(a2, o2), this.m_shape.setPrevVertex(h2, m2), this.m_shape.setPrevVertex(m2, h2);
      let c = m2;
      for (; c !== a2; ) {
        const e6 = this.m_shape.getPrevVertex(c), t3 = this.m_shape.getNextVertex(c);
        if (this.m_shape.setPrevVertex(c, t3), this.m_shape.setNextVertex(c, e6), u || (u = c === o2), this.m_bHasSegments && c !== o2) {
          const e7 = this.m_shape.getVertexIndex(t3), s5 = l2;
          l2 = this.m_shape.getSegmentFromIndex(e7), null !== s5 && s5.reverse(), this.m_shape.setSegmentToIndex(e7, s5);
        }
        if (this.m_bHasSegmentParentage) {
          const e7 = this.m_shape.getSegmentParentage(t3);
          this.m_shape.setSegmentParentagePreserveBreak(t3, g2), g2 = e7;
        }
        c = t3;
      }
      let _ = null;
      if (!u) {
        const e6 = this.m_shape.getPrevVertex(a2), t3 = this.m_shape.getNextVertex(a2);
        if (this.m_shape.setPrevVertex(a2, t3), this.m_shape.setNextVertex(a2, e6), this.m_bHasSegments) {
          const e7 = this.m_shape.getVertexIndex(a2);
          _ = this.m_shape.getSegmentFromIndex(e7), this.m_shape.setSegmentToIndex(e7, null);
        }
      }
      let d2 = -1, p3 = -1;
      if (this.m_bHasSegmentParentage && (d2 = u ? this.m_shape.getSegmentParentage(o2) : this.m_shape.getSegmentParentage(a2), p3 = this.m_shape.getSegmentParentage(h2)), this.transferVertexData_(a2, o2), this.beforeRemoveVertex_(a2, true), this.m_shape.removeVertexInternal(a2, true), this.removeAngleSortInfo_(o2), this.transferVertexData_(m2, h2), this.beforeRemoveVertex_(m2, true), this.m_shape.removeVertexInternal(m2, true), this.removeAngleSortInfo_(h2), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageAndBreak(o2, d2, true), this.m_shape.setSegmentParentageAndBreak(h2, p3, true)), _) {
        const e6 = this.m_shape.getVertexIndex(o2);
        this.m_shape.setSegmentToIndex(e6, _);
      }
    }
    return true;
  }
  cleanupSpikes_() {
    let e5 = false;
    for (let t2 = this.m_shape.getFirstPath(this.m_geometry); t2 !== bm; ) {
      const s4 = this.m_shape.getNextPath(t2);
      let n6 = this.m_shape.getFirstVertex(t2);
      for (let r = 0, i2 = this.m_shape.getPathSize(t2); r < i2 && i2 > 1; ) {
        this.progress_();
        const { v: s5, bModified: o2 } = this.checkAndCleanupSpike_(t2, n6);
        if (s5 === bm) break;
        o2 ? (e5 = true, n6 = s5, r = 0, i2 = this.m_shape.getPathSize(t2)) : (n6 = s5, r++);
      }
      t2 = s4;
    }
    return e5;
  }
  checkAndCleanupSpike_(e5, t2) {
    const s4 = { v: bm, bModified: false };
    let n6 = this.m_shape.getPrevVertex(t2), r = this.m_shape.getNextVertex(t2), i2 = bm, o2 = bm;
    for (; this.m_shape.isEqualXY(n6, r) && (i2 = n6, o2 = r, r !== t2); ) n6 = this.m_shape.getPrevVertex(n6), r = this.m_shape.getNextVertex(r);
    if (i2 === bm) return s4.v = r, s4;
    s4.bModified = true;
    for (let a2 = this.m_shape.getNextVertex(i2); this.beforeRemoveVertex_(a2, false), a2 !== o2; a2 = this.m_shape.getNextVertex(a2)) ;
    if (i2 === t2) return this.m_polylineDegeneracies !== bm ? this.m_shape.movePath(this.m_polylineDegeneracies, bm, e5) : this.m_shape.removePath(e5), s4.v = bm, s4;
    {
      const e6 = this.m_shape.peelALoopIntoAPath(i2, o2);
      this.m_polylineDegeneracies !== bm ? this.m_shape.movePath(this.m_polylineDegeneracies, bm, e6) : this.m_shape.removePath(e6);
    }
    return s4.v = i2, s4;
  }
  removeSpike_(e5) {
    let t2 = this.m_shape.getPrevVertex(e5), s4 = this.m_shape.getNextVertex(e5), n6 = bm, r = bm;
    for (; this.m_shape.isEqualXY(t2, s4) && (n6 = t2, r = s4, s4 !== e5); ) t2 = this.m_shape.getPrevVertex(t2), s4 = this.m_shape.getNextVertex(s4);
    if (n6 === bm) return false;
    if (this.m_shape.peelALoop(n6, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n6, true), this.m_shape.setSegmentParentageBreakVertex(r, true)), this.removeAngleSortInfo_(n6), this.m_polylineDegeneracies === bm) for (let i2 = this.m_shape.getNextVertex(r); ; ) {
      const e6 = this.m_shape.getNextVertex(i2);
      if (this.removeAngleSortInfo_(i2), this.beforeRemoveVertex_(i2, true), this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(i2), null), this.m_shape.removeVertexInternal(i2, false), i2 === r) break;
      i2 = e6;
    }
    else {
      for (let t3 = r; ; ) {
        const e7 = this.m_shape.getNextVertex(t3);
        if (this.removeAngleSortInfo_(t3), this.beforeRemoveVertex_(t3, false), t3 = e7, t3 === r) break;
      }
      const e6 = [false];
      this.m_shape.insertClosedPath(this.m_polylineDegeneracies, bm, r, r, e6);
    }
    return true;
  }
  fixOrphanVertices_() {
    let e5 = 0;
    for (let n6 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n6; n6 = this.m_sortedVertices.getNext(n6)) {
      const e6 = this.m_sortedVertices.getData(n6);
      this.m_shape.setPathToVertex(e6, bm);
    }
    let t2 = 0;
    for (let n6 = this.m_shape.getFirstPath(this.m_geometry); n6 !== bm; ) {
      const s5 = this.m_shape.getFirstVertex(n6);
      if (s5 === bm || this.m_shape.getPathFromVertex(s5) !== bm) {
        const e6 = n6;
        n6 = this.m_shape.getNextPath(n6), this.m_shape.removePathOnly(e6);
        continue;
      }
      this.m_shape.setPathToVertex(s5, n6);
      let r = 1;
      for (let e6 = this.m_shape.getNextVertex(s5); e6 !== s5; e6 = this.m_shape.getNextVertex(e6)) this.m_shape.setPathToVertex(e6, n6), r++;
      this.m_shape.setRingAreaValid(n6, false), this.m_shape.setPathSize(n6, r), this.m_shape.setLastVertex(n6, this.m_shape.getPrevVertex(s5)), t2 += r, e5++, n6 = this.m_shape.getNextPath(n6);
    }
    for (let n6 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n6; n6 = this.m_sortedVertices.getNext(n6)) {
      const s5 = this.m_sortedVertices.getData(n6);
      if (this.m_shape.getPathFromVertex(s5) !== bm) continue;
      const r = [false], i2 = this.m_shape.insertClosedPath(this.m_geometry, bm, s5, s5, r);
      t2 += this.m_shape.getPathSize(i2), e5++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, e5), this.m_shape.setGeometryVertexCount(this.m_geometry, t2);
    let s4 = 0;
    for (let n6 = this.m_shape.getFirstGeometry(); n6 !== bm; n6 = this.m_shape.getNextGeometry(n6)) s4 += this.m_shape.getPointCount(n6);
    this.m_shape.setTotalPointCount(s4);
  }
  getNextEdgeIndex_(e5) {
    if (-1 === e5) return -1;
    for (let t2 = 0, s4 = this.m_bunchEdgeIndices.length - 1; t2 < s4; t2++) if (e5 = (e5 + 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e5]) return e5;
    return -1;
  }
  getPrevEdgeIndex_(e5) {
    if (-1 === e5) return -1;
    for (let t2 = 0, s4 = this.m_bunchEdgeIndices.length - 1; t2 < s4; t2++) if (e5 = (this.m_bunchEdgeIndices.length + e5 - 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e5]) return e5;
    return -1;
  }
  transferVertexData_(e5, t2) {
    const s4 = this.m_shape.getUserIndex(t2, this.m_userIndexSortedIndexToVertex), n6 = this.m_shape.getUserIndex(t2, this.m_userIndexSortedAngleIndexToVertex);
    this.m_shape.transferAllDataToTheVertex(e5, t2), this.m_shape.setUserIndex(t2, this.m_userIndexSortedIndexToVertex, s4), this.m_shape.setUserIndex(t2, this.m_userIndexSortedAngleIndexToVertex, n6);
  }
  removeAngleSortInfo_(e5) {
    const t2 = this.m_shape.getUserIndex(e5, this.m_userIndexSortedAngleIndexToVertex);
    -1 !== t2 && (this.m_bunchEdgeIndices[t2] = -1, this.m_shape.setUserIndex(e5, this.m_userIndexSortedAngleIndexToVertex, -1));
  }
  progress_(e5 = false) {
  }
};
function $n2(s4, n6, r, i2, a2, h2 = true) {
  switch (sr2(i2)) {
    case 0:
      break;
    case 1:
      P("relation string length has to be 9 characters");
      break;
    default:
      P("relation string");
  }
  if (h2) {
    const e5 = dr2(i2, s4.getDimension(), n6.getDimension());
    if (0 !== e5) return Vr2(s4, n6, r, e5, a2);
  }
  let m2 = 0;
  if ("number" == typeof r) m2 = r;
  else {
    const t2 = n4.constructEmpty();
    s4.queryEnvelope(t2);
    const i3 = n4.constructEmpty();
    n6.queryEnvelope(i3);
    const o2 = n4.constructEmpty();
    o2.setCoords({ env2D: t2 }), o2.mergeEnvelope2D(i3), m2 = Bt2(r, o2, false);
  }
  const l2 = wr2(s4, m2), g2 = wr2(n6, m2);
  if (l2.isEmpty() || g2.isEmpty()) return _r2(l2, g2, i2);
  const u = l2.getGeometryType(), c = g2.getGeometryType();
  let _ = false;
  switch (u) {
    case a.enumPolygon:
      switch (c) {
        case a.enumPolygon:
          _ = nr2(l2, g2, m2, i2, a2);
          break;
        case a.enumPolyline:
          _ = rr2(l2, g2, m2, i2, a2);
          break;
        case a.enumPoint:
          _ = mr2(l2, g2, m2, i2);
          break;
        case a.enumMultiPoint:
          _ = ir2(l2, g2, m2, i2, a2);
      }
      break;
    case a.enumPolyline:
      switch (c) {
        case a.enumPolygon:
          _ = rr2(g2, l2, m2, vr2(i2), a2);
          break;
        case a.enumPolyline:
          _ = or2(l2, g2, m2, i2, a2);
          break;
        case a.enumPoint:
          _ = lr2(l2, g2, m2, i2, a2);
          break;
        case a.enumMultiPoint:
          _ = ar2(l2, g2, m2, i2, a2);
      }
      break;
    case a.enumPoint:
      switch (c) {
        case a.enumPolygon:
          _ = mr2(g2, l2, m2, vr2(i2));
          break;
        case a.enumPolyline:
          _ = lr2(g2, l2, m2, vr2(i2), a2);
          break;
        case a.enumPoint:
          _ = ur2(l2, g2, m2, i2);
          break;
        case a.enumMultiPoint:
          _ = gr2(g2, l2, m2, vr2(i2));
      }
      break;
    case a.enumMultiPoint:
      switch (c) {
        case a.enumPolygon:
          _ = ir2(g2, l2, m2, vr2(i2), a2);
          break;
        case a.enumPolyline:
          _ = ar2(g2, l2, m2, vr2(i2), a2);
          break;
        case a.enumMultiPoint:
          _ = hr2(l2, g2, m2, i2, a2);
          break;
        case a.enumPoint:
          _ = gr2(l2, g2, m2, i2);
      }
      break;
    default:
      _ = false;
  }
  return _;
}
function er2(t2, s4, n6, r) {
  const i2 = new Ir2();
  i2.resetMatrix_(), i2.setPredicates_("T*****F**"), i2.setAreaAreaPredicates_();
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  t2.queryEnvelope(o2), s4.queryEnvelope(a2);
  let h2 = false;
  if (Ar2(o2, a2, n6) && (i2.areaAreaDisjointPredicates_(t2, s4), h2 = true), h2 || Mr2(t2, s4), h2) {
    return cr2(i2.m_matrix, i2.m_scl);
  }
  let m2 = new Tm(), l2 = m2.addGeometry(t2), g2 = m2.addGeometry(s4), u = null, c = 0;
  if (t2.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    u = new ca2();
    const e5 = la2(n6, m2.getEnvelope2D(r));
    c = ua2(e5, 0), ra2(m2, e5, n6, 12e3, u, null, r);
  }
  da2(m2, new bt(n6, 0).add(c), r, false, false);
  const _ = m2.getGeometry(g2).getBoundary();
  if (m2.filterClosePoints(0, true, true, false, bm), Qn2(m2, l2, -1, false, bm, r), 0 === m2.getPointCount(l2)) return false;
  Qn2(m2, g2, -1, false, bm, r), i2.setEditShape_(m2, r);
  const d2 = 0 === m2.getPointCount(g2);
  if (!d2) {
    i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
    const e5 = cr2(i2.m_matrix, i2.m_scl);
    if (!e5) return e5;
  }
  const p3 = m2.getGeometry(l2);
  m2 = new Tm(), l2 = m2.addGeometry(p3), g2 = m2.addGeometry(_), i2.setEditShape_(m2, r), i2.m_predicateCount = 0, i2.resetMatrix_(), i2.setPredicates_(d2 ? "T*****F**" : "******F**"), i2.setAreaLinePredicates_(), i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
  return cr2(i2.m_matrix, i2.m_scl);
}
function tr2(t2, s4, n6, r) {
  const i2 = new Ir2();
  i2.resetMatrix_(), i2.setPredicates_("T*****F**"), i2.setAreaLinePredicates_();
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  t2.queryEnvelope(o2), s4.queryEnvelope(a2);
  let h2 = false;
  if (Ar2(o2, a2, n6) && (i2.areaLineDisjointPredicates_(t2, s4), h2 = true), h2 || Mr2(t2, s4), h2) {
    return cr2(i2.m_matrix, i2.m_scl);
  }
  const m2 = new Tm(), l2 = m2.addGeometry(t2), g2 = m2.addGeometry(s4);
  if (i2.setEditShapeCrackAndCluster_(m2, new bt(n6, 0), r), 0 === m2.getPointCount(l2)) return false;
  i2.computeMatrixTopoGraphHalfEdges_(l2, g2), i2.m_topoGraph.removeShape();
  return cr2(i2.m_matrix, i2.m_scl);
}
function sr2(e5) {
  if (9 !== e5.length) return 1;
  for (let t2 = 0; t2 < 9; t2++) {
    const s4 = e5[t2];
    if ("*" !== s4 && "T" !== s4 && "F" !== s4 && "0" !== s4 && "1" !== s4 && "2" !== s4) return 2;
  }
  return 0;
}
function nr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setAreaAreaPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.areaAreaDisjointPredicates_(t2, s4), m2 = true), m2 || Mr2(t2, s4), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.computeMatrixTopoGraphHalfEdges_(r2, a3), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function rr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setAreaLinePredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.areaLineDisjointPredicates_(t2, s4), m2 = true), m2 || Mr2(t2, s4), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.m_clusterIndexB = o2.m_topoGraph.createUserIndexForClusters(), Sr2(a3, o2.m_topoGraph, o2.m_clusterIndexB), o2.computeMatrixTopoGraphHalfEdges_(r2, a3), o2.m_topoGraph.deleteUserIndexForClusters(o2.m_clusterIndexB), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function ir2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setAreaPointPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.areaPointDisjointPredicates_(t2), m2 = true), m2 || Mr2(t2, s4), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.computeMatrixTopoGraphClusters_(r2, a3), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function or2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setLineLinePredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.lineLineDisjointPredicates_(t2, s4), m2 = true), m2 || Mr2(t2, s4), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.m_clusterIndexA = o2.m_topoGraph.createUserIndexForClusters(), o2.m_clusterIndexB = o2.m_topoGraph.createUserIndexForClusters(), Sr2(r2, o2.m_topoGraph, o2.m_clusterIndexA), Sr2(a3, o2.m_topoGraph, o2.m_clusterIndexB), o2.computeMatrixTopoGraphHalfEdges_(r2, a3), o2.m_topoGraph.deleteUserIndexForClusters(o2.m_clusterIndexA), o2.m_topoGraph.deleteUserIndexForClusters(o2.m_clusterIndexB), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function ar2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setLinePointPredicates_();
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.linePointDisjointPredicates_(t2), m2 = true), m2 || Mr2(t2, s4), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.m_clusterIndexA = o2.m_topoGraph.createUserIndexForClusters(), Sr2(r2, o2.m_topoGraph, o2.m_clusterIndexA), o2.computeMatrixTopoGraphClusters_(r2, a3), o2.m_topoGraph.deleteUserIndexForClusters(o2.m_clusterIndexA), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function hr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setPointPointPredicates_();
  const a2 = new n4(), h2 = new n4();
  t2.queryEnvelope(a2), s4.queryEnvelope(h2);
  let m2 = false;
  if (Ar2(a2, h2, n6) && (o2.pointPointDisjointPredicates_(), m2 = true), !m2) {
    const e5 = new Tm(), r2 = e5.addGeometry(t2), a3 = e5.addGeometry(s4);
    o2.setEditShapeCrackAndCluster_(e5, new bt(n6, 0), i2), o2.computeMatrixTopoGraphClusters_(r2, a3), o2.m_topoGraph.removeShape();
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function mr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setAreaPointPredicates_();
  const a2 = n4.constructEmpty();
  t2.queryEnvelope(a2);
  const h2 = s4.getXY();
  let m2 = false;
  if (Ur2(h2, a2, n6) && (o2.areaPointDisjointPredicates_(t2), m2 = true), !m2) {
    const s5 = Ro2(t2, h2, n6);
    if (1 === s5) o2.m_matrix[0] = 0, o2.m_matrix[2] = 2, o2.m_matrix[3] = -1, o2.m_matrix[5] = 1, o2.m_matrix[6] = -1;
    else if (2 === s5) {
      o2.m_matrix[6] = -1;
      if (0 !== t2.calculateArea2D()) o2.m_matrix[0] = -1, o2.m_matrix[3] = 0, o2.m_matrix[2] = 2, o2.m_matrix[5] = 1;
      else {
        o2.m_matrix[0] = 0, o2.m_matrix[3] = -1, o2.m_matrix[5] = -1;
        const s6 = n4.constructEmpty();
        t2.queryEnvelope(s6), o2.m_matrix[2] = s6.height() || s6.width() ? 1 : -1;
      }
    } else o2.areaPointDisjointPredicates_(t2);
  }
  return cr2(o2.m_matrix, r);
}
function lr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setLinePointPredicates_();
  const a2 = n4.constructEmpty();
  t2.queryEnvelope(a2);
  let h2 = false;
  if (Ur2(s4.getXY(), a2, n6) && (o2.linePointDisjointPredicates_(t2), h2 = true), !h2) {
    let e5 = null, r2 = false, a3 = false;
    if (o2.m_performPredicates[0] || o2.m_performPredicates[6]) {
      !Vr2(t2, s4, n6, 4, i2) ? (o2.m_performPredicates[0] && (e5 = Va(t2), a3 = !Vr2(e5, s4, n6, 4, i2), r2 = true, o2.m_matrix[0] = a3 ? -1 : 0), o2.m_matrix[6] = -1) : (o2.m_matrix[0] = -1, o2.m_matrix[6] = 0);
    }
    if (o2.m_performPredicates[3] && (null !== e5 && e5.isEmpty() ? o2.m_matrix[3] = -1 : (r2 || (null == e5 && (e5 = Va(t2)), a3 = !Vr2(e5, s4, n6, 4, i2), r2 = true), o2.m_matrix[3] = a3 ? 0 : -1)), o2.m_performPredicates[5]) if (null !== e5 && e5.isEmpty()) o2.m_matrix[5] = -1;
    else if (r2 && !a3) o2.m_matrix[5] = 0;
    else {
      null === e5 && (e5 = Va(t2));
      const r3 = Vr2(e5, s4, n6, 3, i2);
      o2.m_matrix[5] = r3 ? -1 : 0;
    }
    if (o2.m_performPredicates[2]) {
      if (0 !== t2.calculateLength2D()) o2.m_matrix[2] = 1;
      else {
        const e6 = new Ce({ vd: t2.getDescription() });
        e6.addPoints(t2, 0, t2.getPointCount());
        const r3 = Vr2(e6, s4, n6, 3, i2);
        o2.m_matrix[2] = r3 ? -1 : 0;
      }
    }
  }
  return cr2(o2.m_matrix, o2.m_scl);
}
function gr2(t2, s4, n6, r, i2) {
  const o2 = new Ir2();
  o2.resetMatrix_(), o2.setPredicates_(r), o2.setPointPointPredicates_();
  const a2 = n4.constructEmpty();
  t2.queryEnvelope(a2);
  const h2 = s4.getXY(), m2 = new ei();
  let l2 = false;
  if (Ur2(h2, a2, n6) && (o2.pointPointDisjointPredicates_(), l2 = true), !l2) {
    let e5 = false, s5 = true;
    const r2 = n6 * n6;
    for (let n7 = 0; n7 < t2.getPointCount() && (t2.queryXY(n7, m2), ei.sqrDistance(m2, h2) <= r2 ? e5 = true : s5 = false, !e5 || s5); n7++) ;
    e5 ? (o2.m_matrix[0] = 0, o2.m_matrix[2] = s5 ? -1 : 0, o2.m_matrix[6] = -1) : (o2.m_matrix[0] = -1, o2.m_matrix[2] = 0, o2.m_matrix[6] = 0);
  }
  return cr2(o2.m_matrix, r);
}
function ur2(e5, t2, s4, n6, r) {
  const i2 = e5.getXY(), o2 = t2.getXY(), a2 = Lt(9, -1);
  ei.sqrDistance(i2, o2) <= s4 * s4 ? a2[0] = 0 : (a2[2] = 0, a2[6] = 0), a2[8] = 2;
  return cr2(a2, n6);
}
function cr2(e5, t2) {
  for (let s4 = 0; s4 < 9; s4++) switch (t2[s4]) {
    case "T":
      if (-1 === e5[s4]) return false;
      break;
    case "F":
      if (-1 !== e5[s4]) return false;
      break;
    case "0":
      if (0 !== e5[s4]) return false;
      break;
    case "1":
      if (1 !== e5[s4]) return false;
      break;
    case "2":
      if (2 !== e5[s4]) return false;
  }
  return true;
}
function _r2(t2, s4, n6) {
  const r = Lt(9, -1);
  if (t2.isEmpty() && s4.isEmpty()) return cr2(r, n6);
  let i2, a2 = false;
  t2.isEmpty() ? (i2 = s4, a2 = true) : i2 = t2, r[0] = -1, r[1] = -1, r[3] = -1, r[4] = -1, r[6] = -1, r[7] = -1, r[8] = 2;
  const m2 = i2.getGeometryType();
  if (h(m2)) if (m2 === a.enumPolygon) {
    if (0 !== i2.calculateArea2D()) r[2] = 2, r[5] = 1;
    else {
      r[5] = -1;
      const t3 = n4.constructEmpty();
      i2.queryEnvelope(t3), r[2] = t3.height() || t3.width() ? 1 : 0;
    }
  } else {
    const e5 = 0 !== i2.calculateLength2D();
    r[2] = e5 ? 1 : 0, r[5] = Fa(i2) ? 0 : -1;
  }
  else r[2] = 0, r[5] = -1;
  return a2 && br2(r), cr2(r, n6);
}
function dr2(e5, t2, s4) {
  return pr2(e5) ? 3 : fr2(e5) ? 4 : xr2(e5, t2, s4) ? 8 : yr2(e5, t2, s4) ? 16 : Er2(e5) ? 64 : Pr2(e5) ? 1 : Cr2(e5, t2, s4) ? 32 : 0;
}
function pr2(e5) {
  return "T*F**FFF*" === e5;
}
function fr2(e5) {
  return "FF*FF****" === e5;
}
function xr2(e5, t2, s4) {
  return (0 !== t2 || 0 !== s4) && (2 === t2 && 2 === s4 ? "F***T****" === e5 : (2 === t2 || 1 === t2) && 0 === s4 && "F**T*****" === e5);
}
function yr2(e5, t2, s4) {
  return t2 > s4 ? "T*****T**" === e5 : 1 === t2 && 1 === s4 && "0********" === e5;
}
function Pr2(e5) {
  return "T*****FF*" === e5;
}
function Er2(e5) {
  return "T**FF*FF*" === e5;
}
function Cr2(e5, t2, s4) {
  return t2 === s4 && (1 !== t2 ? "T*T***T**" === e5 : "1*T***T**" === e5);
}
function Sr2(e5, t2, s4) {
  const n6 = t2.getGeometryID(e5);
  for (let r = t2.getFirstCluster(); r !== bm; r = t2.getNextCluster(r)) {
    if (!(t2.getClusterParentage(r) & n6)) continue;
    const e6 = t2.getClusterHalfEdge(r);
    if (e6 === bm) {
      t2.setClusterUserIndex(r, s4, 0);
      continue;
    }
    let i2 = e6, o2 = 0;
    do {
      const e7 = i2;
      t2.getHalfEdgeParentage(e7) & n6 && o2++, i2 = t2.getHalfEdgeNext(t2.getHalfEdgeTwin(e7));
    } while (i2 !== e6);
    t2.setClusterUserIndex(r, s4, o2);
  }
}
var Ir2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor() {
    this.m_clusterIndexA = -1, this.m_clusterIndexB = -1, this.m_visitedIndex = -1, this.m_topoGraph = new Js2(), this.m_matrix = Lt(9, 0), this.m_maxDim = Lt(9, 0), this.m_performPredicates = Lt(9, false), this.m_scl = "", this.m_predicateCount = 0, this.m_predicatesHalfEdge = this.nullFunc, this.m_predicatesCluster = this.nullFunc;
  }
  resetMatrix_() {
    this.m_matrix.fill(-2), this.m_maxDim.fill(-2);
  }
  setPredicates_(e5) {
    this.m_scl = e5;
    for (let t2 = 0; t2 < 9; t2++) "*" !== this.m_scl[t2] ? (this.m_performPredicates[t2] = true, this.m_predicateCount++) : this.m_performPredicates[t2] = false;
  }
  setRemainingPredicatesToFalse_() {
    for (let e5 = 0; e5 < 9; e5++) this.m_performPredicates[e5] && -2 === this.m_matrix[e5] && (this.m_matrix[e5] = -1, this.m_performPredicates[e5] = false);
  }
  isPredicateKnown_(e5) {
    return -2 !== this.m_matrix[e5] && (-1 === this.m_matrix[e5] ? (this.m_performPredicates[e5] = false, this.m_predicateCount--, true) : "T" !== this.m_scl[e5] && "F" !== this.m_scl[e5] ? !(this.m_matrix[e5] < this.m_maxDim[e5]) && (this.m_performPredicates[e5] = false, this.m_predicateCount--, true) : (this.m_performPredicates[e5] = false, this.m_predicateCount--, true));
  }
  setAreaAreaPredicates_() {
    this.m_predicatesHalfEdge = this.areaAreaPredicates_, this.m_maxDim[0] = 2, this.m_maxDim[1] = 1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 2, this.m_maxDim[7] = 1, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaLinePredicates_() {
    this.m_predicatesHalfEdge = this.areaLinePredicates_, this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 0, this.m_maxDim[5] = 1, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLineLinePredicates_() {
    this.m_predicatesHalfEdge = this.lineLinePredicates_, this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = 0, this.m_maxDim[5] = 0, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaPointPredicates_() {
    this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLinePointPredicates_() {
    this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 0, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setPointPointPredicates_() {
    this.m_predicatesCluster = this.pointPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 0, this.m_maxDim[3] = -1, this.m_maxDim[4] = -1, this.m_maxDim[5] = -1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[3] && (this.m_matrix[3] = -1, this.m_performPredicates[3] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[5] && (this.m_matrix[5] = -1, this.m_performPredicates[5] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  areaAreaDisjointPredicates_(e5, t2) {
    this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]), this.areaGeomContainsOrDisjointPredicates_(t2, this.m_performPredicates[6] ? 6 : -1, this.m_scl[6], this.m_performPredicates[7] ? 7 : -1, this.m_scl[7]);
  }
  areaGeomContainsOrDisjointPredicates_(t2, s4, n6, r, i2) {
    const o2 = -1 !== s4, a2 = -1 !== r;
    if (o2 || a2) {
      if (!("T" !== n6 && "F" !== n6 && o2 || "T" !== i2 && "F" !== i2 && a2) || 0 !== t2.calculateArea2D()) o2 && (this.m_matrix[s4] = 2), a2 && (this.m_matrix[r] = 1);
      else if (a2 && (this.m_matrix[r] = -1), o2) {
        const n7 = n4.constructEmpty();
        t2.queryEnvelope(n7), this.m_matrix[s4] = n7.height() || n7.width() ? 1 : 0;
      }
    }
  }
  areaAreaContainsPredicates_(e5) {
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[0] ? 0 : -1, this.m_scl[0], this.m_performPredicates[1] ? 1 : -1, this.m_scl[1]);
  }
  areaAreaWithinPredicates_(e5) {
    this.areaAreaContainsPredicates_(e5), br2(this.m_matrix);
  }
  areaLineDisjointPredicates_(e5, t2) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[6]) {
      const e6 = this.m_scl[6], s4 = "T" === e6 || "F" === e6 || 0 !== t2.calculateLength2D();
      this.m_matrix[6] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e6 = Fa(t2);
      this.m_matrix[7] = e6 ? 0 : -1;
    }
    this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaLineContainsPredicates_(e5, t2) {
    if (this.m_performPredicates[0]) {
      const e6 = this.m_scl[0], s4 = "T" === e6 || "F" === e6 || 0 !== t2.calculateLength2D();
      this.m_matrix[0] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[1]) {
      const e6 = Fa(t2);
      this.m_matrix[1] = e6 ? 0 : -1;
    }
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1;
  }
  areaPointDisjointPredicates_(e5) {
    this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_matrix[6] = 0, this.areaGeomContainsOrDisjointPredicates_(e5, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaPointContainsPredicates_(e5) {
    this.m_matrix[0] = 0, this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1;
  }
  lineLineDisjointPredicates_(e5, t2) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[2]) {
      const t3 = this.m_scl[2], s4 = "T" === t3 || "F" === t3 || 0 !== e5.calculateLength2D();
      this.m_matrix[2] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t3 = Fa(e5);
      this.m_matrix[5] = t3 ? 0 : -1;
    }
    if (this.m_performPredicates[6]) {
      const e6 = this.m_scl[6], s4 = "T" === e6 || "F" === e6 || 0 !== t2.calculateLength2D();
      this.m_matrix[6] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e6 = Fa(t2);
      this.m_matrix[7] = e6 ? 0 : -1;
    }
  }
  linePointDisjointPredicates_(e5) {
    if (this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_performPredicates[2]) {
      const t2 = this.m_scl[2], s4 = "T" === t2 || "F" === t2 || 0 !== e5.calculateLength2D();
      this.m_matrix[2] = s4 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t2 = Fa(e5);
      this.m_matrix[5] = t2 ? 0 : -1;
    }
    this.m_matrix[6] = 0;
  }
  pointPointDisjointPredicates_() {
    this.m_matrix[0] = -1, this.m_matrix[2] = 0, this.m_matrix[6] = 0;
  }
  areaAreaPredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorArea_(e5, t2, s4);
      const r = this.isPredicateKnown_(0);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryArea_(e5, t2, 1);
      const s5 = this.isPredicateKnown_(1);
      n6 && (n6 = s5);
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorArea_(e5, t2, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[3]) {
      this.interiorAreaBoundaryArea_(e5, s4, 3);
      const t3 = this.isPredicateKnown_(3);
      n6 && (n6 = t3);
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryArea_(e5, t2, s4);
      const r = this.isPredicateKnown_(4);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorArea_(e5, t2, s4, 5);
      const r = this.isPredicateKnown_(5);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[6]) {
      this.interiorAreaExteriorArea_(e5, s4, t2, 6);
      const r = this.isPredicateKnown_(6);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[7]) {
      this.boundaryAreaExteriorArea_(e5, s4, t2, 7);
      const r = this.isPredicateKnown_(7);
      n6 && (n6 = r);
    }
    return n6;
  }
  areaLinePredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorLine_(e5, t2, s4);
      const r = this.isPredicateKnown_(0);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryLine_(e5, t2, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(1);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorLine_(e5, t2, s4);
      const r = this.isPredicateKnown_(2);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorLine_(e5, t2, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(3);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryLine_(e5, t2, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorLine_(e5, t2, s4);
      const r = this.isPredicateKnown_(5);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorLine_(e5, t2);
      const s5 = this.isPredicateKnown_(6);
      n6 && (n6 = s5);
    }
    if (this.m_performPredicates[7]) {
      this.exteriorAreaBoundaryLine_(e5, t2, s4, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(7);
      n6 && (n6 = r);
    }
    return n6;
  }
  lineLinePredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorLine_(e5, t2, s4, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(0);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[1]) {
      this.interiorLineBoundaryLine_(e5, t2, s4, this.m_clusterIndexA, this.m_clusterIndexB, 1);
      const r = this.isPredicateKnown_(1);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorLine_(e5, t2, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[3]) {
      this.interiorLineBoundaryLine_(e5, s4, t2, this.m_clusterIndexB, this.m_clusterIndexA, 3);
      const r = this.isPredicateKnown_(3);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[4]) {
      this.boundaryLineBoundaryLine_(e5, t2, s4, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorLine_(e5, t2, s4, this.m_clusterIndexA, 5);
      const r = this.isPredicateKnown_(5);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[6]) {
      this.interiorLineExteriorLine_(e5, s4, t2, 6);
      const r = this.isPredicateKnown_(6);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[7]) {
      this.boundaryLineExteriorLine_(e5, s4, t2, this.m_clusterIndexB, 7);
      const r = this.isPredicateKnown_(7);
      n6 && (n6 = r);
    }
    return n6;
  }
  areaPointPredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorPoint_(e5, t2);
      const s5 = this.isPredicateKnown_(0);
      n6 && (n6 = s5);
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorPoint_(e5, t2);
      const s5 = this.isPredicateKnown_(2);
      n6 && (n6 = s5);
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorPoint_(e5, t2, s4);
      const r = this.isPredicateKnown_(3);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorPoint_(e5, t2);
      const s5 = this.isPredicateKnown_(5);
      n6 && (n6 = s5);
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorPoint_(e5, t2);
      const s5 = this.isPredicateKnown_(6);
      n6 && (n6 = s5);
    }
    return n6;
  }
  linePointPredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorPoint_(e5, t2, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(0);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorPoint_(e5, t2, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(2);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[3]) {
      this.boundaryLineInteriorPoint_(e5, t2, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(3);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorPoint_(e5, t2, s4, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(5);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[6]) {
      this.exteriorLineInteriorPoint_(e5, t2, s4);
      const r = this.isPredicateKnown_(6);
      n6 && (n6 = r);
    }
    return n6;
  }
  pointPointPredicates_(e5, t2, s4) {
    let n6 = true;
    if (this.m_performPredicates[0]) {
      this.interiorPointInteriorPoint_(e5, t2, s4);
      const r = this.isPredicateKnown_(0);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[2]) {
      this.interiorPointExteriorPoint_(e5, t2, s4, 2);
      const r = this.isPredicateKnown_(2);
      n6 && (n6 = r);
    }
    if (this.m_performPredicates[6]) {
      this.interiorPointExteriorPoint_(e5, s4, t2, 6);
      const r = this.isPredicateKnown_(6);
      n6 && (n6 = r);
    }
    return n6;
  }
  interiorAreaInteriorArea_(e5, t2, s4) {
    if (2 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5);
    n6 & t2 && n6 & s4 && (this.m_matrix[0] = 2);
  }
  interiorAreaBoundaryArea_(e5, t2, s4) {
    if (1 === this.m_matrix[s4]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    n6 & t2 && r & t2 && (this.m_matrix[s4] = 1);
  }
  interiorAreaExteriorArea_(e5, t2, s4, n6) {
    if (2 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e5);
    r & t2 && !(r & s4) && (this.m_matrix[n6] = 2);
  }
  boundaryAreaBoundaryArea_(e5, t2, s4) {
    if (1 === this.m_matrix[4]) return;
    const n6 = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (n6 & t2 && n6 & s4) this.m_matrix[4] = 1;
    else if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const n7 = this.m_topoGraph.getHalfEdgeTo(e5), r = this.m_topoGraph.getClusterParentage(n7);
      if (r & t2 && r & s4) return void (this.m_matrix[4] = 0);
    }
  }
  boundaryAreaExteriorArea_(e5, t2, s4, n6) {
    if (1 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e5), i2 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    r & s4 || i2 & s4 || (this.m_matrix[n6] = 1);
  }
  interiorAreaInteriorLine_(e5, t2, s4) {
    if (1 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    n6 & t2 && r & t2 && (this.m_matrix[0] = 1);
  }
  interiorAreaBoundaryLine_(e5, t2, s4, n6) {
    if (0 !== this.m_matrix[1] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (!(i2 & t2)) {
        if (this.m_topoGraph.getHalfEdgeFaceParentage(e5) & t2) {
          const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
          if (i2 & s4 && e6 % 2 != 0) return void (this.m_matrix[1] = 0);
        }
      }
    }
  }
  interiorAreaExteriorLine_(e5, t2, s4) {
    if (2 === this.m_matrix[2]) return;
    this.m_topoGraph.getHalfEdgeParentage(e5) & t2 && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorLine_(e5, t2, s4, n6) {
    if (1 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (r & t2 && r & s4) this.m_matrix[3] = 1;
    else if (0 !== this.m_matrix[3] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r2 = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r2);
      if (i2 & t2) {
        const e6 = this.m_topoGraph.getClusterUserIndex(r2, n6);
        if (i2 & s4 && e6 % 2 == 0) return void (this.m_matrix[3] = 0);
      }
    }
  }
  boundaryAreaBoundaryLine_(e5, t2, s4, n6) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (i2 & t2) {
        const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
        if (i2 & s4 && e6 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryAreaExteriorLine_(e5, t2, s4) {
    if (1 === this.m_matrix[5]) return;
    const n6 = this.m_topoGraph.getHalfEdgeParentage(e5);
    n6 & t2 && !(n6 & s4) && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorLine_(e5, t2) {
    if (1 === this.m_matrix[6]) return;
    const s4 = this.m_topoGraph.getHalfEdgeFaceParentage(e5), n6 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
    s4 & t2 || n6 & t2 || (this.m_matrix[6] = 1);
  }
  exteriorAreaBoundaryLine_(e5, t2, s4, n6) {
    if (0 !== this.m_matrix[7] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e5), i2 = this.m_topoGraph.getClusterParentage(r);
      if (!(i2 & t2)) {
        if (!(this.m_topoGraph.getHalfEdgeFaceParentage(e5) & t2)) {
          const e6 = this.m_topoGraph.getClusterUserIndex(r, n6);
          if (i2 & s4 && e6 % 2 != 0) return void (this.m_matrix[7] = 0);
        }
      }
    }
  }
  interiorLineInteriorLine_(e5, t2, s4, n6, r) {
    if (1 === this.m_matrix[0]) return;
    const i2 = this.m_topoGraph.getHalfEdgeParentage(e5);
    if (i2 & t2 && i2 & s4) this.m_matrix[0] = 1;
    else if (0 !== this.m_matrix[0] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const i3 = this.m_topoGraph.getHalfEdgeTo(e5), o2 = this.m_topoGraph.getClusterParentage(i3);
      if (o2 & t2 && o2 & s4) {
        const e6 = this.m_topoGraph.getClusterUserIndex(i3, n6), t3 = this.m_topoGraph.getClusterUserIndex(i3, r);
        if (e6 % 2 == 0 && t3 % 2 == 0) return void (this.m_matrix[0] = 0);
      }
    }
  }
  interiorLineBoundaryLine_(e5, t2, s4, n6, r, i2) {
    if (0 !== this.m_matrix[i2] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const o2 = this.m_topoGraph.getHalfEdgeTo(e5), a2 = this.m_topoGraph.getClusterParentage(o2);
      if (a2 & t2 && a2 & s4) {
        const e6 = this.m_topoGraph.getClusterUserIndex(o2, n6), t3 = this.m_topoGraph.getClusterUserIndex(o2, r);
        if (e6 % 2 == 0 && t3 % 2 != 0) return void (this.m_matrix[i2] = 0);
      }
    }
  }
  interiorLineExteriorLine_(e5, t2, s4, n6) {
    if (1 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e5);
    r & t2 && !(r & s4) && (this.m_matrix[n6] = 1);
  }
  boundaryLineBoundaryLine_(e5, t2, s4, n6, r) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const i2 = this.m_topoGraph.getHalfEdgeTo(e5), o2 = this.m_topoGraph.getClusterParentage(i2);
      if (o2 & t2 && o2 & s4) {
        const e6 = this.m_topoGraph.getClusterUserIndex(i2, n6), t3 = this.m_topoGraph.getClusterUserIndex(i2, r);
        if (e6 % 2 != 0 && t3 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryLineExteriorLine_(e5, t2, s4, n6, r) {
    if (0 !== this.m_matrix[r] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e5)), this.m_visitedIndex)) {
      const t3 = this.m_topoGraph.getHalfEdgeTo(e5);
      if (!(this.m_topoGraph.getClusterParentage(t3) & s4)) {
        if (this.m_topoGraph.getClusterUserIndex(t3, n6) % 2 != 0) return void (this.m_matrix[r] = 0);
      }
    }
  }
  interiorAreaInteriorPoint_(e5, t2) {
    if (0 === this.m_matrix[0]) return;
    if (!(this.m_topoGraph.getClusterParentage(e5) & t2)) {
      const s4 = this.m_topoGraph.getClusterChain(e5);
      if (this.m_topoGraph.getChainParentage(s4) & t2) return void (this.m_matrix[0] = 0);
    }
  }
  interiorAreaExteriorPoint_(e5, t2) {
    if (2 === this.m_matrix[2]) return;
    this.m_topoGraph.getClusterParentage(e5) & t2 && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorPoint_(e5, t2, s4) {
    if (0 === this.m_matrix[3]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    n6 & t2 && n6 & s4 && (this.m_matrix[3] = 0);
  }
  boundaryAreaExteriorPoint_(e5, t2) {
    if (1 === this.m_matrix[5]) return;
    this.m_topoGraph.getClusterParentage(e5) & t2 && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorPoint_(e5, t2) {
    if (0 === this.m_matrix[6]) return;
    if (!(this.m_topoGraph.getClusterParentage(e5) & t2)) {
      const s4 = this.m_topoGraph.getClusterChain(e5);
      if (!(this.m_topoGraph.getChainParentage(s4) & t2)) return void (this.m_matrix[6] = 0);
    }
  }
  interiorLineInteriorPoint_(e5, t2, s4, n6) {
    if (0 === this.m_matrix[0]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (r & t2 && r & s4) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 == 0) return void (this.m_matrix[0] = 0);
    }
  }
  interiorLineExteriorPoint_(e5, t2, s4, n6) {
    if (1 === this.m_matrix[2]) return;
    if (-1 === this.m_topoGraph.getClusterHalfEdge(e5)) {
      if (0 !== this.m_matrix[2]) {
        if (!(this.m_topoGraph.getClusterParentage(e5) & s4)) return void (this.m_matrix[2] = 0);
      }
    } else this.m_matrix[2] = 1;
  }
  boundaryLineInteriorPoint_(e5, t2, s4, n6) {
    if (0 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (r & t2 && r & s4) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 != 0) return void (this.m_matrix[3] = 0);
    }
  }
  boundaryLineExteriorPoint_(e5, t2, s4, n6) {
    if (0 === this.m_matrix[5]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    if (r & t2 && !(r & s4)) {
      if (this.m_topoGraph.getClusterUserIndex(e5, n6) % 2 != 0) return void (this.m_matrix[5] = 0);
    }
  }
  exteriorLineInteriorPoint_(e5, t2, s4) {
    if (0 === this.m_matrix[6]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    n6 & t2 || !(n6 & s4) || (this.m_matrix[6] = 0);
  }
  interiorPointInteriorPoint_(e5, t2, s4) {
    if (0 === this.m_matrix[0]) return;
    const n6 = this.m_topoGraph.getClusterParentage(e5);
    n6 & t2 && n6 & s4 && (this.m_matrix[0] = 0);
  }
  interiorPointExteriorPoint_(e5, t2, s4, n6) {
    if (0 === this.m_matrix[n6]) return;
    const r = this.m_topoGraph.getClusterParentage(e5);
    !(r & t2) || r & s4 || (this.m_matrix[n6] = 0);
  }
  computeMatrixTopoGraphHalfEdges_(e5, t2) {
    let s4 = false;
    const n6 = this.m_topoGraph.getGeometryID(e5), r = this.m_topoGraph.getGeometryID(t2);
    this.m_visitedIndex = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== bm; i2 = this.m_topoGraph.getNextCluster(i2)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(i2);
      if (e6 === bm) {
        if (null !== this.m_predicatesCluster && (s4 = this.m_predicatesCluster(i2, n6, r), s4)) break;
        continue;
      }
      let t3 = e6;
      do {
        let e7 = t3;
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(e7, this.m_visitedIndex)) do {
          if (s4 = this.m_predicatesHalfEdge(e7, n6, r), s4) break;
          this.m_topoGraph.setHalfEdgeUserIndex(e7, this.m_visitedIndex, 1), e7 = this.m_topoGraph.getHalfEdgeNext(e7);
        } while (e7 !== t3 && !s4);
        if (s4) break;
        t3 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e7));
      } while (t3 !== e6);
      if (s4) break;
    }
    s4 || this.setRemainingPredicatesToFalse_(), this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex);
  }
  computeMatrixTopoGraphClusters_(e5, t2) {
    let s4 = false;
    const n6 = this.m_topoGraph.getGeometryID(e5), r = this.m_topoGraph.getGeometryID(t2);
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== bm && (s4 = this.m_predicatesCluster(i2, n6, r), !s4); i2 = this.m_topoGraph.getNextCluster(i2)) ;
    s4 || this.setRemainingPredicatesToFalse_();
  }
  setEditShape_(e5, t2) {
    this.m_topoGraph.setEditShape(e5, t2);
  }
  setEditShapeCrackAndCluster_(e5, t2, s4) {
    let n6 = 0;
    if (e5.hasCurves()) {
      const r = new ca2(), i2 = e5.getEnvelope2D(s4), o2 = la2(t2.total(), i2);
      n6 = ua2(o2, 0), ra2(e5, o2, t2.total(), 12e3, r, null, s4), r.clearStitcher(e5);
    }
    da2(e5, t2.add(n6), s4, false, false), e5.filterClosePoints(0, true, true, false, bm);
    for (let r = e5.getFirstGeometry(); r !== bm; r = e5.getNextGeometry(r)) e5.getGeometryType(r) === a.enumPolygon && Qn2(e5, r, -1, false, bm, s4);
    this.setEditShape_(e5, s4);
  }
};
function br2(e5) {
  const t2 = e5[1], s4 = e5[2], n6 = e5[5];
  e5[1] = e5[3], e5[2] = e5[6], e5[5] = e5[7], e5[3] = t2, e5[6] = s4, e5[7] = n6;
}
function wr2(t2, s4, n6) {
  const r = t2.getGeometryType();
  if (f(r)) {
    const e5 = new Na({ vd: t2.getDescription() });
    return e5.addSegment(t2, true), e5;
  }
  if (r === a.enumEnvelope) {
    const n7 = t2, r2 = n4.constructEmpty();
    if (t2.queryEnvelope(r2), r2.height() <= s4 && r2.width() <= s4) {
      const e5 = new ee({ vd: t2.getDescription() });
      return n7.getCenter(e5), e5;
    }
    if (r2.height() <= s4 || r2.width() <= s4) {
      const e5 = new Na({ vd: t2.getDescription() }), s5 = new ee();
      return n7.queryCornerByVal(0, s5), e5.startPathPoint(s5), n7.queryCornerByVal(2, s5), e5.lineToPoint(s5), e5;
    }
    const i2 = new eh({ vd: t2.getDescription() });
    return i2.addEnvelope(n7, false), i2;
  }
  return t2;
}
function vr2(e5) {
  return `${e5[0]}${e5[3]}${e5[6]}${e5[1]}${e5[4]}${e5[7]}${e5[2]}${e5[5]}${e5[8]}`;
}
var Nr2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor(t2, s4, n6, r = false) {
    this.m_bDone = false, this.m_tolerance = 0, this.m_elementHandle = -1, this.m_query = n4.constructEmpty(), this.m_envInter = n4.constructEmpty(), this.m_quadTree = null, this.m_intersector = null, this.m_function = this.nullFunc;
    const i2 = t2.getAccelerators();
    let o2 = null;
    null != i2 && (o2 = r ? i2.getQuadTreeForPaths() : i2.getQuadTree());
    const a2 = s4.getAccelerators();
    let m2 = null;
    if (null != a2 && (m2 = r ? a2.getQuadTreeForPaths() : a2.getQuadTree()), null === o2 && null === m2 && !r) {
      const r2 = t2.getPointCount(), i3 = s4.getPointCount();
      if (r2 > 10 && i3 > 10) {
        const a3 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = n4.constructEmpty();
        t2.queryLooseEnvelope(a3), s4.queryLooseEnvelope(l2), a3.inflateCoords(n6, n6), l2.inflateCoords(n6, n6), g2.setCoords({ env2D: a3 }), g2.intersect(l2), r2 >= i3 ? o2 = h(t2.getGeometryType()) ? Wt(t2, g2) : Jt(t2, g2) : m2 = h(s4.getGeometryType()) ? Wt(s4, g2) : Jt(s4, g2);
      }
    }
    this.construct_(t2, o2, s4, m2, n6, r);
  }
  next() {
    if (this.m_bQuadTree) {
      if (this.m_bDone) return false;
      for (; this.m_function(); ) ;
      return !this.m_bDone;
    }
    return !!this.m_intersector && this.m_intersector.next();
  }
  getRedElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElement(this.m_elementHandle) : h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_bSwapElements ? this.m_intersector.getBlueElement(this.m_intersector.getHandleB()) : this.m_intersector.getRedElement(this.m_intersector.getHandleA());
  }
  getBlueElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_quadTree.getElement(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedElement(this.m_intersector.getHandleA()) : this.m_intersector.getBlueElement(this.m_intersector.getHandleB());
  }
  getRedEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_query : this.m_bSwapElements ? this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()) : this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA());
  }
  getBlueEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_query : this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()) : this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB());
  }
  construct_(t2, s4, n6, r, i2, a2) {
    const m2 = n4.constructEmpty(), l2 = n4.constructEmpty();
    t2.queryLooseEnvelope(m2), n6.queryLooseEnvelope(l2), m2.inflateCoords(i2, i2), l2.inflateCoords(i2, i2), this.m_envInter.setCoords({ env2D: m2 }), this.m_envInter.intersect(l2), this.m_multiVertexImplA = t2, this.m_multiVertexImplB = n6;
    const g2 = t2.getGeometryType(), u = n6.getGeometryType();
    this.m_bPaths = a2, this.m_pathIndex = -1, this.m_pointIndex = -1, this.m_bSwapElements = false, this.m_queryType = a.enumUnknown, this.m_bQuadTree = false, null !== s4 && (this.m_bDone = false, this.m_tolerance = i2, this.m_quadTree = s4, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = true, h(u) ? (this.m_queryType = u, this.m_function = this.nextPath_, a2 ? this.m_pathIndex = n6.getPathCount() : this.m_segIter = n6.querySegmentIterator()) : (this.m_queryType = u, this.m_function = this.nextPoint_, this.m_pointIndex = n6.getPointCount())), this.m_bQuadTree || null !== r && (this.m_bDone = false, this.m_tolerance = i2, this.m_quadTree = r, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = false, h(g2) ? (this.m_queryType = g2, this.m_function = this.nextPath_, a2 ? this.m_pathIndex = t2.getPathCount() : this.m_segIter = t2.querySegmentIterator()) : (this.m_queryType = g2, this.m_function = this.nextPoint_, this.m_pointIndex = t2.getPointCount())), this.m_bQuadTree || (a2 && h(g2) && h(u) ? this.m_intersector = Ut2(t2, n6, i2) : h(g2) && h(u) ? (this.m_intersector = Xt(t2, n6, i2), this.m_bSwapElements = false) : h(g2) && !h(u) ? (this.m_intersector = Gt2(t2, n6, i2), this.m_bSwapElements = false) : !h(g2) && h(u) ? (this.m_intersector = Gt2(n6, t2, i2), this.m_bSwapElements = true) : (this.m_intersector = Zt2(t2, n6, i2), this.m_bSwapElements = false));
  }
  nextPath_() {
    return this.m_bPaths ? -1 == --this.m_pathIndex ? (this.m_bDone = true, false) : (this.m_bSwapElements ? this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex, this.m_query) : this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex, this.m_query), this.m_qtIter.resetIterator(this.m_query, this.m_tolerance), this.m_function = this.iterate_, true) : this.m_segIter.nextPath() ? (this.m_function = this.nextSegment_, true) : (this.m_bDone = true, false);
  }
  nextSegment_() {
    if (!this.m_segIter.hasNextSegment()) return this.m_function = this.nextPath_, true;
    const t2 = this.m_segIter.nextSegment(), s4 = new n4();
    return t2.queryLooseEnvelope(s4), !s4.isIntersecting(this.m_envInter) || (this.m_qtIter.resetIterator(t2, this.m_tolerance), this.m_function = this.iterate_, true);
  }
  nextPoint_() {
    if (-1 == --this.m_pointIndex) return this.m_bDone = true, false;
    const t2 = new ei();
    if (this.m_bSwapElements) {
      const e5 = this.m_multiVertexImplB.getXY(this.m_pointIndex);
      t2.setCoordsPoint2D(e5);
    } else {
      const e5 = this.m_multiVertexImplA.getXY(this.m_pointIndex);
      t2.setCoordsPoint2D(e5);
    }
    return !this.m_envInter.contains(t2) || (this.m_qtIter.resetIterator(n4.construct(t2.x, t2.y, t2.x, t2.y), this.m_tolerance), this.m_function = this.iterate_, true);
  }
  iterate_() {
    return this.m_elementHandle = this.m_qtIter.next(), -1 === this.m_elementHandle && (h(this.m_queryType) ? (this.m_function = this.m_bPaths ? this.nextPath_ : this.nextSegment_, true) : (this.m_function = this.nextPoint_, true));
  }
};
function Tr2(e5) {
  return 2 === e5 ? 1 : 1 === e5 ? 2 : 128 === e5 ? 64 : 64 === e5 ? 128 : e5;
}
function Gr2(t2, s4, n6) {
  let r;
  if (t2 instanceof sc || null === t2) {
    const i2 = n4.constructEmpty();
    i2.setCoords({ pt: s4 }), i2.mergeEnvelope2D(n6), r = Bt2(t2, i2, false);
  } else r = t2;
  return r;
}
function Dr2(t2, s4, n6) {
  let r;
  if (t2 instanceof sc || null === t2) {
    const i2 = n4.constructEmpty();
    i2.setCoords({ env2D: s4 }), i2.mergeEnvelope2D(n6), r = Bt2(t2, i2, false);
  } else r = t2;
  return r;
}
function Vr2(t2, s4, n6, i2, h2) {
  if (t2.isEmpty() || s4.isEmpty()) return 4 === i2;
  j(t2), j(s4);
  let m2 = t2.getGeometryType(), l2 = s4.getGeometryType();
  if (m2 === a.enumEnvelope) {
    if (l2 === a.enumEnvelope) return Fr2(t2, s4, n6, i2);
    if (l2 === a.enumPoint) return Hr2(s4, t2, n6, Tr2(i2));
  } else if (m2 === a.enumPoint) {
    if (l2 === a.enumEnvelope) return Hr2(t2, s4, n6, i2);
    if (l2 === a.enumPoint) return kr2(t2, s4, n6, i2);
  }
  const g2 = n4.constructEmpty();
  t2.queryEnvelope(g2);
  const u = n4.constructEmpty();
  s4.queryEnvelope(u);
  const c = Dr2(n6, g2, u);
  if (Ar2(g2, u, c)) return 4 === i2;
  let _ = false, d2 = null, p3 = null, f3 = null, x4 = null;
  switch (f(m2) ? (d2 = new Na({ vd: t2.getDescription() }), d2.addSegment(t2, true), f3 = d2, m2 = a.enumPolyline) : f3 = t2, f(l2) ? (p3 = new Na({ vd: s4.getDescription() }), p3.addSegment(s4, true), x4 = p3, l2 = a.enumPolyline) : x4 = s4, m2 !== a.enumEnvelope && l2 !== a.enumEnvelope ? (f3.getDimension() < x4.getDimension() || m2 === a.enumPoint && l2 === a.enumMultiPoint) && (i2 = Tr2(i2)) : m2 !== a.enumPolygon && l2 !== a.enumEnvelope && (i2 = Tr2(i2)), m2) {
    case a.enumPolygon:
      switch (l2) {
        case a.enumPolygon:
          _ = qr2(f3, x4, c, i2, h2);
          break;
        case a.enumPolyline:
          _ = Or2(f3, x4, c, i2, h2);
          break;
        case a.enumPoint:
          _ = Br2(f3, x4, c, i2);
          break;
        case a.enumMultiPoint:
          _ = Rr2(f3, x4, c, i2);
          break;
        case a.enumEnvelope:
          _ = Yr2(f3, x4, c, i2, h2);
      }
      break;
    case a.enumPolyline:
      switch (l2) {
        case a.enumPolygon:
          _ = Or2(x4, f3, c, i2, h2);
          break;
        case a.enumPolyline:
          _ = Xr2(f3, x4, c, i2, h2);
          break;
        case a.enumPoint:
          _ = Lr2(f3, x4, c, i2);
          break;
        case a.enumMultiPoint:
          _ = zr2(f3, x4, c, i2);
          break;
        case a.enumEnvelope:
          _ = Wr2(f3, x4, c, i2, h2);
      }
      break;
    case a.enumPoint:
      switch (l2) {
        case a.enumPolygon:
          _ = Br2(x4, f3, c, i2);
          break;
        case a.enumPolyline:
          _ = Lr2(x4, f3, c, i2);
          break;
        case a.enumMultiPoint:
          _ = Zr2(x4, f3, c, i2);
      }
      break;
    case a.enumMultiPoint:
      switch (l2) {
        case a.enumPolygon:
          _ = Rr2(x4, f3, c, i2);
          break;
        case a.enumPolyline:
          _ = zr2(x4, f3, c, i2);
          break;
        case a.enumMultiPoint:
          _ = jr2(f3, x4, c, i2);
          break;
        case a.enumPoint:
          _ = Zr2(f3, x4, c, i2);
          break;
        case a.enumEnvelope:
          _ = Kr2(f3, x4, c, i2);
      }
      break;
    case a.enumEnvelope:
      switch (l2) {
        case a.enumPolygon:
          _ = Yr2(x4, f3, c, i2, h2);
          break;
        case a.enumPolyline:
          _ = Wr2(x4, f3, c, i2, h2);
          break;
        case a.enumMultiPoint:
          _ = Kr2(x4, f3, c, i2);
      }
  }
  return _;
}
function Fr2(t2, s4, n6, r, i2) {
  if (t2.isEmpty() || s4.isEmpty()) return 4 === r;
  const o2 = n4.constructEmpty();
  t2.queryEnvelope(o2);
  const a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = Dr2(n6, o2, a2);
  switch (r) {
    case 4:
      return Ar2(o2, a2, h2);
    case 2:
      return ho2(a2, o2, h2, false);
    case 128:
      return ho2(a2, o2, h2, true);
    case 1:
      return ho2(o2, a2, h2, false);
    case 64:
      return ho2(o2, a2, h2, true);
    case 3:
      return io2(o2, a2, h2);
    case 8:
      return oo2(o2, a2, h2);
    case 32:
      return ao2(o2, a2, h2);
    case 16:
      return false;
  }
  return false;
}
function Hr2(t2, s4, n6, r, i2) {
  if (t2.isEmpty() || s4.isEmpty()) return 4 === r;
  const o2 = t2.getXY(), a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = Gr2(n6, o2, a2);
  switch (r) {
    case 4:
      return Ur2(o2, a2, h2);
    case 2:
    case 128:
      return ro2(o2, a2, h2);
    case 1:
    case 64:
      return false;
    case 3:
      return so(o2, a2, h2);
    case 8:
      return no(o2, a2, h2);
  }
  return false;
}
function kr2(t2, s4, n6, r, i2) {
  if (t2.isEmpty() || s4.isEmpty()) return 4 === r;
  const o2 = t2.getXY(), a2 = s4.getXY();
  let h2;
  if (n6 instanceof sc || null === n6) {
    const t3 = n4.constructEmpty();
    t3.setCoords({ pt: o2 }), t3.merge(a2), h2 = Bt2(n6, t3, false);
  } else h2 = n6;
  switch (r) {
    case 4:
      return eo2(o2, a2, h2);
    case 2:
    case 128:
      return to2(a2, o2, h2);
    case 1:
    case 64:
      return to2(o2, a2, h2);
    case 3:
      return $i2(o2, a2, h2);
  }
  return false;
}
function Ar2(t2, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), !t2.isIntersecting(r);
}
function Mr2(e5, t2, n6, r = false) {
  const i2 = e5.getGeometryType(), o2 = t2.getGeometryType();
  if (y(i2)) {
    const t3 = e5.getImpl().getAccelerators();
    if (null !== t3) {
      const e6 = t3.getRasterizedGeometry();
      n2(null === e6);
    }
  }
  if (y(o2)) {
    const e6 = t2.getImpl().getAccelerators();
    if (null !== e6) {
      const t3 = e6.getRasterizedGeometry();
      n2(null === t3);
    }
  }
  return 0;
}
function Ur2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty();
  return i2.setCoords({ env2D: s4 }), i2.inflateCoords(n6, n6), !i2.contains(t2);
}
function qr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Jr2(e5, t2, s4);
    case 2:
      return ti3(t2, e5, s4, r);
    case 128:
      return si3(t2, e5, s4);
    case 1:
      return ti3(e5, t2, s4, r);
    case 64:
      return si3(e5, t2, s4);
    case 3:
      return Qr2(e5, t2, s4, r);
    case 8:
      return $r2(e5, t2, s4);
    case 32:
      return ei3(e5, t2, s4, r);
  }
  return false;
}
function Or2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return ni2(e5, t2, s4);
    case 1:
      return oi2(e5, t2, s4, r);
    case 64:
      return ai2(e5, t2, s4);
    case 8:
      return ri2(e5, t2, s4, r);
    case 16:
      return ii3(e5, t2, s4);
  }
  return false;
}
function Br2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return hi2(e5, t2, s4);
    case 1:
    case 64:
      return li2(e5, t2, s4);
    case 8:
      return mi2(e5, t2, s4);
  }
  return false;
}
function Rr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return gi2(e5, t2, s4);
    case 1:
      return _i2(e5, t2, s4, false);
    case 64:
      return _i2(e5, t2, s4, true);
    case 8:
      return ui2(e5, t2, s4);
    case 16:
      return ci2(e5, t2, s4);
  }
  return false;
}
function Yr2(e5, t2, s4, n6, r) {
  if (pi2(e5, t2, s4)) return 4 === n6;
  if (4 === n6) return false;
  switch (n6) {
    case 2:
      return yi2(e5, t2, s4, false);
    case 128:
      return yi2(e5, t2, s4, true);
    case 1:
      return Pi2(e5, t2, s4, false, r);
    case 64:
      return Pi2(e5, t2, s4, true, r);
    case 3:
      return di2(e5, t2, s4, r);
    case 8:
      return fi2(e5, t2, s4, r);
    case 32:
      return xi2(e5, t2, s4, r);
    case 16:
      return false;
  }
  return false;
}
function Xr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Ci2(e5, t2, s4);
    case 2:
      return wi2(t2, e5, s4, r);
    case 128:
      return vi2(t2, e5, s4, r);
    case 1:
      return wi2(e5, t2, s4, r);
    case 64:
      return vi2(e5, t2, s4, r);
    case 3:
      return Ei2(e5, t2, s4, r);
    case 8:
      return Si2(e5, t2, s4, r);
    case 32:
      return bi2(e5, t2, s4, r);
    case 16:
      return Ii2(e5, t2, s4, r);
  }
  return false;
}
function Lr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Ni2(e5, t2, s4);
    case 1:
    case 64:
      return Gi2(e5, t2, s4);
    case 8:
      return Ti2(e5, t2, s4);
  }
  return false;
}
function zr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Di2(e5, t2, s4);
    case 1:
    case 64:
      return Hi2(e5, t2, s4);
    case 8:
      return Vi2(e5, t2, s4);
    case 16:
      return Fi2(e5, t2, s4);
  }
  return false;
}
function Wr2(e5, t2, s4, n6, r) {
  if (Ai2(e5, t2, s4)) return 4 === n6;
  if (4 === n6) return false;
  switch (n6) {
    case 2:
      return Ui2(e5, t2, s4, false);
    case 128:
      return Ui2(e5, t2, s4, true);
    case 1:
    case 64:
    case 32:
      return false;
    case 3:
      return ki2(e5, t2, s4);
    case 8:
      return Mi2(e5, t2, s4, r);
    case 16:
      return qi2(e5, t2, s4);
  }
  return false;
}
function jr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Bi2(e5, t2, s4);
    case 2:
    case 128:
      return Yi2(t2, e5, s4);
    case 1:
    case 64:
      return Yi2(e5, t2, s4);
    case 3:
      return Oi2(e5, t2, s4);
    case 32:
      return Ri2(e5, t2, s4);
  }
  return false;
}
function Zr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Li2(e5, t2, s4);
    case 2:
    case 128:
      return zi2(e5, t2, s4);
    case 1:
    case 64:
      return Wi2(e5, t2, s4);
    case 3:
      return Xi2(e5, t2, s4);
  }
  return false;
}
function Kr2(e5, t2, s4, n6, r) {
  switch (n6) {
    case 4:
      return Zi2(e5, t2, s4);
    case 2:
      return Qi2(e5, t2, s4, false);
    case 128:
      return Qi2(e5, t2, s4, true);
    case 1:
    case 64:
      return false;
    case 3:
      return ji2(e5, t2, s4);
    case 8:
      return Ki2(e5, t2, s4);
    case 16:
      return Ji2(e5, t2, s4);
  }
  return false;
}
function Qr2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), !io2(i2, o2, n6)) return false;
  if (Mr2(t2, s4), po2(t2, s4, n6)) return true;
  const a2 = t2.calculateLength2D(), h2 = s4.calculateLength2D(), m2 = Math.max(t2.getPointCount(), s4.getPointCount());
  if (Math.abs(a2 - h2) > 4 * m2 * n6) return false;
  if (t2.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return $n2(t2, s4, n6, "**F**FFF*", r, false);
  }
  return yo2(t2, s4, n6, true);
}
function Jr2(e5, t2, s4, n6) {
  Mr2(e5, t2, s4, true);
  return 1 === mo2(e5, t2, s4, true);
}
function $r2(e5, t2, s4, n6) {
  return Mr2(e5, t2), vo2(e5, t2, s4, null);
}
function ei3(e5, t2, s4, n6) {
  return Mr2(e5, t2), No2(e5, t2, s4, n6);
}
function ti3(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!uo2(i2, o2, n6) && (Mr2(t2, s4), To2(t2, s4, n6, r));
}
function si3(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!uo2(i2, o2, n6) && (Mr2(t2, s4), 2 === mo2(t2, s4, n6, false));
}
function ni2(e5, t2, s4, n6) {
  Mr2(e5, t2, s4, true);
  return 1 === mo2(e5, t2, s4, true);
}
function ri2(e5, t2, s4, n6) {
  return Mr2(e5, t2), Go2(e5, t2, s4, n6);
}
function ii3(e5, t2, s4, n6) {
  return Mr2(e5, t2), Do2(e5, t2, s4, null);
}
function oi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!uo2(i2, o2, n6) && (Mr2(t2, s4), Vo2(t2, s4, n6, r));
}
function ai2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!uo2(i2, o2, n6) && (Mr2(t2, s4), 2 === mo2(t2, s4, n6, false));
}
function hi2(e5, t2, s4, n6) {
  return 0 === Bo2(e5, t2, s4);
}
function mi2(e5, t2, s4, n6) {
  return Ho2(e5, t2.getXY(), s4);
}
function li2(e5, t2, s4, n6) {
  return Fo2(e5, t2.getXY(), s4);
}
function gi2(e5, t2, s4, n6, r) {
  Mr2(e5, t2);
  return 1 === lo2(e5, t2, s4);
}
function ui2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = n4.constructEmpty();
  t2.queryEnvelope(i2), i2.inflateCoords(n6, n6);
  const o2 = new ei();
  let a2 = false;
  const h2 = t2.getImpl(), m2 = new eh();
  let l2 = t2, g2 = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, o2), i2.contains(o2)) {
      const e6 = Ro2(l2, o2, n6);
      if (2 === e6) a2 = true;
      else if (1 === e6) return false;
    }
    g2 || (!Xn2(t2, s4.getPointCount() - 1) || null !== h2.getAccelerators() && null !== h2.getAccelerators().getQuadTree() ? l2 = t2 : (t2.copyTo(m2), m2.getImpl().buildQuadTreeAccelerator(1), l2 = m2), g2 = true);
  }
  return !!a2;
}
function ci2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = new n4(), o2 = new n4(), a2 = new n4();
  t2.queryEnvelope(i2), s4.queryEnvelope(a2), o2.setCoords({ env2D: i2 }), o2.inflateCoords(n6, n6);
  let h2 = false, m2 = false;
  const l2 = new ei(), g2 = t2.getImpl(), u = new eh();
  let c = t2, _ = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, l2), o2.contains(l2)) {
      const e6 = Ro2(c, l2, n6);
      0 === e6 ? m2 = true : 1 === e6 && (h2 = true);
    } else m2 = true;
    if (h2 && m2) return true;
    _ || (!Xn2(t2, s4.getPointCount() - 1) || null !== g2.getAccelerators() && null !== g2.getAccelerators().getQuadTree() ? c = t2 : (t2.copyTo(u), u.getImpl().buildQuadTreeAccelerator(1), c = u), _ = true);
  }
  return false;
}
function _i2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t2.queryEnvelope(o2), s4.queryEnvelope(a2), !uo2(o2, a2, n6)) return false;
  Mr2(t2, s4);
  let h2 = false;
  const m2 = new ei(), l2 = t2.getImpl(), g2 = new eh();
  let u = t2, c = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, m2), !o2.contains(m2)) return false;
    const i3 = Ro2(u, m2, n6);
    if (1 === i3) h2 = true;
    else if (0 === i3) return false;
    if (r && 2 === i3) return false;
    c || (!Xn2(t2, s4.getPointCount() - 1) || null !== l2.getAccelerators() && null !== l2.getAccelerators().getQuadTree() ? u = t2 : (t2.copyTo(g2), g2.getImpl().buildQuadTreeAccelerator(1), u = g2), c = true);
  }
  return h2;
}
function di2(t2, s4, n6, r) {
  const i2 = new n4(), o2 = new n4();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), !io2(i2, o2, n6)) return false;
  const a2 = new eh();
  return a2.addEnvelope(s4, false), Qr2(t2, a2, n6, r);
}
function pi2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), uo2(o2, i2, n6)) return false;
  return 0 === Ro2(t2, o2.getLowerLeft(), 0) && (!o2.contains(t2.getXY(0)) && !wo2(t2, o2, n6));
}
function fi2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = new n4(), o2 = new n4();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), uo2(o2, i2, n6)) return false;
  if (o2.height() <= n6 || o2.width() <= n6) return false;
  const a2 = new eh();
  return a2.addEnvelope(s4, false), vo2(t2, a2, n6, r);
}
function xi2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = new n4(), o2 = new n4();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), uo2(o2, i2, n6)) return false;
  if (o2.height() <= n6 || o2.width() <= n6) return false;
  const a2 = new eh();
  return a2.addEnvelope(s4, false), No2(t2, a2, n6, r);
}
function yi2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  return t2.queryEnvelope(o2), s4.queryEnvelope(a2), r ? co2(a2, o2, n6) : uo2(a2, o2, n6);
}
function Pi2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t2.queryEnvelope(o2), s4.queryEnvelope(a2), !uo2(o2, a2, n6)) return false;
  Mr2(t2, s4);
  const h2 = new eh();
  return h2.addEnvelope(s4, false), r ? 2 === mo2(t2, h2, n6, false) : To2(t2, h2, n6, i2);
}
function Ei2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), !io2(i2, o2, n6)) return false;
  if (Mr2(t2, s4), po2(t2, s4, n6)) return true;
  if (t2.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return $n2(t2, s4, n6, "**F**FFF*", r, false);
  }
  return yo2(t2, s4, n6, false);
}
function Ci2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  const r = e5.getImpl(), i2 = t2.getImpl();
  return !new Nr2(r, i2, s4, true).next() || !Eo2(e5, t2, s4);
}
function Si2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = [], o2 = Co2(t2, s4, n6, i2);
  if (-2 === o2) {
    const i3 = n4.constructEmpty(), o3 = n4.constructEmpty(), a3 = n4.constructEmpty();
    let h3, m3;
    if (t2.queryEnvelope(i3), s4.queryEnvelope(o3), i3.inflateCoords(1e3 * n6, 1e3 * n6), o3.inflateCoords(1e3 * n6, 1e3 * n6), a3.setCoords({ env2D: i3 }), a3.intersect(o3), t2.getPointCount() > 10) {
      if (h3 = f2(t2, a3, n6, 0, r), h3.isEmpty()) return false;
    } else h3 = t2;
    if (s4.getPointCount() > 10) {
      if (m3 = f2(s4, a3, n6, 0, r), m3.isEmpty()) return false;
    } else m3 = s4;
    return $n2(h3, m3, n6, "F********", r, false);
  }
  if (0 !== o2) return false;
  const a2 = new Ce();
  for (let e5 = 0; e5 < i2.length; e5 += 2) {
    const t3 = i2[e5], s5 = i2[e5 + 1];
    a2.addXY(t3, s5);
  }
  const h2 = t2.getBoundary(), m2 = s4.getBoundary();
  return h2.addPoints(m2, 0, m2.getPointCount()), !h2.isEmpty() && Yi2(h2, a2, n6);
}
function Ii2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = [], o2 = Co2(t2, s4, n6, i2);
  if (-2 === o2) {
    const i3 = n4.constructEmpty(), o3 = n4.constructEmpty(), a3 = n4.constructEmpty();
    let h3, m3;
    if (t2.queryEnvelope(i3), s4.queryEnvelope(o3), i3.inflateCoords(1e3 * n6, 1e3 * n6), o3.inflateCoords(1e3 * n6, 1e3 * n6), a3.setCoords({ env2D: i3 }), a3.intersect(o3), t2.getPointCount() > 10) {
      if (h3 = f2(t2, a3, n6, 0, r), h3.isEmpty()) return false;
    } else h3 = t2;
    if (s4.getPointCount() > 10) {
      if (m3 = f2(s4, a3, n6, 0, r), m3.isEmpty()) return false;
    } else m3 = s4;
    return $n2(h3, m3, n6, "0********", r, false);
  }
  if (0 !== o2) return false;
  const a2 = new Ce();
  for (let e5 = 0; e5 < i2.length; e5 += 2) {
    const t3 = i2[e5], s5 = i2[e5 + 1];
    a2.addXY(t3, s5);
  }
  const h2 = t2.getBoundary(), m2 = s4.getBoundary();
  return h2.addPoints(m2, 0, m2.getPointCount()), !!h2.isEmpty() || !Yi2(h2, a2, n6);
}
function bi2(t2, s4, n6, r) {
  Mr2(t2, s4);
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  t2.queryEnvelope(i2), s4.queryEnvelope(o2);
  const a2 = _o2(i2, o2, n6), h2 = _o2(o2, i2, n6), m2 = t2.hasNonLinearSegments(), l2 = s4.hasNonLinearSegments(), g2 = Co2(t2, s4, n6, null);
  if (-1 === g2) return false;
  if (1 === g2) {
    if (a2 && h2) return true;
    if (!m2 && !l2) return a2 && !h2 ? !Po2(s4, t2, n6, false) : h2 && !a2 ? !Po2(t2, s4, n6, false) : !Po2(t2, s4, n6, false) && !Po2(s4, t2, n6, false);
  }
  const u = n4.constructEmpty(), c = n4.constructEmpty(), _ = n4.constructEmpty();
  let d2, p3;
  u.setCoords({ env2D: i2 }), u.inflateCoords(1e3 * n6, 1e3 * n6), c.setCoords({ env2D: o2 }), c.inflateCoords(1e3 * n6, 1e3 * n6), _.setCoords({ env2D: u }), _.intersect(c);
  let f3 = "";
  if (f3 += "1*", a2) {
    if (s4.getPointCount() > 10) {
      if (p3 = f2(s4, _, n6, 0, r), p3.isEmpty()) return false;
    } else p3 = s4;
    f3 += "****";
  } else p3 = s4, f3 += "T***";
  if (h2) {
    if (t2.getPointCount() > 10) {
      if (d2 = f2(t2, _, n6, 0, r), d2.isEmpty()) return false;
    } else d2 = t2;
    f3 += "***";
  } else d2 = t2, f3 += "T**";
  return $n2(d2, p3, n6, f3, r, false);
}
function wi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), !uo2(i2, o2, n6)) return false;
  if (Mr2(t2, s4), t2.hasNonLinearSegments() || s4.hasNonLinearSegments()) {
    return $n2(t2, s4, n6, "******FF*", r, false);
  }
  return Po2(s4, t2, n6, false);
}
function vi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), !uo2(i2, o2, n6)) return false;
  Mr2(t2, s4);
  return $n2(t2, s4, n6, "T**FF*FF*", r, false);
}
function Ni2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  return !Io2(e5, t2.getXY(), s4);
}
function Ti2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  return Ao2(e5, t2.getXY(), s4);
}
function Gi2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  return bo2(e5, t2.getXY(), s4);
}
function Di2(e5, t2, s4, n6) {
  return Mr2(e5, t2), !So2(e5, t2, s4, false);
}
function Vi2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  const r = e5.getImpl(), i2 = t2.getImpl(), o2 = new Ce(), a2 = new Nr2(r, i2, s4, false), h2 = r.querySegmentIterator();
  let m2 = false;
  for (; a2.next(); ) {
    const e6 = a2.getRedElement(), t3 = a2.getBlueElement();
    h2.resetToVertex(e6, -1);
    const n7 = h2.nextSegment(), r2 = i2.getXY(t3);
    n7.isIntersectingPoint(r2, s4) && (m2 = true, o2.addPoint2D(r2));
  }
  if (!m2) return false;
  const l2 = e5.getBoundary();
  return !l2.isEmpty() && Yi2(l2, o2, s4);
}
function Fi2(e5, t2, s4, n6) {
  Mr2(e5, t2);
  const r = e5.getImpl(), i2 = t2.getImpl(), o2 = i2.getPointCount(), a2 = Lt(o2, false), h2 = new Nr2(r, i2, s4, false), m2 = r.querySegmentIterator();
  let l2 = false;
  for (; h2.next(); ) {
    const e6 = h2.getRedElement(), t3 = h2.getBlueElement();
    m2.resetToVertex(e6, -1);
    const n7 = m2.nextSegment(), r2 = i2.getXY(t3);
    n7.isIntersectingPoint(r2, s4) && (l2 = true, a2[t3] = true);
  }
  if (!l2) return false;
  let g2 = false;
  for (let _ = 0; _ < o2; _++) if (!a2[_]) {
    g2 = true;
    break;
  }
  if (!g2) return false;
  const u = e5.getBoundary();
  if (u.isEmpty()) return true;
  const c = new Ce();
  for (let _ = 0; _ < o2; _++) a2[_] && c.addPoint2D(i2.getXY(_));
  return !Yi2(u, c, s4);
}
function Hi2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t2.queryEnvelope(o2), s4.queryEnvelope(a2), !uo2(o2, a2, n6)) return false;
  Mr2(t2, s4);
  const h2 = So2(t2, s4, n6, true);
  if (!h2) return h2;
  const m2 = t2.getBoundary();
  return m2.isEmpty() ? h2 : !Yi2(m2, s4, n6);
}
function ki2(t2, s4, n6, r) {
  const i2 = new n4(), o2 = new n4();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !(o2.height() > n6 && o2.width() > n6) && io2(i2, o2, n6);
}
function Ai2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  t2.queryEnvelope(i2), s4.queryEnvelope(o2);
  const a2 = Mo2(o2, i2, n6);
  return 0 === a2 ? !wo2(t2, o2, n6) : 4 === a2;
}
function Mi2(t2, s4, n6, r) {
  const i2 = new n4(), a2 = new n4();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(a2), a2.height() <= n6 || a2.width() <= n6) return false;
  const h2 = new n4(), m2 = new n4();
  if (h2.setCoords({ env2D: a2 }), m2.setCoords({ env2D: a2 }), h2.inflateCoords(n6, n6), m2.inflateCoords(-n6, -n6), m2.containsEnvelope(i2) || !i2.isIntersecting(h2)) return false;
  const l2 = t2.getImpl().querySegmentIterator();
  l2.stripAttributes();
  const u = t2.getImpl().getAccelerators();
  let c = null, _ = null;
  null !== u && (c = u.getQuadTree(), null !== c && (_ = c.getIterator(a2, n6))), _ || l2.nextPath() || b("relational_operations");
  let d2 = false, p3 = null;
  const f3 = new ei(), x4 = new ei(), y2 = t2.hasNonLinearSegments();
  let P5 = false;
  for (; ; ) {
    if (null !== _) {
      const e5 = _.next();
      if (-1 === e5) break;
      l2.resetToVertex(c.getElement(e5), -1), p3 = l2.nextSegment();
    } else {
      for (; !l2.hasNextSegment() && l2.nextPath(); ) ;
      if (!l2.hasNextSegment()) break;
      p3 = l2.nextSegment();
    }
    if (y2 && p3.getGeometryType() !== a.enumLine) {
      const t3 = new n4();
      if (p3.queryEnvelope(t3), m2.containsEnvelope(t3)) return false;
      if (h2.isIntersecting(t3)) {
        P5 = true;
        break;
      }
    } else {
      f3.assign(p3.getStartXY()), x4.assign(p3.getEndXY());
      let e5 = m2.clipLine(f3, x4);
      if (0 !== e5) return false;
      d2 || (e5 = h2.clipLine(f3, x4), 0 !== e5 && (d2 = true));
    }
  }
  if (!P5) return d2;
  const E2 = new eh();
  return E2.addEnvelope(a2, false), ri2(E2, t2, n6, r);
}
function Ui2(t2, s4, n6, r, i2) {
  const a2 = n4.constructEmpty(), h2 = n4.constructEmpty();
  if (t2.queryEnvelope(a2), s4.queryEnvelope(h2), h2.height() <= n6 || h2.width() <= n6) return false;
  if (r) return co2(h2, a2, n6);
  if (!uo2(h2, a2, n6)) return false;
  const m2 = n4.constructEmpty();
  m2.setCoords({ env2D: h2 }), m2.inflateCoords(-n6, -n6);
  const l2 = n4.constructEmpty();
  if (l2.setCoords({ env2D: h2 }), l2.inflateCoords(n6, n6), m2.containsEnvelope(a2)) return true;
  const u = t2.getImpl().querySegmentIterator();
  u.stripAttributes(), u.nextPath() || b("relational_operations");
  let c, _, d2, p3, f3, x4, y2 = false;
  const P5 = t2.hasNonLinearSegments();
  for (P5 && (d2 = new su(), p3 = new su(), f3 = new su(), x4 = new su(), m2.querySide(0, d2), m2.querySide(1, p3), m2.querySide(2, f3), m2.querySide(3, x4)); ; ) {
    for (; !u.hasNextSegment() && u.nextPath(); ) ;
    if (!u.hasNextSegment()) break;
    const e5 = u.nextSegment();
    if (P5 && e5.getGeometryType() !== a.enumLine) {
      if (e5.isIntersecting(d2, n6)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(p3, n6)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(f3, n6)) {
        y2 = true;
        break;
      }
      if (e5.isIntersecting(x4, n6)) {
        y2 = true;
        break;
      }
    } else {
      c = e5.getStartXY(), _ = e5.getEndXY();
      if (0 !== m2.clipLine(c, _)) {
        y2 = true;
        break;
      }
    }
  }
  return y2;
}
function qi2(t2, n6, r, i2) {
  const a2 = new n4(), h2 = new n4();
  if (t2.queryEnvelope(a2), n6.queryEnvelope(h2), h2.height() <= r || h2.width() <= r) return false;
  const m2 = new n4();
  if (m2.setCoords({ env2D: h2 }), m2.inflateCoords(r, r), m2.containsEnvelope(a2)) return false;
  const l2 = true, g2 = new n4();
  if (g2.setCoords({ env2D: h2 }), g2.inflateCoords(-r, -r), !g2.isIntersecting(a2)) return false;
  const u = t2.getImpl().querySegmentIterator();
  u.stripAttributes();
  const c = t2.getImpl().getAccelerators();
  let _ = null, d2 = null;
  if (null !== c && (_ = c.getQuadTree(), null !== _ && (d2 = _.getIterator(h2, r))), !d2) {
    const e5 = u.nextPath();
    n2(e5);
  }
  let p3 = false, f3 = null;
  const x4 = new ei(), y2 = new ei();
  let P5 = null, E2 = null, C2 = null, S3 = null;
  for (t2.hasNonLinearSegments() && (P5 = new su(), E2 = new su(), C2 = new su(), S3 = new su(), g2.querySide(0, P5), g2.querySide(1, E2), g2.querySide(2, C2), g2.querySide(3, S3)); ; ) {
    if (null !== d2) {
      const e5 = d2.next();
      if (-1 === e5) break;
      u.resetToVertex(_.getElement(e5), -1), f3 = u.nextSegment();
    } else {
      for (; !u.hasNextSegment() && u.nextPath(); ) ;
      if (!u.hasNextSegment()) break;
      f3 = u.nextSegment();
    }
    if (f3.getGeometryType() === a.enumLine) {
      x4.assign(f3.getStartXY()), y2.assign(f3.getEndXY());
      if (0 !== g2.clipLine(x4, y2)) {
        p3 = true;
        break;
      }
    } else {
      if (P5.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (E2.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (C2.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
      if (S3.isIntersecting(f3, r)) {
        p3 = true;
        break;
      }
    }
  }
  return p3 && l2;
}
function Oi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!io2(i2, o2, n6) && (!!fo2(t2, s4, n6) || xo2(t2, s4, n6, false, true, false));
}
function Bi2(e5, t2, s4, n6) {
  const r = e5, i2 = t2, o2 = new Nr2(r, i2, s4, false), a2 = s4 * s4, h2 = new ei(), m2 = new ei();
  for (; o2.next(); ) {
    const e6 = o2.getRedElement(), t3 = o2.getBlueElement();
    if (r.queryXY(e6, h2), i2.queryXY(t3, m2), ei.sqrDistance(h2, m2) <= a2) return false;
  }
  return true;
}
function Ri2(e5, t2, s4, n6) {
  return xo2(e5, t2, s4, false, false, true);
}
function Yi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !!uo2(i2, o2, n6) && xo2(s4, t2, n6, true, false, false);
}
function Xi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), io2(i2, o2, n6);
}
function Li2(e5, t2, s4, n6) {
  return ko2(e5, t2.getXY(), s4);
}
function zi2(e5, t2, s4, n6) {
  return Xi2(e5, t2, s4);
}
function Wi2(e5, t2, s4, n6) {
  return !Li2(e5, t2, s4);
}
function ji2(t2, s4, n6, r) {
  const i2 = new n4(), o2 = new n4();
  return t2.queryEnvelope(i2), s4.queryEnvelope(o2), !(o2.height() > n6 || o2.width() > n6) && io2(i2, o2, n6);
}
function Zi2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty(), o2 = n4.constructEmpty();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), uo2(o2, i2, n6)) return false;
  const a2 = n4.constructEmpty();
  a2.setCoords({ env2D: o2 }), a2.inflateCoords(n6, n6);
  const h2 = new ei();
  for (let e5 = 0; e5 < t2.getPointCount(); e5++) if (t2.queryXY(e5, h2), a2.contains(h2)) return false;
  return true;
}
function Ki2(t2, s4, n6, r) {
  const i2 = new n4(), o2 = new n4(), a2 = new n4();
  if (s4.queryEnvelope(i2), i2.height() <= n6 || i2.width() <= n6) return false;
  o2.setCoords({ env2D: i2 }), a2.setCoords({ env2D: i2 }), o2.inflateCoords(n6, n6), a2.inflateCoords(-n6, -n6);
  const h2 = new ei();
  let m2 = false;
  for (let e5 = 0; e5 < t2.getPointCount(); e5++) if (t2.queryXY(e5, h2), o2.contains(h2)) {
    if (a2.containsExclusive(h2)) return false;
    m2 = true;
  }
  return m2;
}
function Qi2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty(), a2 = n4.constructEmpty();
  if (t2.queryEnvelope(o2), s4.queryEnvelope(a2), a2.height() <= n6 || a2.width() <= n6) return false;
  if (r) return co2(a2, o2, n6);
  if (!uo2(a2, o2, n6)) return false;
  let h2 = false;
  const m2 = n4.constructEmpty(), l2 = n4.constructEmpty();
  m2.setCoords({ env2D: a2 }), l2.setCoords({ env2D: a2 }), m2.inflateCoords(-n6, -n6), l2.inflateCoords(n6, n6);
  const g2 = new ei();
  for (let e5 = 0; e5 < t2.getPointCount(); e5++) {
    if (t2.queryXY(e5, g2), !l2.contains(g2)) return false;
    m2.containsExclusive(g2) && (h2 = true);
  }
  return h2;
}
function Ji2(t2, s4, n6, r) {
  const i2 = new n4(), o2 = new n4();
  if (t2.queryEnvelope(i2), s4.queryEnvelope(o2), uo2(o2, i2, n6)) return false;
  if (o2.height() <= n6 || o2.width() <= n6) return false;
  const a2 = new n4(), h2 = new n4();
  a2.setCoords({ env2D: o2 }), a2.inflateCoords(-n6, -n6), h2.setCoords({ env2D: o2 }), h2.inflateCoords(n6, n6);
  const m2 = new ei();
  let l2 = false, g2 = false;
  for (let e5 = 0; e5 < t2.getPointCount(); e5++) if (t2.queryXY(e5, m2), !l2 && a2.containsExclusive(m2) && (l2 = true), g2 || h2.contains(m2) || (g2 = true), l2 && g2) return true;
  return false;
}
function $i2(e5, t2, s4, n6) {
  return ei.sqrDistance(e5, t2) <= s4 * s4;
}
function eo2(e5, t2, s4, n6) {
  return ei.sqrDistance(e5, t2) > s4 * s4;
}
function to2(e5, t2, s4, n6) {
  return $i2(e5, t2, s4);
}
function so(t2, s4, n6, r) {
  const i2 = new n4();
  return i2.setCoords({ pt: t2 }), io2(i2, s4, n6);
}
function no(t2, s4, n6, r) {
  if (s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = new n4(), o2 = new n4();
  return i2.setCoords({ env2D: s4 }), i2.inflateCoords(n6, n6), !!i2.contains(t2) && (o2.setCoords({ env2D: s4 }), o2.inflateCoords(-n6, -n6), !o2.containsExclusive(t2));
}
function ro2(t2, s4, n6, r) {
  if (s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = n4.constructEmpty();
  i2.setCoords({ env2D: s4 }), i2.inflateCoords(-n6, -n6);
  return i2.containsExclusive(t2);
}
function io2(e5, t2, s4, n6) {
  return uo2(e5, t2, s4) && uo2(t2, e5, s4);
}
function oo2(t2, s4, n6, r) {
  if (t2.height() <= n6 || t2.width() <= n6 || s4.height() <= n6 || s4.width() <= n6) return false;
  const i2 = new n4();
  return i2.setCoords({ env2D: t2 }), i2.inflateCoords(-n6, -n6), i2.intersect(s4), !(!i2.isEmpty() && i2.height() > n6 && i2.width() > n6) && (i2.setCoords({ env2D: t2 }), i2.inflateCoords(n6, n6), i2.intersect(s4), !i2.isEmpty());
}
function ao2(t2, s4, n6, r) {
  if (t2.height() <= n6 || t2.width() <= n6 || s4.height() <= n6 || s4.width() <= n6) return false;
  if (uo2(t2, s4, n6)) return false;
  if (uo2(s4, t2, n6)) return false;
  const i2 = new n4();
  return i2.setCoords({ env2D: t2 }), i2.inflateCoords(-n6, -n6), i2.intersect(s4), !i2.isEmpty() && (i2.height() > n6 || i2.width() > n6);
}
function ho2(t2, s4, n6, r, i2) {
  if (t2.height() <= n6 || t2.width() <= n6) return false;
  if (r) return co2(t2, s4, n6);
  if (!uo2(t2, s4, n6)) return false;
  const o2 = n4.constructEmpty();
  return o2.setCoords({ env2D: t2 }), o2.inflateCoords(-n6, -n6), o2.intersect(s4), !o2.isEmpty();
}
function mo2(t2, s4, n6, r, i2) {
  const a2 = new ei(), h2 = new ei(), m2 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = t2.getImpl(), u = s4.getImpl(), c = u.getGeometryType(), _ = new Nr2(g2, u, n6, true);
  if (!_.next()) return 1;
  if (Eo2(t2, s4, n6)) return r ? 4 : 0;
  const d2 = new eh();
  let p3 = t2;
  const f3 = new eh();
  let x4 = null;
  c === a.enumPolygon && (x4 = s4);
  const y2 = c === a.enumPolygon ? Lt(g2.getPathCount(), false) : [], P5 = Lt(u.getPathCount(), false);
  let E2 = false, C2 = false, S3 = false, b2 = false, w4 = false, v3 = false;
  do {
    if (S3 && w4 || b2 && v3) break;
    if (S3 && b2) break;
    const e5 = _.getRedElement(), i3 = _.getBlueElement();
    if (!P5[i3] && (h2.assign(s4.getXY(s4.getPathStart(i3))), m2.setCoords({ env2D: _.getRedEnvelope() }), m2.inflateCoords(n6, n6), m2.contains(h2))) {
      if (0 !== Ro2(p3, h2, 0)) {
        if (b2 = true, r) return 4;
      } else v3 = true;
      P5[i3] = true;
    }
    if (c === a.enumPolygon && !y2[e5] && (a2.assign(t2.getXY(t2.getPathStart(e5))), l2.setCoords({ env2D: _.getBlueEnvelope() }), l2.inflateCoords(n6, n6), l2.contains(a2))) {
      if (0 !== Ro2(x4, a2, 0)) {
        if (S3 = true, r) return 4;
      } else w4 = true;
      y2[e5] = true;
    }
    if (E2 || (!Xn2(t2, s4.getPathCount() - 1) || null !== g2.getAccelerators() && null !== g2.getAccelerators().getQuadTree() ? p3 = t2 : (t2.copyTo(d2), d2.getImpl().buildQuadTreeAccelerator(1), p3 = d2), E2 = true), c === a.enumPolygon && !C2) {
      const e6 = s4;
      !Xn2(e6, t2.getPathCount() - 1) || null !== u.getAccelerators() && null !== u.getAccelerators().getQuadTree() ? x4 = s4 : (e6.copyTo(f3), f3.getImpl().buildQuadTreeAccelerator(1), x4 = f3), C2 = true;
    }
  } while (_.next());
  if (!S3 && !b2) return 1;
  if (!w4 || !v3) {
    if (c === a.enumPolygon) {
      for (let e5 = 0, t3 = g2.getPathCount(); e5 < t3; e5++) if (!y2[e5]) {
        w4 = true;
        break;
      }
    }
    for (let e5 = 0, t3 = u.getPathCount(); e5 < t3; e5++) if (!P5[e5]) {
      v3 = true;
      break;
    }
  }
  return S3 && w4 || b2 && v3 || S3 && b2 ? 4 : b2 ? 2 : 3;
}
function lo2(t2, s4, n6, r, i2) {
  const o2 = n4.constructEmpty();
  t2.queryEnvelope(o2), o2.inflateCoords(n6, n6);
  const a2 = new ei(), h2 = t2.getImpl(), m2 = new eh();
  let l2 = t2, g2 = false, u = false, c = false;
  for (let e5 = 0; e5 < s4.getPointCount(); e5++) {
    if (s4.queryXY(e5, a2), o2.contains(a2)) {
      const e6 = Ro2(l2, a2, n6);
      if (1 === e6) return u = true, 4;
      if (2 === e6) return 4;
      c = true;
    } else c = true;
    g2 || (!Xn2(t2, s4.getPointCount() - 1) || null !== h2.getAccelerators() && null != h2.getAccelerators().getQuadTree() ? l2 = t2 : (t2.copyTo(m2), m2.getImpl().buildQuadTreeAccelerator(1), l2 = m2), g2 = true);
  }
  return u ? c ? 4 : 2 : 1;
}
function go2(t2, n6, r, i2, a2) {
  i2[0] = false;
  const h2 = t2.getImpl(), m2 = n6.getImpl(), l2 = h2.querySegmentIterator(), g2 = m2.querySegmentIterator(), u = [0, 0], c = [0, 0], _ = new Nr2(h2, m2, r);
  let d2 = false;
  for (; _.next(); ) {
    const e5 = _.getRedElement(), t3 = _.getBlueElement();
    l2.resetToVertex(e5, -1), g2.resetToVertex(t3, -1);
    const s4 = l2.nextSegment(), n7 = g2.nextSegment();
    let o2 = 0;
    if (Uo2(s4, n7) ? !d2 && n7.isIntersecting(s4, r) && (d2 = true) : o2 = n7.intersect(s4, null, c, u, r), 0 !== o2 && (d2 = true, 1 === o2)) {
      const e6 = u[0], t4 = c[0];
      if (e6 > 0 && e6 < 1 && t4 > 0 && t4 < 1) return i2[0] = true, false;
    }
  }
  if (!d2) {
    i2[0] = true;
    const a3 = n4.constructEmpty();
    t2.queryEnvelope(a3), a3.inflateCoords(r, r);
    const l3 = new eh();
    let g3 = t2, u2 = false;
    for (let r2 = 0, i3 = n6.getPathCount(); r2 < i3; r2++) if (n6.getPathSize(r2) > 0) {
      const i4 = n4.constructEmpty();
      if (n6.queryPathEnvelope(r2, i4), !a3.isIntersecting(i4)) return false;
      {
        const e5 = Yn2(g3, n6.getXY(n6.getPathStart(r2)), 0);
        if (n2(-1 !== e5), 0 === e5) return false;
      }
      u2 || (!Xn2(t2, n6.getPathCount() - 1) || null !== h2.getAccelerators() && null !== h2.getAccelerators().getQuadTree() ? g3 = t2 : (t2.copyTo(l3), l3.getImpl().buildQuadTreeAccelerator(1), g3 = l3), u2 = true);
    }
    if (1 === t2.getPathCount() || n6.getGeometryType() === a.enumPolyline) return true;
    const c2 = n6, _2 = n4.constructEmpty();
    c2.queryEnvelope(_2), _2.inflateCoords(r, r);
    const d3 = new eh();
    let p3 = c2, f3 = false;
    for (let n7 = 0, r2 = t2.getPathCount(); n7 < r2; n7++) if (t2.getPathSize(n7) > 0) {
      const r3 = n4.constructEmpty();
      if (t2.queryPathEnvelope(n7, r3), _2.isIntersecting(r3)) {
        const e5 = Yn2(p3, t2.getXY(t2.getPathStart(n7)), 0);
        if (n2(-1 !== e5), 1 === e5) return false;
      }
      f3 || (!Xn2(c2, t2.getPathCount() - 1) || null !== m2.getAccelerators() && null !== m2.getAccelerators().getQuadTree() ? p3 = c2 : (c2.copyTo(d3), d3.getImpl().buildQuadTreeAccelerator(1), p3 = d3), f3 = true);
    }
    return true;
  }
  return false;
}
function uo2(t2, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: t2 }), r.inflateCoords(n6, n6), r.containsEnvelope(s4);
}
function co2(t2, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), t2.containsExclusiveEnvelope(r);
}
function _o2(t2, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: s4 }), r.inflateCoords(n6, n6), !r.contains(t2.getLowerLeft()) || (!r.contains(t2.getLowerRight()) || (!r.contains(t2.getUpperLeft()) || !r.contains(t2.getUpperRight())));
}
function po2(e5, t2, s4, n6) {
  if (e5.getPathCount() !== t2.getPathCount() || e5.getPointCount() !== t2.getPointCount()) return false;
  if (e5.hasNonLinearSegments() || t2.hasNonLinearSegments()) return e5.equals(t2);
  const r = new ei(), i2 = new ei();
  let o2 = true;
  const a2 = s4 * s4;
  for (let h2 = 0; h2 < e5.getPathCount(); h2++) {
    if (e5.getPathEnd(h2) !== t2.getPathEnd(h2)) {
      o2 = false;
      break;
    }
    for (let s5 = e5.getPathStart(h2); s5 < t2.getPathEnd(h2); s5++) if (e5.queryXY(s5, r), t2.queryXY(s5, i2), ei.sqrDistance(r, i2) > a2) {
      o2 = false;
      break;
    }
    if (!o2) break;
  }
  return !!o2;
}
function fo2(e5, t2, s4, n6) {
  if (e5.getPointCount() !== t2.getPointCount()) return false;
  const r = new ei(), i2 = new ei();
  let o2 = true;
  const a2 = s4 * s4;
  for (let h2 = 0; h2 < e5.getPointCount(); h2++) if (e5.queryXY(h2, r), t2.queryXY(h2, i2), ei.sqrDistance(r, i2) > a2) {
    o2 = false;
    break;
  }
  return !!o2;
}
function xo2(e5, t2, s4, n6, r, i2, o2) {
  const a2 = e5.getImpl(), h2 = t2.getImpl(), m2 = a2.getPointCount(), l2 = h2.getPointCount(), g2 = Lt(m2, false), u = r || i2 ? Lt(l2, false) : [], c = s4 * s4, _ = new Nr2(a2, h2, s4);
  for (; _.next(); ) {
    const e6 = _.getRedElement(), t3 = _.getBlueElement(), s5 = a2.getXY(e6), n7 = h2.getXY(t3);
    ei.sqrDistance(s5, n7) <= c && (g2[e6] = true, (r || i2) && (u[t3] = true));
  }
  let d2 = false, p3 = false;
  for (let y2 = 0; y2 < m2; y2++) {
    const e6 = g2[y2];
    if (d2 || (d2 = !e6), p3 || (p3 = e6), (r || n6) && d2) return false;
  }
  if (n6) return true;
  let f3 = false, x4 = false;
  for (let y2 = 0; y2 < l2; y2++) {
    const e6 = u[y2];
    if (f3 || (f3 = !e6), x4 || (x4 = e6), r && f3) return false;
  }
  return !!r || d2 && p3 && f3 && x4;
}
function yo2(e5, t2, s4, n6) {
  return Po2(e5, t2, s4, n6) && Po2(t2, e5, s4, n6);
}
function Po2(t2, s4, r, i2) {
  if (N(t2), N(s4), s4.isEmpty()) return false;
  let o2 = true;
  const a2 = Lt(2, Number.NaN), h2 = Lt(2, Number.NaN), m2 = [], l2 = new Oo2();
  let u;
  const c = n4.constructEmpty(), _ = n4.constructEmpty(), d2 = n4.constructEmpty();
  t2.queryEnvelope(c), s4.queryEnvelope(_), c.inflateCoords(r, r), _.inflateCoords(r, r), d2.setCoords({ env2D: c }), d2.intersect(_);
  const p3 = t2.getImpl().querySegmentIterator(), f3 = s4.getImpl().querySegmentIterator(), x4 = s4.getImpl().getAccelerators();
  let y2 = null, P5 = null, E2 = null, C2 = null;
  if (null !== x4 && (y2 = x4.getQuadTree(), P5 = x4.getQuadTreeForPaths(), null !== P5 && (C2 = P5.getIteratorForQT())), null === y2) {
    const e5 = t2.getPointCount(), n6 = s4.getPointCount();
    e5 > 10 && n6 > 10 && (y2 = Wt(s4.getImpl(), d2));
  }
  for (null !== y2 && (E2 = y2.getIteratorForQT()); p3.nextPath(); ) for (; p3.hasNextSegment(); ) {
    let e5 = p3.nextSegment();
    if (e5.queryEnvelope(c), !c.isIntersecting(d2)) return o2 = false, false;
    if (null !== C2 && (C2.resetIterator(c, r), -1 === C2.next())) continue;
    let t3 = 0, s5 = null;
    if (null != E2) E2.resetIterator(e5, r);
    else if (f3.resetToFirstPath(), !f3.nextPath()) return o2 = false, false;
    do {
      if (t3 = 0, null !== E2) {
        const n7 = E2.next();
        if (-1 === n7) return o2 = false, false;
        f3.resetToVertex(y2.getElement(n7), -1), s5 = f3.nextSegment(), t3 = e5.intersect(s5, null, a2, h2, r);
      } else {
        for (; !f3.hasNextSegment(); ) if (!f3.nextPath()) return o2 = false, false;
        s5 = f3.nextSegment(), s5.queryEnvelope(_), _.inflateCoords(r, r), c.isIntersecting(_) && (t3 = e5.intersect(s5, null, a2, h2, r));
      }
    } while (2 !== t3 || 0 !== a2[0] || i2 && !(h2[0] <= h2[1]));
    let n6 = Number.NaN, x5 = false;
    do {
      let i3 = false;
      if (1 === a2[1]) {
        if (!p3.hasNextSegment()) {
          x5 = true;
          break;
        }
        e5 = p3.nextSegment(), i3 = true;
      }
      if (1 === h2[1] && h2[0] <= h2[1]) {
        if (-1 === n6) break;
        if (n6 = 1, !f3.hasNextSegment()) break;
        s5 = f3.nextSegment(), i3 = true;
      }
      if (0 === h2[1] && h2[0] > h2[1]) {
        if (1 === n6) break;
        if (Number.isNaN(n6)) {
          if (!f3.hasPreviousSegment()) break;
          f3.previousSegment(), n6 = -1;
        }
        if (!f3.hasPreviousSegment()) break;
        s5 = f3.previousSegment(), i3 = true;
      }
      if (!i3) break;
      t3 = e5.intersect(s5, null, a2, h2, r);
    } while (2 === t3 && (!i2 || h2[0] <= h2[1]));
    if (x5) continue;
    const P6 = e5.calculateLength2D();
    e5.queryEnvelope(c), m2.length = 0, l2.m_overlapEvents.length = 0;
    let S3 = false, I5 = false, b2 = 0;
    const w4 = Bt2(null, c, true);
    for (null !== E2 ? E2.resetIterator(e5, r) : (f3.resetToFirstPath(), f3.nextPath() || b("relational_operations")); ; ) {
      if (t3 = 0, null !== E2) {
        const n7 = E2.next();
        if (-1 === n7) break;
        f3.resetToVertex(y2.getElement(n7), -1), s5 = f3.nextSegment(), t3 = e5.intersect(s5, null, a2, h2, r);
      } else {
        for (; !f3.hasNextSegment() && f3.nextPath(); ) ;
        if (!f3.hasNextSegment()) break;
        s5 = f3.nextSegment(), s5.queryEnvelope(_), _.inflateCoords(r, r), c.isIntersecting(_) && (t3 = e5.intersect(s5, null, a2, h2, r));
      }
      if (2 === t3 && (!i2 || h2[0] <= h2[1])) {
        const e6 = p3.getStartPointIndex(), t4 = p3.getPathIndex(), s6 = f3.getStartPointIndex(), n7 = f3.getPathIndex();
        if (u = qo2(e6, t4, a2[0], a2[1], s6, n7, h2[0], h2[1]), l2.m_overlapEvents.push(u), m2.push(m2.length), !(S3 || u.m_scalarA0 < b2 && u.m_scalarA1 < b2)) {
          if (0 === b2 && P6 * (u.m_scalarA0 - b2) > r) S3 = true;
          else if (0 !== b2 && P6 * (u.m_scalarA0 - b2) > w4) S3 = true;
          else if (b2 = u.m_scalarA1, P6 * (1 - b2) <= r || 1 === b2) {
            I5 = true;
            break;
          }
        }
      }
    }
    if (!I5) {
      if (!S3) return o2 = false, false;
      m2.length > 1 && m2.sort((e6, t4) => l2.compareOverlapEvents(e6, t4)), b2 = 0;
      for (let e6 = 0; e6 < l2.m_overlapEvents.length; e6++) if (u = l2.m_overlapEvents[m2[e6]], !(u.m_scalarA0 < b2 && u.m_scalarA1 < b2)) {
        if (0 === b2 && P6 * (u.m_scalarA0 - b2) > r) return o2 = false, false;
        if (0 !== b2 && P6 * (u.m_scalarA0 - b2) > w4) return o2 = false, false;
        if (b2 = u.m_scalarA1, P6 * (1 - b2) <= r || 1 === b2) break;
      }
      if (P6 * (1 - b2) > r) return o2 = false, false;
      m2.length = 0, l2.m_overlapEvents.length = 0;
    }
  }
  return o2;
}
function Eo2(e5, t2, s4) {
  const n6 = e5.getImpl(), r = t2.getImpl(), i2 = n6.querySegmentIterator(), o2 = r.querySegmentIterator(), a2 = new Nr2(n6, r, s4);
  for (; a2.next(); ) {
    const e6 = a2.getRedElement(), t3 = a2.getBlueElement();
    i2.resetToVertex(e6, -1), o2.resetToVertex(t3, -1);
    const n7 = i2.nextSegment();
    if (o2.nextSegment().isIntersecting(n7, s4)) return true;
  }
  return false;
}
function Co2(e5, t2, s4, n6) {
  const r = e5.getImpl(), i2 = t2.getImpl(), o2 = r.querySegmentIterator(), a2 = i2.querySegmentIterator(), h2 = Lt(2, Number.NaN), m2 = new Nr2(r, i2, s4);
  let l2 = false, g2 = -1;
  for (; m2.next(); ) {
    const e6 = m2.getRedElement(), t3 = m2.getBlueElement();
    o2.resetToVertex(e6, -1), a2.resetToVertex(t3, -1);
    const r2 = o2.nextSegment(), i3 = a2.nextSegment();
    let u = 0;
    if (Uo2(r2, i3)) {
      if (i3.isIntersecting(r2, s4)) return -2;
    } else u = r2.intersect(i3, null, h2, null, s4);
    if (u) {
      if (2 === u) {
        const e7 = r2.calculateLength2D(), t4 = h2[0];
        if (e7 * (h2[1] - t4) > s4) return g2 = 1, g2;
        l2 = true;
      } else if (g2 = 0, n6) {
        const e7 = h2[0], t4 = new ei();
        r2.queryCoord2D(e7, t4), n6.push(t4.x), n6.push(t4.y);
      }
    }
  }
  return l2 ? -2 : g2;
}
function So2(e5, t2, s4, n6) {
  const r = e5.getImpl(), i2 = t2, o2 = i2.getPointCount(), a2 = n6 ? Lt(o2, false) : [], h2 = new Nr2(r, i2, s4, false), m2 = r.querySegmentIterator();
  for (; h2.next(); ) {
    const e6 = h2.getRedElement(), t3 = h2.getBlueElement();
    m2.resetToVertex(e6, -1);
    const r2 = m2.nextSegment(), o3 = i2.getXY(t3);
    if (r2.isIntersectingPoint(o3, s4)) {
      if (!n6) return true;
      a2[t3] = true;
    }
  }
  if (!n6) return false;
  for (let l2 = 0; l2 < o2; l2++) if (!a2[l2]) return false;
  return true;
}
function Io2(t2, s4, n6) {
  const r = new ei(), i2 = n6 * n6, o2 = t2.querySegmentIterator(), a2 = t2.getImpl().getAccelerators();
  if (null !== a2) {
    const t3 = a2.getQuadTree();
    if (null !== t3) {
      const a3 = n4.constructEmpty();
      a3.setCoords({ pt: s4 });
      const h3 = t3.getIterator(a3, n6);
      for (let e5 = h3.next(); -1 !== e5; e5 = h3.next()) if (o2.resetToVertex(t3.getElement(e5), -1), o2.hasNextSegment()) {
        const e6 = o2.nextSegment(), t4 = e6.getClosestCoordinate(s4, false);
        if (e6.queryCoord2D(t4, r), ei.sqrDistance(s4, r) <= i2) return true;
      }
      return false;
    }
  }
  const h2 = n4.constructEmpty();
  for (; o2.nextPath(); ) for (; o2.hasNextSegment(); ) {
    const e5 = o2.nextSegment();
    if (e5.queryEnvelope(h2), h2.inflateCoords(n6, n6), !h2.contains(s4)) continue;
    const t3 = e5.getClosestCoordinate(s4, false);
    if (e5.queryCoord2D(t3, r), ei.sqrDistance(s4, r) <= i2) return true;
  }
  return false;
}
function bo2(e5, t2, s4) {
  return Io2(e5, t2, s4) && !Ao2(e5, t2, s4);
}
function wo2(t2, s4, n6, r) {
  const i2 = t2.querySegmentIterator(), a2 = t2.getImpl().getAccelerators(), h2 = t2.hasNonLinearSegments();
  let m2 = null, l2 = null, g2 = null, u = null;
  if (null !== a2) {
    const t3 = a2.getQuadTree();
    if (null !== t3) {
      const r2 = t3.getIterator(s4, n6);
      h2 && (m2 = new su(), l2 = new su(), g2 = new su(), u = new su(), s4.querySide(0, m2), s4.querySide(1, l2), s4.querySide(2, g2), s4.querySide(3, u));
      const a3 = n4.constructEmpty();
      a3.setCoords({ env2D: s4 }), a3.inflateCoords(n6, n6);
      for (let e5 = r2.next(); -1 !== e5; e5 = r2.next()) if (i2.resetToVertex(t3.getElement(e5), -1), i2.hasNextSegment()) {
        const e6 = i2.nextSegment();
        if (e6.getGeometryType() === a.enumLine) {
          const t4 = e6.getStartXY(), s5 = e6.getEndXY();
          if (a3.clipLine(t4, s5)) return true;
          continue;
        }
        if (s4.contains(e6.getStartXY()) || s4.contains(e6.getEndXY())) return true;
        if (e6.isIntersecting(m2, n6)) return true;
        if (e6.isIntersecting(l2, n6)) return true;
        if (e6.isIntersecting(g2, n6)) return true;
        if (e6.isIntersecting(u, n6)) return true;
      }
      return false;
    }
  }
  if (h2) {
    m2 = new su(), l2 = new su(), g2 = new su(), u = new su(), s4.querySide(0, m2), s4.querySide(1, l2), s4.querySide(2, g2), s4.querySide(3, u);
    const e5 = t2.querySegmentIterator();
    for (; e5.nextPath(); ) for (; e5.hasNextSegment(); ) {
      const t3 = e5.nextSegment();
      if (s4.contains(t3.getStartXY()) || s4.contains(t3.getEndXY())) return true;
      if (t3.isIntersecting(m2, n6)) return true;
      if (t3.isIntersecting(l2, n6)) return true;
      if (t3.isIntersecting(g2, n6)) return true;
      if (t3.isIntersecting(u, n6)) return true;
    }
  } else {
    const r2 = n4.constructEmpty();
    r2.setCoords({ env2D: s4 }), r2.inflateCoords(n6, n6);
    const i3 = t2.getImpl(), o2 = i3.getAttributeStreamRef(0), a3 = new ei();
    for (let e5 = 0, t3 = i3.getPathCount(); e5 < t3; e5++) {
      let t4 = true;
      const s5 = new ei(), n7 = new ei(), h3 = new ei(), m3 = i3.getPathStart(e5), l3 = new ei();
      for (let g3 = m3, u2 = i3.getPathEnd(e5); g3 < u2; g3++) if (t4) o2.queryPoint2D(2 * g3, s5), l3.assign(s5), t4 = false;
      else {
        if (o2.queryPoint2D(2 * g3, a3), n7.setCoordsPoint2D(s5), h3.setCoordsPoint2D(a3), r2.clipLine(n7, h3)) return true;
        s5.assign(a3);
      }
      if (i3.isClosedPath(e5) && !t4 && (n7.setCoordsPoint2D(s5), h3.setCoordsPoint2D(l3), r2.clipLine(n7, h3))) return true;
    }
  }
  return false;
}
function vo2(t2, s4, n6, r) {
  const i2 = t2.getImpl(), o2 = s4.getImpl(), a2 = [0], h2 = Ht(i2.getIsSimple(0, a2)) && Ht(o2.getIsSimple(0, a2)), m2 = i2.querySegmentIterator(), l2 = o2.querySegmentIterator(), g2 = Lt(2, 0), u = Lt(2, 0), c = new Nr2(i2, o2, n6);
  let _ = false;
  for (; c.next(); ) {
    const e5 = c.getRedElement(), t3 = c.getBlueElement();
    m2.resetToVertex(e5, -1), l2.resetToVertex(t3, -1);
    const s5 = m2.nextSegment(), r2 = l2.nextSegment();
    let i3 = 0;
    if (Uo2(s5, r2)) {
      if (r2.isIntersecting(s5, n6)) {
        _ = true;
        break;
      }
    } else i3 = r2.intersect(s5, null, u, g2, n6);
    if (2 === i3) {
      const e6 = g2[0], t4 = g2[1], r3 = s5.calculateLength2D();
      if (h2 && (t4 - e6) * r3 > n6) return false;
      _ = true;
    } else if (i3) {
      const e6 = g2[0], t4 = u[0];
      if (e6 > 0 && e6 < 1 && t4 > 0 && t4 < 1) return false;
      _ = true;
    }
  }
  if (!_) return false;
  const d2 = n4.constructEmpty(), p3 = n4.constructEmpty(), f3 = n4.constructEmpty();
  let x4, y2;
  if (t2.queryEnvelope(d2), s4.queryEnvelope(p3), d2.inflateCoords(1e3 * n6, 1e3 * n6), p3.inflateCoords(1e3 * n6, 1e3 * n6), f3.setCoords({ env2D: d2 }), f3.intersect(p3), t2.getPointCount() > 10) {
    if (x4 = f2(t2, f3, n6, 0, r), x4.isEmpty()) return false;
  } else x4 = t2;
  if (s4.getPointCount() > 10) {
    if (y2 = f2(s4, f3, n6, 0, r), y2.isEmpty()) return false;
  } else y2 = s4;
  return $n2(x4, y2, n6, "F********", r, false);
}
function No2(t2, s4, n6, r) {
  const i2 = t2.getImpl(), o2 = s4.getImpl(), a2 = [0], h2 = Ht(i2.getIsSimple(0, a2)) && Ht(o2.getIsSimple(0, a2)), m2 = n4.constructEmpty(), l2 = n4.constructEmpty(), g2 = n4.constructEmpty();
  t2.queryEnvelope(m2), s4.queryEnvelope(l2);
  let u = false;
  const c = _o2(m2, l2, n6), _ = _o2(l2, m2, n6), d2 = i2.querySegmentIterator(), p3 = o2.querySegmentIterator(), f3 = Lt(2, Number.NaN), x4 = Lt(2, Number.NaN), y2 = new Nr2(i2, o2, n6);
  for (; y2.next(); ) {
    const e5 = y2.getRedElement(), t3 = y2.getBlueElement();
    d2.resetToVertex(e5, -1), p3.resetToVertex(t3, -1);
    const s5 = d2.nextSegment(), r2 = p3.nextSegment();
    let i3 = 0;
    if (Uo2(s5, r2)) {
      if (r2.isIntersecting(s5, n6)) break;
    } else i3 = r2.intersect(s5, null, x4, f3, n6);
    if (2 === i3) {
      const e6 = f3[0], t4 = f3[1], r3 = s5.calculateLength2D();
      if (h2 && (t4 - e6) * r3 > n6 && (u = true, c && _)) return true;
    } else if (i3) {
      const e6 = f3[0], t4 = x4[0];
      if (e6 > 0 && e6 < 1 && t4 > 0 && t4 < 1) return true;
    }
  }
  const P5 = n4.constructEmpty(), E2 = n4.constructEmpty();
  let C2, S3;
  P5.setCoords({ env2D: m2 }), P5.inflateCoords(1e3 * n6, 1e3 * n6), E2.setCoords({ env2D: l2 }), E2.inflateCoords(1e3 * n6, 1e3 * n6), g2.setCoords({ env2D: P5 }), g2.intersect(E2);
  let I5 = "";
  if (I5 += u ? "**" : "T*", c) {
    if (s4.getPointCount() > 10) {
      if (S3 = f2(s4, g2, n6, 0, r), S3.isEmpty()) return false;
    } else S3 = s4;
    I5 += "****";
  } else S3 = s4, I5 += "T***";
  if (_) {
    if (t2.getPointCount() > 10) {
      if (C2 = f2(t2, g2, n6, 0, r), C2.isEmpty()) return false;
    } else C2 = t2;
    I5 += "***";
  } else C2 = t2, I5 += "T**";
  return $n2(C2, S3, n6, I5, r, false);
}
function To2(t2, s4, n6, r) {
  const i2 = [false], o2 = go2(t2, s4, n6, i2);
  if (i2[0]) return o2;
  const a2 = n4.constructEmpty();
  let h2;
  if (s4.queryEnvelope(a2), a2.inflateCoords(1e3 * n6, 1e3 * n6), t2.getPointCount() > 10) {
    if (h2 = f2(t2, a2, n6, 0, r), h2.isEmpty()) return false;
  } else h2 = t2;
  return er2(h2, s4, n6, r);
}
function Go2(t2, s4, n6, r) {
  const i2 = t2.getImpl(), o2 = s4.getImpl(), a2 = i2.querySegmentIterator(), h2 = o2.querySegmentIterator(), m2 = Lt(2, Number.NaN), l2 = Lt(2, Number.NaN), g2 = new Nr2(i2, o2, n6);
  let u = false;
  for (; g2.next(); ) {
    const e5 = g2.getRedElement(), t3 = g2.getBlueElement();
    a2.resetToVertex(e5, -1), h2.resetToVertex(t3, -1);
    const s5 = a2.nextSegment(), r2 = h2.nextSegment();
    let i3 = 0;
    if (Uo2(s5, r2) ? !u && r2.isIntersecting(s5, n6) && (u = true) : i3 = r2.intersect(s5, null, l2, m2, n6), 2 === i3) u = true;
    else if (i3) {
      const e6 = m2[0], t4 = l2[0];
      if (e6 > 0 && e6 < 1 && t4 > 0 && t4 < 1) return false;
      u = true;
    }
  }
  if (!u) return false;
  const c = n4.constructEmpty(), _ = n4.constructEmpty(), d2 = n4.constructEmpty();
  let p3, f3;
  if (t2.queryEnvelope(c), s4.queryEnvelope(_), c.inflateCoords(1e3 * n6, 1e3 * n6), _.inflateCoords(1e3 * n6, 1e3 * n6), d2.setCoords({ env2D: c }), d2.intersect(_), t2.getPointCount() > 10) {
    if (p3 = f2(t2, d2, n6, 0, r), p3.isEmpty()) return false;
  } else p3 = t2;
  if (s4.getPointCount() > 10) {
    if (f3 = f2(s4, d2, n6, 0, r), f3.isEmpty()) return false;
  } else f3 = s4;
  return $n2(p3, f3, n6, "F********", r, false);
}
function Do2(t2, s4, n6, r) {
  const i2 = t2.getImpl(), o2 = s4.getImpl(), a2 = i2.querySegmentIterator(), h2 = o2.querySegmentIterator(), m2 = Lt(2, Number.NaN), l2 = Lt(2, Number.NaN), g2 = new Nr2(i2, o2, n6);
  let u = false;
  for (; g2.next(); ) {
    const e5 = g2.getRedElement(), t3 = g2.getBlueElement();
    a2.resetToVertex(e5, -1), h2.resetToVertex(t3, -1);
    const s5 = a2.nextSegment(), r2 = h2.nextSegment();
    let i3 = 0;
    if (Uo2(s5, r2) ? !u && r2.isIntersecting(s5, n6) && (u = true) : i3 = r2.intersect(s5, null, l2, m2, n6), 2 === i3) u = true;
    else if (i3) {
      const e6 = m2[0], t4 = l2[0];
      if (e6 > 0 && e6 < 1 && t4 > 0 && t4 < 1) return true;
      u = true;
    }
  }
  if (!u) return false;
  const c = n4.constructEmpty(), _ = n4.constructEmpty(), d2 = n4.constructEmpty(), p3 = n4.constructEmpty(), f3 = n4.constructEmpty();
  if (t2.queryEnvelope(c), s4.queryEnvelope(_), _o2(_, c, n6)) {
    let e5, i3;
    if (d2.setCoords({ env2D: c }), d2.inflateCoords(1e3 * n6, 1e3 * n6), p3.setCoords({ env2D: _ }), p3.inflateCoords(1e3 * n6, 1e3 * n6), f3.setCoords({ env2D: d2 }), f3.intersect(p3), t2.getPointCount() > 10) {
      if (e5 = f2(t2, f3, n6, 0, r), e5.isEmpty()) return false;
    } else e5 = t2;
    if (s4.getPointCount() > 10) {
      if (i3 = f2(s4, f3, n6, 0, r), i3.isEmpty()) return false;
    } else i3 = s4;
    return $n2(e5, i3, n6, "T********", r, false);
  }
  return $n2(t2, s4, n6, "T*****T**", r, false);
}
function Vo2(t2, s4, n6, r) {
  const i2 = [false], o2 = go2(t2, s4, n6, i2);
  if (i2[0]) return o2;
  const a2 = n4.constructEmpty();
  let h2;
  if (s4.queryEnvelope(a2), a2.inflateCoords(1e3 * n6, 1e3 * n6), t2.getPointCount() > 10) {
    if (h2 = f2(t2, a2, n6, 0, r), h2.isEmpty()) return false;
  } else h2 = t2;
  return tr2(h2, s4, n6, r);
}
function Fo2(e5, t2, s4, n6) {
  return 1 === Ro2(e5, t2, s4);
}
function Ho2(e5, t2, s4, n6) {
  return 2 === Ro2(e5, t2, s4);
}
function ko2(e5, t2, s4, n6) {
  const r = new ei(), i2 = s4 * s4;
  for (let o2 = 0; o2 < e5.getPointCount(); o2++) if (e5.queryXY(o2, r), ei.sqrDistance(r, t2) <= i2) return false;
  return true;
}
function Ao2(e5, t2, s4) {
  const n6 = e5.getBoundary();
  return !n6.isEmpty() && !ko2(n6, t2, s4);
}
function Mo2(t2, s4, n6) {
  const r = n4.constructEmpty();
  return r.setCoords({ env2D: t2 }), r.inflateCoords(n6, n6), r.containsEnvelope(s4) ? 1073741824 : r.isIntersecting(s4) ? t2.isIntersecting(s4) ? t2.xmin < s4.xmin && s4.xmax < t2.xmax ? s4.ymin < t2.ymin && s4.ymax > t2.ymax ? 0 : 1073741824 : t2.ymin < s4.ymin && s4.ymax < t2.ymax ? s4.xmin < t2.xmin && s4.xmax > t2.xmax ? 0 : 1073741824 : 0 : 0 : 4;
}
function Uo2(e5, t2) {
  return e5.getGeometryType() !== a.enumLine || t2.getGeometryType() !== a.enumLine;
}
function qo2(e5, t2, s4, n6, r, i2, o2, a2) {
  return { m_ivertexA: e5, m_ipathA: t2, m_scalarA0: s4, m_scalarA1: n6, m_ivertexB: r, m_ipathB: i2, m_scalarB0: o2, m_scalarB1: a2 };
}
var Oo2 = class {
  constructor() {
    this.m_overlapEvents = [];
  }
  compareOverlapEvents(e5, t2) {
    const s4 = this.m_overlapEvents[e5], n6 = this.m_overlapEvents[t2];
    if (s4.m_ipathA < n6.m_ipathA) return -1;
    if (s4.m_ipathA === n6.m_ipathA) {
      if (s4.m_ivertexA < n6.m_ivertexA) return -1;
      if (s4.m_ivertexA === n6.m_ivertexA) {
        if (s4.m_scalarA0 < n6.m_scalarA0) return -1;
        if (s4.m_scalarA0 === n6.m_scalarA0) {
          if (s4.m_scalarA1 < n6.m_scalarA1) return -1;
          if (s4.m_scalarA1 === n6.m_scalarA1 && s4.m_ivertexB < n6.m_ivertexB) return -1;
        }
      }
    }
    return 1;
  }
};
function Bo2(e5, t2, s4) {
  const n6 = Rn2(e5, t2, s4);
  return n6 ? 1 === n6 ? 1 : 2 : 0;
}
function Ro2(e5, t2, s4) {
  const n6 = Yn2(e5, t2, s4);
  return n6 ? 1 === n6 ? 1 : 2 : 0;
}
function Yo2(e5, t2, s4, n6, r) {
  for (let i2 = 0; i2 < s4; i2++) r[i2] = Ro2(e5, t2[i2], n6);
}
function Xo2(t2, s4, n6, r, i2) {
  if (t2.getGeometryType() === a.enumPolygon) Yo2(t2, s4, n6, r, i2);
  else if (t2.getGeometryType() === a.enumEnvelope) {
    const o2 = n4.constructEmpty();
    t2.queryEnvelope(o2), zo2(o2, s4, n6, r, i2);
  } else C("");
}
function Lo2(e5, t2, s4, n6, r) {
  const i2 = e5.getGeometryType();
  i2 === a.enumPolyline ? Ko2(e5, t2, s4, n6, r) : f(i2) ? Zo2() : C("");
}
function zo2(e5, t2, s4, n6, r) {
  if (e5.isEmpty()) {
    for (let e6 = 0; e6 < s4; e6++) r[e6] = 0;
    return;
  }
  const i2 = e5.clone();
  i2.inflateCoords(0.5 * -n6, 0.5 * -n6);
  const o2 = e5.clone();
  o2.inflateCoords(0.5 * n6, 0.5 * n6);
  for (let a2 = 0; a2 < s4; a2++) i2.contains(t2[a2]) ? r[a2] = 1 : o2.contains(t2[a2]) ? r[a2] = 2 : r[a2] = 0;
}
function Wo2(e5) {
  if (e5.isEmpty()) return 0;
  switch (e5.getGeometryType()) {
    case a.enumMultiPoint:
      return e5.getImpl().getPointCount();
    case a.enumPolyline:
      return e5.getImpl().getPathCount();
    case a.enumPolygon:
      return e5.getImpl().getOGCPolygonCount();
    case a.enumGeometryCollection:
      return e5.getGeometryCount();
  }
  return 1;
}
function jo2(e5, t2, s4) {
  if (s4.reset(), t2 < 3) return;
  const n6 = e5[0].clone(), r = n6.x, i2 = n6.y, o2 = e5[1].clone(), a2 = new ei();
  for (let h2 = 2; h2 < t2; h2++) a2.assign(e5[h2]), s4.pe((a2.x - n6.x) * (o2.y - i2)), n6.assign(o2), o2.assign(a2);
  s4.pe((r - n6.x) * (o2.y - i2));
}
function Zo2(e5, t2, n6, r, i2) {
  n2(0);
}
function Ko2(t2, n6, r, i2, o2) {
  const a2 = t2.getImpl(), h2 = a2.getAccelerators();
  let m2 = null;
  h2 && (m2 = h2.getRasterizedGeometry());
  let l2 = r;
  for (let e5 = 0; e5 < r; e5++) o2[e5] = 1, m2 && n2(0);
  if (l2) {
    if (h2) {
      let t4 = null;
      null !== h2 && null !== h2.getQuadTree() && (t4 = h2.getQuadTree());
      const s4 = a2.getPointCount();
      if (null === t4 && s4 > 20 && s4 * r > 4 * s4 + Math.log(s4) * r && (t4 = Wt(a2)), t4) {
        let s5 = null;
        const h3 = a2.querySegmentIterator(), m3 = new n4();
        for (let e5 = 0; e5 < r && l2; e5++) if (1 === o2[e5]) {
          m3.setCoords(n6[e5]), null === s5 ? s5 = t4.getIterator(m3, i2) : s5.resetIterator(m3, i2);
          let r2 = -1;
          for (let a3 = s5.next(); -1 !== a3; a3 = s5.next()) {
            h3.resetToVertex(t4.getElement(a3), r2), r2 = h3.getPathIndex();
            if (h3.nextSegment().isIntersectingPoint(n6[e5], i2)) {
              o2[e5] = 2, l2--;
              break;
            }
            o2[e5] = 0;
          }
        }
        return;
      }
    }
    const t3 = a2.querySegmentIterator();
    for (; t3.nextPath() && l2; ) for (; t3.hasNextSegment() && l2; ) {
      const e5 = t3.nextSegment();
      for (let t4 = 0; t4 < r && l2; t4++) 1 === o2[t4] && e5.isIntersectingPoint(n6[t4], i2) && (o2[t4] = 2, l2--);
    }
  }
  for (let e5 = 0; e5 < r; e5++) 1 === o2[e5] && (o2[e5] = 0);
}
function Qo2(e5, t2, s4, n6, r) {
  const i2 = Ue(t2), o2 = Math.max(4 * i2, s4);
  return new na2(t2, null, o2, Number.NaN, r).approximateWithCirclesImpl(e5, n6);
}
function Jo2() {
  return Number.isNaN(this.radius.value());
}
function $o2() {
  return { ptStart: new ei(), ptEnd: new ei(), center: new Se(), radius: new p2(), fcenter: new an(), fradius2: new Hs(), maxError: Number.NaN, isLine: Jo2 };
}
var ea2 = 5;
var ta2 = 1 / 8;
function sa2(e5, t2, s4, n6) {
  return { pt: e5.clone(), t: t2, err: s4, checkCount: n6 };
}
var na2 = class _na {
  constructor(e5, t2, s4, n6, r) {
    this.m_left = e5, this.m_tracker = r, this.m_eps = s4, this.m_trackerCounter = 0, this.m_tolerance = n6, this.m_circleCheckCounter = 0, this.m_bReversedLeft = false, this.m_leftArc = $o2();
  }
  closeToCircularArc(e5, t2, s4, n6, r, i2) {
    if (this.m_circleCheckCounter++, i2.maxError = 0, !_na.checkSweepAngle(e5, t2)) return false;
    if (i2.ptStart.setCoordsPoint2D(s4), i2.ptEnd.setCoordsPoint2D(r), e5.isCircular()) {
      const t3 = e5;
      return i2.fradius2 = Hs.constructDouble(t3.getSemiMajorAxis()).mulDouble(t3.getSemiMajorAxis()), i2.radius.set(t3.getSemiMajorAxis()), i2.fcenter.assignPoint2D(t3.getCenter()), i2.center.set(t3.getCenter()), true;
    }
    const o2 = i2.ptEnd.sub(i2.ptStart).clone();
    o2.leftPerpendicularThis(), o2.normalize();
    if (Math.abs(o2.dotProduct(n6.sub(i2.ptStart))) <= this.m_eps) return !!this.confirmIsLine(i2, o2) && (i2.radius.set(Number.NaN), i2.center.setCoords(0, 0), true);
    {
      const s5 = i2.ptEnd.sub(i2.ptStart), r2 = n6.sub(i2.ptStart), o3 = s5.crossProduct(r2);
      if (0 === o3) return false;
      const a3 = 0.5 * s5.sqrLength(), h3 = 0.5 * r2.sqrLength();
      let m3 = a3 * r2.y - h3 * s5.y;
      m3 /= o3;
      let l3 = s5.x * h3 - r2.x * a3;
      l3 /= o3;
      const g3 = Math.sqrt(m3 * m3 + l3 * l3);
      if (4 * Number.EPSILON * g3 > this.m_eps) return false;
      const u2 = m3 + i2.ptStart.x, c2 = l3 + i2.ptStart.y;
      i2.radius.set(g3), i2.center.setCoords(u2, c2);
      const _2 = this.maxCircleApproximationError(e5, t2, i2);
      if (_2 > this.m_eps) return i2.maxError = _2, false;
    }
    const a2 = new an().assignPoint2D(i2.ptStart), h2 = new an().assignPoint2D(i2.ptEnd).sub(a2), m2 = new an().assignPoint2D(n6).sub(a2), l2 = h2.crossProduct(m2);
    if (l2.isZero()) return false;
    const g2 = h2.sqrLength().mulDouble(0.5), u = m2.sqrLength().mulDouble(0.5), c = g2.mul(m2.y).sub(u.mul(h2.y)), _ = h2.x.mul(u).sub(m2.x.mul(g2)), d2 = c.mul(c).add(_.mul(_)), p3 = l2.clone();
    p3.invertThis(), i2.fradius2 = d2.mul(p3).mul(p3), i2.fcenter.setCoords(c.mul(p3).add(a2.x), _.mul(p3).add(a2.y)), i2.center.setWithEps(i2.fcenter.asPoint2D()), i2.radius.setWithEps(Math.sqrt(i2.fradius2.toDouble()));
    const f3 = Se.constructPoint2D(i2.ptStart).subE(i2.center), x4 = Se.constructPoint2D(i2.ptEnd).subE(i2.center);
    if (!f3.dotProduct(x4).gt(I2)) return false;
    const y2 = this.maxCircleApproximationError(e5, t2, i2);
    return i2.maxError = y2, y2 <= this.m_eps;
  }
  static checkSweepAngle(e5, t2) {
    if (e5.getGeometryType() === a.enumEllipticArc) {
      const s4 = e5, n6 = Ah(s4, t2.vmin), r = Ah(s4, t2.vmax);
      return !(Math.abs(r - n6) > 0.5 * Yt);
    }
    return true;
  }
  confirmIsLine(e5, t2) {
    const s4 = e5.ptEnd.sub(e5.ptStart);
    return !(Math.abs(t2.dotProduct(s4.mul(0.25))) > this.m_eps) && !(Math.abs(t2.dotProduct(s4.mul(0.75))) > this.m_eps);
  }
  maxCircleApproximationError(e5, t2, s4) {
    const n6 = [0.25, 0.75], r = [0.1, 0.25, 0.75, 0.9];
    let i2, a2;
    e5.getGeometryType() === a.enumEllipticArc ? (i2 = n6, a2 = n6.length) : (i2 = r, a2 = r.length);
    let h2 = 0;
    for (let o2 = 0; o2 < a2; ++o2) {
      const n7 = new ei();
      e5.queryCoord2D(Q(t2.vmin, t2.vmax, i2[o2]), n7);
      const r2 = n7.sub(s4.center.value()).length(), a3 = Math.abs(r2 - s4.radius.value());
      a3 > h2 && (h2 = a3);
    }
    return h2;
  }
  approximateWithCirclesImpl(e5, t2) {
    let s4 = 1;
    t2 && t2.push(0);
    const n6 = Lt(9, Number.NaN);
    let r;
    e5 ? r = this.m_left.getMonotonicPartParams(n6.length, n6) : (n6[0] = 0, n6[1] = 1, r = 2);
    const i2 = [], o2 = [], a2 = new ei(0, 0);
    for (let h2 = 1; h2 < r; h2++) {
      const e6 = new x2(n6[h2 - 1], n6[h2]);
      for (this.m_bReversedLeft = !_na.goodOrientation(this.m_left, e6), this.m_bReversedLeft ? (i2.push(sa2(a2, e6.vmin, 0, 0)), i2.push(sa2(a2, e6.vmax, 0, 0))) : (i2.push(sa2(a2, e6.vmax, 0, 0)), i2.push(sa2(a2, e6.vmin, 0, 0))), i2[0].pt = this.m_left.getCoord2D(i2[0].t), i2[1].pt = this.m_left.getCoord2D(i2[1].t); i2.length > 1; ) {
        this.progress_();
        const e7 = i2.at(-1);
        let n7 = e7.checkCount, r2 = e7.err;
        const a3 = e7.pt.clone(), h3 = e7.t, m2 = i2[i2.length - 2].t, l2 = 0.5 * (h3 + m2), g2 = this.m_left.getCoord2D(l2);
        if (r2 <= this.m_eps || n7 >= ea2) {
          const e8 = new x2();
          if (e8.setCoords(h3, m2), this.closeToCircularArc(this.m_left, e8, a3, g2, i2[i2.length - 2].pt, this.m_leftArc)) {
            t2 && (this.m_bReversedLeft ? o2.push(h3) : t2.push(m2)), s4++, i2.pop();
            continue;
          }
          n7 = 0, r2 = this.m_leftArc.maxError;
        }
        e7.t = l2, e7.pt.setCoordsPoint2D(g2), r2 *= ta2, n7++, e7.err = r2, e7.checkCount = n7, i2.push(sa2(a3, h3, r2, n7));
      }
      this.m_bReversedLeft && t2 && (t2.length = t2.length + o2.length, Tt(t2, o2.reverse(), t2.length - o2.length, 0, o2.length), o2.length = 0), i2.length = 0;
    }
    return s4;
  }
  approximateWithCirclesImplPolyline(e5) {
    const t2 = new Na(), s4 = [];
    if (!this.approximateWithCirclesImpl(true, s4)) return t2;
    let n6 = 0;
    const r = this.m_left.getStartXY();
    t2.startPath(r);
    for (let i2 = 1; i2 < s4.length; ++i2) if (e5) t2.lineTo(this.m_left.getCoord2D(s4[i2]));
    else {
      const e6 = new ei();
      this.m_left.queryCoord2D(s4[i2], e6);
      const o2 = new ei();
      this.m_left.queryCoord2D(0.5 * (s4[i2] + n6), o2);
      const a2 = new Oa();
      a2.constructCircularArcThreePoint(r, e6, o2), t2.addSegment(a2, false), r.assign(e6), n6 = s4[i2];
    }
    return t2;
  }
  static goodOrientation(e5, t2) {
    const s4 = e5.getCoord2D(t2.vmin), n6 = e5.getCoord2D(t2.vmax);
    return s4.compare(n6) < 0;
  }
  progress_(e5 = false) {
  }
};
function ra2(e5, t2, s4, n6, r, i2, o2) {
  oa2(e5, t2, s4, r, i2, o2);
}
function ia2(e5, t2, s4, n6) {
  if (!h(e5.getGeometryType())) return e5;
  const r = e5.getImpl();
  if (!r.hasNonLinearSegments()) return e5;
  const i2 = e5.createInstance();
  if (i2.getGeometryType() === a.enumPolygon) {
    i2.setFillRule(e5.getFillRule());
  }
  new Tm();
  const a2 = new ee(), m2 = new nu(), l2 = [], g2 = [], u = [], c = e5.getDescription().getAttributeCount() > 1, _ = r.querySegmentIterator();
  for (; _.nextPath(); ) {
    let e6 = true;
    for (; _.hasNextSegment(); ) {
      const n7 = _.isClosingSegment(), r2 = _.nextSegment();
      if (!r2.isCurve()) {
        i2.addSegment(r2, e6, n7), e6 = false;
        continue;
      }
      let h2, d2 = false;
      const p3 = true, f3 = true;
      switch (r2.getGeometryType()) {
        case a.enumEllipticArc:
        case a.enumRationalBezier2:
          h2 = oh(r2, t2, s4, p3, f3, g2, u, l2), d2 = true;
          break;
        default:
          h2 = ih(r2, t2, s4, true, p3, g2, l2);
      }
      const x4 = d2 ? 2 : 3;
      g2[1].isNAN() ? (m2.createLine(), m2.get().construct(g2[0], g2[x4])) : d2 ? (m2.createQuadraticRationalBezier(), m2.get().constructArrayWeights(g2, u)) : (m2.createCubicBezier(), m2.get().constructPoints(g2)), c && e6 && (r2.queryCoord(l2[0], a2), m2.get().setStart(a2)), c && (r2.queryCoord(l2[1], a2), m2.get().setEnd(a2)), i2.addSegment(m2.get(), e6, n7 && 1 === h2), e6 = false;
      for (let e7 = 1, t3 = h2, s5 = x4; e7 < t3; ++e7, s5 += x4) g2[s5 + 1].isNAN() ? (m2.createLine(), m2.get().construct(g2[s5], g2[s5 + x4])) : d2 ? (m2.createQuadraticRationalBezier(), m2.get().constructArrayWeights(g2.slice(s5), u.slice(s5))) : (m2.createCubicBezier(), m2.get().constructPoints(g2.slice(s5))), c && (r2.queryCoord(l2[e7 + 1], a2), m2.get().setEnd(a2)), i2.addSegment(m2.get(), false, n7 && e7 + 1 === t3);
    }
  }
  return i2;
}
function oa2(e5, t2, s4, n6, r, i2) {
  e5.hasCurves() ? (e5.setCurveStitcherPointer(n6), n6.m_impl = new _a2(i2, false, null), n6.m_impl.buildMonotonicCurveParentage(e5, t2, s4, r)) : n6.m_impl = null;
}
function aa2(e5, t2, s4, n6, r, i2, o2, a2) {
  e5.hasCurves() ? (e5.setCurveStitcherPointer(i2), i2.m_impl = new _a2(a2, true, r), i2.m_impl.buildMonotonicCurveParentage(e5, t2, s4, o2), ya2(e5, s4, a2)) : i2.m_impl = null;
}
function ha2(e5) {
  if (!e5.hasSegmentParentage()) return;
  const t2 = new st2(0), s4 = e5.queryVertexIteratorOnSelection();
  for (let o2 = s4.next(); o2 !== bm; o2 = s4.next()) t2.add(o2);
  if (0 === t2.size()) return;
  e5.sortVerticesSimpleByY(t2, 0, t2.size()), t2.add(bm);
  const n6 = ei.getNAN();
  e5.queryXY(t2.read(0), n6);
  let r = 0;
  const i2 = ei.getNAN();
  for (let o2 = 1, a2 = t2.size(); o2 < a2; o2++) {
    {
      const s5 = t2.read(o2);
      s5 !== bm ? e5.queryXY(s5, i2) : i2.setNAN();
    }
    if (!i2.isEqualPoint2D(n6)) {
      let s5 = false, a3 = -2;
      for (let n7 = r; n7 < o2; ++n7) {
        const r2 = t2.read(n7);
        if (e5.getSegmentParentageBreakVertex(r2)) {
          s5 = true;
          break;
        }
        let i3 = e5.getSegmentParentage(r2);
        const o3 = e5.getPrevVertex(r2);
        if (o3 !== bm) {
          let t3 = e5.getSegmentParentage(o3);
          if (-1 === i3 && (i3 = t3), -1 === t3 && (t3 = i3), i3 !== t3) {
            s5 = true;
            break;
          }
        }
        if (-2 !== a3 && i3 !== a3) {
          s5 = true;
          break;
        }
        a3 = i3;
      }
      if (s5) for (let n7 = r; n7 < o2; ++n7) e5.setSegmentParentageBreakVertex(t2.read(n7), true);
      n6.setCoordsPoint2D(i2), r = o2;
    }
  }
}
function ma2(e5, t2) {
  let s4 = t2.isEmpty() ? e5 : wt2(null, t2, true).total();
  return s4 > e5 && (s4 = e5), 0.125 * s4;
}
function la2(t2, s4) {
  return s4 || (s4 = n4.constructEmpty()), ma2(t2, s4);
}
function ga2(e5, t2) {
  return 0.125 * e5;
}
function ua2(e5, t2) {
  return 3 * e5 + 3 * t2;
}
var ca2 = class {
  constructor() {
    this.m_impl = null;
  }
  stitchCurves(e5, t2, s4, n6) {
    this.m_impl && (this.m_impl.stitchCurves(e5, t2, s4), n6 && this.clearStitcher(e5));
  }
  clearStitcher(e5) {
    this.m_impl && (this.m_impl.clearStitcher(e5), this.m_impl = null);
  }
  getOriginalVertexIndex(e5, t2) {
    return this.m_impl.getOriginalVertexIndex(e5, t2);
  }
  getOriginalSegmentTypeInfo(e5) {
    return this.m_impl.getOriginalSegmentTypeInfo(e5);
  }
};
var _a2 = class __a {
  constructor(e5, t2, s4) {
    this.m_originalPlanarSegments = [], this.m_progressTracker = null, this.m_nsr = null, this.m_progressTracker = e5, this.m_nsr = s4, this.m_tolerance = 0, this.m_originalVertexIndex = -1, this.m_type = 0, this.m_progressCounter = 0, this.m_bIsSimple = t2;
  }
  buildMonotonicCurveParentage(e5, t2, n6, r) {
    const i2 = false, a2 = true;
    if (!e5.hasCurves()) return;
    n2(!e5.hasSegmentParentage()), this.m_type = 1, this.m_originalPlanarSegments.length = 0, this.m_bIsSimple && (this.m_originalVertexIndex = e5.createUserIndex()), this.m_tolerance = n6;
    const h2 = new ee(), m2 = new nu(), l2 = [], g2 = [], u = [];
    for (let c = e5.getFirstGeometry(); c !== bm; c = e5.getNextGeometry(c)) for (let r2 = e5.getFirstPath(c); r2 !== bm; r2 = e5.getNextPath(r2)) {
      let c2 = e5.getPathSize(r2), _ = e5.getFirstVertex(r2), d2 = 0, p3 = -1;
      for (let f3 = 0; f3 < c2; f3++) {
        let x4 = e5.getNextVertex(_);
        if (!e5.querySegment(_, m2, true, false)) {
          _ = x4;
          continue;
        }
        if (0 === d2) {
          p3 = e5.getVertexIndex(_);
          const t3 = __a.regularizeCurve(e5, m2.get(), _, n6);
          if (t3 >= 0) {
            this.m_nsr && 0 === this.m_nsr.m_reason && this.m_nsr.assign(new es2(13, p3, -1)), d2 = t3, c2 = e5.getPathSize(r2), x4 = e5.getNextVertex(_);
            const n7 = e5.querySegment(_, m2, true, false);
            n2(n7);
          }
        } else d2--;
        const y2 = e5.getVertexIndex(_);
        let P5;
        -1 !== this.m_originalVertexIndex && e5.setUserIndex(_, this.m_originalVertexIndex, p3), e5.setSegmentToIndex(y2, null);
        let E2 = false;
        switch (m2.get().getGeometryType()) {
          case a.enumEllipticArc:
          case a.enumRationalBezier2:
            P5 = oh(m2.get(), t2, n6, i2, a2, g2, u, l2), E2 = true;
            break;
          default: {
            const e6 = !this.m_bIsSimple || !m2.get().isMonotoneQuickAndDirty();
            P5 = ih(m2.get(), t2, n6, e6, i2, g2, l2);
          }
        }
        const C2 = this.m_originalPlanarSegments.length;
        if (e5.setSegmentParentageAndBreak(_, C2, true), !g2[1].isNAN()) {
          let t3 = null;
          t3 = E2 ? new on({ points: g2, weights: u }) : new mo({ cp: g2 }), t3.snapControlPoints(n6 * n6), e5.setSegmentToIndex(y2, t3);
        }
        const S3 = E2 ? 2 : 3;
        for (let t3 = 1, s4 = P5, i3 = S3; t3 < s4; ++t3, i3 += S3) {
          m2.get().queryCoord(l2[t3], h2);
          const s5 = e5.insertVertex(r2, x4, h2);
          if (-1 !== this.m_originalVertexIndex && e5.setUserIndex(s5, this.m_originalVertexIndex, p3), !g2[i3 + 1].isNAN()) if (E2) {
            const t4 = new on({ points: g2.slice(i3), weights: u.slice(i3) });
            t4.snapControlPoints(n6 * n6), e5.setSegmentToIndex(e5.getVertexIndex(s5), t4);
          } else {
            const t4 = new mo({ cp: g2.slice(i3) });
            t4.snapControlPoints(n6 * n6), e5.setSegmentToIndex(e5.getVertexIndex(s5), t4);
          }
          e5.setSegmentParentageAndBreak(s5, C2, false);
        }
        P5 > 1 && (f3 += P5 - 1, c2 = e5.getPathSize(r2)), this.m_originalPlanarSegments.push(m2.releaseSegment()), _ = x4;
      }
    }
  }
  stitchCurves(e5, t2, s4) {
    __a.st_stitchCurvesImpl(this, e5, t2, s4, false);
  }
  clearStitcher(e5) {
    this.m_originalPlanarSegments.length = 0, -1 !== this.m_originalVertexIndex && (e5.removeUserIndex(this.m_originalVertexIndex), this.m_originalVertexIndex = -1), e5.deleteSegmentParentage();
  }
  static st_verifyParentage(e5) {
    __a.st_stitchCurvesImpl(null, e5, bm, 0, true);
  }
  getOriginalVertexIndex(e5, t2) {
    return -1 !== this.m_originalVertexIndex && t2 !== bm ? e5.getUserIndex(t2, this.m_originalVertexIndex) : -1;
  }
  getOriginalSegmentTypeInfo(e5) {
    if (-1 !== e5) {
      const t2 = this.m_originalPlanarSegments[e5];
      switch (t2.getGeometryType()) {
        case a.enumEllipticArc:
          return 0 === t2.projectionBehavior() ? 0 : 1;
        case a.enumBezier:
          return 2;
        case a.enumBezier2:
          return 3;
        case a.enumLine:
          return -1;
        case a.enumRationalBezier2:
          return 4;
        default:
          z("");
      }
    }
    return -1;
  }
  progress_(e5 = false) {
    this.m_progressCounter++;
  }
  processSpan_(e5, t2, n6, r, i2, o2, a2) {
    if (t2 === n6 && 0 === r) return n2(e5.getNextVertex(t2) === bm), e5.setSegmentToIndex(e5.getVertexIndex(t2), null), void e5.setSegmentParentageAndBreak(t2, -1);
    const h2 = e5.getNextVertex(t2);
    {
      let t3 = 2;
      for (let s4 = h2; s4 !== n6; s4 = e5.getNextVertex(s4)) t3++;
      n2(t3 === r);
    }
    if (null === i2) {
      e5.setSegmentToIndex(e5.getVertexIndex(t2), null);
      for (let t3 = h2; t3 !== n6; ) t3 = e5.removeVertex(t3, true);
      return;
    }
    const m2 = e5.getXY(t2), l2 = e5.getXY(n6);
    if (i2.isClosed()) {
      if (m2.isEqualPoint2D(l2) && m2.isEqualPoint2D(i2.getStartXY())) {
        let s4;
        if (s4 = this.verifySegmentFitness(e5, t2, n6, r, i2, o2, a2)) {
          const r2 = i2.clone();
          return r2.dropAllAttributes(), s4 < 0 && r2.reverse(), this.removeSpan(e5, t2, n6), void e5.setSegmentToIndex(e5.getVertexIndex(t2), r2);
        }
      }
    } else if (m2.isEqualPoint2D(i2.getStartXY())) {
      if (l2.isEqualPoint2D(i2.getEndXY())) {
        const s4 = i2.clone();
        if (s4.dropAllAttributes(), this.verifySegmentFitness(e5, t2, n6, r, s4, o2, a2)) return this.removeSpan(e5, t2, n6), void e5.setSegmentToIndex(e5.getVertexIndex(t2), s4);
      }
    } else if (l2.isEqualPoint2D(i2.getStartXY()) && m2.isEqualPoint2D(i2.getEndXY())) {
      const s4 = i2.getReversed();
      if (s4.dropAllAttributes(), this.verifySegmentFitness(e5, t2, n6, r, s4, o2, a2)) return this.removeSpan(e5, t2, n6), void e5.setSegmentToIndex(e5.getVertexIndex(t2), s4);
    }
    this.processSpanSplitSegment(e5, t2, n6, r, i2, o2, a2);
  }
  processSpanSplitSegment(e5, t2, s4, n6, r, i2, o2) {
    if (r.isLine()) return;
    if (this.fitSegmentToSpan(e5, t2, s4, n6, r, i2, o2)) return;
    const a2 = o2 * o2;
    let h2 = n6, m2 = t2;
    const l2 = e5.getXY(t2);
    let g2 = r.getClosestCoordinate(l2, false);
    const u = r.getCoord2D(g2);
    let c = false;
    const _ = ei.sqrDistance(l2, u);
    if (_ > a2) {
      const n7 = e5.getNextVertex(t2);
      if (this.approximateSpanSection(e5, t2, r, i2, o2), n7 === s4) return;
      m2 = n7, c = true, h2 -= 1;
    }
    let d2 = s4;
    const p3 = e5.getXY(s4);
    g2 = r.getClosestCoordinate(p3, false);
    const f3 = r.getCoord2D(g2);
    let x4 = false;
    const y2 = ei.sqrDistance(p3, f3);
    if (y2 > a2) {
      const t3 = e5.getPrevVertex(s4);
      if (this.approximateSpanSection(e5, t3, r, i2, o2), t3 === m2) return;
      d2 = t3, x4 = true, h2 -= 1;
    }
    if ((c || x4) && this.fitSegmentToSpan(e5, m2, d2, h2, r, i2, o2)) return;
    let P5 = false;
    if (!c && _ > 0) {
      const s5 = e5.getNextVertex(t2);
      if (this.approximateSpanSection(e5, t2, r, i2, o2), s5 === d2) return;
      m2 = s5, c = true, P5 = true, h2 -= 1;
    }
    if (!x4 && y2 > 0) {
      const t3 = e5.getPrevVertex(s4);
      if (this.approximateSpanSection(e5, t3, r, i2, o2), t3 === m2) return;
      d2 = t3, x4 = true, P5 = true, h2 -= 1;
    }
    if (P5 && this.fitSegmentToSpan(e5, m2, d2, h2, r, i2, o2)) return;
    let E2 = m2;
    for (; ; ) {
      const t3 = e5.getNextVertex(E2);
      if (this.approximateSpanSection(e5, E2, r, i2, o2), E2 = t3, E2 === d2) return;
    }
  }
  fitSegmentToSpan(e5, t2, n6, r, i2, o2, a2) {
    const h2 = 0 === this.m_type, m2 = [];
    if (m2.push(e5.getXY(t2)), h2) {
      let i3 = t2;
      const o3 = 32;
      if (r > o3) {
        const t3 = BigInt(r - 1), a3 = BigInt(o3 - 1);
        let h3 = a3, l3 = 0n;
        for (let s4 = 1; s4 < r; s4++, h3 += a3) if (i3 = e5.getNextVertex(i3), h3 >= l3 + t3) {
          l3 += t3;
          const s5 = e5.getXY(i3);
          m2.push(s5);
        }
        n2(i3 === n6);
      } else {
        for (let t3 = 1; t3 < r; t3++) {
          i3 = e5.getNextVertex(i3);
          const t4 = e5.getXY(i3);
          m2.push(t4);
        }
        n2(i3 === n6);
      }
    } else {
      let s4 = t2;
      const i3 = new nu();
      for (; ; ) {
        e5.querySegment(s4, i3, false, true);
        const t3 = [0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9, 1];
        let o3 = 0;
        for (const e6 of t3) {
          (2 === r || 1 & o3) && m2.push(i3.get().getCoord2D(e6)), o3++;
        }
        if (s4 = e5.getNextVertex(s4), s4 === n6) break;
      }
    }
    const l2 = (() => {
      let e6 = m2[0].compare(m2.at(-1));
      if (0 === e6) {
        const t3 = new n3(0);
        jo2(m2, m2.length, t3), e6 = t3.getResult() >= 0 ? -1 : 1;
      }
      return e6 > 0;
    })();
    l2 && m2.reverse();
    const g2 = i2.clone();
    if (g2.dropAllAttributes(), g2.setSegmentFromCoords(m2, m2.length), l2 && g2.reverse(), g2.snapControlPoints(this.m_tolerance * this.m_tolerance), this.verifySegmentFitness(e5, t2, n6, r, g2, o2, a2)) {
      this.removeSpan(e5, t2, n6);
      const s4 = e5.getVertexIndex(t2);
      return e5.setSegmentToIndex(s4, g2), true;
    }
    return false;
  }
  approximateSpanSection(e5, t2, s4, n6, r) {
    const i2 = new nu();
    if (!e5.querySegment(t2, i2, true, false)) return;
    const a2 = s4.getGeometryType();
    if (a2 !== i2.get().getGeometryType()) {
      if (a2 === a.enumEllipticArc) {
        if (i2.get().getGeometryType() !== a.enumRationalBezier2) return;
        if (0 === s4.projectionBehavior()) {
          const s5 = [];
          Qo2(false, i2.get(), r, s5, this.m_progressTracker);
          const n7 = e5.getNextVertex(t2), o2 = e5.getPathFromVertex(t2), a3 = new ee();
          let h2 = t2;
          for (let t3 = 1, r2 = s5.length; t3 < r2; t3++) {
            const r3 = s5[t3], m2 = i2.get().getCoord2D(s5[t3 - 1]), l2 = i2.get().getCoord2D(Q(s5[t3 - 1], r3, 0.5));
            i2.get().queryCoord(r3, a3);
            const g2 = a3.getXY(), u = new Oa();
            u.constructCircularArcThreePoint(m2, g2, l2);
            let c = bm;
            r3 < 1 && (c = e5.insertVertex(o2, n7, a3)), e5.setSegmentToIndex(e5.getVertexIndex(h2), u), h2 = c;
          }
          return;
        }
        {
          const s5 = Rt(ei, 3);
          i2.get().queryControlPoints(s5);
          const n7 = [0, 0, 0];
          i2.get().queryWeights(n7);
          const r2 = tr(n7), o2 = new Oa();
          return rm(s5, r2 * r2, null, false, o2), void e5.setSegmentToIndex(e5.getVertexIndex(t2), o2);
        }
      }
      b("approximate_span_section_");
    }
  }
  verifySegmentFitness(e5, t2, s4, n6, r, i2, o2) {
    return 0 === this.m_type ? this.verifySegmentFitnessLines(e5, t2, s4, n6, r, i2, o2) : this.verifySegmentFitnessCurves(e5, t2, s4, n6, r, i2, o2);
  }
  verifySegmentFitnessCurves(e5, t2, s4, n6, r, i2, o2) {
    const a2 = e5.getXY(t2), h2 = e5.getXY(s4);
    if (!a2.isEqualPoint2D(r.getStartXY()) || !h2.isEqualPoint2D(r.getEndXY())) return 0;
    let m2 = 0;
    if (r.isClosed()) {
      const e6 = r.getCoord2D(0.1).sub(a2);
      m2 = r.getCoord2D(0.7).sub(a2).crossProduct(e6) >= 0 ? 1 : -1;
    }
    const l2 = Lt($e.s_maxMonotonicPartParams, Number.NaN);
    let g2 = r.getMonotonicPartParams(l2.length, l2);
    g2--;
    const u = new su(), c = [1, 0.5, 0.75, 0.25];
    let _ = 0, d2 = t2;
    const p3 = a2.clone();
    for (; ; ) {
      const t3 = e5.getNextVertex(d2);
      let n7 = e5.getSegment(d2);
      null === n7 && (e5.queryLineConnector(d2, u, true), n7 = u);
      for (let e6 = t3 === s4 ? 1 : 0; e6 < c.length; e6++) {
        const t4 = n7.getCoord2D(c[e6]);
        if (!r.isCloserThanDistance(t4, x2.unit(), o2)) return 0;
      }
      if (g2 > 1) for (let e6 = 1; e6 < g2; ) {
        const t4 = r.getCoord2D(l2[e6]);
        n7.isCloserThanDistance(t4, x2.unit(), o2) ? (l2[g2 - 1] = Mt(l2[e6], l2[e6] = l2[g2 - 1]), g2--) : e6++;
      }
      if (m2) {
        const e6 = n7.getCoord2D(0.25);
        _ += e6.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e6), e6.assign(n7.getCoord2D(0.75)), _ += e6.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e6);
      }
      if (d2 = t3, d2 === s4) return g2 > 1 ? 0 : m2 ? _ < 0 ? -m2 : m2 : 1;
    }
  }
  verifySegmentFitnessLines(e5, t2, n6, r, i2, o2, a2) {
    return n2(0), 0;
  }
  removeSpan(e5, t2, s4) {
    e5.setSegmentToIndex(e5.getVertexIndex(t2), null);
    const n6 = e5.getNextVertex(t2);
    n6 !== s4 && e5.removeVertices(n6, s4);
  }
  static st_stitchCurvesImpl(e5, t2, s4, n6, r) {
    if (t2.hasSegmentParentage()) return t2.hasCurves() ? __a.st_stitchCurvesFromCurvesImpl(e5, t2, s4, n6, r) : __a.st_stitchCurvesFromLinesImpl(e5, t2, s4, n6, r);
  }
  static st_stitchCurvesFromLinesImpl(e5, t2, n6, r, i2) {
    let o2 = n6 === bm ? t2.getFirstGeometry() : n6;
    for (; o2 !== bm; ) {
      for (let n7 = t2.getFirstPath(o2); n7 !== bm; n7 = t2.getNextPath(n7)) {
        let o3 = t2.getPathSize(n7);
        t2.isClosedPath(n7) && (o3 += 1);
        let a2 = true, h2 = false;
        const m2 = t2.getFirstVertex(n7);
        let l2 = m2;
        for (let n8 = 0; n8 < o3 && l2 !== bm; ) {
          let g2 = t2.getSegmentParentage(l2);
          if (-1 === g2 || a2) {
            a2 = false, n8++, l2 = t2.getNextVertex(l2), h2 = true;
            continue;
          }
          let u, c, _ = 0;
          if (h2 ? (u = t2.getPrevVertex(l2), c = l2, n2(u !== bm), n2(c !== u), n2(-1 === t2.getSegmentParentage(u) || m2 === u)) : (u = l2, c = t2.getNextVertex(u), n8++, n2(c !== bm), n2(c !== u), g2 = t2.getSegmentParentage(c)), _ = 2, h2 = false, -1 === g2 || t2.getSegmentParentageBreakVertex(c)) {
            l2 = c;
            continue;
          }
          let d2 = t2.getNextVertex(c);
          for (n8++; n8 < o3 && d2 !== bm; ) {
            c = d2, _++;
            const e6 = t2.getSegmentParentage(d2);
            if (-1 === e6 || t2.getSegmentParentageBreakVertex(d2)) break;
            n2(e6 === g2), n8++, d2 = t2.getNextVertex(d2);
          }
          if (!i2) {
            const s4 = e5.m_originalPlanarSegments[g2];
            e5.processSpan_(t2, u, c, _, s4, g2, r);
          }
          l2 = c;
        }
      }
      if (n6 !== bm) break;
      o2 = t2.getNextGeometry(o2);
    }
  }
  static st_stitchCurvesFromCurvesImpl(e5, t2, n6, r, i2) {
    let o2 = n6 === bm ? t2.getFirstGeometry() : n6;
    for (; o2 !== bm; ) if (p(t2.getGeometryType(o2))) {
      for (let n7 = t2.getFirstPath(o2); n7 !== bm; n7 = t2.getNextPath(n7)) {
        let o3 = t2.getPathSize(n7);
        const a2 = t2.isClosedPath(n7);
        a2 && (o3 += 1);
        let h2 = t2.getFirstVertex(n7);
        if (a2) {
          if (-1 !== t2.getSegmentParentage(h2)) {
            let e6 = h2;
            for (let s4 = 0; !t2.getSegmentParentageBreakVertex(e6); s4++) {
              if (s4 === o3) {
                h2 = t2.getFirstVertex(n7), t2.setSegmentParentageBreakVertex(e6, true);
                break;
              }
              e6 = t2.getPrevVertex(e6);
            }
          }
        } else n2(-1 === t2.getSegmentParentage(h2) || t2.getSegmentParentageBreakVertex(h2));
        let m2 = h2;
        for (let n8 = 0; n8 < o3 && m2 !== bm; ) {
          const a3 = t2.getSegmentParentage(m2);
          if (-1 === a3) {
            n8++, m2 = t2.getNextVertex(m2);
            continue;
          }
          let h3 = 0, l2 = bm;
          const g2 = m2;
          h3 = 1;
          let u = t2.getNextVertex(g2);
          for (; n8 < o3 && u !== bm; ) {
            n8++, l2 = u, h3++;
            const e6 = t2.getSegmentParentage(u);
            if (-1 === e6 || t2.getSegmentParentageBreakVertex(u)) break;
            n2(e6 === a3), u = t2.getNextVertex(u);
          }
          if (l2 === bm) break;
          if (!i2) {
            const s4 = e5.m_originalPlanarSegments[a3];
            e5.processSpan_(t2, g2, l2, h3, s4, a3, r);
          }
          m2 = l2;
        }
      }
      if (n6 !== bm) break;
      o2 = t2.getNextGeometry(o2);
    } else o2 = n6 === bm ? t2.getNextGeometry(o2) : bm;
  }
  static regularizeCurve(e5, t2, s4, n6) {
    let r = t2.snapControlPoints(n6 * n6);
    if (r) {
      const n7 = e5.getVertexIndex(s4), r2 = t2.clone();
      e5.setSegmentToIndex(n7, r2);
    }
    if (t2.getGeometryType() === mo.type) {
      const i2 = [], o2 = t2.calculateSpecialPointsForCracking(n6, i2);
      if (o2 > 0) {
        e5.splitSegment(s4, i2, o2), r = e5.snapControlPoints(s4, o2 + 1, n6 * n6) || r;
        for (let t3 = 0; t3 < o2; t3++) s4 = e5.getNextVertex(s4), e5.setSegmentParentageBreakVertex(s4, true);
        return o2;
      }
    }
    return r ? 0 : -1;
  }
};
function da2(e5, t2, s4, n6, r) {
  return new Ea2(e5, s4, t2, n6, r).do_();
}
function pa2(e5, t2, s4) {
  const n6 = Pt2(e5);
  return an2(t2.getX(), t2.getY(), s4.getX(), s4.getY(), $(n6));
}
function fa2(e5, t2, s4 = 1, n6 = 1, r = 1, i2 = 1) {
  if (n6 > i2) return e5;
  if (i2 > n6) return t2;
  const o2 = [0], a2 = [0], h2 = new ee();
  return ln2(e5, t2, s4, n6, r, i2, h2, a2, o2), h2;
}
function xa2(e5, t2, s4) {
  const n6 = Pt2(t2), r = Ft2(t2);
  return !!gn2(e5, n6, bm, null, s4) || Hn2(true, e5, r, null, s4);
}
function ya2(e5, t2, s4) {
  return Ea2.fixCurveTwoPointLoops(e5, t2, s4);
}
function Pa2(e5) {
  return Pt2(e5);
}
var Ea2 = class _Ea {
  constructor(e5, t2, s4, n6, r) {
    this.m_shape = e5, this.m_progressTracker = t2, this.m_tolerance = s4, this.m_bFilterDegenerateSegments = n6, this.m_bTrackChanges = r, this.m_progressCounter = 0;
  }
  do_() {
    const e5 = new bt(this.m_tolerance.tolerance, this.m_tolerance.resolution), t2 = 1e-5, s4 = 1e-6, n6 = Pa2(e5);
    let r = Ft2(e5);
    const i2 = r * (1 + t2);
    r *= 1 + s4;
    let o2 = false;
    const a2 = this.m_shape.getTotalPointCount() + 10 > 30 ? 1e3 : (this.m_shape.getTotalPointCount() + 10) * (this.m_shape.getTotalPointCount() + 10), h2 = this.m_shape.hasPointFeatures();
    for (let m2 = 0; ; m2++) {
      this.m_shape.dbgCheckSelection(), m2 > a2 && b("crack_and_cluster_iteration_exceeded"), this.m_shape.dbgVerifyMonotone();
      let e6 = -1;
      0 === m2 && (e6 = this.firstCrack_(), o2 || (o2 = e6 > 0));
      const t3 = this.cluster_(n6);
      if (this.m_shape.dbgVerifyMonotone(), o2 || (o2 = t3), this.m_bFilterDegenerateSegments) {
        const e7 = 0 !== this.m_shape.filterClosePoints(n6, true, false, this.m_bTrackChanges, bm);
        o2 || (o2 = e7), this.m_shape.dbgVerifyMonotone();
      }
      const s5 = this.m_shape.snapControlPointsOnSelection(i2 * i2);
      o2 || (o2 = s5), this.m_shape.dbgCheckSelection();
      let l2 = false;
      if ((0 === m2 && -1 === e6 || h2 || Hn2(true, this.m_shape, r, null, this.m_progressTracker)) && (l2 = this.crack_(i2), o2 || (o2 = l2), this.m_shape.dbgVerifyMonotone()), !l2 && !_Ea.fixCurveTwoPointLoops(this.m_shape, n6, this.m_progressTracker)) {
        this.m_shape.dbgVerifyMonotone();
        break;
      }
    }
    return o2 && ha2(this.m_shape), o2;
  }
  cluster_(e5) {
    return on2(this.m_shape, e5, bm, this.m_bTrackChanges, this.m_progressTracker);
  }
  crack_(e5) {
    return Fn2(this.m_shape, e5, this.m_bTrackChanges, this.m_progressTracker);
  }
  static fixCurveTwoPointLoops(e5, t2, n6) {
    if (!e5.hasCurves()) return false;
    e5.dbgVerifyCurves();
    const r = e5.createUserIndexUninitialized(), i2 = new st2(0), o2 = e5.queryVertexIteratorOnSelection();
    for (let s4 = o2.next(); s4 !== bm; s4 = o2.next()) i2.add(s4), e5.setUserIndex(s4, r, -1);
    if (0 === i2.size()) return false;
    i2.add(bm), e5.sortVerticesSimpleByY(i2, 0, i2.size() - 1);
    let a2 = 0;
    const h2 = e5.getXY(i2.read(a2)), m2 = new ei(Number.NaN, Number.NaN), l2 = [];
    for (let s4 = 1, g2 = i2.size(); s4 < g2; ++s4) {
      const t3 = i2.read(s4), n7 = t3 !== bm ? e5.getXY(t3) : m2;
      if (n7.equals(h2)) continue;
      const o3 = [];
      for (let m3 = a2; m3 < s4; m3++) {
        const t4 = i2.read(m3), s5 = e5.getPrevVertex(t4);
        if (s5 !== bm && -1 === e5.getUserIndex(s5, r)) {
          const t5 = Ca2(e5.getXY(s5), e5.getSegment(s5));
          0 !== ei.sqrDistance(h2, t5.otherPt) && (t5.vert = s5, t5.dir = -1, o3.push(t5)), e5.setUserIndex(s5, r, 1);
        }
        const n8 = e5.getNextVertex(t4);
        if (n8 !== bm && -1 === e5.getUserIndex(t4, r)) {
          const s6 = Ca2(e5.getXY(n8), e5.getSegment(t4));
          0 !== ei.sqrDistance(h2, s6.otherPt) && (s6.vert = t4, s6.dir = 1, o3.push(s6)), e5.setUserIndex(t4, r, 1);
        }
      }
      if (o3.length > 1) {
        o3.sort((e7, t5) => ba2(e7, t5));
        const e6 = Ca2(m2.clone(), null);
        o3.push(e6);
        let t4 = 0;
        for (let s5 = 1, n8 = o3.length; s5 < n8; s5++) if (!o3[s5].otherPt.equals(o3[s5 - 1].otherPt)) {
          if (s5 - t4 > 1 && null !== o3[t4].seg) {
            let e7 = false;
            const n9 = t4;
            for (let r2 = t4 + 1; r2 < s5; r2++) if (!Sa2(o3[n9], o3[r2])) {
              e7 = true;
              break;
            }
            if (e7) for (let r2 = t4; r2 < s5 && null !== o3[r2].seg; r2++) l2.push(o3[r2].vert);
          }
          t4 = s5;
        }
      }
      a2 = s4, h2.setCoordsPoint2D(n7);
    }
    for (const g2 of l2) {
      const n7 = e5.getSegment(g2);
      n2(null !== n7);
      const r2 = e5.getXY(g2), i3 = e5.getXY(e5.getNextVertex(g2));
      if (ei.distance(r2, i3) < 3 * t2) e5.setSegmentToIndex(e5.getVertexIndex(g2), null);
      else {
        const t3 = n7.lengthToT(0.5 * n7.calculateLength2D());
        e5.splitSegment(g2, [t3], 1);
      }
    }
    return e5.removeUserIndex(r), l2.length > 0;
  }
  firstCrack_() {
    const e5 = this.m_shape.getEnvelope2D(this.m_progressTracker), t2 = wt2(null, e5, true).total();
    if (4 * t2 < this.m_tolerance.total()) {
      let e6 = false;
      const s4 = 1.1 * t2, n6 = t2, r = this.cluster_(s4);
      e6 || (e6 = r);
      let i2 = 0;
      this.m_bFilterDegenerateSegments && (i2 = this.m_shape.filterClosePoints(0, true, false, this.m_bTrackChanges, bm));
      const o2 = this.crack_(n6);
      return e6 || (e6 = o2), e6 ? 1 : i2 ? 2 : 0;
    }
    return -1;
  }
  progress_(e5 = false) {
    this.m_progressCounter++, !e5 && 4095 & this.m_progressCounter || (this.m_progressCounter = 0);
  }
};
function Ca2(e5, t2) {
  return { otherPt: e5, seg: t2, vert: -1, dir: 0 };
}
function Sa2(e5, t2) {
  if (n2(e5.otherPt.equals(t2.otherPt)), null === e5.seg) return null === t2.seg;
  if (null === t2.seg) return false;
  const n6 = e5.seg.getGeometryType();
  if (n6 !== t2.seg.getGeometryType()) return false;
  if (n6 === a.enumBezier) {
    const s4 = e5.seg, n7 = t2.seg;
    let r = s4.getControlPoint1(), i2 = s4.getControlPoint2();
    -1 === e5.dir && (i2 = Mt(r, r = i2));
    let o2 = n7.getControlPoint1(), a2 = n7.getControlPoint2();
    return -1 === t2.dir && (a2 = Mt(o2, o2 = a2)), r.equals(o2) && i2.equals(a2);
  }
  if (n6 === a.enumRationalBezier2) {
    const s4 = e5.seg, n7 = t2.seg, r = s4.getControlPoint1(), i2 = n7.getControlPoint1();
    if (!r.equals(i2)) return false;
    const o2 = [0, 0, 0];
    s4.queryWeights(o2), -1 === e5.dir && (o2[2] = Mt(o2[0], o2[0] = o2[2]));
    const a2 = [0, 0, 0];
    return n7.queryWeights(a2), -1 === t2.dir && (a2[2] = Mt(a2[0], a2[0] = a2[2])), o2[0] === a2[0] && o2[1] === a2[1] && o2[2] === a2[2];
  }
  b("");
}
function Ia2(e5, t2) {
  if (null === e5.seg || null === t2.seg) return null !== e5.seg ? -1 : null !== t2.seg ? 1 : 0;
  const s4 = e5.seg.getGeometryType(), n6 = t2.seg.getGeometryType();
  return s4 < n6 ? -1 : s4 > n6 ? 1 : 0;
}
function ba2(e5, t2) {
  const s4 = e5.otherPt.compare(t2.otherPt);
  return 0 !== s4 ? s4 : Ia2(e5, t2);
}
var wa2 = h;
var va2 = f;
var Na2 = m;
function Ta2(e5) {
  switch (e5) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 3:
      return 3;
    case 4:
      return 4;
    case 0:
      return 0;
    default:
      n2(0, "unrecognized cut side");
  }
  return 3;
}
function Ga2() {
  return { unsplitBehavior: 0, allCrossRoadsImpassable: false, ogcRule: false };
}
function Da2(e5, t2, s4, n6) {
  return new za2(n6).autoCompleteImpl(e5, t2, s4);
}
function Va2(e5, t2, s4, n6, r, i2, a2) {
  const h2 = new za2(r);
  h2.m_bOGCOutput = true;
  const m2 = e5.getGeometryType() === a.enumPolygon && 1 === e5.getFillRule() && !Ht(n6);
  return h2.planarSimplifyImpl_(e5, t2, m2, s4, n6, r, i2, a2);
}
function Fa2(e5, t2, s4, n6, r, i2, o2, a2) {
  return new za2(i2).planarSimplifyImpl_(e5, t2, s4, n6, r, i2, o2, a2);
}
function Ha2(e5, t2, n6, r) {
  const i2 = new za2(r), o2 = new Tm(), a2 = o2.addGeometry(t2), h2 = i2.planarSimplifyNoCrackingAndCluster(e5, o2, a2, n6);
  n2(h2, "planar_simplify_no_cracking_and_cluster");
  return o2.getGeometry(a2);
}
function ka2(e5, t2, n6, r, i2, o2, a2) {
  return n2(0), {};
}
function Aa2(e5, t2, n6, r) {
  return n2(0), {};
}
function Ma2(e5, t2, s4) {
  return ja2(e5, t2, s4);
}
function Ua2(t2, s4, n6, r) {
  if (t2.isEmpty() || s4.isEmpty() || t2.getDimension() > s4.getDimension()) return Za2(Ka(t2), t2, s4, "-");
  const i2 = new n4();
  t2.queryEnvelope(i2);
  const a2 = new n4();
  s4.queryEnvelope(a2);
  const h2 = new n4();
  h2.setCoords({ env2D: i2 }), h2.mergeEnvelope2D(a2);
  const m2 = wt2(n6, h2, true), l2 = a2.clone(), g2 = Pt2(m2);
  if (l2.inflateCoords(g2, g2), !i2.isIntersecting(l2)) return Za2(Ka(t2), t2, s4, "-");
  const u = new za2(r), c = new Tm(), _ = c.addGeometry(Ka(t2)), d2 = c.addGeometry(Ka(s4));
  let p3 = 0, f3 = 0, x4 = null;
  if (c.hasCurves()) {
    x4 = new ca2();
    const e5 = c.getEnvelope2D(r);
    f3 = ga2(m2.total());
    const t3 = la2(m2.total(), e5);
    p3 = ua2(t3, f3), ra2(c, t3, m2.total(), 12e3, x4, null, r);
  }
  u.setEditShapeCrackAndCluster(c, m2.add(p3));
  const y2 = u.difference(_, d2);
  null !== x4 && x4.stitchCurves(c, y2, f3, true);
  const P5 = Za2(c.getGeometry(y2), t2, s4, "-");
  return wa2(P5.getGeometryType()) && (P5.getImpl().setIsSimple(4, m2.total()), P5.getGeometryType() === a.enumPolygon && P5.getImpl().updateOGCFlagsProtected()), P5;
}
function qa2(t2, s4, n6, r) {
  if (t2.getDimension() > s4.getDimension()) return Za2(Ka(t2), t2, s4, "^");
  if (t2.getDimension() < s4.getDimension()) return Za2(Ka(s4), t2, s4, "^");
  if (t2.isEmpty()) return Za2(Ka(s4), t2, s4, "^");
  if (s4.isEmpty()) return Za2(Ka(t2), t2, s4, "^");
  const i2 = new n4();
  t2.queryEnvelope(i2);
  const a2 = new n4();
  s4.queryEnvelope(a2);
  const h2 = new n4();
  h2.setCoords({ env2D: i2 }), h2.mergeEnvelope2D(a2);
  const m2 = wt2(n6, h2, true), l2 = new za2(r), g2 = new Tm(), u = g2.addGeometry(Ka(t2)), c = g2.addGeometry(Ka(s4));
  let _ = 0, d2 = null;
  if (g2.hasCurves()) {
    d2 = new ca2();
    const e5 = g2.getEnvelope2D(r);
    _ = ga2(m2.total());
    ra2(g2, la2(m2.total(), e5), m2.total(), 12e3, d2, null, r);
  }
  l2.setEditShapeCrackAndCluster(g2, m2);
  const p3 = l2.symmetricDifference(u, c);
  null !== d2 && d2.stitchCurves(g2, p3, _, true);
  const f3 = Za2(g2.getGeometry(p3), t2, s4, "^");
  return wa2(f3.getGeometryType()) && (f3.getImpl().setIsSimple(4, m2.total()), f3.getGeometryType() === a.enumPolygon && f3.getImpl().updateOGCFlagsProtected()), f3;
}
function Oa2(e5, t2, s4) {
  return Wa2(e5, t2, s4, true);
}
function Ba2(e5, t2, s4) {
  return e5.isEmpty() || t2.isEmpty() ? e5.createInstance() : pa2(s4, e5, t2) ? new ee({ copy: fa2(e5, t2) }) : e5.createInstance();
}
function Ra2(t2, s4, n6, r) {
  const i2 = n4.constructEmpty();
  t2.queryEnvelope(i2);
  const a2 = n4.constructEmpty();
  s4.queryEnvelope(a2);
  const h2 = n4.constructEmpty();
  h2.setCoords({ env2D: i2 }), h2.mergeEnvelope2D(a2);
  const m2 = wt2(n6, h2, true), l2 = new n4(a2), g2 = Pt2(m2);
  if (l2.inflateCoords(g2, g2), !i2.isIntersecting(l2)) {
    if (t2.getDimension() <= s4.getDimension()) return Za2(Ka(t2.createInstance()), t2, s4, "&");
    if (t2.getDimension() > s4.getDimension()) return Za2(Ka(s4.createInstance()), t2, s4, "&");
  }
  const u = new za2(r), c = new Tm(), _ = c.addGeometry(Ka(t2)), d2 = c.addGeometry(Ka(s4));
  let p3 = 0, f3 = 0, x4 = null;
  if (c.hasCurves()) {
    x4 = new ca2();
    const e5 = c.getEnvelope2D(r);
    f3 = ga2(m2.total());
    const t3 = la2(m2.total(), e5);
    p3 = ua2(t3, f3), ra2(c, t3, m2.total(), 12e3, x4, null, r);
  }
  u.setEditShapeCrackAndCluster(c, m2.add(p3));
  const y2 = u.intersection(_, d2);
  null !== x4 && x4.stitchCurves(c, y2, f3, true);
  const P5 = Za2(c.getGeometry(y2), t2, s4, "&");
  return wa2(P5.getGeometryType()) && (P5.getImpl().setIsSimple(4, m2.total()), P5.getGeometryType() === a.enumPolygon && P5.getImpl().updateOGCFlagsProtected()), P5;
}
function Ya2(t2, s4, n6, r) {
  const i2 = new Array(3), a2 = n4.constructEmpty();
  t2.queryEnvelope(a2);
  const h2 = n4.constructEmpty();
  s4.queryEnvelope(h2);
  const m2 = n4.constructEmpty();
  m2.setCoords({ env2D: a2 }), m2.mergeEnvelope2D(h2);
  const l2 = wt2(n6, m2, true), g2 = new n4(h2), u = Pt2(l2);
  if (g2.inflateCoords(u, u), !a2.isIntersecting(g2)) {
    if (t2.getDimension() <= s4.getDimension()) {
      const e5 = Za2(Ka(t2.createInstance()), t2, s4, "&");
      return i2[e5.getDimension()] = e5, i2;
    }
    if (t2.getDimension() > s4.getDimension()) {
      const e5 = Za2(Ka(s4.createInstance()), t2, s4, "&");
      return i2[e5.getDimension()] = e5, i2;
    }
  }
  const c = new za2(r), _ = new Tm(), d2 = _.addGeometry(Ka(t2)), p3 = _.addGeometry(Ka(s4));
  let f3 = 0, x4 = 0, y2 = null;
  if (_.hasCurves()) {
    y2 = new ca2();
    const e5 = _.getEnvelope2D(r);
    x4 = ga2(l2.total());
    const t3 = la2(l2.total(), e5);
    f3 = ua2(t3, x4), ra2(_, t3, l2.total(), 12e3, y2, null, r);
  }
  c.setEditShapeCrackAndCluster(_, l2.add(f3)), _.dbgVerifyCurves();
  const P5 = c.intersectionEx(d2, p3);
  for (const e5 of P5) {
    null !== y2 && y2.stitchCurves(_, e5, x4, false);
    const n7 = Za2(_.getGeometry(e5), t2, s4, "&");
    wa2(n7.getGeometryType()) && (n7.getImpl().setIsSimple(4, l2.total()), n7.getGeometryType() === a.enumPolygon && n7.getImpl().updateOGCFlagsProtected()), i2[n7.getDimension()] = n7;
  }
  return null !== y2 && y2.clearStitcher(_), i2;
}
function Xa2(e5, s4, n6, r, i2, o2 = false) {
  0 === s4 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let t2 = 0, d2 = s4; t2 < d2; t2++) a2 = Math.max(e5[t2].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new za2(r).dissolveMultiPaths_(a2, false, e5, s4, n6, i2, o2);
  let h2 = 0, m2 = -1;
  for (let t2 = 0, d2 = s4; t2 < d2; t2++) e5[t2].getDimension() === a2 && (-1 === m2 && (m2 = t2), e5[t2].isEmpty() || (m2 = t2, h2++));
  if (h2 < 2) return Ka(e5[m2]);
  const l2 = U3.constructEmpty(), g2 = new Tm();
  let u = bm;
  for (let t2 = 0, d2 = s4; t2 < d2; t2++) if (e5[t2].getDimension() === a2 && !e5[t2].isEmpty()) {
    u === bm ? u = g2.addGeometry(Ka(e5[t2])) : g2.appendGeometry(u, Ka(e5[t2]));
    const s5 = U3.constructEmpty();
    e5[t2].queryLooseEnvelope(s5), l2.mergeEnv3D(s5);
  }
  const c = wt2(n6, l2.getEnvelope2D(), true), _ = new za2(r);
  if (o2) {
    const e6 = At2(n6, l2.getEnvelopeZs(), true);
    return _.planarSimplify3DImpl_(g2, c, e6, 0, true);
  }
  return _.m_bOGCOutput = true, _.planarSimplifyMultiPoints(g2, c, false, -1);
}
function La2(e5, s4, n6, r, i2, o2 = false) {
  s4 < 2 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let t2 = 0, p3 = s4; t2 < p3; t2++) a2 = Math.max(e5[t2].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new za2(r).dissolveMultiPaths_(a2, true, e5, s4, n6, i2, o2);
  const h2 = U3.constructEmpty(), m2 = new Tm();
  let l2 = bm, g2 = 0, u = -1;
  for (let t2 = 0, p3 = s4; t2 < p3; t2++) if (e5[t2].getDimension() === a2 && (-1 === u && (u = t2), !e5[t2].isEmpty())) {
    u = t2, l2 === bm ? l2 = m2.addGeometry(Ka(e5[t2])) : m2.appendGeometry(l2, Ka(e5[t2]));
    const s5 = U3.constructEmpty();
    e5[t2].queryLooseEnvelope(s5), h2.mergeEnv3D(s5), g2++;
  }
  if (g2 < 2) return Ka(e5[u]);
  const c = 0 === a2 ? n6 : null, _ = wt2(c, h2.getEnvelope2D(), true), d2 = new za2(r);
  if (o2) {
    const e6 = At2(c, h2.getEnvelopeZs(), true);
    return d2.m_bOGCOutput = true, d2.planarSimplify3DImpl_(m2, _, e6, 0, true);
  }
  return d2.planarSimplifyMultiPoints(m2, _, true, -1);
}
var za2 = class {
  constructor(e5) {
    this.m_topoGraph = null, this.m_maskLookup = [], this.m_dummyPt1 = ei.getNAN(), this.m_dummyPt2 = ei.getNAN(), this.m_fromEdgeForPolylines = bm, this.m_progressCounter = 0, this.m_bOGCOutput = false, this.m_progressTracker = e5;
  }
  linesToPolygonsImpl(e5, t2) {
    let s4 = 0, n6 = 0, r = null;
    if (e5.hasCurves()) {
      r = new ca2();
      const i3 = e5.getEnvelope2D(this.m_progressTracker);
      n6 = ga2(t2.total());
      const o3 = la2(t2.total(), i3);
      s4 = ua2(o3, n6), ra2(e5, o3, t2.total(), 12e3, r, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e5, t2.add(s4));
    const i2 = this.m_topoGraph.createUserIndexForChains(), o2 = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(o2, i2, 1);
    for (let h2 = this.m_topoGraph.getChainFirstIsland(o2); h2 !== bm; h2 = this.m_topoGraph.getChainNextInParent(h2)) this.m_topoGraph.setChainUserIndex(h2, i2, 1);
    const a2 = [];
    for (let h2 = this.m_topoGraph.getFirstChain(); h2 !== bm; h2 = this.m_topoGraph.getChainNext(h2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(h2, i2)) continue;
      this.m_topoGraph.setChainUserIndex(h2, i2, 1);
      for (let e6 = this.m_topoGraph.getChainFirstIsland(h2); e6 !== bm; e6 = this.m_topoGraph.getChainNextInParent(e6)) this.m_topoGraph.setChainUserIndex(e6, i2, 1);
      if (0 === this.m_topoGraph.getChainArea(h2)) continue;
      const t3 = this.m_topoGraph.extractPolygonFromChainAndIslands(e5, bm, h2, bm);
      null != r && r.stitchCurves(e5, t3, n6, false);
      const s5 = e5.getGeometry(t3);
      a2.push(s5);
    }
    return new s2(a2);
  }
  autoCompleteImpl(e5, t2, s4) {
    let n6 = 0, r = 0, i2 = null;
    if (e5.hasCurves()) {
      i2 = new ca2();
      const t3 = e5.getEnvelope2D(this.m_progressTracker);
      r = ga2(s4.total());
      const o3 = la2(s4.total(), t3);
      n6 = ua2(o3, r), ra2(e5, o3, s4.total(), 12e3, i2, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e5, s4.add(n6));
    const o2 = this.m_topoGraph.getGeometryID(t2), a2 = this.m_topoGraph.createUserIndexForChains(), h2 = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(h2, a2, 1);
    for (let l2 = this.m_topoGraph.getChainFirstIsland(h2); l2 !== bm; l2 = this.m_topoGraph.getChainNextInParent(l2)) this.m_topoGraph.setChainUserIndex(l2, a2, 1);
    const m2 = [];
    for (let l2 = this.m_topoGraph.getFirstChain(); l2 !== bm; l2 = this.m_topoGraph.getChainNext(l2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(l2, a2)) continue;
      this.m_topoGraph.setChainUserIndex(l2, a2, 1);
      for (let e6 = this.m_topoGraph.getChainFirstIsland(l2); e6 !== bm; e6 = this.m_topoGraph.getChainNextInParent(e6)) this.m_topoGraph.setChainUserIndex(e6, a2, 1);
      if (0 !== this.m_topoGraph.getChainParentage(l2)) continue;
      const t3 = this.m_topoGraph.getChainHalfEdge(l2);
      let s5 = t3, n7 = false;
      do {
        const e6 = this.m_topoGraph.getHalfEdgeTwin(s5);
        if (this.m_topoGraph.getHalfEdgeChain(e6) !== l2 && this.m_topoGraph.getHalfEdgeParentage(s5) & o2) {
          n7 = true;
          break;
        }
        s5 = this.m_topoGraph.getHalfEdgeNext(s5);
      } while (s5 !== t3);
      if (!n7) continue;
      if (0 === this.m_topoGraph.getChainArea(l2)) continue;
      const h3 = this.m_topoGraph.extractPolygonFromChainAndIslands(e5, bm, l2, bm);
      null !== i2 && i2.stitchCurves(e5, h3, r, false);
      const g2 = e5.getGeometry(h3);
      m2.push(g2);
    }
    return new s2(m2);
  }
  setEditShape(e5, t2 = false) {
    null === this.m_topoGraph && (this.m_topoGraph = new Js2()), this.m_topoGraph.setEditShape(e5, this.m_progressTracker, true, t2);
  }
  setEditShapeCrackAndCluster(e5, t2) {
    da2(e5, t2, this.m_progressTracker, true, false);
    for (let s4 = e5.getFirstGeometry(); s4 !== bm; s4 = e5.getNextGeometry(s4)) e5.getGeometryType(s4) === a.enumPolygon && Qn2(e5, s4, -1, this.m_bOGCOutput, bm, this.m_progressTracker);
    this.setEditShape(e5);
  }
  setHalfEdgeOrientations_(e5, t2) {
    const s4 = this.m_topoGraph.getShape();
    for (let n6 = s4.getFirstGeometry(); n6 !== bm; n6 = s4.getNextGeometry(n6)) if (n6 === t2) for (let t3 = s4.getFirstPath(n6); t3 !== bm; t3 = s4.getNextPath(t3)) {
      let n7 = s4.getFirstVertex(t3);
      if (n7 === bm) continue;
      let r = s4.getNextVertex(n7);
      for (; r !== bm; ) {
        const t4 = this.m_topoGraph.getClusterFromVertex(n7), i2 = this.m_topoGraph.getClusterFromVertex(r), o2 = this.m_topoGraph.getHalfEdgeConnector(t4, i2);
        if (o2 !== bm) {
          const t5 = this.m_topoGraph.getHalfEdgeTwin(o2);
          this.m_topoGraph.setHalfEdgeUserIndex(o2, e5, 1), this.m_topoGraph.setHalfEdgeUserIndex(t5, e5, 2);
        }
        n7 = r, r = s4.getNextVertex(n7);
      }
    }
  }
  flushVertices_(e5, t2) {
    const s4 = this.m_topoGraph.getShape(), n6 = s4.hasSegmentParentage(), r = new nu(), i2 = s4.insertPath(e5, bm);
    t2.push(t2[0]);
    const o2 = t2.length;
    let a2 = bm;
    for (let h2 = 0; h2 < o2; h2++) {
      const e6 = t2[h2];
      if (a2 = s4.addVertex(i2, e6), !n6) continue;
      const m2 = this.m_topoGraph.getClusterFromVertex(e6);
      if (h2 > 0 && this.m_topoGraph.isBreakNode(m2) && s4.setSegmentParentageBreakVertex(a2, true), h2 < o2 - 1) {
        const e7 = this.m_topoGraph.getHalfEdgeConnector(m2, this.m_topoGraph.getClusterFromVertex(t2[h2 + 1])), n7 = this.m_topoGraph.getSegmentParentage(e7);
        s4.setSegmentParentageAndBreak(a2, n7, h2 > 0 || this.m_topoGraph.isBreakNode(m2)), this.m_topoGraph.isHalfEdgeCurve(e7) && (this.m_topoGraph.querySegmentXY(e7, r), s4.setSegmentToIndex(s4.getVertexIndex(a2), r.get().clone()));
      }
    }
    if (n6) {
      const e6 = this.m_topoGraph.getClusterFromVertex(t2[o2 - 1]);
      this.m_topoGraph.isBreakNode(e6) && s4.setSegmentParentageBreakVertex(a2, true);
    }
    s4.setClosedPath(i2, true);
  }
  processPolygonCuts_(e5, t2, s4, n6) {
    const r = this.m_topoGraph.getGeometryID(s4), i2 = this.m_topoGraph.getGeometryID(n6), a2 = [], h2 = this.m_topoGraph.getShape(), m2 = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let l2 = this.m_topoGraph.getFirstCluster(); l2 !== bm; l2 = this.m_topoGraph.getNextCluster(l2)) {
      const s5 = this.m_topoGraph.getClusterHalfEdge(l2);
      if (s5 === bm) continue;
      let n7 = s5;
      do {
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(n7, m2)) {
          let s6 = n7, l3 = n7, g2 = false, u = 0;
          do {
            if (this.m_topoGraph.setHalfEdgeUserIndex(s6, m2, 1), !g2) {
              if (this.m_topoGraph.getHalfEdgeParentage(s6) & i2) {
                this.m_topoGraph.getHalfEdgeFaceParentage(s6) & r && (l3 = s6, g2 = true);
              }
            }
            if (g2) {
              const t3 = this.m_topoGraph.getHalfEdgeOrigin(s6), n8 = this.m_topoGraph.getClusterVertexIterator(t3), r2 = this.m_topoGraph.getVertexFromVertexIterator(n8);
              if (a2.push(r2), -1 !== e5) {
                if (this.m_topoGraph.getHalfEdgeParentage(s6) & i2) {
                  u |= this.m_topoGraph.getHalfEdgeUserIndex(s6, e5);
                }
              }
            }
            s6 = this.m_topoGraph.getHalfEdgeNext(s6);
          } while (s6 !== l3);
          if (g2 && this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(l3)) > 0) {
            const e6 = h2.createGeometry(a.enumPolygon);
            this.flushVertices_(e6, a2), -1 !== t2 && h2.setGeometryUserIndex(e6, t2, u);
          }
          a2.length = 0;
        }
        n7 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(n7));
      } while (n7 !== s5);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(m2);
  }
  cutPolygonPolyline_(e5, t2, s4, n6) {
    this.m_topoGraph.removeSpikes_();
    let r = -1;
    -1 !== e5 && (r = this.m_topoGraph.createUserIndexForHalfEdges(), this.setHalfEdgeOrientations_(r, s4)), this.processPolygonCuts_(r, e5, t2, s4), -1 !== r && (this.m_topoGraph.deleteUserIndexForHalfEdges(r), r = -1);
    const i2 = this.m_topoGraph.getShape();
    for (let o2 = i2.getFirstGeometry(); o2 !== bm; o2 = i2.getNextGeometry(o2)) o2 !== t2 && o2 !== s4 && n6.push(o2);
    n6.sort((e6, t3) => {
      const s5 = i2.getFirstPath(e6), n7 = i2.getRingArea(s5), r2 = i2.getFirstPath(t3), o2 = i2.getRingArea(r2);
      return n7 < o2 ? -1 : n7 > o2 ? 1 : 0;
    });
  }
  cut(e5, t2, s4, n6, r) {
    const i2 = this.m_topoGraph.getShape().getGeometryType(s4), o2 = this.m_topoGraph.getShape().getGeometryType(n6), a2 = m(i2), h2 = m(o2);
    if (2 !== a2 || 1 !== h2) if (1 !== a2 || 1 !== h2) b("");
    else {
      new Ja2(this, e5, t2, s4, n6, r).Do();
    }
    else this.cutPolygonPolyline_(t2, s4, n6, r);
  }
  progress_(e5 = false) {
  }
  isGoodParentage(e5) {
    return e5 >= 0 && e5 < this.m_maskLookup.length && this.m_maskLookup[e5];
  }
  normalizeInputGeometry(e5) {
    const s4 = e5.getGeometryType();
    if (s4 === a.enumEnvelope) {
      const t2 = new eh({ vd: e5.getDescription() });
      return e5.isEmpty() || t2.addEnvelope(e5, false), t2;
    }
    if (s4 === a.enumPoint) {
      const t2 = new Ce({ vd: e5.getDescription() });
      return e5.isEmpty() || t2.add(e5), t2;
    }
    if (f(s4)) {
      const t2 = new Na({ vd: e5.getDescription() });
      return e5.isEmpty() || t2.addSegment(e5, true), t2;
    }
    return s4 !== a.enumMultiPoint && s4 !== a.enumPolyline && s4 !== a.enumPolygon && P("Unexpected geometry type"), e5;
  }
  dissolveNonSimplePolygons(e5, t2, n6, r) {
    n2(t2 > 0);
    const i2 = new Tm();
    let o2 = 0, a2 = -1;
    for (let s4 = 0, h2 = t2; s4 < h2; s4++) 2 === e5[s4].getDimension() && (-1 === a2 && (a2 = s4), e5[s4].isEmpty() || (o2++, i2.addGeometry(e5[s4])));
    return 0 === o2 ? (n2(a2 >= 0), this.normalizeInputGeometry(e5[a2])) : this.planarSimplifyPolygons(i2, n6, true, false, -1, true);
  }
  dissolveMultiPaths_(t2, n6, r, i2, m2, l2, g2) {
    n2(t2 >= 1 && t2 <= 2), n2(i2 > 0);
    const c = 8 & l2 ? 1 : 2, _ = U3.constructEmpty();
    let d2 = 0, p3 = -1, f3 = true;
    for (let e5 = 0, s4 = i2; e5 < s4; e5++) if (r[e5].getDimension() === t2 && (-1 === p3 && (p3 = e5), !r[e5].isEmpty())) {
      p3 = e5, d2++;
      const s5 = U3.constructEmpty();
      if (r[e5].queryLooseEnvelope(s5), _.mergeEnv3D(s5), 2 === t2 && f3 && r[e5].getGeometryType() === a.enumPolygon) if (16 & l2) {
        const t3 = [0], s6 = r[e5].getImpl().getIsSimple(0, t3), n7 = this.m_bOGCOutput ? 5 === s6 : Ot2(s6);
        f3 && (f3 = n7);
      } else {
        const t3 = kt2(r[e5], 0);
        f3 && (f3 = t3);
      }
    }
    if (d2 < 2 && (n2(p3 >= 0), 0 === d2 || !(16 & l2))) return this.normalizeInputGeometry(r[p3]);
    if (!f3) {
      const e5 = wt2(n6 ? null : m2, _.getEnvelope2D(), true);
      return this.dissolveNonSimplePolygons(r, i2, e5, l2);
    }
    const x4 = r.slice(0, i2), y2 = wt2(m2, _.getEnvelope2D(), true), P5 = 10 * Pt2(y2);
    let E2 = new bt(0, 0);
    if (g2 && (E2 = At2(m2, _.getEnvelopeZs(), true)), 1 === d2 && 1 === t2 && 2 === c && !n6) return g2 ? ka2() : this.m_bOGCOutput ? Va2(x4[p3], y2, false, -1, this.m_progressTracker, c, false) : Fa2(x4[p3], y2, false, false, -1, this.m_progressTracker, c, false);
    const C2 = new yt2();
    C2.startConstruction();
    let S3 = 2 === t2 ? 3 : 4, w4 = 0;
    for (let u = 0, I5 = i2; u < I5; u++) {
      if (x4[u].getDimension() !== t2 || x4[u].isEmpty()) continue;
      let r2 = x4[u].getGeometryType();
      if (r2 !== a.enumEnvelope) {
        if (f(r2) ? (x4[u] = this.normalizeInputGeometry(x4[u]), r2 = a.enumPolyline) : n2(h(r2)), 1 === t2) {
          n2(r2 === a.enumPolyline);
          let e5 = -1;
          if (g2) n2(0, "3d not implemented yet");
          else {
            const t3 = [0];
            e5 = x4[u].getImpl().getIsSimple(y2.total(), t3);
          }
          if (this.m_bOGCOutput ? 5 !== e5 : !Ot2(e5)) if (n6) S3 = -1;
          else {
            g2 ? n2(0, "3d not implemented yet") : this.m_bOGCOutput ? x4[u] = Va2(x4[u], y2, false, -1, this.m_progressTracker, c, false) : x4[u] = Fa2(x4[u], y2, false, false, -1, this.m_progressTracker, c, false);
            const e6 = [0];
            n2(Ot2(x4[u].getImpl().getIsSimple(y2.total(), e6)));
          }
        } else {
          n2(r2 === a.enumPolygon);
          const e5 = [0], t3 = x4[u].getImpl().getIsSimple(0, e5);
          n2(Ht(t3));
        }
        const i3 = x4[u].getImpl();
        for (let t3 = 0, s4 = i3.getPathCount(); t3 < s4; t3++) {
          const s5 = n4.constructEmpty();
          i3.queryLoosePathEnvelope(t3, s5), s5.inflateCoords(P5, P5), C2.addEnvelope(w4, s5), w4++;
        }
      } else {
        n2(r2 === a.enumEnvelope);
        const t3 = n4.constructEmpty();
        x4[u].queryLooseEnvelope(t3), t3.inflateCoords(P5, P5), C2.addEnvelope(w4, t3), w4++, S3 = -1;
      }
    }
    C2.endConstruction();
    const v3 = w4, N2 = Lt(v3, -2147483647), G4 = Lt(v3, -1);
    let D3 = 0;
    p3 = -1, w4 = 0;
    for (let e5 = 0, a2 = i2; e5 < a2; e5++) {
      if (x4[e5].getDimension() !== t2) continue;
      if (-1 === p3 && (p3 = e5), x4[e5].isEmpty()) continue;
      p3 = e5, D3++;
      const n7 = x4[e5].getGeometryType();
      if (h(n7)) {
        for (let t3 = 0, s4 = x4[e5].getPathCount(); t3 < s4; t3++) G4[w4] = e5, N2[w4] = -t3 - 1, w4++;
      } else n2(n7 === a.enumEnvelope), G4[w4] = e5, N2[w4] = -1, w4++;
    }
    if (D3 < 2 && 2 === t2) return n2(p3 >= 0), this.normalizeInputGeometry(x4[p3]);
    let F3 = v3;
    for (; C2.next() && F3 > 0; ) {
      this.progress_();
      const e5 = C2.getHandleA(), t3 = C2.getHandleB(), s4 = C2.getElement(e5), n7 = C2.getElement(t3);
      G4[s4] !== G4[n7] && (N2[s4] < 0 && (F3--, N2[s4] = -(N2[s4] + 1)), N2[n7] < 0 && (F3--, N2[n7] = -(N2[n7] + 1)));
    }
    const H3 = new Tm();
    let k4 = false, A4 = 0;
    for (let e5 = 0, a2 = i2; e5 < a2; e5++) {
      if (x4[e5].getDimension() !== t2 || x4[e5].isEmpty()) continue;
      const n7 = x4[e5].getGeometryType(), r2 = A4;
      let i3 = 0, a3 = 0;
      const m3 = h(n7) ? x4[e5] : null;
      for (let t3 = r2, s4 = N2.length; t3 < s4 && G4[t3] === e5; t3++) N2[t3] >= 0 && (i3++, a3 += m3 ? m3.getPathSize(N2[t3]) : w(x4[e5])), A4++;
      if (a3 > 0.95 * w(x4[e5])) {
        H3.addGeometry(this.normalizeInputGeometry(x4[e5]));
        for (let e6 = r2; e6 < A4; e6++) N2[e6] < 0 && (N2[e6] = -(N2[e6] + 1));
      } else {
        if (0 === i3) {
          k4 = true;
          continue;
        }
        {
          k4 = true, n2(h(n7)), n2(null != m3);
          const t3 = new eh({ vd: x4[e5].getDescription() }), i4 = new Na({ vd: x4[e5].getDescription() }), a4 = n7 === a.enumPolygon ? t3 : i4;
          for (let e6 = r2; e6 < A4; e6++) N2[e6] >= 0 && a4.addPath(m3, N2[e6], true);
          H3.addGeometry(a4);
        }
      }
    }
    let M2;
    if (H3.getFirstGeometry() !== bm) {
      const e5 = 2 === t2, s4 = n6 ? wt2(null, _.getEnvelope2D(), true) : y2;
      let r2 = new bt(0, 0);
      if (g2 && (r2 = n6 ? At2(null, _.getEnvelopeZs(), true) : E2), 2 === t2 && !(2 & l2)) {
        H3.collapseAllGeometriesToFirst();
        let e6 = 0, t3 = null;
        if (H3.hasCurves() && !H3.hasSegmentParentage()) {
          t3 = new ca2();
          const n7 = H3.getEnvelope2D(this.m_progressTracker);
          e6 = ga2(s4.total());
          ra2(H3, la2(s4.total(), n7), s4.total(), 12e3, t3, null, this.m_progressTracker);
        }
        Tn2(H3, H3.getFirstGeometry(), s4.total(), this.m_progressTracker), null !== t3 && t3.stitchCurves(H3, bm, e6, true);
      }
      if (g2) M2 = this.planarSimplify3DImpl_(H3, s4, r2, c, true);
      else if (2 === t2) M2 = this.planarSimplifyPolygons(H3, s4, e5, n6, -1, false);
      else {
        const e6 = Ga2();
        e6.ogcRule = this.m_bOGCOutput, e6.allCrossRoadsImpassable = true, e6.unsplitBehavior = c, M2 = this.planarSimplifyPolylines(H3, s4, n6, e6, -1);
      }
      if (!k4) {
        const e6 = [0];
        S3 = M2.getImpl().getIsSimple(s4.total(), e6);
      }
    } else n2(k4), n2(p3 >= 0), M2 = 2 === t2 ? new eh({ vd: x4[p3].getDescription() }) : new Na({ vd: x4[p3].getDescription() });
    if (k4) {
      let e5 = 0;
      for (let t3 = 0, s4 = N2.length; t3 < s4; t3++) {
        const s5 = G4[t3];
        if (!(s5 < 0) && N2[t3] < 0) {
          const n7 = x4[s5].getGeometryType(), r2 = h(n7) ? x4[s5] : null;
          if (r2) {
            const s6 = -(N2[t3] + 1);
            e5 += r2.getPathSize(s6);
          } else e5 += 4;
        }
      }
      M2.reserve(M2.getPointCount() + e5);
      for (let t3 = 0, n7 = N2.length; t3 < n7; t3++) {
        const e6 = G4[t3];
        if (!(e6 < 0) && N2[t3] < 0) {
          const n8 = x4[e6].getGeometryType(), r2 = h(n8) ? x4[e6] : null;
          if (r2) {
            const e7 = -(N2[t3] + 1);
            M2.addPath(r2, e7, true);
          } else n8 === a.enumEnvelope ? M2.addEnvelope(x4[e6], false) : (n2(f(n8)), M2.addSegment(x4[e6], true));
        }
      }
    }
    let U4 = 0;
    if (2 === t2 ? -1 !== S3 && (S3 = 3, U4 = n6 ? 0 : y2.total()) : (n2(1 === t2), n6 || -1 === S3 || (U4 = y2.total())), g2 || M2.getImpl().setIsSimple(S3, U4), !n6 && k4) if (2 === t2) {
      if (!g2) return new fh2().execute(M2, m2, false, this.m_progressTracker);
      n2(0, "3d not yet implemented");
    } else 1 === t2 && 1 !== c && (M2 = g2 ? Aa2() : Ha2(this.m_bOGCOutput, M2, c, this.m_progressTracker), M2.getImpl().setIsSimple(S3, U4));
    return M2;
  }
  dissolveTopoGraphCommonEdges_() {
    const e5 = this.m_topoGraph.createUserIndexForHalfEdges(), t2 = [];
    for (let s4 = this.m_topoGraph.getFirstCluster(); s4 !== bm; s4 = this.m_topoGraph.getNextCluster(s4)) {
      const n6 = this.m_topoGraph.getClusterHalfEdge(s4);
      let r = n6;
      if (n6 !== bm) do {
        this.progress_();
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(r, e5)) {
          const s5 = this.m_topoGraph.getHalfEdgeTwin(r);
          this.m_topoGraph.setHalfEdgeUserIndex(s5, e5, 1), this.m_topoGraph.setHalfEdgeUserIndex(r, e5, 1);
          const n7 = this.m_topoGraph.getHalfEdgeFaceParentage(r);
          if (this.isGoodParentage(n7)) {
            const e6 = this.m_topoGraph.getHalfEdgeFaceParentage(s5);
            this.isGoodParentage(e6) && t2.push(r);
          }
        }
        r = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(r));
      } while (r !== n6);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(e5), this.m_topoGraph.deleteEdgesBreakFaces_(t2);
  }
  chooseVertexByOrder(e5, t2, n6, r) {
    let i2 = os(), o2 = bm;
    for (let s4 = this.m_topoGraph.getClusterVertexIterator(e5); s4 !== bm; s4 = this.m_topoGraph.incrementVertexIterator(s4)) {
      const e6 = this.m_topoGraph.getVertexFromVertexIterator(s4), r2 = t2.getUserIndex(e6, n6);
      r2 >= 0 && r2 < i2 && (i2 = r2, o2 = e6);
    }
    n2(o2 !== bm);
    let a2 = t2.getUserIndex(o2, r);
    return a2 > 0 && (t2.setUserIndex(o2, r, --a2), 0 === a2 && t2.setUserIndex(o2, n6, -1)), o2;
  }
  chooseVertexFromCluster_(e5, t2) {
    return this.m_topoGraph.getVertexDominantFromCluster(e5, t2);
  }
  chooseVertexFromVertexCluster_(e5, t2) {
    return this.m_topoGraph.getVertexDominant(e5, t2);
  }
  collectPolygonPathsPreservingFrom_(e5, t2, s4, n6, r) {
    const i2 = this.m_topoGraph.getShape();
    if (i2.getGeometryType(e5) !== a.enumPolygon) return;
    const a2 = i2.hasSegmentParentage(), h2 = new nu();
    for (let o2 = i2.getFirstPath(e5); o2 !== bm; o2 = i2.getNextPath(o2)) {
      const e6 = i2.getFirstVertex(o2);
      this.m_topoGraph.getClusterFromVertex(e6);
      const m2 = this.m_topoGraph.getHalfEdgeFromVertex(e6);
      if (m2 === bm) continue;
      const l2 = this.m_topoGraph.getHalfEdgeUserIndex(m2, s4);
      if (1 === l2 || 2 === l2) continue;
      const g2 = this.m_topoGraph.getHalfEdgeFaceParentage(m2);
      if (!this.isGoodParentage(g2)) {
        this.m_topoGraph.setHalfEdgeUserIndex(m2, s4, 2);
        continue;
      }
      this.m_topoGraph.setHalfEdgeUserIndex(m2, s4, 1);
      const u = i2.insertPath(t2, bm);
      i2.setClosedPath(u, true);
      let c = m2, _ = e6, d2 = this.m_topoGraph.getClusterFromVertex(_), p3 = 1;
      do {
        this.progress_();
        const e7 = this.chooseVertexFromVertexCluster_(_, r), t3 = i2.addVertex(u, e7);
        if (this.m_topoGraph.isHalfEdgeCurve(c) && (this.m_topoGraph.querySegmentXY(c, h2), i2.setSegmentToIndex(i2.getVertexIndex(t3), h2.get().clone())), a2) {
          const e8 = this.m_topoGraph.getSegmentParentage(c);
          i2.setSegmentParentageAndBreak(t3, e8, this.m_topoGraph.isBreakNode(d2));
        }
        let o3, m3;
        -1 !== n6 && this.m_topoGraph.setClusterUserIndex(d2, n6, 1), this.m_topoGraph.setHalfEdgeUserIndex(c, s4, 1), c = this.m_topoGraph.getHalfEdgeNext(c);
        do {
          o3 = 1 === p3 ? i2.getNextVertex(_) : i2.getPrevVertex(_), m3 = o3 !== bm ? this.m_topoGraph.getClusterFromVertex(o3) : bm;
        } while (m3 === d2);
        const l3 = this.m_topoGraph.getHalfEdgeOrigin(c);
        if (l3 !== m3) {
          do {
            o3 = 1 === p3 ? i2.getPrevVertex(_) : i2.getNextVertex(_), m3 = o3 !== bm ? this.m_topoGraph.getClusterFromVertex(o3) : bm;
          } while (m3 === d2);
          if (l3 !== m3) {
            m3 = l3;
            const e8 = this.m_topoGraph.getClusterVertexIterator(m3);
            o3 = this.m_topoGraph.getVertexFromVertexIterator(e8);
          } else p3 = -p3;
        }
        d2 = m3, _ = o3;
      } while (c !== m2);
    }
  }
  topoOperationPolygonPolygonHelper_(e5, t2, s4, n6, r, i2) {
    this.progress_(true), e5 !== bm && this.collectPolygonPathsPreservingFrom_(e5, s4, r, i2, n6), t2 !== bm && this.collectPolygonPathsPreservingFrom_(t2, s4, r, i2, n6);
    const o2 = new nu(), a2 = this.m_topoGraph.getShape();
    a2.dbgVerifyCurves();
    const h2 = a2.hasSegmentParentage();
    for (let m2 = this.m_topoGraph.getFirstCluster(); m2 !== bm; m2 = this.m_topoGraph.getNextCluster(m2)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(m2);
      if (e6 === bm) continue;
      let t3 = e6;
      do {
        this.progress_();
        const e7 = this.m_topoGraph.getHalfEdgeUserIndex(t3, r);
        if (1 !== e7 && 2 !== e7) {
          const e8 = this.m_topoGraph.getHalfEdgeFaceParentage(t3);
          if (this.isGoodParentage(e8)) {
            const e9 = a2.insertPath(s4, bm);
            a2.setClosedPath(e9, true);
            let m3 = t3;
            do {
              const t4 = this.m_topoGraph.getHalfEdgeVertexIterator(m3);
              let s5 = bm;
              if (t4 !== bm) s5 = this.m_topoGraph.getVertexFromVertexIterator(t4);
              else {
                const e10 = this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(m3));
                s5 = this.m_topoGraph.getVertexFromVertexIterator(e10), s5 = a2.getNextVertex(s5);
              }
              const l2 = this.chooseVertexFromVertexCluster_(s5, n6), g2 = a2.addVertex(e9, l2);
              if (h2) {
                const e10 = this.m_topoGraph.getSegmentParentage(m3), t5 = this.m_topoGraph.getHalfEdgeOrigin(m3);
                a2.setSegmentParentageAndBreak(g2, e10, this.m_topoGraph.isBreakNode(t5));
              }
              if (this.m_topoGraph.isHalfEdgeCurve(m3) && (this.m_topoGraph.querySegmentXY(m3, o2), a2.setSegmentToIndex(a2.getVertexIndex(g2), o2.get().clone())), this.m_topoGraph.setHalfEdgeUserIndex(m3, r, 1), -1 !== i2) {
                const e10 = this.m_topoGraph.getClusterFromVertex(l2);
                this.m_topoGraph.setClusterUserIndex(e10, i2, 1);
              }
              m3 = this.m_topoGraph.getHalfEdgeNext(m3);
            } while (m3 !== t3);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t3, r, 2);
        }
        t3 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t3));
      } while (t3 !== e6);
    }
  }
  topoOperationPolygonPolygon_(e5, t2, s4, n6 = false) {
    this.dissolveTopoGraphCommonEdges_();
    const r = this.m_topoGraph.getShape(), i2 = r.createGeometry(a.enumPolygon), a2 = this.m_topoGraph.createUserIndexForHalfEdges();
    return this.topoOperationPolygonPolygonHelper_(e5, t2, i2, s4, a2, -1), this.m_topoGraph.deleteUserIndexForHalfEdges(a2), n6 || Qn2(r, i2, 3, this.m_bOGCOutput, bm, this.m_progressTracker), i2;
  }
  topoOperationPolyline_(e5, t2) {
    const s4 = Ga2();
    return s4.allCrossRoadsImpassable = false, s4.ogcRule = t2, s4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(bm, e5, false, s4).first;
  }
  topoOperationMultiPoint_() {
    const e5 = this.m_topoGraph.getShape(), t2 = e5.createGeometry(a.enumMultiPoint), s4 = e5.insertPath(t2, bm);
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== bm; n6 = this.m_topoGraph.getNextCluster(n6)) {
      const t3 = this.m_topoGraph.getClusterParentage(n6);
      if (this.isGoodParentage(t3)) {
        let t4 = bm;
        for (let s5 = this.m_topoGraph.getClusterVertexIterator(n6); s5 !== bm; s5 = this.m_topoGraph.incrementVertexIterator(s5)) {
          const n7 = this.m_topoGraph.getVertexFromVertexIterator(s5);
          t4 === bm && (t4 = n7);
          const r = e5.getGeometryFromPath(e5.getPathFromVertex(n7)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t4 = n7;
            break;
          }
        }
        e5.addVertex(s4, t4);
      }
    }
    return t2;
  }
  intersection(e5, t2) {
    const n6 = this.m_topoGraph.getShape().getGeometryType(e5), r = this.m_topoGraph.getShape().getGeometryType(t2), i2 = m(n6), o2 = m(r), a2 = this.m_topoGraph.getGeometryID(e5), h2 = this.m_topoGraph.getGeometryID(t2);
    n2(a2 >= 0), n2(h2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (a2 | h2), this.m_maskLookup[a2 | h2] = true;
    let m2 = bm;
    return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (m2 = e5), 2 === i2 && 2 === o2 ? this.topoOperationPolygonPolygon_(e5, t2, m2) : 1 === i2 && o2 > 0 || 1 === o2 && i2 > 0 ? this.topoOperationPolyline_(m2, this.m_bOGCOutput) : 0 === i2 || 0 === o2 ? this.topoOperationMultiPoint_() : void b("");
  }
  topoOperationPolygonPolygonEx(e5, t2, s4) {
    const n6 = this.m_topoGraph.getShape(), r = n6.createGeometry(a.enumPolygon), i2 = n6.createGeometry(a.enumPolyline), a2 = n6.createGeometry(a.enumMultiPoint);
    this.dissolveTopoGraphCommonEdges_();
    let h2 = bm;
    const m2 = this.m_topoGraph.createUserIndexForHalfEdges(), l2 = this.m_topoGraph.createUserIndexForClusters();
    n6.dbgVerifyCurves(), this.topoOperationPolygonPolygonHelper_(e5, t2, r, s4, m2, l2), n6.dbgVerifyCurves();
    const g2 = n6.hasSegmentParentage(), u = new nu();
    for (let o2 = this.m_topoGraph.getFirstCluster(); o2 !== bm; o2 = this.m_topoGraph.getNextCluster(o2)) {
      const e6 = this.m_topoGraph.getClusterHalfEdge(o2);
      if (e6 === bm) continue;
      let t3 = e6;
      do {
        let e7 = this.m_topoGraph.getHalfEdgeUserIndex(t3, m2), r2 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t3), m2), a3 = e7 | r2;
        if (2 === a3) {
          let h3 = this.m_topoGraph.getHalfEdgeParentage(t3);
          if (this.isGoodParentage(h3)) {
            const c2 = n6.insertPath(i2, bm);
            let _ = t3;
            const d2 = this.chooseVertexFromCluster_(o2, s4);
            let p3 = n6.addVertex(c2, d2);
            if (g2) {
              const e8 = this.m_topoGraph.getSegmentParentage(t3), s5 = this.m_topoGraph.getHalfEdgeOrigin(t3);
              n6.setSegmentParentageAndBreak(p3, e8, this.m_topoGraph.isBreakNode(s5));
            }
            this.m_topoGraph.isHalfEdgeCurve(t3) && (this.m_topoGraph.querySegmentXY(t3, u), n6.setSegmentToIndex(n6.getVertexIndex(p3), u.get().clone())), this.m_topoGraph.setClusterUserIndex(o2, l2, 1);
            do {
              this.progress_();
              const i3 = this.m_topoGraph.getHalfEdgeTo(_), o3 = this.chooseVertexFromCluster_(i3, s4);
              if (p3 = n6.addVertex(c2, o3), g2) {
                const e8 = this.m_topoGraph.getSegmentParentage(t3), s5 = this.m_topoGraph.getHalfEdgeOrigin(t3);
                n6.setSegmentParentageAndBreak(p3, e8, this.m_topoGraph.isBreakNode(s5));
              }
              if (this.m_topoGraph.setHalfEdgeUserIndex(_, m2, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m2, 1), this.m_topoGraph.setClusterUserIndex(i3, l2, 1), _ = this.m_topoGraph.getHalfEdgeNext(_), e7 = this.m_topoGraph.getHalfEdgeUserIndex(_, m2), r2 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m2), a3 = e7 | r2, 2 !== a3) break;
              if (h3 = this.m_topoGraph.getHalfEdgeParentage(_), !this.isGoodParentage(h3)) {
                this.m_topoGraph.setHalfEdgeUserIndex(_, m2, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m2, 1);
                break;
              }
              this.m_topoGraph.isHalfEdgeCurve(t3) && _ !== t3 && (this.m_topoGraph.querySegmentXY(t3, u), n6.setSegmentToIndex(n6.getVertexIndex(p3), u.get().clone()));
            } while (_ !== t3);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t3, m2, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t3), m2, 1);
        }
        t3 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t3));
      } while (t3 !== e6);
    }
    for (let o2 = this.m_topoGraph.getFirstCluster(); o2 !== bm; o2 = this.m_topoGraph.getNextCluster(o2)) {
      this.progress_();
      if (1 === this.m_topoGraph.getClusterUserIndex(o2, l2)) continue;
      const e6 = this.m_topoGraph.getClusterParentage(o2);
      if (this.isGoodParentage(e6)) {
        h2 === bm && (h2 = n6.insertPath(a2, bm));
        const e7 = this.m_topoGraph.getClusterVertexIterator(o2);
        let t3 = bm;
        if (e7 !== bm) {
          t3 = this.m_topoGraph.getVertexFromVertexIterator(e7);
          const r2 = this.chooseVertexFromVertexCluster_(t3, s4);
          n6.addVertex(h2, r2);
        }
      }
    }
    this.m_topoGraph.deleteUserIndexForClusters(l2), this.m_topoGraph.deleteUserIndexForHalfEdges(m2), n6.dbgVerifyCurves(), Qn2(n6, r, 3, this.m_bOGCOutput, bm, this.m_progressTracker);
    const c = [bm, bm, bm];
    return c[0] = a2, c[1] = i2, c[2] = r, c;
  }
  topoOperationPolylinePolylineOrPolygonEx(e5, t2) {
    const s4 = Ga2();
    return s4.allCrossRoadsImpassable = false, s4.ogcRule = t2, s4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(bm, e5, true, s4);
  }
  topoOperationMultiPoint() {
    const e5 = this.m_topoGraph.getShape(), t2 = e5.createGeometry(a.enumMultiPoint), s4 = e5.insertPath(t2, bm);
    for (let n6 = this.m_topoGraph.getFirstCluster(); n6 !== bm; n6 = this.m_topoGraph.getNextCluster(n6)) {
      const t3 = this.m_topoGraph.getClusterParentage(n6);
      if (this.isGoodParentage(t3)) {
        let t4 = bm;
        for (let s5 = this.m_topoGraph.getClusterVertexIterator(n6); s5 !== bm; s5 = this.m_topoGraph.incrementVertexIterator(s5)) {
          const n7 = this.m_topoGraph.getVertexFromVertexIterator(s5);
          t4 === bm && (t4 = n7);
          const r = e5.getGeometryFromPath(e5.getPathFromVertex(n7)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t4 = n7;
            break;
          }
        }
        e5.addVertex(s4, t4);
      }
    }
    return t2;
  }
  intersectionEx(e5, t2) {
    const n6 = this.m_topoGraph.getShape().getGeometryType(e5), r = this.m_topoGraph.getShape().getGeometryType(t2), i2 = Na2(n6), o2 = Na2(r), a2 = this.m_topoGraph.getGeometryID(e5), h2 = this.m_topoGraph.getGeometryID(t2);
    n2(a2 >= 0), n2(h2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (a2 | h2), this.m_maskLookup[a2 | h2] = true;
    let m2 = bm;
    if (this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (m2 = e5), 2 === i2 && 2 === o2) return this.topoOperationPolygonPolygonEx(e5, t2, m2);
    if (1 === i2 && o2 > 0 || 1 === o2 && i2 > 0) {
      const { first: e6, second: t3 } = this.topoOperationPolylinePolylineOrPolygonEx(m2, this.m_bOGCOutput);
      return [t3, e6];
    }
    if (0 === i2 || 0 === o2) {
      const e6 = [];
      return e6.push(this.topoOperationMultiPoint()), e6;
    }
    b("");
  }
  getCombinedHalfEdgeParentage(e5) {
    return this.m_topoGraph.getHalfEdgeParentage(e5) | this.m_topoGraph.getHalfEdgeFaceParentage(e5) | this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e5));
  }
  prevailingDirection(e5, t2) {
    const s4 = this.getCombinedHalfEdgeParentage(t2), n6 = this.m_topoGraph.getHalfEdgeOrigin(t2), r = this.m_topoGraph.getHalfEdgeTo(t2);
    let i2 = 0, o2 = 0;
    for (let a2 = this.m_topoGraph.getClusterVertexIterator(n6); a2 !== bm; a2 = this.m_topoGraph.incrementVertexIterator(a2)) {
      const n7 = this.m_topoGraph.getVertexFromVertexIterator(a2), h2 = e5.getPathFromVertex(n7), m2 = e5.getGeometryFromPath(h2), l2 = this.m_topoGraph.getGeometryID(m2), g2 = e5.getFirstVertex(h2), u = !!(l2 & s4);
      u && g2 === n7 && (this.m_fromEdgeForPolylines = t2);
      const c = e5.getNextVertex(n7);
      if (c !== bm && this.m_topoGraph.getClusterFromVertex(c) === r) {
        if (i2++, u) {
          if (this.m_fromEdgeForPolylines === bm && g2 === c) {
            const e6 = this.m_topoGraph.getHalfEdgeNext(t2);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e6)) && (this.m_fromEdgeForPolylines = e6);
          }
          o2++;
        }
      } else {
        const s5 = e5.getPrevVertex(n7);
        if (s5 !== bm && this.m_topoGraph.getClusterFromVertex(s5) === r && (i2--, u)) {
          if (this.m_fromEdgeForPolylines === bm && g2 === s5) {
            const e6 = this.m_topoGraph.getHalfEdgeNext(t2);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e6)) && (this.m_fromEdgeForPolylines = e6);
          }
          o2--;
        }
      }
    }
    this.m_topoGraph.queryXY(n6, this.m_dummyPt1), this.m_topoGraph.queryXY(r, this.m_dummyPt2);
    return (0 !== o2 ? o2 : i2) * ei.distance(this.m_dummyPt1, this.m_dummyPt2);
  }
  tryMoveThroughCrossroadBackwards(e5, t2) {
    const s4 = this.m_topoGraph.getHalfEdgePrev(e5), n6 = this.m_topoGraph.getHalfEdgeTwin(s4);
    if (!t2) {
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e5))) return bm;
      const t3 = this.m_topoGraph.getHalfEdgeTwin(e5);
      if (n6 === this.m_topoGraph.getHalfEdgeNext(t3)) return s4;
    }
    let r = n6, i2 = bm;
    for (; r !== e5; ) {
      const e6 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e6)) {
        if (i2 !== bm) return bm;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(r));
    }
    return i2;
  }
  tryMoveThroughCrossroadForward(e5, t2) {
    const s4 = this.m_topoGraph.getHalfEdgeNext(e5), n6 = this.m_topoGraph.getHalfEdgeTwin(s4);
    if (!t2) {
      const t3 = this.m_topoGraph.getHalfEdgeTwin(e5);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t3))) return bm;
      if (n6 === this.m_topoGraph.getHalfEdgePrev(t3)) return s4;
    }
    let r = n6, i2 = bm;
    for (; r !== e5; ) {
      const e6 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e6)) {
        if (i2 !== bm) return bm;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(r));
    }
    return i2;
  }
  isOnALoop(e5, t2) {
    let s4 = e5;
    const n6 = 2 * this.m_topoGraph.getShape().getTotalPointCount() + 10;
    for (let r = 0; r < n6; r++) {
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(s4, t2)) return false;
      const n7 = this.m_topoGraph.getHalfEdgeNext(s4);
      if (n7 === this.m_topoGraph.getHalfEdgeTwin(s4)) return false;
      if (s4 = n7, s4 === e5) return true;
    }
    b("is_on_a_loop_");
  }
  restorePolylineParts(e5, t2, n6, r, i2, o2, a2, h2, m2, l2) {
    n2(i2 === bm && o2 >= 0 && a2 >= 0 || -1 === o2 && -1 === a2), n2(-1 === h2 && 1 !== l2.unsplitBehavior || -1 !== h2 && 1 === l2.unsplitBehavior);
    const g2 = l2.ogcRule, u = l2.allCrossRoadsImpassable, c = 1 === l2.unsplitBehavior, _ = 0 === l2.unsplitBehavior, d2 = this.m_topoGraph.getShape(), p3 = d2.hasSegmentParentage();
    let f3 = e5, x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
    const y2 = new nu();
    this.m_fromEdgeForPolylines = bm;
    let P5 = this.prevailingDirection(d2, f3), E2 = f3, C2 = bm, S3 = false, I5 = false, b2 = false;
    if (!c) for (; ; ) {
      const t3 = this.m_topoGraph.getHalfEdgePrev(f3);
      if (t3 === x4) {
        b2 = true;
        break;
      }
      const s4 = this.m_topoGraph.getHalfEdgeNext(x4);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(s4))) {
        S3 = true;
        break;
      }
      if (this.m_topoGraph.getHalfEdgeTwin(t3) !== s4) {
        if (u) {
          S3 = true;
          break;
        }
        if (f3 = this.tryMoveThroughCrossroadBackwards(f3, true), f3 === bm) {
          S3 = true;
          break;
        }
        x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
      } else f3 = t3, x4 = s4;
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, n6)) {
        b2 = true;
        break;
      }
      if (f3 === e5) {
        C2 = e5, I5 = true;
        break;
      }
      const r2 = this.getCombinedHalfEdgeParentage(f3);
      if (!this.isGoodParentage(r2)) break;
      E2 = f3, P5 += this.prevailingDirection(d2, f3);
    }
    if (C2 === bm) {
      for (f3 = e5, x4 = this.m_topoGraph.getHalfEdgeTwin(f3), C2 = f3; ; ) {
        const e6 = this.m_topoGraph.getHalfEdgeNext(f3), t4 = this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e6));
        if (t4) {
          S3 = true;
          break;
        }
        if (e6 === x4) {
          b2 = true;
          break;
        }
        if (-1 !== h2) {
          const e7 = this.m_topoGraph.getHalfEdgeOrigin(x4);
          if (1 === this.m_topoGraph.getClusterUserIndex(e7, h2)) {
            S3 = true;
            break;
          }
        }
        const s4 = this.m_topoGraph.getHalfEdgePrev(x4);
        if (this.m_topoGraph.getHalfEdgeTwin(e6) !== s4) {
          if (t4 || u) {
            S3 = true;
            break;
          }
          if (f3 = this.tryMoveThroughCrossroadForward(f3, true), f3 === bm) {
            S3 = true;
            break;
          }
          x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
        } else f3 = e6, x4 = s4;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, n6)) {
          b2 = true;
          break;
        }
        const r2 = this.getCombinedHalfEdgeParentage(f3);
        if (!this.isGoodParentage(r2)) break;
        C2 = f3, P5 += this.prevailingDirection(d2, f3);
      }
      const t3 = this.m_topoGraph.getHalfEdgeOrigin(E2);
      I5 = this.m_topoGraph.getHalfEdgeTo(C2) === t3;
    } else if (this.m_fromEdgeForPolylines !== bm) {
      E2 = e5, C2 = this.tryMoveThroughCrossroadBackwards(E2, false), n2(C2 !== bm);
      const t3 = this.m_topoGraph.getHalfEdgeTwin(E2);
      this.m_topoGraph.getHalfEdgeNext(t3);
    }
    let v3 = I5;
    I5 || b2 || m2 && (v3 = this.isOnALoop(e5, n6), v3 || (v3 = this.isOnALoop(x4, n6)));
    const N2 = P5 >= 0;
    let T3 = false;
    v3 && S3 && (I5 ? (T3 = g2, N2 && (T3 || c || _) && E2 !== e5 && (n2(!c), E2 = e5, T3 = false)) : (c || N2 && _) && (E2 = e5));
    let G4 = 0;
    for (f3 = E2; x4 = this.m_topoGraph.getHalfEdgeTwin(f3), this.m_topoGraph.setHalfEdgeUserIndex(f3, n6, 1), this.m_topoGraph.setHalfEdgeUserIndex(x4, n6, 1), G4++, f3 !== C2; ) f3 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false);
    N2 || (C2 = Mt(E2, E2 = C2), C2 = this.m_topoGraph.getHalfEdgeTwin(C2), E2 = this.m_topoGraph.getHalfEdgeTwin(E2));
    let D3 = d2.insertPath(t2, bm);
    f3 = E2;
    const F3 = this.m_topoGraph.getHalfEdgeOrigin(E2);
    let H3;
    H3 = -1 !== o2 ? this.chooseVertexByOrder(F3, d2, o2, a2) : this.chooseVertexFromCluster_(F3, i2), this.m_topoGraph.isStrongPathNode(F3) && d2.setStrongPathStart(D3, true);
    let k4 = d2.addVertex(D3, H3), A4 = k4;
    -1 !== r && this.m_topoGraph.setClusterUserIndex(F3, r, 1);
    let M2 = 0;
    const U4 = T3 ? Math.trunc((G4 + 1) / 2) : -1;
    let q2 = bm, O3 = true, B4 = bm;
    for (; ; ) {
      if (p3) {
        const e7 = this.m_topoGraph.getSegmentParentage(f3), t3 = this.m_topoGraph.getHalfEdgeOrigin(f3);
        d2.setSegmentParentageAndBreak(A4, e7, O3 || this.m_topoGraph.isBreakNode(t3));
      }
      O3 = false, this.m_topoGraph.isHalfEdgeCurve(f3) && (this.m_topoGraph.querySegmentXY(f3, y2), d2.setSegmentToIndex(d2.getVertexIndex(A4), y2.get().clone())), q2 !== bm && -1 !== a2 && d2.addToUserIndex(q2, a2, -1);
      const e6 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false), s4 = this.m_topoGraph.getHalfEdgeTo(f3);
      let n7;
      if (n7 = -1 !== o2 ? this.chooseVertexByOrder(s4, d2, o2, a2) : this.chooseVertexFromCluster_(s4, i2), k4 = d2.addVertex(D3, n7), B4 = s4, -1 !== r && this.m_topoGraph.setClusterUserIndex(s4, r, 1), p3 && this.m_topoGraph.isBreakNode(s4) && d2.setSegmentParentageBreakVertex(k4, true), q2 = n7, M2++, T3 && M2 === U4 && (D3 = d2.insertPath(t2, bm), k4 = d2.addVertex(D3, n7), O3 = true, -1 !== a2 && d2.addToUserIndex(n7, a2, -1), q2 = bm), f3 === C2) break;
      f3 = e6, A4 = k4;
    }
    B4 !== bm && this.m_topoGraph.isStrongPathNode(B4) && d2.setStrongPathEnd(D3, true);
  }
  topoOperationPolylineSimplify_(e5, t2) {
    return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, bm, false, t2).first;
  }
  topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, t2, n6, r) {
    n2(t2 === bm || e5 === bm);
    const i2 = this.m_topoGraph.getShape(), a2 = (t3) => t3 = e5 === bm ? t3 === bm ? i2.getFirstGeometry() : i2.getNextGeometry(t3) : t3 === bm ? e5 : bm, h2 = i2.createGeometry(a.enumPolyline);
    let m2 = -1;
    n6 && (m2 = this.m_topoGraph.createUserIndexForClusters());
    const l2 = this.m_topoGraph.createUserIndexForHalfEdges(), g2 = t2 === bm ? i2.createUserIndex() : -1, u = t2 === bm ? i2.createUserIndex() : -1;
    let c = -1;
    if (1 === r.unsplitBehavior) {
      c = this.m_topoGraph.createUserIndexForClusters();
      for (let e6 = a2(bm); e6 !== bm; e6 = a2(e6)) for (let t3 = i2.getFirstPath(e6); t3 !== bm; t3 = i2.getNextPath(t3)) {
        {
          const e7 = i2.getFirstVertex(t3), s4 = this.m_topoGraph.getClusterFromVertex(e7);
          this.m_topoGraph.setClusterUserIndex(s4, c, 1);
        }
        if (!i2.isClosedPath(t3)) {
          const e7 = i2.getLastVertex(t3), s4 = this.m_topoGraph.getClusterFromVertex(e7);
          this.m_topoGraph.setClusterUserIndex(s4, c, 1);
        }
      }
    }
    if (t2 === bm) {
      let e6 = 0;
      for (let t3 = a2(bm); t3 !== bm; t3 = a2(t3)) for (let s4 = i2.getFirstPath(t3); s4 !== bm; s4 = i2.getNextPath(s4)) {
        if (i2.isClosedPath(s4)) {
          let t4 = i2.getFirstVertex(s4);
          for (let n7 = 0, r2 = i2.getPathSize(s4); n7 < r2; n7++, t4 = i2.getNextVertex(t4)) i2.setUserIndex(t4, g2, e6++), i2.setUserIndex(t4, u, 2);
        } else {
          const t4 = i2.getFirstVertex(s4);
          i2.setUserIndex(t4, g2, e6++), i2.setUserIndex(t4, u, 1);
          let n7 = i2.getNextVertex(t4);
          for (let r2 = 1, o2 = i2.getPathSize(s4) - 1; r2 < o2; ++r2) i2.setUserIndex(n7, g2, e6++), i2.setUserIndex(n7, u, 2), n7 = i2.getNextVertex(n7);
          i2.setUserIndex(n7, g2, e6++), i2.setUserIndex(n7, u, 1);
        }
      }
    }
    for (let s4 = a2(bm); s4 !== bm; s4 = a2(s4)) for (let e6 = i2.getFirstPath(s4); e6 !== bm; e6 = i2.getNextPath(e6)) {
      let s5 = i2.getFirstVertex(e6);
      for (let n7 = 0, o2 = i2.getPathSize(e6); n7 < o2; n7++, s5 = i2.getNextVertex(s5)) {
        const e7 = this.m_topoGraph.getHalfEdgeFromVertex(s5);
        if (e7 === bm) continue;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(e7, l2)) continue;
        const i3 = this.getCombinedHalfEdgeParentage(e7);
        if (this.isGoodParentage(i3)) {
          const s6 = 0 === n7;
          this.restorePolylineParts(e7, h2, l2, m2, t2, g2, u, c, s6, r);
        }
      }
    }
    let _ = bm;
    if (n6) {
      _ = i2.createGeometry(a.enumMultiPoint);
      let e6 = bm;
      for (let s4 = this.m_topoGraph.getFirstCluster(); s4 !== bm; s4 = this.m_topoGraph.getNextCluster(s4)) {
        this.progress_();
        if (1 !== this.m_topoGraph.getClusterUserIndex(s4, m2)) {
          const n7 = this.m_topoGraph.getClusterParentage(s4);
          if (this.isGoodParentage(n7)) {
            e6 === bm && (e6 = i2.insertPath(_, bm));
            const n8 = this.m_topoGraph.getClusterVertexIterator(s4);
            if (n8 !== bm) {
              let r2;
              this.m_topoGraph.getVertexFromVertexIterator(n8), r2 = -1 !== g2 ? this.chooseVertexByOrder(s4, i2, g2, u) : this.chooseVertexFromCluster_(s4, t2), i2.addVertex(e6, r2);
            }
          }
        }
      }
    }
    return -1 !== u && i2.removeUserIndex(u), -1 !== g2 && i2.removeUserIndex(g2), -1 !== m2 && i2.removeUserIndex(m2), this.m_topoGraph.deleteUserIndexForHalfEdges(l2), Qt(h2, _);
  }
  difference(e5, t2) {
    const s4 = this.m_topoGraph.getShape().getGeometryType(e5), n6 = this.m_topoGraph.getShape().getGeometryType(t2), r = m(s4), i2 = m(n6);
    if (r > i2) return e5;
    const o2 = this.m_topoGraph.getGeometryID(e5), a2 = this.m_topoGraph.getGeometryID(t2);
    if (this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (o2 | a2), this.m_maskLookup[o2] = true, 2 === r && 2 === i2) {
      let s5 = bm;
      return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (s5 = e5), this.topoOperationPolygonPolygon_(e5, t2, s5);
    }
    if (1 === r && 2 === i2) {
      const t3 = Ga2();
      return t3.allCrossRoadsImpassable = false, t3.ogcRule = this.m_bOGCOutput, t3.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, bm, false, t3).first;
    }
    if (1 === r && 1 === i2) {
      const t3 = Ga2();
      return t3.allCrossRoadsImpassable = true, t3.ogcRule = this.m_bOGCOutput, t3.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e5, bm, false, t3).first;
    }
    if (0 === r) return this.topoOperationMultiPoint_();
    b("");
  }
  symmetricDifference(e5, t2) {
    const n6 = this.m_topoGraph.getShape().getGeometryType(e5), r = this.m_topoGraph.getShape().getGeometryType(t2), i2 = Na2(n6), o2 = Na2(r), a2 = this.m_topoGraph.getGeometryID(e5), h2 = this.m_topoGraph.getGeometryID(t2);
    return n2(a2 >= 0), n2(h2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (a2 | h2), this.m_maskLookup[a2] = true, this.m_maskLookup[a2] = true, this.m_maskLookup[h2] = true, 2 === i2 && 2 === o2 ? this.topoOperationPolygonPolygon_(e5, t2, bm) : 1 === i2 && 1 === o2 ? this.topoOperationPolyline_(bm, this.m_bOGCOutput) : 0 === i2 && 0 === o2 ? this.topoOperationMultiPoint() : void b("");
  }
  planarSimplifyNoCrackingAndCluster(e5, t2, n6, r) {
    this.m_bOGCOutput = e5, this.m_topoGraph = new Js2();
    const i2 = t2.getFillRule(n6), a2 = t2.getGeometryType(n6);
    if (1 !== i2 || a2 === a.enumMultiPoint ? this.m_topoGraph.setAndSimplifyEditShapeAlternate(t2, n6, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeWinding(t2, n6, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return false;
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const h2 = this.m_topoGraph.getGeometryID(n6);
    if (n2(h2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = h2 + 1, this.m_maskLookup[h2] = true, t2.getGeometryType(n6) === a.enumPolygon || 1 === i2 && t2.getGeometryType(n6) !== a.enumMultiPoint) {
      t2.setFillRule(n6, 0);
      const s4 = this.topoOperationPolygonPolygon_(n6, bm, bm);
      if (t2.swapGeometry(s4, n6), t2.removeGeometry(s4), 1 === i2 && this.m_bOGCOutput) return this.planarSimplifyNoCrackingAndCluster(e5, t2, n6, r);
    } else if (t2.getGeometryType(n6) === a.enumPolyline) {
      const e6 = Ga2();
      e6.ogcRule = this.m_bOGCOutput, e6.allCrossRoadsImpassable = true, e6.unsplitBehavior = r;
      const s4 = this.topoOperationPolylineSimplify_(t2.getFirstGeometry(), e6);
      t2.swapGeometry(s4, n6), t2.removeGeometry(s4);
    } else if (t2.getGeometryType(n6) === a.enumMultiPoint) {
      const e6 = this.topoOperationMultiPoint_();
      t2.swapGeometry(e6, n6), t2.removeGeometry(e6);
    } else b("");
    return true;
  }
  unsplitPolylineExact(e5) {
    return n2(0), new Na();
  }
  planarSimplifyPolylines(e5, t2, n6, r, i2) {
    for (let _ = e5.getFirstGeometry(); _ !== bm; _ = e5.getNextGeometry(_)) {
      const t3 = e5.getGeometryType(_);
      n2(t3 === a.enumPolyline);
    }
    let a2 = 0, h2 = 0, m2 = null;
    if (e5.hasCurves() && !e5.hasSegmentParentage()) {
      m2 = new ca2();
      const s4 = e5.getEnvelope2D(this.m_progressTracker);
      h2 = ga2(t2.total());
      const n7 = la2(t2.total(), s4);
      a2 = ua2(n7, h2), ra2(e5, n7, t2.total(), 12e3, m2, null, this.m_progressTracker);
    }
    {
      const s4 = Pa2(t2.add(a2));
      e5.filterClosePoints(s4, false, false, false, bm);
    }
    if (this.m_topoGraph = new Js2(), 4 !== i2 && 5 !== i2) if (null === m2 && n6) {
      const s4 = new Nn2(this.m_progressTracker, false);
      s4.sweepVertical(e5, t2.total()), s4.hadComplications() ? (da2(e5, t2, this.m_progressTracker, true, false), n6 = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t2.total());
    } else da2(e5, t2.add(a2), this.m_progressTracker, true, false), n6 = false;
    else n6 = false;
    e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const l2 = e5.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, l2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(n6 && null === m2), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolylines(e5, t2, false, r, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const g2 = this.m_topoGraph.getGeometryID(l2);
    n2(g2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = g2 + 1, this.m_maskLookup[g2] = true;
    const u = this.topoOperationPolylineSimplify_(e5.getFirstGeometry(), r);
    null !== m2 && m2.stitchCurves(e5, u, h2, true);
    const c = e5.getGeometry(u);
    return n6 || c.getImpl().setIsSimple(4, t2.total()), c;
  }
  planarSimplifyMultiPoints(e5, t2, n6, r) {
    for (let l2 = e5.getFirstGeometry(); l2 !== bm; l2 = e5.getNextGeometry(l2)) {
      const t3 = e5.getGeometryType(l2);
      n2(t3 === a.enumMultiPoint);
    }
    this.m_topoGraph = new Js2(), 4 !== r && 5 !== r ? (da2(e5, t2, this.m_progressTracker, true, false), n6 = false) : n6 = false, e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const i2 = e5.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, i2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(n6), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyMultiPoints(e5, t2, false, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const a2 = this.m_topoGraph.getGeometryID(i2);
    n2(a2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = a2 + 1, this.m_maskLookup[a2] = true;
    const h2 = this.topoOperationMultiPoint(), m2 = e5.getGeometry(h2);
    return n6 || m2.getImpl().setIsSimple(4, t2.total()), m2;
  }
  planarSimplifyPolygons(e5, t2, n6, r, i2, a2) {
    for (let f3 = e5.getFirstGeometry(); f3 !== bm; f3 = e5.getNextGeometry(f3)) {
      const t3 = e5.getGeometryType(f3);
      n2(t3 === a.enumPolygon || t3 === a.enumPolyline && n6);
    }
    let h2 = 0, m2 = 0, l2 = null;
    if (e5.hasCurves() && !e5.hasSegmentParentage()) {
      l2 = new ca2();
      const s4 = e5.getEnvelope2D(this.m_progressTracker);
      m2 = ga2(t2.total());
      const n7 = la2(t2.total(), s4);
      h2 = ua2(n7, m2), ra2(e5, n7, t2.total(), 12e3, l2, null, this.m_progressTracker);
    }
    if (a2) {
      da2(e5, t2.add(h2), this.m_progressTracker, true, false);
      for (let t3 = e5.getFirstGeometry(); t3 !== bm; t3 = e5.getNextGeometry(t3)) e5.getGeometryType(t3) === a.enumPolygon && Qn2(e5, t3, -1, false, bm, this.m_progressTracker);
    }
    if (this.m_topoGraph = new Js2(), a2 || 4 === i2 || 5 === i2) r = false;
    else if (null === l2 && r) {
      const s4 = new Nn2(this.m_progressTracker, false);
      s4.sweepVertical(e5, t2.total()), s4.hadComplications() ? (da2(e5, t2, this.m_progressTracker, true, false), r = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t2.total());
    } else da2(e5, t2.add(h2), this.m_progressTracker, true, false), r = false;
    e5.removeSelection(), e5.collapseAllGeometriesToFirst();
    const g2 = e5.getFirstGeometry();
    if (n6 ? this.m_topoGraph.setAndSimplifyEditShapeWinding(e5, g2, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, g2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n2(r && null === l2), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolygons(e5, t2, n6, false, -1, false);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const u = this.m_topoGraph.getGeometryID(g2);
    n2(u >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = u + 1, this.m_maskLookup[u] = true, e5.setFillRule(g2, 0);
    const c = this.m_bOGCOutput && n6, _ = c;
    let d2 = this.topoOperationPolygonPolygon_(g2, bm, bm, _);
    if (c) {
      this.m_topoGraph.removeShape(), this.m_topoGraph = null, e5.removeGeometry(g2), this.m_topoGraph = new Js2(), this.m_topoGraph.setAndSimplifyEditShapeAlternate(e5, d2, this.m_progressTracker);
      d2 = this.topoOperationPolygonPolygon_(d2, bm, bm, false);
    }
    null !== l2 && l2.stitchCurves(e5, d2, m2, true);
    const p3 = e5.getGeometry(d2);
    return p3.setFillRule(0), r ? p3.getImpl().setIsSimple(3, 0) : (p3.getImpl().setIsSimple(4, t2.total()), p3.getImpl().updateOGCFlagsProtected()), p3;
  }
  planarSimplify3DImpl_(e5, t2, n6, r, i2) {
    return n2(0), {};
  }
  planarSimplifyImpl_(e5, t2, s4, n6, r, i2, a2, h2) {
    if (e5.isEmpty()) return e5.clone();
    const m2 = e5.getGeometryType(), l2 = new Tm(), u = l2.addGeometry(e5);
    if (Ht(r) && m2 === a.enumPolygon && (s4 = false, l2.setFillRule(u, 0)), h2 && (e5.hasAttribute(1) && l2.replaceNaNs(1, 0), l2.removeNaNVertices()), m2 === a.enumPolygon || m2 === a.enumPolyline && s4) return this.planarSimplifyPolygons(l2, t2, s4, n6, r, false);
    if (m2 === Na.type) {
      const e6 = Ga2();
      return e6.allCrossRoadsImpassable = true, e6.ogcRule = this.m_bOGCOutput, e6.unsplitBehavior = a2, this.planarSimplifyPolylines(l2, t2, n6, e6, r);
    }
    if (m2 === a.enumMultiPoint) return this.planarSimplifyMultiPoints(l2, t2, n6, r);
    b("what else?");
  }
};
function Wa2(e5, t2, s4, n6) {
  if (e5.isEmpty()) return e5.createInstance();
  if (t2.isEmpty()) return n6 ? e5.createInstance() : new ee({ copy: e5 });
  const r = [new ei()], i2 = [0], o2 = 2 === t2.getDimension();
  1 !== t2.getDimension() && 2 !== t2.getDimension() && b(""), r[0] = e5.getXY(), o2 ? Xo2(t2, r, 1, s4.total(), i2) : Lo2(t2, r, 1, s4.total(), i2);
  let a2 = 0 === i2[0];
  return n6 || (a2 = !a2), a2 ? e5.createInstance() : e5;
}
function ja2(e5, t2, s4, n6) {
  const r = e5.createInstance(), i2 = Rt(ei, 100), o2 = new Array(100), a2 = e5.getPointCount();
  let h2 = true;
  const m2 = 2 === t2.getDimension();
  1 !== t2.getDimension() && 2 !== t2.getDimension() && b("");
  for (let l2 = 0; l2 < a2; ) {
    const n7 = e5.queryCoordinates(i2, i2.length, l2, -1) - l2;
    m2 ? Xo2(t2, i2, n7, s4.total(), o2) : Lo2(t2, i2, n7, s4.total(), o2);
    let a3 = 0;
    for (let t3 = 0; t3 < n7; t3++) {
      0 === o2[t3] && (h2 && (h2 = false, r.addPoints(e5, 0, l2)), a3 !== t3 && r.addPoints(e5, l2 + a3, l2 + t3), a3 = t3 + 1);
    }
    h2 || a3 === n7 || r.addPoints(e5, l2 + a3, l2 + n7), l2 += n7;
  }
  return h2 ? e5 : r;
}
function Za2(e5, t2, s4, n6) {
  const r = e5.getGeometryType();
  if (r === a.enumEnvelope) {
    const t3 = new eh({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.addEnvelope(e5, false), t3;
  }
  if (r === a.enumPoint && ("|" === n6 || "^" === n6)) {
    const t3 = new Ce({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.add(e5), t3;
  }
  if (r === a.enumLine) {
    const t3 = new Na({ vd: e5.getDescription() });
    return e5.isEmpty() || t3.addSegment(e5, true), t3;
  }
  if (r === a.enumMultiPoint && "-" === n6 && t2.getGeometryType() === a.enumPoint) {
    const t3 = new ee({ vd: e5.getDescription() });
    return e5.isEmpty() || e5.getPointByVal(0, t3), t3;
  }
  if (r === a.enumMultiPoint && "&" === n6 && t2.getGeometryType() === a.enumPoint) {
    const t3 = new ee({ vd: e5.getDescription() });
    return e5.isEmpty() || e5.getPointByVal(0, t3), t3;
  }
  return e5;
}
function Ka(e5) {
  const s4 = e5.getGeometryType();
  if (s4 === a.enumEnvelope) {
    const t2 = new eh({ vd: e5.getDescription() });
    return e5.isEmpty() || t2.addEnvelope(e5, false), t2;
  }
  if (s4 === a.enumPoint) {
    const t2 = new Ce({ vd: e5.getDescription() });
    return e5.isEmpty() || t2.add(e5), t2;
  }
  if (va2(s4)) {
    const t2 = new Na({ vd: e5.getDescription() });
    return e5.isEmpty() || t2.addSegment(e5, true), t2;
  }
  return s4 !== a.enumMultiPoint && s4 !== a.enumPolyline && s4 !== a.enumPolygon && P("Unexpected geometry type"), e5;
}
function Qa(e5, t2, n6, r) {
  const i2 = n6 === bm ? e5.getClusterHalfEdge(t2) : n6;
  let o2 = i2;
  n2(e5.getHalfEdgeOrigin(i2) === t2);
  do {
    r(o2), o2 = e5.getHalfEdgeNext(e5.getHalfEdgeTwin(o2));
  } while (o2 !== i2);
}
var Ja2 = class {
  constructor(e5, t2, s4, n6, r, i2) {
    this.m_rParent = e5, this.m_rTopoGraph = e5.m_topoGraph, this.m_rShape = this.m_rTopoGraph.getShape(), this.m_IDCuttee = this.m_rTopoGraph.getGeometryID(n6), this.m_IDCutter = this.m_rTopoGraph.getGeometryID(r), this.m_IDBoth = this.m_IDCuttee | this.m_IDCutter, this.m_bConsiderTouch = t2, this.m_sideIndex = s4, this.m_cuttee = n6, this.m_cutter = r, this.m_rCutHandles = i2, this.m_cutteeBreadcrumbsIndex = this.m_rShape.createUserIndexUninitialized(), this.m_clusterParentageIndex = this.m_rShape.createUserIndexUninitialized();
    for (let o2 = this.m_rShape.getFirstPath(this.m_cuttee); o2 !== bm; o2 = this.m_rShape.getNextPath(o2)) {
      let e6 = 0;
      const t3 = this.m_rShape.getPathSize(o2);
      for (let s5 = this.m_rShape.getFirstVertex(o2); e6 < t3; e6++, s5 = this.m_rShape.getNextVertex(s5)) this.m_rShape.setUserIndex(s5, this.m_clusterParentageIndex, this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(s5)));
    }
  }
  Do() {
    this.cutPolylinePolyline_(), this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex), this.m_rShape.removeUserIndex(this.m_clusterParentageIndex);
  }
  setTbd(e5) {
    return 8 | e5;
  }
  classifyStandardCut(e5, t2, s4, n6) {
    const r = this.m_rShape.getPrevVertex(e5), i2 = this.m_rShape.getNextVertex(e5), o2 = r === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(s4)), m2 = this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(n6));
    let l2 = 1, g2 = 32, u = 32;
    if (Qa(this.m_rTopoGraph, t2, m2, (e6) => {
      e6 === h2 && (l2 = 2), e6 === o2 && (g2 = l2), e6 === a2 && (u = l2);
    }), this.m_bConsiderTouch) 32 !== g2 && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), 32 !== u && this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | u);
    else {
      if (32 === g2 || 32 === u) return 1;
      if (g2 === u && !(o2 === h2 || o2 === m2 || a2 === h2 || a2 === m2)) return 1;
      this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | u);
    }
    return 0;
  }
  classifyTouchCut(e5, t2, s4, n6) {
    const r = this.m_rShape.getPrevVertex(e5), i2 = this.m_rShape.getNextVertex(e5), o2 = r === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = s4 === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(s4)), m2 = n6 === bm ? bm : this.m_rTopoGraph.getHalfEdgeConnector(t2, this.m_rTopoGraph.getClusterFromVertex(n6));
    if (!this.m_bConsiderTouch) {
      let t3;
      return (t3 = h2 === o2 || m2 === o2) ? this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))) : (t3 = h2 === a2 || m2 === a2) && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), t3 ? 0 : 1;
    }
    if (o2 === bm) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
    if (a2 === bm) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
    if (o2 === a2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
    if (m2 !== bm) {
      if (o2 === m2) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === m2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s5 = 1;
      Qa(this.m_rTopoGraph, t2, m2, (t3) => {
        if (t3 === o2) {
          const e6 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e6), s5 = 2;
        } else if (t3 === a2) {
          const t4 = this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, t4), s5 = 2;
        }
      });
    } else {
      if (o2 === h2) return this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === h2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s5 = 2;
      Qa(this.m_rTopoGraph, t2, h2, (t3) => {
        if (t3 === o2) {
          const e6 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e6), s5 = 1;
        } else if (t3 === a2) {
          const t4 = this.m_rShape.getUserIndex(e5, this.m_cutteeBreadcrumbsIndex) | s5;
          this.m_rShape.setUserIndex(e5, this.m_cutteeBreadcrumbsIndex, t4), s5 = 1;
        }
      });
    }
    return 0;
  }
  classifyCutVertex(e5, t2) {
    let s4 = 0, n6 = 0;
    for (let r = this.m_rTopoGraph.getClusterVertexIterator(t2); r !== bm; r = this.m_rTopoGraph.incrementVertexIterator(r)) {
      const i2 = this.m_rTopoGraph.getVertexFromVertexIterator(r);
      if (this.m_rShape.getGeometryFromVertex(i2) === this.m_cutter) {
        n6++;
        const r2 = this.m_rShape.getPrevVertex(i2), o2 = this.m_rShape.getNextVertex(i2);
        s4 += r2 === bm || o2 === bm ? this.classifyTouchCut(e5, t2, r2, o2) : this.classifyStandardCut(e5, t2, r2, o2);
      }
    }
    n6 && s4 === n6 && !this.m_bConsiderTouch && this.m_rShape.setUserIndex(e5, this.m_clusterParentageIndex, this.m_IDCuttee);
  }
  cutPolylinePolyline_() {
    this.m_rShape.getGeometryType(this.m_cuttee), this.m_rShape.getGeometryType(this.m_cutter), this.m_rParent.m_maskLookup.length = 0, this.m_rParent.m_maskLookup.length = this.m_IDBoth + 1, this.m_rParent.m_maskLookup[this.m_IDBoth] = true;
    for (let o2 = this.m_rShape.getFirstPath(this.m_cuttee); o2 !== bm; o2 = this.m_rShape.getNextPath(o2)) {
      const e6 = this.m_rShape.getPathSize(o2);
      let t3 = this.m_rShape.getFirstVertex(o2);
      for (let s5 = 0; s5 < e6; ++s5, t3 = this.m_rShape.getNextVertex(t3)) this.m_rShape.setUserIndex(t3, this.m_cutteeBreadcrumbsIndex, 0);
      t3 = this.m_rShape.getFirstVertex(o2);
      for (let s5 = 0; s5 < e6; ++s5, t3 = this.m_rShape.getNextVertex(t3)) {
        const e7 = this.m_rTopoGraph.getClusterFromVertex(t3);
        this.m_rTopoGraph.getClusterParentage(e7) === this.m_IDBoth && this.classifyCutVertex(t3, e7);
      }
    }
    const e5 = (e6, t3) => {
      let s5 = this.m_rShape.getUserIndex(e6, this.m_cutteeBreadcrumbsIndex);
      const n7 = this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(e6), this.m_rTopoGraph.getClusterFromVertex(t3));
      return (this.m_rTopoGraph.getHalfEdgeParentage(n7) & this.m_IDBoth) === this.m_IDBoth && (s5 |= 4), s5;
    };
    for (let o2 = this.m_rShape.getFirstPath(this.m_cuttee); o2 !== bm; o2 = this.m_rShape.getNextPath(o2)) {
      let t3 = this.m_rShape.getFirstVertex(o2);
      const s5 = this.m_rShape.isClosedPath(o2), n7 = this.m_rShape.getPathSize(o2) + (s5 ? 1 : 0);
      let r2 = 1, i3 = 32;
      for (let o3 = this.m_rShape.getNextVertex(t3); r2 < n7; ++r2, t3 = o3, o3 = this.m_rShape.getNextVertex(o3)) {
        const s6 = e5(t3, o3);
        this.m_rShape.getUserIndex(t3, this.m_clusterParentageIndex) === this.m_IDBoth && (i3 = s6), 32 !== i3 && this.m_rShape.setUserIndex(t3, this.m_cutteeBreadcrumbsIndex, i3 | s6);
      }
      t3 = this.m_rShape.getLastVertex(o2);
      let a2 = 32;
      r2 = 1;
      for (let o3 = this.m_rShape.getPrevVertex(t3); r2 < n7; ++r2, t3 = o3, o3 = this.m_rShape.getPrevVertex(o3)) {
        const s6 = e5(o3, t3);
        this.m_rShape.getUserIndex(t3, this.m_clusterParentageIndex) === this.m_IDBoth && (a2 = s6), 32 !== a2 && this.m_rShape.setUserIndex(o3, this.m_cutteeBreadcrumbsIndex, a2 | s6);
      }
    }
    let t2 = bm, s4 = bm, n6 = 32;
    const r = this.m_rShape.hasSegmentParentage(), i2 = new nu();
    for (let a2 = this.m_rShape.getFirstPath(this.m_cuttee); a2 !== bm; a2 = this.m_rShape.getNextPath(a2)) {
      const e6 = this.m_rShape.isClosedPath(a2), h2 = this.m_rShape.getPathSize(a2) + (e6 ? 1 : 0);
      let m2 = 1, l2 = this.m_rShape.getFirstVertex(a2), g2 = bm, u = true;
      for (let a3 = this.m_rShape.getNextVertex(l2); m2 < h2; ++m2, a3 = this.m_rShape.getNextVertex(a3)) {
        let e7 = this.m_rShape.getUserIndex(l2, this.m_cutteeBreadcrumbsIndex);
        8 === e7 ? e7 = 3 : (e7 &= -9, 4 & e7 ? e7 = 4 : 3 & ~e7 || (e7 = 3)), e7 !== n6 ? (t2 !== bm && (g2 = this.m_rShape.addVertex(s4, l2), r && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t2), this.m_rShape.setGeometryUserIndex(t2, this.m_sideIndex, n6)), t2 = this.m_rShape.createGeometry(a.enumPolyline), s4 = this.m_rShape.insertPath(t2, bm), n6 = e7, u = true) : this.m_rShape.getUserIndex(l2, this.m_clusterParentageIndex) === this.m_IDBoth && 4 !== e7 && (g2 = this.m_rShape.addVertex(s4, l2), r && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), s4 = this.m_rShape.insertPath(t2, bm), u = true), g2 = this.m_rShape.addVertex(s4, l2);
        const h3 = this.m_rTopoGraph.getClusterFromVertex(l2);
        !u && r && this.m_rTopoGraph.isBreakNode(h3) && this.m_rShape.setSegmentParentageBreakVertex(g2, true);
        const m3 = this.m_rTopoGraph.getHalfEdgeFromVertex(l2);
        if (r) {
          const e8 = this.m_rTopoGraph.getSegmentParentage(m3);
          this.m_rShape.setSegmentParentageAndBreak(g2, e8, u || this.m_rTopoGraph.isBreakNode(h3));
        }
        this.m_rTopoGraph.isHalfEdgeCurve(m3) && (this.m_rTopoGraph.querySegmentXY(m3, i2), this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(g2), i2.get().clone())), l2 = a3, u = false;
      }
      g2 = this.m_rShape.addVertex(s4, l2), r && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t2), this.m_rShape.setGeometryUserIndex(t2, this.m_sideIndex, n6), t2 = bm, s4 = bm, n6 = 32;
    }
  }
};
function $a2(e5, t2, s4) {
  return new za2(s4).linesToPolygonsImpl(e5, t2);
}
function eh2(t2, s4, n6, r, i2) {
  if (r && (r.m_reason = 0, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), t2.isEmpty()) return 5;
  const h2 = t2.getGeometryType();
  if (h2 === a.enumPoint) return ih2(t2, r);
  const m2 = zt2(s4, t2, false).total();
  if (h2 === a.enumEnvelope) {
    const s5 = t2, n7 = new n4();
    return s5.queryEnvelope(n7), n7.isDegenerate(m2) ? (r && (r.m_reason = 4, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const e5 = t2, o2 = new Na({ vd: e5.getDescription() });
    return o2.addSegment(e5, true), sh2(o2, s4, n6, r, i2);
  }
  const l2 = [0], u = t2.getImpl().getIsSimple(m2, l2);
  let c = n6 ? -1 : u;
  if (Ot2(c) || 0 === c) return c;
  const _ = new ph(t2, s4, c, i2, false);
  h2 === a.enumMultiPoint || h2 === a.enumPolyline || h2 === a.enumPolygon ? c = _.isSimplePlanarImpl() : b("");
  return t2.getImpl().setIsSimple(c, m2), r && r.assign(_.m_nonSimpleResult), c;
}
function th2(t2, s4, n6, r, i2) {
  if (r && (r.m_reason = 0, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), t2.isEmpty()) return 5;
  const h2 = t2.getGeometryType();
  if (h2 === a.enumPoint) return ih2(t2, r);
  const u = zt2(s4, t2, false).total();
  if (h2 === a.enumEnvelope) {
    const s5 = t2, n7 = new n4();
    return s5.queryEnvelope(n7), n7.isDegenerate(u) ? (r && (r.m_reason = 4, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const e5 = t2, o2 = new Na({ vd: e5.getDescription() });
    return o2.addSegment(e5, true), th2(o2, s4, n6, r, i2);
  }
  I(h2), y(h2) || z("OGC simplify is not implemented for this geometry type");
  const c = [0], _ = t2.getImpl().getIsSimple(u, c);
  let d2 = n6 ? -1 : _;
  if (5 === d2 || 0 === d2) return d2;
  const p3 = new ph(t2, s4, d2, i2, true);
  h2 === a.enumMultiPoint || h2 === a.enumPolyline || h2 === a.enumPolygon ? (d2 = p3.isSimplePlanarImpl(), Ot2(d2) && (d2 = 5)) : b("");
  return t2.getImpl().setIsSimple(d2, u), r && r.assign(p3.m_nonSimpleResult), d2;
}
function sh2(t2, s4, n6, r, i2) {
  if (r && (r.m_reason = 0, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), t2.isEmpty()) return 5;
  const h2 = t2.getGeometryType();
  if (h2 === a.enumPoint) return ih2(t2, r);
  const m2 = zt2(s4, t2, false).total();
  if (h2 === a.enumEnvelope) {
    const s5 = t2, n7 = n4.constructEmpty();
    return s5.queryEnvelope(n7), n7.isDegenerate(m2) ? (r && (r.m_reason = 4, r.m_vertexIndex1 = -1, r.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const e5 = t2, o2 = new Na({ vd: e5.getDescription() });
    return o2.addSegment(e5, true), sh2(o2, s4, n6, r, i2);
  }
  const l2 = [0], u = t2.getImpl().getIsSimple(m2, l2);
  let c = n6 ? -1 : u;
  if (-1 !== c) return c;
  const _ = new ph(t2, s4, c, i2, false);
  return h2 === a.enumMultiPoint ? c = _.multipointIsSimpleAsFeature() : h2 === a.enumPolyline ? c = _.polylineIsSimpleAsFeature() : h2 === a.enumPolygon ? c = _.polygonIsSimpleAsFeature() : b(""), t2.getImpl().setIsSimple(c, m2), r && r.assign(_.m_nonSimpleResult), c;
}
function nh(t2, s4, n6, r) {
  if (t2.isEmpty()) return t2;
  const i2 = t2.getGeometryType();
  if (i2 === a.enumPoint) {
    const e5 = new es2();
    if (ih2(t2, e5), 3 === e5.m_reason) {
      const e6 = t2.clone();
      return e6.replaceNaNs(1, 0), e6;
    }
    return 2 === e5.m_reason ? t2.createInstance() : t2;
  }
  if (i2 === a.enumEnvelope) {
    const n7 = zt2(s4, t2, true).total(), r2 = t2, i3 = n4.constructEmpty();
    return r2.queryEnvelope(i3), i3.isDegenerate(n7) ? r2.createInstance() : t2;
  }
  if (f(i2)) {
    const e5 = t2, i3 = new Na({ vd: e5.getDescription() });
    return i3.addSegment(e5, true), nh(i3, s4, n6, r);
  }
  I(i2);
  const h2 = zt2(s4, t2, false).total(), m2 = [0], l2 = t2.getImpl().getIsSimple(h2, m2), u = n6 ? -1 : l2;
  if (Ot2(u)) {
    if (i2 === a.enumPolygon && 0 !== t2.getFillRule()) {
      const e5 = t2.clone();
      return e5.setFillRule(0), e5;
    }
    return t2;
  }
  if ((i2 === a.enumMultiPoint || i2 === a.enumPolyline) && u >= 1) return t2;
  const c = new ph(t2, s4, u, r, false);
  let _;
  return i2 === a.enumMultiPoint ? _ = c.multipointSimplifyAsFeature() : i2 === a.enumPolyline ? _ = c.polylineSimplifyAsFeature() : i2 === a.enumPolygon ? _ = c.polygonSimplifyAsFeature() : b(""), _;
}
function rh(t2, s4, n6, r) {
  if (t2.isEmpty()) return t2;
  const i2 = t2.getGeometryType();
  if (i2 === a.enumPoint) {
    const e5 = new es2();
    if (ih2(t2, e5), 3 === e5.m_reason) {
      const e6 = t2.clone();
      return e6.replaceNaNs(1, 0), e6;
    }
    return 2 === e5.m_reason ? t2.createInstance() : t2;
  }
  if (i2 === a.enumEnvelope) {
    const n7 = t2, r2 = new n4();
    n7.queryEnvelope(r2);
    const i3 = zt2(s4, t2, true).total();
    return r2.isDegenerate(i3) ? n7.createInstance() : t2;
  }
  if (f(i2)) {
    const e5 = t2, i3 = new Na({ vd: e5.getDescription() });
    return i3.addSegment(e5, true), rh(i3, s4, n6, r);
  }
  I(i2), y(i2) || z("OGC simplify is not implemented for this geometry type");
  const h2 = zt2(s4, t2, false).total(), g2 = [0], u = t2.getImpl().getIsSimple(h2, g2), c = n6 ? -1 : u;
  if (5 === c) {
    if (i2 === a.enumPolygon && 0 !== t2.getFillRule()) {
      const e5 = t2.clone();
      return e5.setFillRule(0), e5;
    }
    return t2;
  }
  return Va2(t2, zt2(s4, t2, true), false, c, r, 0, true);
}
function ih2(e5, t2) {
  const s4 = e5.getX(), n6 = e5.getY();
  if (!Number.isFinite(s4) || !Number.isFinite(n6)) return t2 && (t2.m_reason = 2, t2.m_vertexIndex1 = -1, t2.m_vertexIndex2 = -1), 0;
  if (e5.hasAttribute(1)) {
    const s5 = e5.getZ();
    if (!Number.isFinite(s5)) return t2 && (t2.m_reason = Number.isNaN(s5) ? 3 : 2, t2.m_vertexIndex1 = -1, t2.m_vertexIndex2 = -1), 0;
  }
  return 5;
}
var oh2 = class {
  constructor() {
    this.m_segment = null, this.m_vertexIndex = -1, this.m_pathIndex = -1, this.m_flags = 0;
  }
  setReversed(e5) {
    this.m_flags &= -2, this.m_flags = this.m_flags | (e5 ? 1 : 0);
  }
  getReversed() {
    return !!(1 & this.m_flags);
  }
  getRightSide() {
    return this.getReversed() ? 0 : 1;
  }
};
function ah2() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, ipolygon: -1 };
}
function hh2(e5, t2, s4, n6, r) {
  return { x: e5, y: t2, ipath: s4, ivertex: n6, ipolygon: r };
}
function mh(e5, t2) {
  return e5.x === t2.x && e5.y === t2.y && e5.ipath === t2.ipath && e5.ivertex === t2.ivertex && e5.ipolygon === t2.ipolygon;
}
function lh(e5, t2) {
  e5.x = t2.x, e5.y = t2.y, e5.ipath = t2.ipath, e5.ivertex = t2.ivertex, e5.ipolygon = t2.ipolygon;
}
function gh() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, bBoundary: false, bEndPoint: false };
}
function uh(e5, t2, s4, n6, r, i2) {
  return { x: e5, y: t2, ipath: s4, ivertex: n6, bBoundary: r, bEndPoint: i2 };
}
function ch2(e5, t2) {
  e5.x = t2.x, e5.y = t2.y, e5.ipath = t2.ipath, e5.ivertex = t2.ivertex, e5.bBoundary = t2.bBoundary, e5.bEndPoint = t2.bEndPoint;
}
var _h = class extends dt {
  constructor(e5) {
    super(), this.m_helper = e5;
  }
  compare(e5, t2, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_xy.read(2 * t2) - this.m_helper.m_xy.read(2 * n6);
    return r < 0 ? -1 : r > 0 ? 1 : 0;
  }
};
var dh2 = class extends dt {
  constructor(e5) {
    super(), this.m_helper = e5;
  }
  compare(e5, t2, s4) {
    const n6 = e5.getElement(s4), r = this.m_helper.m_edges[t2], i2 = this.m_helper.m_edges[n6], o2 = r.getReversed(), a2 = i2.getReversed();
    let h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0), m2 = i2.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    if (h2 === m2) {
      const e6 = o2 ? r.m_segment.getStartY() : r.m_segment.getEndY(), t3 = a2 ? i2.m_segment.getStartY() : i2.m_segment.getEndY(), s5 = Math.min(e6, t3);
      let n7 = 0.5 * (s5 - this.m_helper.m_yScanline) + this.m_helper.m_yScanline;
      n7 === this.m_helper.m_yScanline && (n7 = s5), h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(n7, 0), m2 = i2.m_segment.intersectionOfYMonotonicWithAxisX(n7, 0);
    }
    return h2 < m2 ? -1 : h2 > m2 ? 1 : 0;
  }
};
var ph = class _ph {
  constructor(e5, t2, s4, n6, r) {
    this.m_multiVertexGeom = null, this.m_edges = [], this.m_freeEdges = [], this.m_lineEdgesRecycle = [], this.m_newEdges = [], this.m_recycledSegIter = null, this.m_crossOverHelperList = new pt2(), this.m_progressTracker = null, this.m_progressCounter = 0, this.m_AET = new ct2(), this.m_xyToNode1 = null, this.m_xyToNode2 = null, this.m_pathOrientations = null, this.m_pathParentage = null, this.m_xy = null, this.m_pairs = [], this.m_pairIndices = null, this.m_pathsForOGCTests = [], this.m_curveStitcher = null, this.m_editShape = null, this.m_multiPathStitcher = null, this.m_nonSimpleResult = new es2(), this.m_progressCounter = 0, this.m_progressTracker = n6, this.m_geometry = e5, this.m_knownSimpleResult = s4, this.m_sr = t2;
    const i2 = zt2(t2, e5, false);
    this.m_toleranceIsSimple = i2, this.m_toleranceIsSimpleClustering = Pt2(i2), this.m_toleranceIsSimpleCracking = Ft2(i2), this.m_toleranceSimplify = zt2(t2, e5, true), this.m_description = this.m_geometry.getDescription(), this.m_attributeCount = this.m_description.getAttributeCount(), this.m_bOGCRestrictions = r, this.m_bPlanarSimplify = this.m_bOGCRestrictions, this.m_unknownOrientationPathCount = -1, this.m_yScanline = 0, this.m_progressCounter = 0;
  }
  isSimplePlanarImpl() {
    if (this.m_bPlanarSimplify = true, !this.checkStructure()) return 0;
    const e5 = this.m_geometry.getGeometryType();
    return h(e5) && !this.checkDegenerateSegments(false) ? 0 : this._CheckClustering() ? h(e5) ? this._CheckCracking() ? this.m_geometry.getGeometryType() === a.enumPolyline ? this.checkSelfIntersectionsPolylinePlanar() ? 4 : 0 : this._CheckSelfIntersections() ? this._CheckValidRingOrientation() : 0 : 0 : 5 : 0;
  }
  isSimplePlanarImpl3D() {
    return n2(0), 7;
  }
  generateSortedPairs(e5) {
    let t2 = null;
    h(e5.getGeometryType()) && (t2 = e5);
    const s4 = (this.m_bPlanarSimplify || this.m_bOGCRestrictions) && null !== t2, n6 = e5.getPointCount();
    this.m_xy = e5.getAttributeStreamRef(0), this.m_pairs.length = 0, this.m_pairIndices = new st2(0), s4 && (this.m_pathsForOGCTests.length = 0);
    let r = 0;
    for (let a2 = 0; a2 < n6; a2++) if (this.m_pairs.push(2 * a2), this.m_pairs.push(2 * a2 + 1), this.m_pairIndices.add(2 * a2), this.m_pairIndices.add(2 * a2 + 1), s4) {
      for (; a2 >= t2.getPathEnd(r); ) r++;
      this.m_pathsForOGCTests.push(r);
    }
    const i2 = new ht(), o2 = { parent: this, workPt: new ei(), userSort(e6, t3, n7) {
      n7.sort(e6, t3, (e7, t4) => this.parent.compareVerticesForPlanarClustering(e7, t4, s4));
    }, getValue(e6) {
      const t3 = this.parent.m_pairs[e6], s5 = t3 >> 1;
      this.parent.m_xy.queryPoint2D(2 * s5, this.workPt);
      return this.workPt.y + (1 & t3 ? this.parent.m_toleranceIsSimpleClustering : -this.parent.m_toleranceIsSimpleClustering);
    } };
    i2.sort(this.m_pairIndices, 0, 2 * n6, o2);
  }
  _TestToleranceDistancePlanar(e5, t2) {
    const s4 = this.m_xy.read(2 * e5), n6 = this.m_xy.read(2 * e5 + 1), r = this.m_xy.read(2 * t2), i2 = this.m_xy.read(2 * t2 + 1);
    if (!!an2(s4, n6, r, i2, this.m_toleranceIsSimpleClustering * this.m_toleranceIsSimpleClustering)) {
      if (0 === this.m_geometry.getDimension()) return false;
      return s4 === r && n6 === i2;
    }
    return true;
  }
  checkStructure() {
    const e5 = this.m_geometry.getGeometryType();
    if (h(e5)) {
      const e6 = this.m_geometry.getImpl(), t2 = this.m_geometry.getGeometryType() === a.enumPolygon ? 3 : 2;
      for (let s4 = 0, n6 = e6.getPathCount(); s4 < n6; s4++) if (e6.getPathSize(s4) < t2) {
        if (e6.hasNonLinearSegments() && e6.hasNonLinearSegmentsPath(s4) && e6.getPathSize(s4) > 0) continue;
        return this.m_nonSimpleResult = new es2(1, s4, 0), false;
      }
    }
    if (y(e5)) {
      const e6 = this.m_geometry.getImpl(), t2 = e6.getAttributeStreamRef(0);
      for (let s4 = 0, n6 = e6.getPointCount(); s4 < n6; s4++) {
        if (!t2.readPoint2D(2 * s4).isFinite()) return this.m_nonSimpleResult = new es2(2, s4, 0), false;
      }
      if (this.m_geometry.hasAttribute(1)) {
        const t3 = e6.getAttributeStreamRef(1);
        for (let s4 = 0, n6 = e6.getPointCount(); s4 < n6; s4++) {
          const e7 = t3.read(s4);
          if (!Number.isFinite(e7)) return Number.isNaN(e7) ? this.m_nonSimpleResult = new es2(3, s4, 0) : this.m_nonSimpleResult = new es2(2, s4, 0), false;
        }
      }
    }
    return true;
  }
  checkDegenerateSegments(e5) {
    const t2 = this.m_geometry.getImpl(), s4 = t2.querySegmentIterator(), n6 = t2.hasAttribute(1), r = n6 ? qt2(this.m_sr, t2, false).total() : 0, i2 = t2.hasNonLinearSegments(), o2 = this.m_toleranceIsSimple.total();
    for (; s4.nextPath(); ) for (; s4.hasNextSegment(); ) {
      const t3 = s4.nextSegment();
      let a2 = t3.calculateLowerLength2D();
      if (!(a2 > o2) && !(i2 && t3.isCurve() && (a2 = t3.calculateLength2D(), a2 > o2))) {
        if (e5 && n6) {
          const e6 = t3.getStartAttributeAsDbl(1, 0), s5 = t3.getEndAttributeAsDbl(1, 0);
          if (Math.abs(s5 - e6) > r) continue;
        }
        return this.m_nonSimpleResult = new es2(4, s4.getStartPointIndex(), -1), false;
      }
    }
    return true;
  }
  checkDegenerateSegments3D() {
    return n2(0), false;
  }
  _CheckClustering() {
    const e5 = this.m_geometry.getImpl();
    this.generateSortedPairs(e5);
    const t2 = e5.getPointCount();
    this.m_AET.clear(), this.m_AET.setComparator(new _h(this)), this.m_AET.setCapacity(t2);
    for (let s4 = 0, n6 = 2 * t2; s4 < n6; s4++) {
      this.progress_();
      const e6 = this.m_pairIndices.read(s4), t3 = this.m_pairs[e6], n7 = t3 >> 1;
      if (1 & t3) {
        const e7 = this.m_AET.search(n7), t4 = this.m_AET.getPrev(e7), s5 = this.m_AET.getNext(e7);
        if (this.m_AET.deleteNode(e7), t4 !== ct2.st_nullNode() && s5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t4), this.m_AET.getElement(s5))) return this.m_nonSimpleResult = new es2(5, this.m_AET.getElement(t4), this.m_AET.getElement(s5)), false;
      } else {
        const e7 = this.m_AET.addElement(n7), t4 = this.m_AET.getPrev(e7);
        if (t4 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t4), n7)) return this.m_nonSimpleResult = new es2(5, n7, this.m_AET.getElement(t4)), false;
        const s5 = this.m_AET.getNext(e7);
        if (s5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(s5), n7)) return this.m_nonSimpleResult = new es2(5, n7, this.m_AET.getElement(s5)), false;
      }
    }
    return true;
  }
  _CheckCracking() {
    const e5 = this.m_geometry.getImpl(), t2 = e5.getPointCount();
    return !e5.hasNonLinearSegments() && t2 < 10 ? this._CheckCrackingBrute() : this._CheckCrackingPlanesweep();
  }
  _CheckCrackingPlanesweep() {
    if (this.m_editShape = new Tm(), this.m_editShape.addGeometry(this.m_geometry), this.m_editShape.hasCurves()) {
      this.m_curveStitcher = new ca2();
      const t3 = n4.constructEmpty();
      this.m_geometry.queryEnvelope(t3);
      const s4 = la2(this.m_toleranceSimplify.total(), t3), n6 = new es2();
      if (aa2(this.m_editShape, s4, this.m_toleranceSimplify.total(), 12e3, n6, this.m_curveStitcher, null, this.m_progressTracker), 0 !== n6.m_reason) return this.m_editShape = null, this.m_nonSimpleResult.assign(n6), false;
    }
    const t2 = new es2();
    return Hn2(false, this.m_editShape, this.m_toleranceIsSimpleCracking, t2, this.m_progressTracker) ? (null != this.m_curveStitcher ? (t2.m_vertexIndex1 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, t2.m_vertexIndex1), t2.m_vertexIndex2 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, t2.m_vertexIndex2), this.m_curveStitcher = null) : (t2.m_vertexIndex1 = this.m_editShape.getVertexIndex(t2.m_vertexIndex1), t2.m_vertexIndex2 = this.m_editShape.getVertexIndex(t2.m_vertexIndex2)), this.m_editShape = null, this.m_nonSimpleResult.assign(t2), false) : (null == this.m_curveStitcher && (this.m_editShape = null), true);
  }
  _CheckCrackingBrute() {
    const e5 = this.m_geometry.getImpl(), t2 = e5.querySegmentIterator(), s4 = e5.querySegmentIterator();
    for (; t2.nextPath(); ) for (; t2.hasNextSegment(); ) {
      const e6 = t2.nextSegment();
      if (!t2.isLastSegmentInPath() || !t2.isLastPath()) {
        s4.resetTo(t2);
        do {
          for (; s4.hasNextSegment(); ) {
            const n6 = s4.nextSegment(), r = jm(true, e6, n6, this.m_toleranceIsSimpleCracking, true);
            if (r) {
              const e7 = 2 === r ? 7 : 6;
              return this.m_nonSimpleResult = new es2(e7, t2.getStartPointIndex(), s4.getStartPointIndex()), false;
            }
          }
        } while (s4.nextPath());
      }
    }
    return true;
  }
  _CheckSelfIntersections() {
    let e5 = this.m_geometry.getImpl();
    null !== this.m_curveStitcher && (this.m_multiPathStitcher = this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()), e5 = this.m_multiPathStitcher.getImpl(), this.generateSortedPairs(e5)), this.m_edges.length = 0, this.m_lineEdgesRecycle.length = 0, this.m_recycledSegIter = e5.querySegmentIterator(), this.m_recycledSegIter.setCirculator(true);
    const t2 = [], s4 = e5.getPointCount();
    let n6 = Number.NaN, r = 0;
    for (let i2 = 0, o2 = 2 * s4; i2 < o2; i2++) {
      this.progress_();
      const e6 = this.m_pairIndices.read(i2), s5 = this.m_pairs[e6];
      if (1 & s5) continue;
      const o3 = s5 >> 1, a2 = this.m_xy.read(2 * o3), h2 = this.m_xy.read(2 * o3 + 1);
      if (t2.length && (a2 !== n6 || h2 !== r)) {
        if (!this.processBunchForSelfIntersectionTest(t2)) return false;
        t2.length = 0;
      }
      t2.push(o3), n6 = a2, r = h2;
    }
    return !!this.processBunchForSelfIntersectionTest(t2);
  }
  checkSelfIntersectionsPolylinePlanar() {
    const e5 = this.m_geometry.getImpl(), t2 = [];
    for (let o2 = 0, a2 = e5.getPathCount(); o2 < a2; o2++) t2.push(e5.isClosedPathInXYPlane(o2));
    const s4 = gh();
    let n6, r, i2;
    {
      const o2 = this.m_pairIndices.read(0), a2 = this.m_pairs[o2] >> 1, h2 = this.m_xy.readPoint2D(2 * a2), m2 = this.m_pathsForOGCTests[a2];
      n6 = t2[m2], r = e5.getPathStart(m2), i2 = e5.getPathEnd(m2) - 1, s4.bEndPoint = a2 === r || a2 === i2, this.m_bOGCRestrictions ? s4.bBoundary = !n6 && s4.bEndPoint : s4.bBoundary = s4.bEndPoint, s4.ipath = m2, s4.x = h2.x, s4.y = h2.y, s4.ivertex = a2;
    }
    for (let o2 = 1, a2 = this.m_pairIndices.size(); o2 < a2; o2++) {
      const a3 = this.m_pairIndices.read(o2), h2 = this.m_pairs[a3];
      if (1 & h2) continue;
      const m2 = h2 >> 1, l2 = this.m_xy.readPoint2D(2 * m2), g2 = this.m_pathsForOGCTests[m2];
      let u;
      g2 !== s4.ipath && (n6 = t2[g2], r = e5.getPathStart(g2), i2 = e5.getPathEnd(g2) - 1);
      const c = m2 === r || m2 === i2;
      u = this.m_bOGCRestrictions ? !n6 && c : c;
      const _ = uh(l2.x, l2.y, g2, m2, u, c);
      if (_.x === s4.x && _.y === s4.y) {
        if (this.m_bOGCRestrictions) {
          if (!(_.bBoundary && s4.bBoundary || _.ipath === s4.ipath && _.bEndPoint && s4.bEndPoint)) return this.m_nonSimpleResult = new es2(10, _.ivertex, s4.ivertex), false;
        } else if (!_.bEndPoint || !s4.bEndPoint) return this.m_nonSimpleResult = new es2(7, _.ivertex, s4.ivertex), false;
      }
      ch2(s4, _);
    }
    return true;
  }
  checkSelfIntersectionsPolylinePlanar3D(e5) {
    return n2(0), false;
  }
  checkSelfIntersectionsPolygonsOGC() {
    const e5 = this.m_geometry.getImpl(), t2 = [];
    let s4 = -1, n6 = false;
    for (let l2 = 0, g2 = e5.getPathCount(); l2 < g2; l2++) e5.isExteriorRingOGC(l2) && (n6 = false, s4++, l2 < g2 - 1 && (e5.isExteriorRingOGC(l2 + 1) || (n6 = true))), t2.push(n6 ? s4 : -1);
    const r = ah2();
    {
      const e6 = this.m_pairIndices.read(0), s5 = this.m_pairs[e6] >> 1, n7 = this.m_xy.readPoint2D(2 * s5), i3 = this.m_pathsForOGCTests[s5];
      r.ipath = i3, r.x = n7.x, r.y = n7.y, r.ivertex = s5, r.ipolygon = t2[i3];
    }
    const i2 = [];
    for (let l2 = 1, g2 = this.m_pairIndices.size(); l2 < g2; l2++) {
      const e6 = this.m_pairIndices.read(l2), s5 = this.m_pairs[e6];
      if (1 & s5) continue;
      const n7 = s5 >> 1, o3 = this.m_xy.readPoint2D(2 * n7), a3 = this.m_pathsForOGCTests[n7], h3 = hh2(o3.x, o3.y, a3, n7, t2[a3]);
      if (h3.x === r.x && h3.y === r.y) {
        if (h3.ipath === r.ipath) return this.m_nonSimpleResult = new es2(11, h3.ivertex, r.ivertex), false;
        t2[h3.ipath] >= 0 && t2[h3.ipath] === t2[r.ipath] && (0 !== i2.length && mh(i2.at(-1), r) || i2.push({ ...r }), i2.push(h3));
      }
      lh(r, h3);
    }
    if (0 === i2.length) return true;
    const o2 = new pt2(true);
    t2.fill(-1);
    let a2 = -1;
    const h2 = new ei();
    for (let l2 = 0, g2 = i2.length; l2 < g2; l2++) {
      const e6 = i2[l2];
      e6.x === h2.x && e6.y === h2.y || (a2 = o2.createList(0), h2.x = e6.x, h2.y = e6.y);
      let s5 = t2[e6.ipath];
      -1 === s5 && (s5 = o2.createList(2), t2[e6.ipath] = s5), o2.addElement(s5, a2), o2.addElement(a2, s5);
    }
    const m2 = [];
    for (let l2 = o2.getFirstList(); -1 !== l2; l2 = o2.getNextList(l2)) {
      const e6 = o2.getListData(l2);
      if (1 & e6 || !(2 & e6)) continue;
      let s5 = -1;
      for (m2.push(l2), m2.push(-1); m2.length; ) {
        const e7 = m2.at(-1);
        m2.pop();
        const t3 = m2.at(-1);
        m2.pop();
        const n7 = o2.getListData(t3);
        if (1 & n7) {
          s5 = 2 & n7 ? t3 : e7;
          break;
        }
        o2.setListData(t3, 1 | n7);
        for (let s6 = o2.getFirst(t3); -1 !== s6; s6 = o2.getNext(s6)) {
          const n8 = o2.getData(s6);
          n8 !== e7 && (m2.push(n8), m2.push(t3));
        }
      }
      if (-1 !== s5) {
        const e7 = t2.indexOf(s5);
        return this.m_nonSimpleResult = new es2(12, e7, -1), false;
      }
    }
    return true;
  }
  _CheckValidRingOrientation() {
    const e5 = null !== this.m_multiPathStitcher ? this.m_multiPathStitcher.getImpl() : this.m_geometry.getImpl();
    if (e5.calculateArea2D() <= 0) return this.m_nonSimpleResult = new es2(8, 1 === e5.getPathCount() ? 1 : -1, -1), 0;
    if (1 === e5.getPathCount()) return this.m_bOGCRestrictions && !this.checkSelfIntersectionsPolygonsOGC() ? 0 : 4;
    this.m_pathOrientations = new et(e5.getPathCount(), 0), this.m_pathParentage = new st2(e5.getPathCount(), -1);
    let t2 = -1, s4 = 0;
    for (let i2 = 0, o2 = e5.getPathCount(); i2 < o2; i2++) {
      const n7 = e5.calculateRingArea2D(i2);
      if (this.m_pathOrientations.write(i2, n7 < 0 ? 0 : 8), n7 > 0) t2 = i2, s4 = n7;
      else {
        if (0 === n7) return this.m_nonSimpleResult = new es2(8, i2, -1), 0;
        if ((t2 < 0 || s4 < Math.abs(n7)) && (this.m_nonSimpleResult = new es2(9, i2, -1), this.m_bOGCRestrictions)) return 0;
        this.m_pathParentage.write(i2, t2);
      }
    }
    this.m_unknownOrientationPathCount = e5.getPathCount(), this.m_newEdges.length = 0;
    const n6 = e5.getPointCount();
    this.m_yScanline = Number.NaN;
    const r = [];
    this.m_xyToNode1 = new st2(n6, ct2.st_nullNode()), this.m_xyToNode2 = new st2(n6, ct2.st_nullNode()), this.m_freeEdges.length = 0, this.m_AET.clear(), this.m_AET.setComparator(new dh2(this));
    for (let i2 = 0, o2 = 2 * n6; this.m_unknownOrientationPathCount > 0 && i2 < o2; i2++) {
      const e6 = this.m_pairIndices.read(i2), t3 = this.m_pairs[e6];
      if (1 & t3) continue;
      const s5 = t3 >> 1, n7 = this.m_xy.read(2 * s5 + 1);
      if (n7 !== this.m_yScanline && r.length) {
        if (!this.processBunchForRingOrientationTest(r)) return 0;
        r.length = 0;
      }
      r.push(s5), this.m_yScanline = n7;
    }
    return this.m_unknownOrientationPathCount > 0 && !this.processBunchForRingOrientationTest(r) ? 0 : this.m_bOGCRestrictions ? 0 !== this.m_nonSimpleResult.m_reason ? 0 : this.checkSelfIntersectionsPolygonsOGC() ? 5 : 0 : 0 === this.m_nonSimpleResult.m_reason ? 4 : 3;
  }
  processBunchForSelfIntersectionTest(e5) {
    if (1 === e5.length) return true;
    for (let o2 = 0, a2 = e5.length; o2 < a2; o2++) {
      const t3 = e5[o2];
      this.m_recycledSegIter.resetToVertex(t3, -1);
      const s5 = this.m_recycledSegIter.previousSegment();
      this.m_edges.push(this.createEdge(s5, t3, this.m_recycledSegIter.getPathIndex(), true)), this.m_recycledSegIter.nextSegment();
      const n7 = this.m_recycledSegIter.nextSegment();
      this.m_edges.push(this.createEdge(n7, t3, this.m_recycledSegIter.getPathIndex(), false));
    }
    this.m_edges.sort((e6, t3) => this.edgeAngleCompare(e6, t3));
    let t2 = this.m_crossOverHelperList.getFirstList();
    -1 === t2 && (t2 = this.m_crossOverHelperList.createList(0)), this.m_crossOverHelperList.reserveNodes(this.m_edges.length);
    for (let o2 = 0, a2 = this.m_edges.length; o2 < a2; o2++) this.m_crossOverHelperList.addElement(t2, o2);
    let s4 = true, n6 = -1, r = -1;
    for (; s4; ) {
      s4 = false;
      let e6 = this.m_crossOverHelperList.getFirst(t2);
      if (-1 === e6) break;
      let i3 = this.m_crossOverHelperList.getNext(e6);
      for (; -1 !== i3; ) {
        const o2 = this.m_crossOverHelperList.getData(e6), a2 = this.m_crossOverHelperList.getData(i3);
        if (n6 = this.m_edges[o2].m_vertexIndex, r = this.m_edges[a2].m_vertexIndex, n6 !== r) e6 = i3, i3 = this.m_crossOverHelperList.getNext(e6);
        else if (s4 = true, this.m_crossOverHelperList.deleteElement(t2, e6), e6 = this.m_crossOverHelperList.getPrev(i3), i3 = this.m_crossOverHelperList.deleteElement(t2, i3), -1 === i3 || -1 === e6) break;
      }
    }
    const i2 = this.m_crossOverHelperList.getListSize(t2);
    if (this.m_crossOverHelperList.clear(t2), i2 > 0) return this.m_nonSimpleResult = new es2(7, n6, r), false;
    for (let o2 = 0, a2 = e5.length; o2 < a2; o2++) this.recycleEdge(this.m_edges[o2]);
    return this.m_edges.length = 0, true;
  }
  processBunchForRingOrientationTest(e5) {
    for (let t2 = 0, s4 = e5.length; t2 < s4; t2++) {
      const s5 = e5[t2];
      let n6 = this.m_xyToNode1.read(s5);
      if (n6 !== ct2.st_nullNode()) {
        const e6 = this.m_AET.getElement(n6);
        this.m_freeEdges.push(e6), this.m_AET.deleteNode(n6), this.recycleEdge(this.m_edges[e6]), this.m_edges[e6] = null, this.m_xyToNode1.write(s5, ct2.st_nullNode());
      }
      if (n6 = this.m_xyToNode2.read(s5), n6 !== ct2.st_nullNode()) {
        const e6 = this.m_AET.getElement(n6);
        this.m_freeEdges.push(e6), this.m_AET.deleteNode(n6), this.recycleEdge(this.m_edges[e6]), this.m_edges[e6] = null, this.m_xyToNode2.write(s5, ct2.st_nullNode());
      }
    }
    for (let t2 = 0, s4 = e5.length; t2 < s4; t2++) {
      const s5 = e5[t2];
      this.m_recycledSegIter.resetToVertex(s5, -1);
      const n6 = this.m_recycledSegIter.previousSegment();
      if (n6.getStartY() > n6.getEndY()) {
        const e6 = this.m_recycledSegIter.getStartPointIndex(), t3 = this.createEdge(n6, s5, this.m_recycledSegIter.getPathIndex(), true);
        let r2;
        this.m_freeEdges.length > 0 ? (r2 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[r2] = t3) : (r2 = this.m_edges.length, this.m_edges.push(t3));
        const i2 = this.m_AET.addElement(r2);
        this.m_xyToNode1.read(e6) === ct2.st_nullNode() ? this.m_xyToNode1.write(e6, i2) : this.m_xyToNode2.write(e6, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
      this.m_recycledSegIter.nextSegment();
      const r = this.m_recycledSegIter.nextSegment();
      if (r.getStartY() < r.getEndY()) {
        const e6 = this.m_recycledSegIter.getEndPointIndex(), t3 = this.createEdge(r, s5, this.m_recycledSegIter.getPathIndex(), false);
        let n7;
        this.m_freeEdges.length > 0 ? (n7 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[n7] = t3) : (n7 = this.m_edges.length, this.m_edges.push(t3));
        const i2 = this.m_AET.addElement(n7);
        this.m_xyToNode1.read(e6) === ct2.st_nullNode() ? this.m_xyToNode1.write(e6, i2) : this.m_xyToNode2.write(e6, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
    }
    for (let t2 = 0, s4 = this.m_newEdges.length; t2 < s4 && this.m_unknownOrientationPathCount > 0; t2++) {
      const e6 = this.m_newEdges[t2], s5 = this.m_AET.getElement(e6), n6 = this.m_edges[s5].m_pathIndex;
      if (!(3 & this.m_pathOrientations.read(n6))) {
        let t3 = -1, s6 = this.m_AET.getPrev(e6), n7 = e6, r = 0;
        {
          let e7 = -1, i2 = null, o2 = -1, a2 = 0;
          for (; s6 !== ct2.st_nullNode() && (e7 = this.m_AET.getElement(s6), i2 = this.m_edges[e7], o2 = i2.m_pathIndex, a2 = this.m_pathOrientations.read(o2), !(3 & a2)); ) n7 = s6, s6 = this.m_AET.getPrev(s6);
          s6 === ct2.st_nullNode() ? (r = 1, s6 = n7) : (t3 = 1 == (3 & a2) ? o2 : this.m_pathParentage.read(o2), r = i2.getRightSide() ? 0 : 1, s6 = this.m_AET.getNext(s6));
        }
        do {
          const e7 = this.m_AET.getElement(s6), i2 = this.m_edges[e7], o2 = i2.m_pathIndex;
          let a2 = this.m_pathOrientations.read(o2);
          if (!(3 & a2)) {
            if (r !== i2.getRightSide()) return this.m_nonSimpleResult = new es2(8, o2, -1), false;
            const e8 = r && !i2.getReversed() ? 1 : 2;
            if (a2 = -4 & a2 | e8, this.m_pathOrientations.write(o2, a2), 2 === e8 && 0 === this.m_nonSimpleResult.m_reason) {
              const e9 = this.m_pathParentage.read(o2);
              if (e9 !== t3 && (this.m_nonSimpleResult = new es2(9, o2, e9), this.m_bOGCRestrictions)) return false;
            }
            if (this.m_unknownOrientationPathCount--, !this.m_unknownOrientationPathCount) return true;
          }
          t3 = 1 == (3 & a2) ? o2 : this.m_pathParentage.read(o2), n7 = s6, s6 = this.m_AET.getNext(s6), r = r ? 0 : 1;
        } while (n7 !== e6);
      }
    }
    return this.m_newEdges.length = 0, true;
  }
  createEdge(e5, t2, s4, n6) {
    let r;
    return e5.getGeometryType() === a.enumLine ? r = this.createEdgeLine(e5) : (r = new oh2(), r.m_segment = e5.clone()), r.m_vertexIndex = t2, r.m_pathIndex = s4, r.m_flags = 0, r.setReversed(n6), r;
  }
  createEdgeLine(e5) {
    let t2;
    return this.m_lineEdgesRecycle.length > 0 ? (t2 = this.m_lineEdgesRecycle.at(-1), this.m_lineEdgesRecycle.pop(), e5.copyTo(t2.m_segment)) : (t2 = new oh2(), t2.m_segment = e5.clone()), t2;
  }
  recycleEdge(e5) {
    e5.m_segment.getGeometryType() === a.enumLine && this.m_lineEdgesRecycle.push(e5);
  }
  static isShortSegment(e5, t2, s4, n6) {
    let r = e5.calculateLowerLength2D();
    if (r <= s4) {
      let i2 = true;
      if (e5.isCurve() && (r = e5.calculateLength2D(), i2 = r <= s4), i2) {
        if (t2) {
          let t3 = e5.getEndAttributeAsDbl(1, 0);
          Number.isNaN(t3) && (t3 = 0);
          let s5 = e5.getStartAttributeAsDbl(1, 0);
          return Number.isNaN(s5) && (s5 = 0), Math.abs(s5 - t3) <= n6;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  static isShortSegmentPoints(e5, t2, s4, n6, r) {
    if (s4) {
      const s5 = e5.getXYZ(), i2 = t2.getXYZ();
      return Mt2(s5, i2, n6, r);
    }
    {
      const s5 = e5.getXY(), r2 = t2.getXY();
      return ei.sqrDistance(s5, r2) <= n6 * n6;
    }
  }
  removeDegenerateSegmentsFromCurvedPath(e5, t2, n6, r) {
    const i2 = e5.hasAttribute(1), o2 = e5.querySegmentIterator();
    o2.resetToPath(t2), n2(o2.nextPath());
    const a2 = this.m_toleranceSimplify.total();
    let h2 = false, m2 = true;
    const l2 = new ee(), g2 = new ee(), u = new ei();
    for (; o2.hasNextSegment(); ) {
      this.progress_();
      const e6 = o2.nextSegment();
      if (_ph.isShortSegment(e6, i2, a2, n6)) if (h2) {
        if (e6.queryEnd(g2), _ph.isShortSegmentPoints(l2, g2, i2, a2, n6)) continue;
        m2 && (r.startPathPoint(l2), m2 = false), e6.queryEnd(l2), r.lineToPoint(l2), h2 = false;
      } else u.assign(e6.getStartXY()), e6.queryStart(l2), h2 = true;
      else if (h2) if (e6.isCurve()) {
        const t3 = e6.clone();
        if (t3.setCoordsForIntersector(u, e6.getEndXY(), false), t3.setStart(l2), _ph.isShortSegment(t3, i2, a2, n6)) continue;
        r.addSegment(t3, m2), m2 = false, h2 = false;
      } else {
        if (e6.queryEnd(g2), _ph.isShortSegmentPoints(l2, g2, i2, a2, n6)) continue;
        m2 && (r.startPathPoint(l2), m2 = false), r.lineToPoint(g2), h2 = false;
      }
      else r.addSegment(e6, m2), m2 = false;
    }
    if (m2) return;
    if (!h2) return;
    e5.isClosedPath(t2) ? e5.getPointByVal(e5.getPathStart(t2), l2) : e5.getPointByVal(e5.getPathEnd(t2) - 1, l2);
    const c = r.querySegmentIterator();
    c.resetToLastPath(), c.resetToLastSegment();
    const _ = r.getDescription().getAttributeCount() > 1;
    for (n2(c.previousPath()); c.hasPreviousSegment(); ) {
      const e6 = c.previousSegment();
      if (e6.isCurve()) {
        const t3 = e6.clone();
        if (t3.setCoordsForIntersector(e6.getStartXY(), l2.getXY(), false), !_ph.isShortSegment(t3, i2, a2, n6)) {
          _ && t3.setEnd(l2);
          const e7 = c.getEndPointIndex();
          for (let t4 = r.getPointCount() - 1; t4 >= e7; t4--) r.removePoint(t4);
          return void r.addSegment(t3, false);
        }
      } else if (e6.queryStart(g2), !_ph.isShortSegmentPoints(g2, l2, i2, a2, n6)) {
        const e7 = c.getEndPointIndex();
        for (let t3 = r.getPointCount() - 1; t3 >= e7; t3--) r.removePoint(t3);
        return void r.lineToPoint(l2);
      }
    }
    r.removePath(r.getPathCount() - 1);
  }
  multipointIsSimpleAsFeature() {
    if (!this.checkStructure()) return 0;
    const e5 = this.m_geometry.getImpl();
    this.m_multiVertexGeom = e5;
    const t2 = e5.getPointCount(), s4 = Lt(t2, 0);
    for (let n6 = 0; n6 < t2; n6++) s4[n6] = n6;
    s4.sort((e6, t3) => this.compareVerticesMultiPoint(e6, t3));
    for (let n6 = 1; n6 < t2; n6++) if (0 === this.compareVerticesMultiPoint(s4[n6 - 1], s4[n6])) return this.m_nonSimpleResult = new es2(5, s4[n6 - 1], s4[n6]), 0;
    return 1;
  }
  polylineIsSimpleAsFeature() {
    return this.checkStructure() && this.checkDegenerateSegments(true) ? 1 : 0;
  }
  polygonIsSimpleAsFeature() {
    return this.isSimplePlanarImpl();
  }
  multipointSimplifyAsFeature() {
    let e5 = this.m_geometry.getImpl();
    const t2 = _ph.hasNanZs(e5);
    let s4, n6 = this.m_geometry;
    t2 && (s4 = this.m_geometry.clone(), e5 = s4.getImpl(), s4.replaceNaNs(1, B3.getDefaultValue(1)), n6 = s4), this.m_multiVertexGeom = e5;
    const r = e5.getPointCount(), i2 = Lt(r, 0);
    for (let g2 = 0; g2 < r; g2++) i2[g2] = g2;
    i2.sort((e6, t3) => this.compareVerticesMultiPoint(e6, t3));
    const o2 = new Array(r);
    o2.fill(false);
    let a2 = -1;
    for (let g2 = 0; g2 < r; g2++) {
      const t3 = i2[g2];
      e5.getXY(t3).isFinite() && ((a2 < 0 || 0 !== this.compareVerticesMultiPoint(a2, t3)) && (o2[t3] = true), a2 = t3);
    }
    const h2 = this.m_geometry.createInstance();
    let m2 = 0, l2 = 0;
    for (let g2 = 0; g2 < r; g2++) o2[g2] ? l2 = g2 + 1 : (m2 < l2 && h2.addPoints(n6, m2, l2), m2 = g2 + 1);
    return m2 < l2 && h2.addPoints(n6, m2, l2), h2.getImpl().setIsSimple(1, this.m_toleranceSimplify.total()), h2;
  }
  polylineSimplifyAsFeature() {
    const e5 = this.m_geometry.getImpl(), t2 = e5.querySegmentIterator(), s4 = e5.querySegmentIterator(), n6 = this.m_geometry.createInstance(), r = this.m_geometry, i2 = e5.hasAttribute(1), o2 = i2 ? qt2(this.m_sr, e5, true).total() : 0, a2 = [], h2 = [];
    let m2 = null;
    i2 && (m2 = e5.getAttributeStreamRef(1));
    const l2 = new ee(), g2 = e5.hasNonLinearSegments(), u = this.m_toleranceSimplify.total();
    for (; t2.nextPath(); ) {
      if (s4.nextPath(), e5.getPathSize(t2.getPathIndex()) < 2) continue;
      if (g2 && e5.hasNonLinearSegmentsPath(t2.getPathIndex())) {
        this.removeDegenerateSegmentsFromCurvedPath(e5, t2.getPathIndex(), o2, n6);
        continue;
      }
      s4.resetToLastSegment();
      let c = 0, _ = 0, d2 = true, p3 = true;
      for (; t2.hasNextSegment(); ) {
        this.progress_();
        const n7 = t2.nextSegment(), r2 = s4.previousSegment();
        if (t2.getStartPointIndex() > s4.getStartPointIndex()) break;
        if (d2) {
          const s5 = t2.getStartPointIndex();
          e5.getXY(s5).isNAN() || (d2 = false, a2.push(s5));
        }
        if (p3) {
          const t3 = s4.getEndPointIndex();
          e5.getXY(t3).isNAN() || (h2.push(t3), p3 = false);
        }
        if (!d2) {
          const s5 = a2.at(-1), r3 = t2.getEndPointIndex();
          if (r3 - s5 > 1) {
            const t3 = new ei();
            t3.setSub(e5.getXY(s5), e5.getXY(r3)), c = t3.length();
          } else c = n7.calculateLength2D();
          if (c > u) a2.push(r3), c = 0;
          else if (i2) {
            let e6 = m2.read(s5);
            Number.isNaN(e6) && (e6 = 0);
            let t3 = m2.read(r3);
            Number.isNaN(t3) && (t3 = 0), Math.abs(t3 - e6) > o2 && (a2.push(r3), c = 0);
          }
        }
        if (!p3) {
          const t3 = h2.at(-1), n8 = s4.getStartPointIndex();
          if (n8 - t3 > 1) {
            const s5 = new ei();
            s5.setSub(e5.getXY(t3), e5.getXY(n8)), _ = s5.length();
          } else _ = r2.calculateLength2D();
          if (_ > u) h2.push(n8), _ = 0;
          else if (i2) {
            let e6 = m2.read(t3);
            Number.isNaN(e6) && (e6 = 0);
            let s5 = m2.read(n8);
            Number.isNaN(s5) && (s5 = 0), Math.abs(s5 - e6) > o2 && (h2.push(n8), _ = 0);
          }
        }
      }
      if (a2.length > 0 && h2.length > 0 && (a2.at(-1) < h2.at(-1) ? a2.length > h2.length ? a2.pop() : h2.pop() : (a2.at(-1) === h2.at(-1) || h2.pop(), h2.pop())), h2.length + a2.length >= 2) {
        let e6 = false;
        for (let t3 = 0, s5 = a2.length; t3 < s5; t3++) r.getPointByVal(a2[t3], l2), e6 ? n6.lineToPoint(l2) : (n6.startPathPoint(l2), e6 = true);
        for (let t3 = h2.length - 1; t3 > 0; t3--) r.getPointByVal(h2[t3], l2), e6 ? n6.lineToPoint(l2) : (n6.startPathPoint(l2), e6 = true);
        r.isClosedPath(t2.getPathIndex()) ? n6.closePathWithLine() : h2.length > 0 && (r.getPointByVal(h2[0], l2), n6.lineToPoint(l2));
      }
      a2.length = 0, h2.length = 0;
    }
    return i2 && n6.replaceNaNs(1, 0), n6.getImpl().setIsSimple(1, u), n6;
  }
  polygonSimplifyAsFeature() {
    return this.simplifyPlanar();
  }
  simplifyPlanar() {
    if (1 === this.m_geometry.getFillRule() && !Ht(this.m_knownSimpleResult)) return Fa2(this.m_geometry, this.m_toleranceSimplify, true, false, this.m_knownSimpleResult, this.m_progressTracker, 0, true);
    const t2 = new Tm();
    if (t2.addGeometry(this.m_geometry), this.m_geometry.hasAttribute(1) && t2.replaceNaNs(1, 0), t2.removeNaNVertices(), 0 !== t2.getTotalPointCount()) {
      let s5 = null, n6 = 0, r = 0;
      if (t2.hasCurves()) {
        s5 = new ca2();
        const i2 = n4.constructEmpty();
        this.m_geometry.queryEnvelope(i2);
        const o2 = la2(this.m_toleranceSimplify.total(), i2);
        n6 = ga2(this.m_toleranceSimplify.total()), r = ua2(o2, n6), ra2(t2, o2, this.m_toleranceSimplify.total(), 12e3, s5, null, this.m_progressTracker);
      }
      if (!Ht(this.m_knownSimpleResult)) {
        da2(t2, this.m_toleranceSimplify.add(r), this.m_progressTracker, true, false);
      }
      this.m_geometry.getGeometryType() === a.enumPolygon && Qn2(t2, t2.getFirstGeometry(), this.m_knownSimpleResult, false, -1, this.m_progressTracker), null !== s5 && s5.stitchCurves(t2, t2.getFirstGeometry(), n6, true);
    }
    const s4 = t2.getGeometry(t2.getFirstGeometry());
    return s4.getGeometryType() === a.enumPolygon && (s4.getImpl().updateOGCFlagsProtected(), s4.setFillRule(0)), s4.getImpl().setIsSimple(4, this.m_toleranceSimplify.total()), s4;
  }
  progress_() {
  }
  static hasNanZs(e5) {
    if (e5.hasAttribute(1)) {
      const t2 = e5.getAttributeStreamRef(1);
      for (let s4 = 0, n6 = e5.getPointCount(); s4 < n6; s4++) {
        const e6 = t2.read(s4);
        if (Number.isNaN(e6)) return true;
      }
    }
    return false;
  }
  compareVerticesForPlanarClustering(e5, t2, s4) {
    if (e5 === t2) return 0;
    const n6 = this.m_pairs[e5], r = this.m_pairs[t2], i2 = n6 >> 1, o2 = r >> 1, a2 = this.m_xy.readPoint2D(2 * i2);
    a2.y += 1 & n6 ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const h2 = this.m_xy.readPoint2D(2 * o2);
    h2.y += 1 & r ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const m2 = a2.compare(h2);
    if (0 === m2 && s4) {
      const e6 = this.m_pathsForOGCTests[i2] - this.m_pathsForOGCTests[o2];
      return X(e6);
    }
    return m2;
  }
  compareVerticesMultiPoint(e5, t2) {
    if (e5 === t2) return 0;
    const s4 = this.m_multiVertexGeom.getXY(e5), n6 = this.m_multiVertexGeom.getXY(t2), r = !s4.isFinite(), i2 = !n6.isFinite();
    if (r || i2) return r < i2 ? -1 : r > i2 ? 1 : 0;
    if (s4.y < n6.y) return -1;
    if (s4.y > n6.y) return 1;
    if (s4.x < n6.x) return -1;
    if (s4.x > n6.x) return 1;
    for (let o2 = 1; o2 < this.m_attributeCount; o2++) {
      const s5 = this.m_description.getSemantics(o2), n7 = B3.getComponentCount(s5);
      for (let r2 = 0; r2 < n7; r2++) {
        const n8 = this.m_multiVertexGeom.getAttributeAsDbl(s5, e5, r2), i3 = this.m_multiVertexGeom.getAttributeAsDbl(s5, t2, r2), o3 = as(n8, i3);
        if (0 !== o3) return o3;
      }
    }
    return 0;
  }
  edgeAngleCompare(e5, t2) {
    if (e5 === t2) return 0;
    const s4 = e5.m_segment.getTangent(e5.getReversed() ? 1 : 0);
    e5.getReversed() && s4.negateThis();
    const n6 = t2.m_segment.getTangent(t2.getReversed() ? 1 : 0);
    t2.getReversed() && n6.negateThis();
    const r = s4.getQuarter(), i2 = n6.getQuarter();
    if (i2 === r) {
      const e6 = s4.crossProduct(n6);
      return e6 < 0 ? 1 : e6 > 0 ? -1 : 0;
    }
    return r < i2 ? -1 : 1;
  }
};
var fh2 = class {
  getOperatorType() {
    return 10103;
  }
  accelerateGeometry(e5, t2, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  isSimpleAsFeature(e5, t2, s4, n6, r) {
    const i2 = sh2(e5, t2, s4, n6, r);
    return Yt2(e5.getGeometryType(), i2);
  }
  isSimplePlanarDONOTUSE(e5, t2, s4, n6, r) {
    const i2 = eh2(e5, t2, s4, n6, r);
    return Ot2(i2);
  }
  executeMany(e5, t2, s4, n6) {
    return new xh2(e5, t2, s4, n6);
  }
  execute(e5, t2, s4, n6) {
    const r = new s2([e5]), i2 = this.executeMany(r, t2, s4, n6).next();
    return i2 || b("null geometry"), i2;
  }
};
var xh2 = class extends t {
  constructor(e5, t2, s4, n6) {
    super(), this.m_progressTracker = n6, this.m_bForceSimplify = s4, this.m_index = -1, this.m_inputGeometryCursor = e5, this.m_spatialReference = t2;
  }
  next() {
    const e5 = this.m_inputGeometryCursor.next();
    return e5 ? (this.m_index = this.m_inputGeometryCursor.getGeometryID(), this.simplify(e5)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return false;
  }
  getRank() {
    return 1;
  }
  simplify(e5) {
    if (e5 || P(""), e5.getGeometryType() === a.enumGeometryCollection) {
      const t2 = ss(e5, -1), s4 = new fh2().executeMany(t2, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker), n6 = e5.createInstance();
      for (let e6 = s4.next(); null != e6; e6 = s4.next()) n6.addGeometry(e6);
      return n6;
    }
    return nh(e5, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker);
  }
};
function yh2(t2, s4, n6) {
  const r = new n4();
  t2.queryEnvelope(r);
  const i2 = new n4();
  s4.queryEnvelope(i2);
  const a2 = new n4(i2);
  if (a2.inflate(2 * n6), !a2.isIntersecting(r)) return 4;
  const h2 = t2.getGeometryType(), m2 = s4.getGeometryType();
  if (h2 === a.enumEnvelope && r.containsEnvelope(a2)) return 1;
  if (m2 === a.enumEnvelope) {
    const t3 = new n4(r);
    if (t3.inflate(2 * n6), i2.containsEnvelope(t3)) return 2;
  }
  return 0;
}
var Ph2 = class _Ph {
  constructor(e5, t2, s4, n6) {
    this.m_intersectorGeom = null, this.m_sr = null, this.m_dimensionMask = -1, this.m_progressTracker = null, this.m_intersectorGeomType = a.enumUnknown, this.m_geomIntersectorEmptyGeom = null, this.m_intersectorGeom = e5, this.m_sr = t2, this.m_dimensionMask = s4, this.m_progressTracker = n6, this.m_intersectorGeomType = e5.getGeometryType();
  }
  intersect(t2) {
    const s4 = this.tryFastImplementation(t2);
    if (null !== s4) return s4;
    const n6 = Ct2(this.m_intersectorGeom, t2), r = wt2(this.m_sr, n6, true).total(), i2 = n4.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(i2);
    const o2 = n4.constructEmpty();
    t2.queryEnvelope(o2), i2.inflateCoords(2 * r, 2 * r), i2.intersect(o2), i2.inflateCoords(100 * r, 100 * r);
    const a2 = 0;
    let h2 = f2(this.m_intersectorGeom, i2, a2, 0, this.m_progressTracker), m2 = f2(t2, i2, a2, 0, this.m_progressTracker);
    return t2.getDimension() > this.m_intersectorGeom.getDimension() && (h2 = Mt(m2, m2 = h2)), Ra2(m2, h2, this.m_sr, this.m_progressTracker);
  }
  intersectEx(t2) {
    const s4 = this.tryFastImplementation(t2);
    if (null !== s4) {
      const e5 = [];
      return e5.length = 3, e5[s4.getDimension()] = s4, this.prepareVector(t2.getDescription(), this.m_dimensionMask, e5);
    }
    const n6 = Ct2(this.m_intersectorGeom, t2), r = wt2(this.m_sr, n6, true).total(), i2 = n4.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(i2);
    const o2 = n4.constructEmpty();
    t2.queryEnvelope(o2), i2.inflateCoords(2 * r, 2 * r), i2.intersect(o2), i2.inflateCoords(100 * r, 100 * r);
    const a2 = 0;
    let h2 = f2(this.m_intersectorGeom, i2, a2, 0, this.m_progressTracker), m2 = f2(t2, i2, a2, 0, this.m_progressTracker);
    t2.getDimension() > this.m_intersectorGeom.getDimension() && (h2 = Mt(m2, m2 = h2));
    const l2 = Ya2(m2, h2, this.m_sr, this.m_progressTracker);
    return this.prepareVector(t2.getDescription(), this.m_dimensionMask, l2);
  }
  init(e5, t2, n6, r = null) {
    n2(0);
  }
  static intersectPoints(e5, t2, s4) {
    const n6 = Ct2(e5, t2);
    return Ba2(e5, t2, wt2(s4, n6, true));
  }
  tryFastImplementation(t2) {
    const s4 = t2.getGeometryType();
    if (this.m_intersectorGeomType === a.enumPoint && s4 === a.enumPoint) {
      const e5 = _Ph.intersectPoints(t2, this.m_intersectorGeom, this.m_sr);
      if (-1 !== this.m_dimensionMask) {
        const t3 = new Ce({ vd: e5.getDescription() });
        return e5.isEmpty() || t3.add(e5), t3;
      }
      return e5;
    }
    if (s4 === a.enumEnvelope && this.m_intersectorGeomType === a.enumEnvelope && (-1 === this.m_dimensionMask || 4 === this.m_dimensionMask)) {
      const e5 = t2, s5 = this.m_intersectorGeom, n7 = new re({ copy: e5 });
      return n7.intersect(s5), n7;
    }
    const n6 = Ct2(t2, this.m_intersectorGeom), r = wt2(this.m_sr, n6, true), i2 = t2.isEmpty(), a2 = this.m_intersectorGeom.isEmpty();
    let h2 = i2 || a2;
    if (!h2) {
      const e5 = yh2(this.m_intersectorGeom, t2, r.total());
      if (4 === e5) h2 = true;
      else {
        if (2 & e5) return this.m_intersectorGeom;
        if (1 & e5) return t2;
      }
    }
    if (h2) {
      const e5 = m(s4), n7 = m(this.m_intersectorGeomType);
      return e5 < n7 ? _Ph.ReturnEmpty(t2, i2) : e5 > n7 || 0 === e5 && s4 === a.enumMultiPoint && this.m_intersectorGeomType === a.enumPoint ? this.ReturnEmptyIntersector() : _Ph.ReturnEmpty(t2, i2);
    }
    if (s4 === a.enumEnvelope && 0 === m(this.m_intersectorGeomType) || this.m_intersectorGeomType === a.enumEnvelope && 0 === m(s4)) {
      const n7 = s4 === a.enumEnvelope ? t2 : this.m_intersectorGeom, i3 = s4 === a.enumEnvelope ? this.m_intersectorGeom : t2, a3 = n4.constructEmpty();
      return n7.queryEnvelope(a3), f2(i3, a3, r.total(), 0, this.m_progressTracker);
    }
    if (0 === m(s4) && m(this.m_intersectorGeomType) > 0 || m(s4) > 0 && 0 === m(this.m_intersectorGeomType)) {
      if (s4 === a.enumMultiPoint) return Ma2(t2, this.m_intersectorGeom, r);
      if (s4 === a.enumPoint) return Oa2(t2, this.m_intersectorGeom, r);
      if (this.m_intersectorGeomType === a.enumMultiPoint) return Ma2(this.m_intersectorGeom, t2, r);
      if (this.m_intersectorGeomType === a.enumPoint) return Oa2(this.m_intersectorGeom, t2, r);
      b("");
    }
    return null;
  }
  ReturnEmptyIntersector() {
    return null === this.m_geomIntersectorEmptyGeom && (this.m_geomIntersectorEmptyGeom = this.m_intersectorGeom.createInstance()), this.m_geomIntersectorEmptyGeom;
  }
  static ReturnEmpty(e5, t2) {
    return t2 ? e5 : e5.createInstance();
  }
  prepareVector(e5, t2, s4) {
    let n6 = 0;
    return 1 & t2 ? (s4[0] || (s4[0] = new Ce({ vd: e5 })), n6++) : s4.shift(), 2 & t2 ? (s4[n6] || (s4[n6] = new Na({ vd: e5 })), n6++) : s4.splice(n6, 1), 4 & t2 ? s4[n6] || (s4[n6] = new eh({ vd: e5 })) : s4.splice(n6, 1), new s2(s4);
  }
};
var Eh2 = class extends t {
  constructor(e5, s4, n6, r, i2) {
    super(), this.m_smallCursor = null, this.m_progressTracker = r, this.m_geomIntersector = s4.next(), this.m_intersector = new Ph2(this.m_geomIntersector, n6, i2, r), this.m_index = -1, this.m_inputGeoms = e5, this.m_dimensionMask = i2, -1 !== this.m_dimensionMask && (this.m_dimensionMask <= 0 || this.m_dimensionMask > 7) && P("bad dimension mask");
  }
  next() {
    if (!this.m_geomIntersector) return null;
    let e5;
    if (null !== this.m_smallCursor) {
      if (e5 = this.m_smallCursor.next(), e5) return e5;
      this.m_smallCursor = null;
    }
    for (; e5 = this.m_inputGeoms.next(); ) {
      if (j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), -1 === this.m_dimensionMask) {
        return this.m_intersector.intersect(e5);
      }
      this.m_smallCursor = this.m_intersector.intersectEx(e5);
      return this.m_smallCursor.next();
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var Ch2 = class {
  getOperatorType() {
    return 1e4;
  }
  accelerateGeometry(e5, t2, s4) {
    if (!this.canAccelerateGeometry(e5)) return false;
    zt2(t2, e5, true);
    let n6 = 0;
    return e5.getGeometryType() !== a.enumPolygon && e5.getGeometryType() !== a.enumPolyline || !As(e5) || 0 === s4 || (n6 |= e5.getImpl().buildQuadTreeAccelerator(s4) ? 1 : 0), !!n6;
  }
  canAccelerateGeometry(e5) {
    return As(e5);
  }
  supportsCurves() {
    return true;
  }
  executeMany(e5, t2, s4, n6, r = -1) {
    return new Eh2(e5, t2, s4, n6, r);
  }
  execute(e5, t2, s4, n6) {
    if (e5.getGeometryType() === a.enumPoint && t2.getGeometryType() === a.enumPoint) return Ph2.intersectPoints(e5, t2, s4);
    const r = new s2([e5]), i2 = new s2([t2]), a2 = this.executeMany(r, i2, s4, n6, -1).next();
    return a2 || b("null output"), a2;
  }
};
function Sh2(e5, t2, s4) {
  return t2.m_projector.project(e5, s4);
}
function Ih2(e5, t2, s4, n6, r) {
  e5.m_projector.transformInPlaceZ(t2, null, s4, n6, null, r);
  const i2 = n6.slice(0, s4).filter((e6) => !e6.isNAN());
  for (let o2 = 0, a2 = i2.length; o2 < a2; ++o2) n6[o2].assign(i2[o2]);
  return i2.length;
}
function bh2(e5, t2, s4, n6, r) {
  return e5.m_projector.transformInPlaceZ(t2, null, s4, n6, null, r);
}
function wh2(s4, n6, r, i2) {
  if (s4 && n6 && n6.isPannable() || P("fold_into_360_range_geodetic"), s4.isEmpty()) return s4;
  if (4 === r) return vh2(s4, n6, i2);
  let m2 = s4;
  const l2 = m2.getGeometryType();
  if (h(l2)) {
    m2 = Vl(s4, n6);
    const t2 = new n4();
    m2.queryEnvelope(t2);
    const i3 = wt2(n6, t2, false).total(), o2 = n6.getPannableExtent();
    let a2 = Math.floor((t2.xmin - o2.xmin) / o2.width()) * o2.width() + o2.xmin, h2 = m2;
    for (; a2 < t2.xmax; ) a2 > t2.xmin + i3 && a2 < t2.xmax - i3 && (h2 = Gl(h2, n6, r, true, a2)), a2 += o2.width();
    m2 = h2;
  } else {
    if (l2 === a.enumEnvelope) {
      const e5 = new eh({ vd: m2.getDescription() });
      return e5.addEnvelope(m2, false), wh2(e5, n6, r, i2);
    }
    if (f(l2)) {
      const e5 = new Na({ vd: m2.getDescription() });
      return e5.addSegment(m2, true), wh2(e5, n6, r, i2);
    }
  }
  return vh2(m2, n6, i2);
}
function vh2(e5, s4, n6) {
  if (e5 && s4 && s4.isPannable() || P(""), e5.isEmpty()) return e5;
  let r;
  const i2 = e5.getGeometryType();
  if (i2 === a.enumEnvelope) {
    const t2 = new eh({ vd: e5.getDescription() });
    t2.addEnvelope(e5, false), r = t2;
  } else if (f(i2)) {
    const t2 = new Na({ vd: e5.getDescription() });
    t2.addSegment(e5, true), r = t2;
  } else r = e5;
  const h2 = Vl(r, s4);
  return h2.isEmpty() ? h2 : Sl(h2, s4, 0, h2 !== e5, 0, n6);
}
function Nh2(e5, t2, s4) {
  if (!t2.isPannable() || e5.isEmpty()) return e5;
  const n6 = t2.getPannableExtent().width(), r = 0.5 * n6, i2 = e5.queryInterval(0, 0);
  if (i2.width() < r || !y(e5.getGeometryType())) {
    if (Number.isNaN(s4)) return e5;
    const t3 = i2.getCenter();
    if (Math.abs(t3 - s4) <= r) return e5;
    {
      const r2 = new x3(), i3 = S((s4 - t3) / n6) * n6;
      r2.setShiftCoords(i3, 0);
      const o3 = e5.clone();
      return o3.applyTransformation(r2), o3;
    }
  }
  const o2 = e5.getGeometryType(), a2 = e5, m2 = a2.getAttributeStreamRef(0), g2 = e5.clone(), u = g2.getAttributeStreamRef(0);
  let c = 0, _ = 0, d2 = 0, p3 = h(o2) ? 0 : -1;
  const f3 = x2.constructEmpty();
  let x4 = false;
  for (let l2 = 0, y2 = a2.getPointCount(); l2 < y2; l2++) {
    const e6 = m2.read(2 * l2);
    l2 === _ && (h(o2) ? (0 === p3 && Number.isNaN(s4) && (x4 = true), p3 > 0 && Number.isNaN(s4) && (s4 = f3.getCenter(), x4 = false), _ = a2.getPathEnd(p3), p3++) : _ = a2.getPointCount(), Number.isNaN(s4) ? d2 = e6 : (d2 = s4, c = 0));
    let t3 = e6 - d2;
    Math.abs(t3) > r && (t3 = S(t3 / n6) * n6, c -= t3, Math.abs(c) < 0.1 * n6 && (c = 0));
    const i3 = e6 + c;
    u.write(2 * l2, i3), x4 && f3.mergeCoordinate(i3), d2 = e6;
  }
  return g2.notifyModified(), g2;
}
var Th2 = "missing implementation";
function Gh2(t2, s4, n6, r) {
  const i2 = s4.getCoordinateSystemType();
  if (0 === i2) {
    const e5 = new nc();
    return s4.queryPrecisionDescriptor(e5), Dh2(t2, e5, s4, n6);
  }
  let o2 = t2;
  2 !== r && 3 !== r || !s4.isPannable() || (o2 = vh2(o2, s4, n6));
  const a2 = new nc();
  if (s4.queryPrecisionDescriptor(a2), o2 = Dh2(o2, a2, s4, n6), 0 === r || o2.isEmpty()) return o2;
  if (1 === i2) {
    if (1 === r) {
      const t3 = new n4();
      o2.queryLooseEnvelope(t3);
      const r2 = s4.getPannableExtent(), i3 = 0.01 * r2.width();
      return r2.xmin = t3.xmin - i3, r2.xmax = t3.xmax + i3, new I4().execute(o2, r2, s4, n6);
    }
    return o2;
  }
  if (2 === i2) {
    const e5 = s4.getPCSHorizon();
    if (1 === r || 2 === r) {
      const t3 = new Ch2().execute(o2, e5, s4, n6);
      return t3 === e5 ? t3.clone() : t3;
    }
    return o2;
  }
  if (3 === i2) return o2;
  b(Th2);
}
function Dh2(e5, t2, s4, n6) {
  const r = t2.getXYGridRange(), i2 = e5.hasAttribute(1), o2 = e5.hasAttribute(2);
  let a2 = new x2(), h2 = new x2();
  i2 && (a2 = t2.getZGridRange()), o2 && (h2 = t2.getMGridRange());
  let m2 = new I4().execute(e5, r, s4, n6);
  if (i2) {
    const t3 = m2.queryInterval(1, 0);
    a2.contains(t3) || (e5 === m2 && (m2 = m2.clone()), $t(m2, a2, 1, 0));
  }
  if (o2) {
    const t3 = m2.queryInterval(2, 0);
    h2.contains(t3) || (e5 === m2 && (m2 = m2.clone()), $t(m2, h2, 2, 0));
  }
  return m2;
}
var Vh2 = class {
  constructor(e5) {
    this.m_inputPCSHorizonClipOption = 0, this.m_outputPCSHorizonClipOption = 0, this.m_bDontGeonormalizePolygon = false, this.m_bClipOutCurvedPoles = false, this.m_bNormalizeOutputGeometry = false, this.m_bDontHackPolesInGeogToGeog = false, this.m_centralMeridianOfOutputGCS = 0, this.m_densificationStepInput = 0, e5 || P(""), this.m_projTransform = e5, this.m_bClipOutCurvedPoles = false;
    const s4 = this.m_projTransform.getExtendedParamsImpl();
    this.m_bNormalizeOutputGeometry = s4.normalizeResultGeometry, this.m_bNormalizeOutputGeometry && (s4.legacyHorizonClipping ? this.m_bNormalizeOutputGeometry = false : this.m_projTransform.getOutputSR().isPannable() || (this.m_bNormalizeOutputGeometry = false)), s4.clipWithInputHorizon ? (this.m_inputPCSHorizonClipOption = 0, !s4.legacyHorizonClipping && this.m_projTransform.getInputSR().isPannable() && (this.m_inputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_inputPCSHorizonClipOption = 1, s4.clipWithOutputHorizon ? (this.m_outputPCSHorizonClipOption = 0, !s4.legacyHorizonClipping && this.m_projTransform.getOutputSR().isPannable() && (this.m_outputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_outputPCSHorizonClipOption = 1, this.m_centralMeridianOfOutputGCS = s4.centralMeridianOfOutputGCS, this.m_densificationStepInput = s4.densificationStep;
    const n6 = this.m_projTransform.getExtendedParamsInternal();
    this.m_bDontGeonormalizePolygon = n6.hasFlag(2147483648), this.m_bDontHackPolesInGeogToGeog = n6.hasFlag(1073741824), this.m_bClipOutCurvedPoles = n6.hasFlag(536870912);
  }
  project(e5, t2) {
    if (this.m_projTransform.isIdentity() || e5.isEmpty()) return e5;
    const s4 = e5.getGeometryType();
    if (s4 === a.enumPoint) return this.projectPoint(e5, t2);
    const n6 = this.m_projTransform.getInputSR().getCoordinateSystemType(), r = this.m_projTransform.getOutputSR().getCoordinateSystemType(), i2 = this.m_projTransform.getInputSR(), a2 = this.m_projTransform.getOutputSR();
    if (0 === n6 && n6 === r) {
      const t3 = Hh2(i2, a2), s5 = e5.clone();
      return s5.applyTransformation(t3), s5;
    }
    switch (s4) {
      case a.enumPolyline:
      case a.enumPolygon:
        return this.projectMultiPath(e5, t2);
      case a.enumMultiPoint:
        return this.projectMultiPoint(e5, t2);
      case a.enumEnvelope:
        return this.projectEnvelope(e5, t2);
      case a.enumGeometryCollection:
        return this.projectGeometryCollection(e5, t2);
      default:
        b("");
    }
  }
  projectPoint(e5, t2) {
    const s4 = [e5.getXY()];
    let n6, r = null;
    (n6 = e5.hasAttribute(1)) && (r = [e5.getZ()]), this.transformInPlaceZ(s4, r, 1, s4, r, null);
    const i2 = e5.clone();
    return i2.setXY(s4[0]), n6 && i2.setZ(r[0]), i2;
  }
  projectMultiPoint(e5, t2) {
    let n6 = new Ce({ copy: e5 });
    const r = this.m_projTransform.getInputSR(), i2 = this.m_projTransform.getOutputSR(), o2 = r.getCoordinateSystemType(), a2 = i2.getCoordinateSystemType();
    if (3 === o2 && n2(0), n6 = Ol(n6, r, this.m_inputPCSHorizonClipOption, t2), n6.isEmpty()) return n6;
    2 === o2 && Zl(r, 0, n6), ag(this.m_projTransform, n6, false);
    let h2 = 0;
    3 === a2 && n2(0);
    const m2 = 2 === a2;
    return m2 ? h2 = i2.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (h2 = this.m_centralMeridianOfOutputGCS), m2 && 0 !== this.m_outputPCSHorizonClipOption || (n6 = Sl(n6, Lu(i2), h2, false, 0, t2)), m2 && (n6 = xl(n6, i2, this.m_outputPCSHorizonClipOption, t2), zl(i2, n6, this.m_bNormalizeOutputGeometry), n6.isEmpty()), n6;
  }
  projectMultiPath(e5, t2) {
    const s4 = e5.getGeometryType();
    return s4 === a.enumPolygon ? this.projectPolygon(e5, t2) : s4 === a.enumPolyline ? this.projectPolyline(e5, t2) : void b("project_multi_path_");
  }
  projectEnvelope(e5, t2) {
    this.m_projTransform.getInputSR(), this.m_projTransform.getOutputSR();
    const s4 = this.m_projTransform.isVertical() && e5.hasAttribute(1);
    let n6 = x2.constructEmpty();
    if (s4 && (n6 = e5.queryInterval(1, 0)), n6.width() > 0) {
      const s5 = e5.clone();
      s5.setInterval(1, 0, n6.vmin, n6.vmin);
      const r = this.projectEnvelopeHelper(s5, t2);
      s5.setInterval(1, 0, n6.vmax, n6.vmax);
      const i2 = this.projectEnvelopeHelper(s5, t2);
      return r.merge(i2), r;
    }
    return this.projectEnvelopeHelper(e5, t2);
  }
  projectPolygon(t2, n6) {
    n2(t2.getGeometryType() === a.enumPolygon), n2(!this.m_projTransform.isIdentity()), n2(!t2.isEmpty());
    const r = this.m_projTransform.getInputSR(), i2 = this.m_projTransform.getOutputSR(), a2 = r.getCoordinateSystemType(), h2 = i2.getCoordinateSystemType(), m2 = new eh({ copy: t2 });
    3 === a2 && n2(0), 3 === h2 && n2(0);
    const l2 = 2 === a2, g2 = 2 === h2, u = l2 ? r.getGCS() : r, c = g2 ? i2.getGCS() : i2, _ = !g2 && !this.m_bDontHackPolesInGeogToGeog;
    let d2 = false, p3 = Ol(m2, r, this.m_inputPCSHorizonClipOption, n6);
    if (p3.isEmpty()) return p3;
    let f3 = this.m_densificationStepInput;
    const x4 = !Number.isNaN(f3);
    let y2;
    x4 && (p3 = new o().execute(p3, f3, 0, 0, n6));
    let P5 = g2 ? i2.getPCSInfo() : null, E2 = Number.NaN;
    l2 && (E2 = r.getCentralMeridian());
    const C2 = null !== i2.getGCSSplitLines();
    if (this.m_bDontGeonormalizePolygon) {
      const e5 = p3;
      if (l2 && (rg(r, E2, e5), x4)) {
        const e6 = r.getUnitsPerMillimeter();
        f3 *= r.getGCS().getUnitsPerMillimeter() / e6;
      }
      if (mg(this.m_projTransform, e5, _), x4) {
        const e6 = r.getGCS().getUnitsPerMillimeter();
        f3 *= i2.getGCS().getUnitsPerMillimeter() / e6;
      }
      y2 = e5;
    } else {
      let t3 = new Na({ vd: p3.getDescription() });
      if (t3.addAndExplicitlyOpenAllPaths(p3, false), l2) {
        if (rg(r, E2, t3), x4) {
          const e5 = r.getUnitsPerMillimeter();
          f3 *= r.getGCS().getUnitsPerMillimeter() / e5;
        }
        if (this.m_bClipOutCurvedPoles) {
          const s5 = r.getPCSInfo(), i3 = s5.getSouthPoleGeometry() === Ic.PE_POLE_LINE_CURVED, o3 = s5.getNorthPoleGeometry() === Ic.PE_POLE_LINE_CURVED;
          if (i3 || o3) {
            const s6 = n4.constructEmpty();
            t3.queryLooseEnvelope(s6), s6.inflateCoords(1, 1);
            const r2 = 89.9999 * u.getOneDegreeGCSUnit();
            i3 && (s6.ymin = -r2), o3 && (s6.ymax = r2), t3 = d(t3, s6, u, 0, 0, n6);
          }
        }
      }
      if (mg(this.m_projTransform, t3, _), x4) {
        const e5 = Lu(r).getUnitsPerMillimeter();
        f3 *= Lu(i2).getUnitsPerMillimeter() / e5;
      }
      let s4 = Number.NaN;
      g2 ? (P5 = i2.getPCSInfo(), s4 = i2.getCentralMeridian()) : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (s4 = this.m_centralMeridianOfOutputGCS);
      let o2 = Fh2(r) | Fh2(i2), a3 = 10 * c.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (o2 = 3, a3 = 10 * c.getTolerance(0)), y2 = Nl(p3, r, t3, c, s4, n6, o2, a3, this.m_bNormalizeOutputGeometry), o2 = 0;
    }
    if (C2 && (n2(!i2.isPannable()), y2 = ml(y2, i2, n6)), g2) {
      if (!d2) {
        const e5 = c.getPannableExtent().width();
        if (y2.queryInterval(0, 0).width() >= e5 - 10 * c.getTolerance(0)) {
          const e6 = P5.getNorthPoleLocation(), t3 = P5.getSouthPoleLocation(), s4 = P5.getNorthPoleGeometry(), n7 = P5.getSouthPoleGeometry();
          let r2 = 0;
          s4 === Ic.PE_POLE_POINT && e6 !== Ic.PE_POLE_OUTSIDE_BOUNDARY && (r2 = 1), n7 === Ic.PE_POLE_POINT && t3 !== Ic.PE_POLE_OUTSIDE_BOUNDARY && (r2 |= 2), d2 || (d2 = 0 !== r2);
        }
      }
      y2 = xl(y2, i2, this.m_outputPCSHorizonClipOption, n6), x4 && (y2 = new o().execute(y2, f3, 0, 0, n6)), jl(i2, y2, this.m_bNormalizeOutputGeometry);
    }
    return y2.isEmpty() || d2 && (y2 = new fh2().execute(y2, i2, false, n6)), y2;
  }
  projectPolyline(e5, t2) {
    n2(e5.getGeometryType() === a.enumPolyline), n2(!this.m_projTransform.isIdentity()), n2(!e5.isEmpty());
    const n6 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = n6.getCoordinateSystemType(), a2 = r.getCoordinateSystemType(), h2 = new Na({ copy: e5 });
    3 === i2 && n2(0), 3 === a2 && n2(0);
    const m2 = 2 === i2, l2 = 2 === a2;
    m2 && n6.getGCS();
    const g2 = l2 ? r.getGCS() : r, u = !l2 && !this.m_bDontHackPolesInGeogToGeog;
    let c = Ol(h2, n6, this.m_inputPCSHorizonClipOption, t2);
    if (c.isEmpty()) return c;
    let _ = Number.NaN;
    m2 && (_ = n6.getCentralMeridian());
    const d2 = null !== r.getGCSSplitLines();
    let p3 = this.m_densificationStepInput;
    const f3 = !Number.isNaN(p3);
    let x4;
    if (f3 && (c = new o().execute(c, p3, 0, 0, t2)), this.m_bDontGeonormalizePolygon) {
      if (m2 && (rg(n6, _, c), f3)) {
        const e6 = n6.getUnitsPerMillimeter();
        p3 *= n6.getGCS().getUnitsPerMillimeter() / e6;
      }
      if (mg(this.m_projTransform, c, u), f3) {
        const e6 = n6.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e6;
      }
      x4 = c;
    } else {
      const e6 = new Na({ vd: c.getDescription() });
      if (e6.addAndExplicitlyOpenAllPaths(c, false), m2 && (rg(n6, _, e6), f3)) {
        const e7 = n6.getUnitsPerMillimeter();
        p3 *= n6.getGCS().getUnitsPerMillimeter() / e7;
      }
      if (mg(this.m_projTransform, e6, u), f3) {
        const e7 = n6.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e7;
      }
      let s4 = Number.NaN;
      l2 ? s4 = r.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (s4 = this.m_centralMeridianOfOutputGCS);
      let i3 = Fh2(n6) | Fh2(r), o2 = 10 * g2.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (i3 = 3, o2 = 0), x4 = Tl(c, n6, e6, g2, s4, t2, i3, o2, this.m_bNormalizeOutputGeometry), i3 = 0;
    }
    return d2 && (n2(!r.isPannable()), x4 = ml(x4, r, t2)), l2 && (x4 = xl(x4, r, this.m_outputPCSHorizonClipOption, t2), f3 && (x4 = new o().execute(x4, p3, 0, 0, t2)), jl(r, x4, this.m_bNormalizeOutputGeometry)), x4.isEmpty(), x4;
  }
  projectGeometryCollection(e5, t2) {
    return n2(0), {};
  }
  projectEnvelopeHelper(t2, s4) {
    const n6 = (t2.height() + t2.width()) / 400;
    if (0 !== n6) {
      const r = new o().execute(t2, n6, 0, 0, s4), i2 = this.projectMultiPath(r, s4), o2 = new re({ vd: t2.getDescription() });
      if (i2.isEmpty()) {
        const n7 = Math.min(t2.height(), t2.width()), i3 = zt2(this.m_projTransform.getInputSR(), t2, true).total();
        if (n7 > 100 * i3) {
          const t3 = n4.constructEmpty(), s5 = wt2(this.m_projTransform.getOutputSR(), t3, true).total(), r2 = this.m_projTransform.getInputSR().getOneMeter() / this.m_projTransform.getOutputSR().getOneMeter();
          if (n7 > 100 * Math.max(i3, s5 * r2)) return o2;
        }
        const a2 = new Na();
        a2.addAndExplicitlyOpenAllPaths(r, false);
        this.projectMultiPath(a2, s4).queryEnvelope(o2);
        const h2 = new Ce({ vd: t2.getDescription() });
        h2.reserve(4);
        const m2 = new ee();
        for (let e5 = 0; e5 < 4; e5++) t2.queryCornerByVal(e5, m2), h2.add(m2);
        const l2 = this.projectMultiPoint(h2, s4), g2 = new re();
        return l2.queryEnvelope(g2), o2.merge(g2), o2;
      }
      return i2.queryEnvelope(o2), o2;
    }
    {
      const e5 = t2.getCenterXY(), n7 = new ee(e5), r = this.projectPoint(n7, s4), i2 = new re({ vd: t2.getDescription() });
      if (r.isEmpty()) i2.setEmpty();
      else {
        t2.copyTo(i2);
        const e6 = r.getXY();
        i2.setCoords(e6.x, e6.y, e6.x, e6.y);
      }
      return i2;
    }
  }
  transformInPlace(e5, t2, n6, r) {
    return n2(0), 0;
  }
  transformInPlaceZ(e5, t2, n6, r, i2, o2) {
    if (this.m_projTransform.isIdentity()) return e5 !== r && Bt(r, e5, n6), t2 !== i2 && Tt(i2, t2, 0, 0, n6), n6;
    const a2 = this.m_projTransform, h2 = a2.getInputSR(), l2 = a2.getOutputSR(), g2 = h2.getCoordinateSystemType(), u = l2.getCoordinateSystemType();
    if (0 === g2 && g2 === u) {
      return Hh2(h2, l2).transformPoints2D(e5, n6, r), a2.isVertical() && n2(0), n6;
    }
    3 === g2 && z("image: transform_in_place_"), 3 === u && z("image: transform_in_place_"), Bl(e5, n6, r, h2, this.m_inputPCSHorizonClipOption), i2 !== t2 && Tt(i2, t2, 0, 0, n6), 2 === g2 && ig(h2, 0, r, n6), cg(this.m_projTransform, r, i2, n6, false);
    let c = 0;
    const _ = 2 === u;
    if (_ ? c = l2.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (c = this.m_centralMeridianOfOutputGCS), _ && 0 !== this.m_outputPCSHorizonClipOption || Il(r, n6, l2.getGCS(), c), _) {
      if (!Cl(r, n6, l2, this.m_outputPCSHorizonClipOption)) for (let e6 = 0; e6 < n6; ++e6) r[e6].setNAN();
      Yl(l2, r, n6, false);
    }
    let d2 = n6;
    for (let s4 = 0; s4 < n6; ++s4) r[s4].isNAN() && (i2 && (i2[s4] = Number.NaN), d2--);
    return d2;
  }
};
function Fh2(e5) {
  if (2 !== e5.getCoordinateSystemType()) return 0;
  let t2 = 0;
  const s4 = e5.getPCSInfo(), n6 = s4.getNorthPoleLocation(), r = s4.getSouthPoleLocation(), i2 = s4.getNorthPoleGeometry(), o2 = s4.getSouthPoleGeometry();
  return i2 === Ic.PE_POLE_POINT && n6 !== Ic.PE_POLE_OUTSIDE_BOUNDARY && (t2 = 1), o2 === Ic.PE_POLE_POINT && r !== Ic.PE_POLE_OUTSIDE_BOUNDARY && (t2 |= 2), t2;
}
function Hh2(e5, t2) {
  const s4 = e5.getHorzUnitFactor(), n6 = t2.getHorzUnitFactor();
  let r = 1, i2 = 1;
  const o2 = 20015077 / 180;
  1 === e5.getUnit().getUnitType() && (r = o2), 1 === t2.getUnit().getUnitType() && (i2 = o2);
  const a2 = s4 / n6 * (r !== i2 ? r / i2 : 1), h2 = new x3();
  return h2.setScaleCoords(a2, a2), h2;
}
var kh2 = class {
  getOperatorType() {
    return 10300;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t2, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t2, s4) {
    return !t2 || t2.isIdentity() ? e5 : new Ah2(e5, t2, s4);
  }
  execute(e5, t2, s4) {
    return t2.isIdentity() ? e5 : Sh2(e5, t2, s4);
  }
  transform(e5, t2, s4, n6, r = true) {
    return r ? Ih2(e5, t2, s4, n6, null) : bh2(e5, t2, s4, n6, null);
  }
  transform3D(e5, t2, n6, r, i2 = true) {
    return n2(0), 0;
  }
  foldInto360Range(e5, t2) {
    return vh2(e5, t2, null);
  }
  foldInto360RangeGeodetic(e5, t2, s4) {
    return wh2(e5, t2, s4, null);
  }
  normalizeGeometryEx(e5, t2, s4, n6, r = 0) {
    return bm2(e5, t2, s4, n6, r);
  }
  normalizeGeometry(e5, t2, s4) {
    return Nh2(e5, t2, s4);
  }
  clipToSpatialReference(e5, t2, s4, n6 = 0) {
    return Gh2(e5, t2, s4, n6);
  }
};
var Ah2 = class extends t {
  constructor(e5, s4, n6) {
    super(), this.m_projTrans = s4, this.m_progressTracker = n6, this.m_index = -1, e5 || P(""), this.m_inputGeoms = e5;
  }
  next() {
    const e5 = this.m_inputGeoms.next();
    return null != e5 ? (N(e5), j(e5), this.m_index = this.m_inputGeoms.getGeometryID(), Sh2(e5, this.m_projTrans, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Mh2(e5, n6, m2, l2, g2, u, c = false) {
  e5 || P("Geometry.Geodetic_densify.densify");
  let _ = e5.getGeometryType();
  if (j(e5), e5.isEmpty() || l(_)) return e5;
  const d2 = new Yh2();
  d2.m_sr = n6, d2.m_gcs = n6.getGCS(), d2.m_transform = d2.m_gcs !== n6 ? n6.getSRToGCSTransform() : null, d2.m_progressTracker = u;
  const p3 = Gu();
  let f3, x4, y2;
  if (d2.m_gcs.querySpheroidData(p3), d2.m_a = p3.majorSemiAxis, d2.m_eSquared = p3.e2, d2.m_rpu = d2.m_gcs.getUnit().getUnitToBaseFactor(), d2.m_gcsTolerance = d2.m_gcs.getTolerance(0), d2.m_radTolerance = d2.m_gcsTolerance * d2.m_rpu, d2.m_maxLength = l2, d2.m_maxDeviation = g2, d2.m_curveType = m2, _ === a.enumEnvelope) {
    const t2 = new eh({ vd: e5.getDescription() });
    t2.addEnvelope(e5, false), f3 = t2, _ = a.enumPolygon;
  } else if (f(_)) {
    const t2 = new Na({ vd: e5.getDescription() });
    t2.addSegment(e5, true), f3 = t2, _ = a.enumPolyline;
  } else f3 = e5;
  if (4 !== d2.m_curveType) {
    if (n2(h(_)), x4 = d2.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(f3), x4.isEmpty()) return x4;
    x4 = Uh2(d2.m_rpu, x4);
    let e6 = d2.geodeticDensify(x4);
    c || (e6 = new kh2().foldInto360RangeGeodetic(e6, d2.m_gcs, d2.m_curveType)), y2 = d2.m_transform && !d2.m_transform.isIdentity() ? new kh2().execute(e6, d2.m_transform.getInverse(), u) : e6;
  } else {
    let e6;
    if (n2(h(_)), n6.isPannable()) e6 = Vl(f3, n6);
    else {
      const t2 = n6.getPCSHorizon();
      e6 = new Ch2().execute(f3, t2, n6, u), e6 === t2 && (e6 = t2.clone());
    }
    if (x4 = e6, x4.isEmpty()) return x4;
    y2 = d2.shapePreservingDensify(x4);
  }
  return y2;
}
function Uh2(t2, s4) {
  const n6 = new n4();
  if (s4.queryLooseEnvelope(n6), n6.width() * t2 < Math.PI) return s4;
  let r = false;
  const i2 = s4.querySegmentIterator(), o2 = new ei(), a2 = new ei();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e5 = i2.nextSegment();
    if (o2.setCoordsPoint2D(e5.getStartXY()), a2.setCoordsPoint2D(e5.getEndXY()), o2.scale(t2), a2.scale(t2), Math.abs(o2.x - a2.x) > Math.PI) {
      if (!Oh2(o2, a2)) {
        r = true;
        break;
      }
      if (Math.abs(o2.x - a2.x) > 2 * Math.PI) {
        r = true;
        break;
      }
    }
  }
  if (!r) return s4;
  const h2 = s4.createInstance();
  h2.reserve(s4.getPointCount());
  const m2 = s4.getDescription().getAttributeCount() > 1, l2 = new ei(), g2 = new ei(), u = new ei(0, 0), c = new ei(0, 0), _ = new ee();
  for (i2.resetToFirstPath(); i2.nextPath(); ) {
    let e5 = Number.NaN, s5 = 0;
    for (; i2.hasNextSegment(); ) {
      const n7 = i2.nextSegment();
      o2.setCoordsPoint2D(n7.getStartXY()), a2.setCoordsPoint2D(n7.getEndXY()), o2.scale(t2), a2.scale(t2), Number.isNaN(e5) ? (s5 = tm2(o2.x, Number.NaN, s5), u.setCoordsPoint2D(o2)) : u.setCoordsPoint2D(c), e5 = u.x;
      if (Oh2(o2, a2)) {
        if (a2.x - o2.x > 2 * Math.PI) for (; a2.x - o2.x > 2 * Math.PI; ) a2.x -= 2 * Math.PI;
        else if (a2.x - o2.x < 2 * -Math.PI) for (; a2.x - o2.x < 2 * -Math.PI; ) a2.x += 2 * Math.PI;
        s5 = tm2(a2.x, Number.NaN, s5), c.setCoordsPoint2D(a2);
      } else l2.setCoordsPoint2D(a2), am2(l2), s5 = tm2(l2.x, e5, s5), c.setCoords(s5 + l2.x, l2.y);
      if (Math.abs(c.x - a2.x) < 0.5 && c.setCoordsPoint2D(a2), m2) {
        n7.queryCoord(0, _), g2.setCoordsPoint2D(u), g2.scale(1 / t2), _.setXY(g2);
        i2.isFirstSegmentInPath() ? h2.startPathPoint(_) : h2.lineToPoint(_), i2.isLastSegmentInPath() && !i2.isPathClosed() && (n7.queryCoord(1, _), g2.setCoordsPoint2D(c), g2.scale(1 / t2), _.setXY(g2), h2.lineToPoint(_));
      } else {
        i2.isFirstSegmentInPath() && h2.insertPath2D(-1, null, 0, 0, true);
        const e6 = h2.getPathCount() - 1;
        g2.setCoordsPoint2D(u), g2.scale(1 / t2), h2.insertPoint2D(e6, -1, g2), i2.isLastSegmentInPath() && !i2.isPathClosed() && (g2.setCoordsPoint2D(c), g2.scale(1 / t2), h2.insertPoint2D(e6, -1, g2));
      }
    }
  }
  return h2;
}
function qh2(e5, t2, s4, n6, r, i2, o2, a2, h2, m2, l2, g2) {
  const u = new ei(), c = new ei(), _ = n6.compare(r) > 0;
  $h2(_, n6, r, u, c);
  const d2 = zh2(e5, t2, s4, u, c, i2, o2, a2, h2, m2, null, l2, g2);
  return _ && Jh2(h2, m2, null, l2), d2;
}
function Oh2(e5, t2) {
  return !(!pc(e5.y, Yt) || !pc(t2.y, Yt)) || !(!pc(e5.y, -Yt) || !pc(t2.y, -Yt));
}
function Bh2(e5, t2) {
  return !(!pc(e5.y, Yt) || pc(t2.y, Yt)) || !(!pc(e5.y, -Yt) || pc(t2.y, -Yt));
}
function Rh2(e5, t2) {
  return !(!pc(t2.y, Yt) || pc(e5.y, Yt)) || !(!pc(t2.y, -Yt) || pc(e5.y, -Yt));
}
var Yh2 = class {
  constructor() {
    this.m_sr = null, this.m_gcs = null, this.m_transform = null, this.m_progressTracker = null, this.m_a = 0, this.m_eSquared = 0, this.m_rpu = 0, this.m_gcsTolerance = 0, this.m_radTolerance = 0, this.m_maxLength = 0, this.m_maxDeviation = 0, this.m_curveType = 0;
  }
  geodeticDensify(e5) {
    const t2 = e5.createInstance(), s4 = e5.querySegmentIterator(), n6 = [], r = [], i2 = new nu(), o2 = e5.getDescription().getAttributeCount() > 1;
    for (; s4.nextPath(); ) {
      const e6 = [0];
      for (; s4.hasNextSegment(); ) {
        const a2 = s4.nextSegment(), h2 = a2.getStartXY(), m2 = a2.getEndXY();
        h2.scale(this.m_rpu), m2.scale(this.m_rpu);
        const l2 = new ei(), g2 = new ei(), u = h2.compare(m2) > 0;
        $h2(u, h2, m2, l2, g2), n6.length = 0, r.length = 0, this.m_maxLength > 0 ? zh2(this.m_a, this.m_eSquared, this.m_curveType, l2, g2, this.m_maxLength, this.m_maxDeviation, this.m_radTolerance, null, null, o2 ? r : null, n6, e6) : Wh2(), u && Jh2(null, null, o2 ? r : null, n6), n6[0].setCoordsPoint2D(a2.getStartXY()), n6.at(-1).setCoordsPoint2D(a2.getEndXY());
        const c = 1 / this.m_rpu;
        for (let e7 = 1, t3 = n6.length - 1; e7 < t3; e7++) n6[e7].scale(c);
        if (o2) {
          const e7 = em2(u, a2, i2);
          Lh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), a2, e7, r, n6, t2);
        } else Xh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), n6, t2);
      }
    }
    return t2;
  }
  shapePreservingDensify(e5) {
    const t2 = e5.createInstance(), s4 = e5.querySegmentIterator(), n6 = [], r = [], i2 = new nu(), o2 = e5.getDescription().getAttributeCount() > 1;
    for (; s4.nextPath(); ) for (; s4.hasNextSegment(); ) {
      const e6 = s4.nextSegment(), a2 = e6.getStartXY(), h2 = e6.getEndXY(), m2 = a2.compare(h2) > 0, l2 = em2(m2, e6, i2);
      n6.length = 0, r.length = 0, Qh2(this.m_a, this.m_eSquared, this.m_rpu, l2, this.m_sr, this.m_maxLength, this.m_maxDeviation, o2 ? r : null, n6), m2 && Jh2(null, null, o2 ? r : null, n6), o2 ? Lh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), e6, l2, r, n6, t2) : Xh2(s4.isFirstSegmentInPath(), s4.isLastSegmentInPath() && !s4.isPathClosed(), n6, t2);
    }
    return t2;
  }
  replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(e5) {
    const t2 = e5.hasNonLinearSegments();
    if ((!this.m_transform || this.m_transform.isIdentity()) && (e5 = Vl(e5, this.m_gcs), !t2)) return e5;
    const s4 = e5.createInstance();
    s4.reserveParts(e5.getPointCount(), e5.getPathCount());
    for (let n6 = 0, r = e5.getPathCount(); n6 < r; ++n6) {
      let t3 = new Ce();
      const r2 = e5.getPathStart(n6), i2 = e5.getPathEnd(n6);
      t3.addPoints(e5, r2, i2);
      const o2 = e5.isClosedPath(n6);
      let a2 = false;
      if (o2 && i2 - r2 == 1 && e5.hasNonLinearSegmentsPath(n6)) {
        const s5 = new ee();
        e5.getPointByVal(r2, s5), t3.add(s5), a2 = true;
      }
      if (this.m_transform && !this.m_transform.isIdentity()) {
        if (o2 && !a2) {
          const s5 = new ee();
          e5.getPointByVal(r2, s5), t3.add(s5);
        }
        if (t3 = new kh2().execute(t3, this.m_transform, this.m_progressTracker), o2 && t3.getPointCount() > 1) {
          const e6 = t3.getXY(0), s5 = t3.getXY(t3.getPointCount() - 1);
          e6.equals(s5) && t3.removePoint(t3.getPointCount() - 1);
        }
      }
      t3.getPointCount() > 1 && (s4.addPathMultiPoint(t3, 0, -1, true), o2 && s4.closePathWithLine());
    }
    return s4;
  }
};
function Xh2(e5, t2, s4, n6) {
  e5 && n6.insertPath2D(-1, null, 0, 0, true);
  const r = n6.getPathCount() - 1;
  n6.insertPointsFromPoints(r, -1, s4, 0, s4.length - 1, true), t2 && n6.insertPoint2D(r, -1, s4.at(-1));
}
function Lh2(e5, t2, s4, n6, r, i2, o2) {
  o2.reserve(o2.getPointCount() + i2.length - 1);
  const a2 = new ee();
  if (s4.queryStart(a2), e5 ? o2.startPathPoint(a2) : o2.lineToPoint(a2), i2.length > 2) {
    const e6 = n6.calculateLength2D();
    for (let t3 = 1; t3 < i2.length - 1; t3++) {
      const s5 = n6.lengthToT(r[t3] * e6);
      n6.queryCoord(s5, a2), a2.setXY(i2[t3]), o2.lineToPoint(a2);
    }
  }
  t2 && (s4.queryEnd(a2), o2.lineToPoint(a2));
}
function zh2(e5, t2, s4, n6, r, i2, o2, a2, h2, m2, l2, g2, u) {
  const c = { stack: [], error: void 0, hasError: false };
  try {
    const _ = n(c, new yc(), false), d2 = n(c, new yc(), false), p3 = n(c, new yc(), false);
    vc.geodeticDistance(e5, t2, n6.x, n6.y, r.x, r.y, p3, _, d2, s4);
    const f3 = p3.val, x4 = _.val, y2 = d2.val;
    let P5 = x4, E2 = y2;
    P5 < 0 && (P5 += 2 * Math.PI), E2 < 0 && (E2 += 2 * Math.PI), h2 && (h2[0] = P5), m2 && (m2[0] = E2);
    let C2 = Number.NaN, S3 = Number.NaN;
    if (null !== l2) {
      const s5 = Nc.q90(e5, t2), r2 = Nc.q(e5, t2, n6.y);
      C2 = (s5 - r2) / f3, S3 = (s5 + r2) / f3;
    }
    const I5 = Bh2(n6, r), b2 = Rh2(n6, r), w4 = I5 || b2, v3 = im2(n6, r, a2), N2 = n(c, new Gt(new yc(), new yc()), false), T3 = new ei(), G4 = new ei(), D3 = new ei();
    u[0] = tm2(n6.x, Number.NaN, u[0]);
    let V4 = u[0];
    if (f3 <= i2) return g2.push(n6.clone()), u[0] = tm2(r.x, Number.NaN, u[0]), null != l2 && l2.push(0), w4 ? (I5 && sm2(n6, r, l2, g2), b2 && nm2(n6, r, l2, g2)) : v3 ? rm2(n6, r, x4, C2, S3, l2, g2) : o2 > 0 && (G4.setCoords(n6.x - V4, n6.y), T3.setCoords(r.x - u[0], r.y), V4 = jh2()), g2.push(r.clone()), f3;
    const F3 = 1 + Math.ceil(f3 / i2), H3 = f3 / (F3 - 1), k4 = new ei();
    g2.push(n6.clone()), k4.setCoordsPoint2D(n6), G4.setCoords(n6.x - u[0], n6.y), null !== l2 && l2.push(0);
    for (let i3 = 1; i3 < F3; i3++) {
      let h3;
      if (i3 < F3 - 1) {
        const r2 = i3 * H3;
        vc.geodeticCoordinate(e5, t2, n6.x, n6.y, r2, x4, N2.at(0), N2.at(1), s4), T3.setCoords(N2.at(0).val, N2.at(1).val), u[0] = tm2(T3.x, k4.x, u[0]), D3.setCoords(u[0] + T3.x, T3.y), h3 = i3 / (F3 - 1);
      } else u[0] = tm2(r.x, Number.NaN, u[0]), T3.setCoords(r.x - u[0], r.y), D3.setCoordsPoint2D(r), h3 = 1;
      w4 ? (1 === i3 && I5 && sm2(n6, D3, l2, g2), i3 === F3 - 1 && b2 && nm2(k4, r, l2, g2)) : v3 ? om2(k4, D3, a2) && (n6.x < r.x ? k4.x > D3.x && (u[0] += 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)) : k4.x < D3.x && (u[0] -= 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)), rm2(k4, D3, x4, C2, S3, l2, g2)) : o2 > 0 && jh2(), g2.push(D3.clone()), null != l2 && l2.push(h3), k4.setCoordsPoint2D(D3), G4.setCoordsPoint2D(T3), V4 = u[0];
    }
    return f3;
  } catch (_) {
    c.error = _, c.hasError = true;
  } finally {
    s(c);
  }
}
function Wh2(e5, t2, n6, r, i2, o2, a2, h2, m2, l2) {
  n2(0);
}
function jh2(e5, t2, n6, r, i2, o2, a2, h2, m2, l2, g2, u, c, _, d2) {
  return n2(0), 0;
}
function Zh2(e5, t2, s4, n6) {
  const r = us3(e5, t2, s4), i2 = us3(e5, t2, n6);
  return X2.distance(r, i2);
}
function Kh2(e5, t2, n6, r, i2, o2, a2, h2) {
  const m2 = new Array(), l2 = Rt(Array, 8);
  let g2 = 2, u = i2.getCoord2D(o2);
  l2[0][0] = u.x, l2[0][1] = u.y, u = i2.getCoord2D(a2), l2[1][0] = u.x, l2[1][1] = u.y;
  const c = (e6) => {
    if (null !== n6) {
      const t3 = Cc.projToGeog(n6, e6, l2);
      n2(t3 === e6);
    }
    for (const t3 of l2) t3[0] *= r, t3[1] *= r;
  };
  c(2), m2.push(us3(e5, t2, new ei(l2[0][0], l2[0][1]))), m2.push(us3(e5, t2, new ei(l2[1][0], l2[1][1])));
  let _ = X2.distance(m2[0], m2[1]);
  if (_ > h2) return _;
  let d2 = 0;
  for (g2 = 3; g2 <= 17; ) {
    const n7 = 1 / (g2 - 1);
    let r2 = 0;
    for (let e6 = 1; e6 < g2; ++e6) if (1 & e6) {
      const t3 = Q(o2, a2, e6 * n7);
      i2.queryCoord2D(t3, u), l2[r2][0] = u.x, l2[r2][1] = u.y, r2++;
    }
    c(r2);
    let p3 = 1;
    for (let s4 = 0; s4 < r2; ++s4) m2.splice(p3, 0, us3(e5, t2, new ei(l2[s4][0], l2[s4][1]))), p3++;
    p3 = 0;
    let f3 = m2[p3];
    p3++;
    let x4 = 0;
    for (; p3 !== m2.length; ++p3) {
      const e6 = m2[p3];
      x4 += X2.distance(f3, e6), f3 = e6;
    }
    if (x4 > h2) return x4;
    if (d2 = x4 - _, n2(d2 >= 0 || Math.abs(d2) < 1e-14 * x4), d2 < 0 && (d2 = 0), _ = x4, x4 + d2 <= h2) return x4 + d2;
    g2 = 2 * g2 - 1;
  }
  return _ + d2;
}
function Qh2(e5, t2, n6, r, i2, o2, a2, h2, m2) {
  const l2 = r.isCurve(), g2 = Gs3(e5, t2) * Math.PI * 179 / 180;
  let u = o2;
  o2 > 0 && !(o2 > g2) || (u = g2);
  const c = a2, _ = c > 0;
  let d2 = Number.NaN;
  _ && (d2 = Ms3(e5, t2, c));
  const p3 = 1 === i2.getCoordinateSystemType();
  let f3 = null;
  p3 || (f3 = i2.getPECoordSys());
  const x4 = i2.getTolerance(0), y2 = r.getStartXY(), P5 = r.getEndXY(), E2 = new ei(), C2 = new ei();
  if (p3) E2.setCoordsPoint2D(y2), E2.scale(n6), C2.setCoordsPoint2D(P5), C2.scale(n6);
  else {
    const e6 = [y2.x, y2.y, P5.x, P5.y];
    Cc.projToGeog(f3, 2, e6), E2.setCoords(e6[0], e6[1]), E2.scale(n6), C2.setCoords(e6[2], e6[3]), C2.scale(n6);
  }
  let S3 = 0, I5 = 0;
  const b2 = [], w4 = [], v3 = [];
  b2.push(P5.clone()), w4.push(C2.clone()), v3.push(1), m2.push(y2.clone()), null !== h2 && h2.push(I5);
  const N2 = i2.isPannable(), T3 = y2.clone(), G4 = [0.5, 0.33333333333333337, 0.6666666666666666, 0.16666666666666669, 0.8333333333333333];
  let D3 = 5;
  l2 || (_ ? (G4[0] = 0.5, G4[1] = 0.25, G4[2] = 0.75, D3 = 3) : D3 = 1), n2(u > 0);
  const V4 = (e6) => {
    if (e6 = e6.clone(), null !== f3) {
      const t3 = [e6.x, e6.y];
      Cc.projToGeog(f3, 1, t3), e6.setCoords(t3[0], t3[1]);
    }
    return e6.scale(n6), e6;
  };
  for (; w4.length > 0; ) {
    const o3 = b2.at(-1).clone();
    C2.assign(w4.at(-1));
    const a3 = v3.at(-1);
    let g3 = false, c2 = Number.NaN;
    const y3 = Kh2(e5, t2, f3, n6, r, I5, a3, u);
    let P6 = u >= y3 && Math.abs(E2.y - C2.y) < 0.9 * Math.PI;
    p3 && P6 && (P6 = Math.abs(E2.x - C2.x) < 0.9 * Math.PI);
    const F3 = new ei(), H3 = new ei();
    let k4 = false;
    if (!_ && P6 && P6 && (k4 = true), r.calculateSubLength(I5, a3) <= x4 && (k4 = true), !k4) for (let h3 = 0; h3 < D3; h3++) {
      const m3 = Q(I5, a3, G4[h3]), u2 = new ei();
      r.queryCoord2D(m3, u2);
      const f4 = V4(u2);
      if (0 === h3 && (c2 = m3, F3.setCoordsPoint2D(u2), H3.setCoordsPoint2D(f4), !P6)) {
        g3 = true;
        break;
      }
      if (n2(_), p3 && Math.abs(E2.x - f4.x) >= Math.PI) {
        g3 = true;
        break;
      }
      let x5 = new ei(), y4 = new ei();
      l2 ? (x5 = ei.lerp(T3, o3, G4[h3]), y4 = V4(x5)) : (x5 = u2.clone(), y4 = f4.clone());
      const S4 = ys(e5, t2, E2, C2, G4[h3]), b3 = S4.clone();
      if (p3 ? (b3.x /= n6, b3.y /= n6) : (b3.x /= n6, b3.y /= n6, bh2(i2.getGCSToSRTransform(), [b3], 1, [b3], null)), b3.isNAN()) {
        const s4 = us3(e5, t2, f4), n7 = us3(e5, t2, E2), r2 = us3(e5, t2, C2), { first: i3, second: o4 } = Is3(e5, t2, s4, n7, r2, 2, null);
        if (o4 > d2) {
          g3 = true;
          break;
        }
      } else {
        if (N2) {
          const e6 = i2.getPannableExtent().width(), t3 = Q(r.getStartX(), r.getEndX(), 0.5);
          for (; b3.x < t3 - 0.5 * e6; ) b3.x += e6;
          for (; b3.x >= t3 + 0.5 * e6; ) b3.x -= e6;
        }
        const s4 = r.getClosestCoordinateOnInterval(b3, new x2(I5, a3), -1);
        let n7 = r.getCoord2D(s4);
        n7 = V4(n7);
        let o4 = Zh2(e5, t2, n7, S4);
        if (o4 > d2) {
          if (o4 < 4 * d2) {
            const s5 = us3(e5, t2, n7), r2 = us3(e5, t2, E2), i3 = us3(e5, t2, C2), { first: a4, second: h4 } = Is3(e5, t2, s5, r2, i3, 2, null);
            o4 = h4;
          }
          if (o4 > d2) {
            g3 = true;
            break;
          }
        } else if (l2) {
          let s5 = us3(e5, t2, f4);
          const n8 = us3(e5, t2, E2), r2 = us3(e5, t2, C2);
          let { second: i3 } = Is3(e5, t2, s5, n8, r2, 3, null);
          if (i3 <= d2) {
            s5 = us3(e5, t2, y4);
            const { first: o5, second: a4 } = Is3(e5, t2, s5, n8, r2, 3, null);
            i3 = a4;
          }
          if (i3 > d2) {
            g3 = true;
            break;
          }
        }
      }
    }
    g3 ? (b2.push(F3.clone()), w4.push(H3.clone()), v3.push(c2)) : (b2.pop(), w4.pop(), v3.pop(), m2.push(o3.clone()), S3 += y3, null !== h2 && h2.push(S3), T3.setCoordsPoint2D(o3), E2.setCoordsPoint2D(C2), I5 = a3);
  }
  if (null !== h2) {
    const e6 = 1 / S3;
    for (let t3 = 0; t3 < h2.length; t3++) h2[t3] *= e6;
  }
}
function Jh2(e5, t2, s4, n6) {
  if (n6.reverse(), null !== s4 && s4.reverse(), e5) {
    const s5 = e5[0], n7 = t2[0];
    e5[0] = n7, t2[0] = s5;
  }
}
function $h2(e5, t2, s4, n6, r) {
  e5 ? (n6.setCoordsPoint2D(s4), r.setCoordsPoint2D(t2)) : (n6.setCoordsPoint2D(t2), r.setCoordsPoint2D(s4));
}
function em2(e5, t2, s4) {
  return e5 ? (s4.create(t2.getGeometryType()), t2.copyTo(s4.get()), s4.get().reverse(), s4.get()) : t2;
}
function tm2(e5, t2, s4) {
  if (Number.isNaN(t2)) {
    for (; s4 - e5 > Math.PI; ) s4 -= 2 * Math.PI;
    for (; e5 - s4 > Math.PI; ) s4 += 2 * Math.PI;
    return s4;
  }
  return s4 + e5 - t2 > Math.PI ? s4 -= 2 * Math.PI : t2 - (s4 + e5) > Math.PI && (s4 += 2 * Math.PI), s4;
}
function sm2(e5, t2, s4, n6) {
  if (e5.y > 0) {
    const r = new ei();
    r.setCoords(t2.x, Yt), pc(e5.x, r.x) || pc(t2.y, r.y) || (n6.push(r), null !== s4 && s4.push(0));
  } else {
    const r = new ei();
    r.setCoords(t2.x, -Yt), pc(e5.x, r.x) || pc(t2.y, r.y) || (n6.push(r), null !== s4 && s4.push(0));
  }
}
function nm2(e5, t2, s4, n6) {
  if (t2.y > 0) {
    const r = new ei();
    r.setCoords(e5.x, Yt), pc(t2.x, r.x) || pc(e5.y, r.y) || (n6.push(r), null !== s4 && s4.push(1));
  } else {
    const r = new ei();
    r.setCoords(e5.x, -Yt), pc(t2.x, r.x) || pc(e5.y, r.y) || (n6.push(r), null !== s4 && s4.push(1));
  }
}
function rm2(e5, t2, s4, n6, r, i2, o2) {
  if (xc(s4)) {
    if (Yt - e5.y > 0) {
      const t3 = new ei();
      t3.setCoords(e5.x, Yt), o2.push(t3), null !== i2 && i2.push(n6);
    }
    if (Yt - t2.y > 0) {
      const e6 = new ei();
      e6.setCoords(t2.x, Yt), o2.push(e6), null !== i2 && i2.push(n6);
    }
  } else {
    if (Yt + e5.y > 0) {
      const t3 = new ei();
      t3.setCoords(e5.x, -Yt), o2.push(t3), null !== i2 && i2.push(r);
    }
    if (Yt + t2.y > 0) {
      const e6 = new ei();
      e6.setCoords(t2.x, -Yt), o2.push(e6), null !== i2 && i2.push(r);
    }
  }
}
function im2(e5, t2, s4) {
  return !(!om2(e5, t2, s4) || pc(e5.y, Yt) || pc(e5.y, -Yt) || pc(t2.y, Yt) || pc(t2.y, -Yt));
}
function om2(e5, t2, s4) {
  return Math.abs(Math.abs(e5.x - t2.x) - Math.PI) <= s4;
}
function am2(e5) {
  if (e5.x < -Math.PI) for (; e5.x < -Math.PI; ) e5.x += 2 * Math.PI;
  else if (e5.x > Math.PI) for (; e5.x > Math.PI; ) e5.x -= 2 * Math.PI;
}
function hm2(e5, t2, s4, n6) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = [s4.x], o2 = [s4.y - n6], a2 = [s4.x], h2 = [s4.y + n6];
    Ts3(i2, o2), Ts3(a2, h2);
    const m2 = n(r, new yc(), false), l2 = n(r, new yc(), false);
    vc.greatEllipticDistance(e5, t2, s4.x, s4.y, i2[0], o2[0], m2, null, null), vc.greatEllipticDistance(e5, t2, s4.x, s4.y, a2[0], h2[0], l2, null, null);
    return Math.min(m2.val, l2.val);
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    s(r);
  }
}
function mm2(t2, s4, n6, r, i2) {
  const o2 = new n4();
  n6.queryEnvelope(o2);
  const a2 = zt2(null, n6, true).total();
  if (s4.xmin - o2.xmin <= a2 && o2.xmax - s4.xmax <= a2) return n6;
  const h2 = s4.width();
  let m2 = 0;
  for (; s4.xmin + m2 * h2 < o2.xmin; ) m2++;
  for (; s4.xmin + m2 * h2 > o2.xmin; ) m2--;
  const l2 = m2 * h2, g2 = new x3();
  g2.setShiftCoords(-l2, 0);
  const u = n6;
  u.applyTransformation(g2);
  const c = new n4();
  u.queryEnvelope(c);
  let _ = null;
  if (c.xmax > s4.xmax) {
    let n7 = 0;
    const r2 = new n4();
    r2.setCoords({ env2D: s4 }), r2.ymin -= 1, r2.ymax += 1;
    let o3 = u;
    for (; r2.xmin < c.xmax; ) {
      c.xmax > r2.xmax && (o3 = Gl(o3, t2, 2, true, r2.xmax));
      const e5 = Dt2(o3, r2), a3 = wt2(null, e5, true).total(), m3 = f2(o3, r2, a3, Number.NaN, i2);
      null === _ ? _ = m3 === o3 ? m3.clone() : m3 : (g2.setShiftCoords(-n7 * h2, 0), m3.applyTransformation(g2), _.add(m3, false)), n7++, r2.xmin = r2.xmax, r2.xmax = s4.xmax + n7 * h2;
    }
  } else _ = u;
  return _;
}
var lm2 = class {
  constructor(e5, t2) {
    this.m_basisX = new X2(), this.m_basisY = new X2(), this.m_normal = new X2(), n2(1 === e5.getCoordinateSystemType()), this.m_gcs = e5;
    const n6 = Gu();
    e5.querySpheroidData(n6), this.m_a = n6.majorSemiAxis, this.m_e2 = n6.e2, this.m_rpu = e5.getUnit().getUnitToBaseFactor(), this.m_curvCenterRad = t2.mul(this.m_rpu);
    const r = this.m_curvCenterRad.x, i2 = this.m_curvCenterRad.y, o2 = Math.cos(r), a2 = Math.sin(r), h2 = Math.cos(i2), m2 = Math.sin(i2);
    this.m_cartCenter3D = _s2(this.m_a, this.m_e2, o2, a2, h2, m2), this.m_normal.setCoordsPoint3D(this.m_cartCenter3D), this.m_d = this.m_cartCenter3D.length(), this.m_normal.divThis(this.m_d), X2.selectRightHandedBasisFromNormal(this.m_normal, this.m_basisX, this.m_basisY), this.m_northPolePcs = this.projectPoint(ei.construct(0, 0.5 * Math.PI / this.m_rpu)), this.m_southPolePcs = this.projectPoint(ei.construct(0, 0.5 * -Math.PI / this.m_rpu));
  }
  project(e5) {
    const s4 = e5.getGeometryType();
    if (y(s4)) {
      N(e5);
      const t2 = e5;
      return this.projectMultiVertex(t2);
    }
    P("Gnomonic.project");
  }
  unproject(e5, s4, r) {
    const i2 = e5.getGeometryType();
    if (y(i2)) {
      N(e5);
      let t2 = e5;
      const a2 = [];
      if (i2 === a.enumPolygon) {
        const e6 = t2.getPathCount();
        for (let s5 = 0; s5 < e6; s5++) {
          const e7 = t2.calculateRingArea2D(s5);
          a2.push(e7);
        }
      }
      return this.unprojectMultiVertex(s4, t2), h(i2) ? (ym2(this.m_gcs, 0, t2), gm2(a2, this.m_gcs, 0, t2, r)) : t2 = Sl(t2, this.m_gcs, 0, true, 0, r), t2;
    }
    P("Gnomonic.unproject");
  }
  projectPoint(e5) {
    const t2 = e5.mul(this.m_rpu), s4 = us3(this.m_a, this.m_e2, t2), n6 = this.m_normal.dotProduct(s4);
    if (n6 <= 0) return ei.construct(Number.NaN, Number.NaN);
    const r = this.m_d / n6, i2 = s4.mul(r).sub(this.m_cartCenter3D), o2 = new ei();
    return o2.x = this.m_basisX.dotProduct(i2), o2.y = this.m_basisY.dotProduct(i2), o2;
  }
  unprojectPoint(e5) {
    const t2 = this.m_cartCenter3D.add(this.m_basisX.mul(e5.x).add(this.m_basisY.mul(e5.y)));
    return fs2(this.m_a, this.m_e2, t2).divide(this.m_rpu);
  }
  projectMultiVertex(e5) {
    const t2 = e5.getImpl();
    let s4 = true;
    const n6 = new ei(), r = new ei();
    for (let i2 = 0, o2 = t2.getPointCount(); i2 < o2; i2++) t2.queryXY(i2, n6), n6.y * this.m_rpu > 0.5 * Math.PI ? r.assign(this.m_northPolePcs) : n6.y * this.m_rpu < 0.5 * -Math.PI ? r.assign(this.m_southPolePcs) : r.assign(this.projectPoint(n6)), t2.setXY(i2, r), r.isNAN() && (s4 = false);
    return t2.notifyModifiedFlags(2001), s4;
  }
  unprojectMultiVertex(e5, t2) {
    const s4 = t2.getImpl(), n6 = e5 * e5, r = !this.m_northPolePcs.isNAN(), i2 = !this.m_southPolePcs.isNAN();
    for (let o2 = 0, a2 = s4.getPointCount(); o2 < a2; o2++) {
      const e6 = s4.getXY(o2);
      let t3 = new ei();
      r && ei.sqrDistance(e6, this.m_northPolePcs) <= n6 ? (t3.setCoords(this.m_curvCenterRad.x, 0.5 * Math.PI), t3.scale(1 / this.m_rpu)) : i2 && ei.sqrDistance(e6, this.m_southPolePcs) <= n6 ? (t3.setCoords(this.m_curvCenterRad.x, 0.5 * -Math.PI), t3.scale(1 / this.m_rpu)) : t3 = this.unprojectPoint(e6), s4.setXY(o2, t3);
    }
    s4.notifyModifiedFlags(2001);
  }
};
function gm2(t2, s4, n6, r, i2) {
  const a2 = r.getGeometryType(), h2 = s4.getPannableExtent();
  let m2 = r, l2 = false, g2 = false;
  if (a2 === a.enumPolygon) {
    const r2 = new n4(), o2 = ei.construct(n6, 0);
    r2.setCoords({ env2D: h2 }), r2.centerAt(o2), l2 = um2(t2, s4, r2, m2, i2);
    const a3 = xm2(s4, r2, m2, i2);
    a3 !== m2 && (g2 = true), m2 = a3;
  } else m2 = new kh2().foldInto360RangeGeodetic(m2, s4, 2);
  a2 === a.enumPolygon && (l2 || g2) && (m2 = new fh2().execute(m2, s4, false, i2)), m2 !== r && (r.setEmpty(), r.add(m2, false));
}
function um2(e5, t2, s4, n6, r) {
  const i2 = cm2(s4, n6), o2 = _m2(e5, t2, s4, n6, r);
  return i2 || o2;
}
function cm2(t2, s4) {
  const n6 = new n4();
  s4.queryEnvelope(n6);
  const r = pc(t2.ymax, n6.ymax), i2 = pc(t2.ymin, n6.ymin), o2 = r || i2;
  return !!o2 && (dm2(t2, s4), o2);
}
function _m2(e5, t2, s4, n6, r) {
  const i2 = [], o2 = [], a2 = 0.5 * s4.width();
  for (let g2 = 0; g2 < n6.getPathCount(); g2++) {
    const h3 = n6.getXY(n6.getPathStart(g2)), m3 = n6.getXY(n6.getPathEnd(g2) - 1), l3 = e5[g2] < 0;
    if (Math.abs(h3.x - m3.x) > a2) {
      const e6 = pm2(l3, t2, s4, g2, n6, r);
      i2.push(e6), o2.push(g2);
    } else if (!l3) {
      if (n6.calculateRingArea2D(g2) < 0) {
        const e6 = fm2(t2, s4, g2, n6, r);
        i2.push(e6), o2.push(g2);
      }
    }
  }
  if (0 === i2.length) return false;
  const h2 = new eh({ vd: n6.getDescription() });
  let m2 = 0, l2 = o2[m2];
  for (let g2 = 0; g2 < n6.getPathCount(); g2++) g2 === l2 ? (h2.add(i2[m2], false), m2++, m2 < o2.length && (l2 = o2[m2])) : h2.addPath(n6, g2, true);
  return n6.setEmpty(), n6.add(h2, false), true;
}
function dm2(t2, s4) {
  const n6 = new eh(), r = new n4();
  for (let e5 = 0; e5 < s4.getPathCount(); e5++) {
    s4.queryPathEnvelope(e5, r);
    let i2 = pc(t2.ymax, r.ymax), o2 = pc(t2.ymin, r.ymin);
    if (!(i2 || o2)) {
      n6.addPath(s4, e5, true);
      continue;
    }
    n6.insertPath2D(-1, null, 0, 0, true);
    const a2 = s4.getPathStart(e5), h2 = s4.getPathEnd(e5), m2 = h2 - a2;
    let l2 = -1;
    for (l2 = a2; l2 < h2; l2++) {
      const e6 = s4.getXY(l2);
      if (i2 = pc(t2.ymax, e6.y), o2 = pc(t2.ymin, e6.y), !i2 && !o2) break;
    }
    let g2 = l2, u = false, c = Number.NaN;
    do {
      const r2 = s4.getXY(g2);
      i2 = pc(t2.ymax, r2.y), o2 = pc(t2.ymin, r2.y);
      const h3 = a2 + (g2 + 1 - a2) % m2;
      if (i2 || o2) {
        let i3 = ei.construct(c, r2.y);
        n6.insertPoint2D(e5, -1, i3);
        const o3 = s4.getXY(h3), a3 = pc(t2.ymax, o3.y), m3 = pc(t2.ymin, o3.y);
        a3 || m3 || (i3 = ei.construct(o3.x, r2.y), u ? n6.setXY(n6.getPointCount() - 1, i3) : n6.insertPoint2D(e5, -1, i3)), u = true;
      } else n6.insertPoint2D(e5, -1, r2), c = r2.x, u = false;
      g2 = h3;
    } while (g2 !== l2);
  }
  s4.setEmpty(), s4.add(n6, false);
}
function pm2(t2, s4, n6, r, i2, o2) {
  const a2 = new eh(), h2 = new eh(), m2 = new x3(), l2 = i2.getXY(i2.getPathStart(r)), g2 = i2.getXY(i2.getPathEnd(r) - 1), u = n6.width(), c = 0.5 * u, _ = new n4();
  i2.queryEnvelope(_);
  const d2 = Math.ceil(_.width() / u) + 1;
  let p3, f3;
  l2.x > g2.x ? (p3 = -u, f3 = t2 ? n6.ymin : n6.ymax) : (p3 = u, f3 = t2 ? n6.ymax : n6.ymin), m2.setShiftCoords(p3, 0), a2.addPath(i2, r, true), h2.add(a2, false);
  const x4 = new ee();
  for (let e5 = 0; e5 < d2; e5++) h2.applyTransformation(m2), h2.getPointByVal(0, x4), a2.lineToPoint(x4), a2.addSegmentsFromPath(h2, 0, 0, h2.getSegmentCount() - 1, false);
  const y2 = a2.getXY(0), P5 = a2.getXY(a2.getPointCount() - 1);
  y2.y = f3, P5.y = f3, a2.lineTo(P5);
  const E2 = new ei();
  for (E2.setCoordsPoint2D(P5), E2.x -= 0.5 * p3; Math.abs(E2.x - y2.x) > c; ) a2.lineTo(E2), E2.x -= 0.5 * p3;
  a2.lineTo(y2);
  const C2 = n6.getCenter().x, S3 = new n4();
  a2.queryEnvelope(S3);
  let b2 = 0;
  const w4 = S3.getCenter().x;
  w4 - C2 > c ? b2 = -Math.ceil((w4 - C2 - c) / u) : C2 - w4 > c && (b2 = Math.ceil((C2 - w4 - c) / u)), 0 !== b2 && (m2.setShiftCoords(b2 * u, 0), a2.applyTransformation(m2));
  const v3 = new Tm(), N2 = v3.addGeometry(a2);
  Dl(v3, N2, s4, 0, 2, true, n6.xmin), Dl(v3, N2, s4, 0, 2, true, n6.xmax);
  const G4 = v3.getGeometry(N2), D3 = Dt2(G4, n6);
  D3.inflateCoords(0, 1);
  const V4 = wt2(null, D3, true);
  return f2(G4, n6, V4.total(), Number.NaN, o2);
}
function fm2(t2, s4, n6, r, i2) {
  const o2 = s4.width(), a2 = 0.5 * o2, h2 = s4.getCenter().x, m2 = new n4();
  r.queryPathEnvelope(n6, m2);
  let l2, g2 = 0, u = m2.getCenter().x;
  if (u - h2 > a2 ? g2 = -Math.ceil((u - h2 - a2) / o2) : h2 - u > a2 && (g2 = Math.ceil((h2 - u - a2) / o2)), 0 !== g2) {
    const e5 = new x3();
    e5.setShiftCoords(g2 * o2, 0), r.getImpl().applyTransformationToPath(e5, n6), r.queryPathEnvelope(n6, m2), u = m2.getCenter().x;
  }
  const c = new n4();
  s4.containsExclusiveEnvelope(m2) ? (l2 = false, c.setCoords({ env2D: s4 })) : (l2 = true, c.setCoords({ env2D: s4 }), c.xmin -= o2, c.xmax += o2);
  let _ = r.createInstance();
  _.addPathPoint2D(null, 0, true);
  const d2 = new ei();
  if (d2.setCoords(c.xmin, c.ymin), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmin, c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(0.5 * (c.xmin + c.xmax), c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmax, c.ymax), _.insertPoint2D(0, -1, d2), d2.setCoords(c.xmax, c.ymin), _.insertPoint2D(0, -1, d2), d2.setCoords(0.5 * (c.xmin + c.xmax), c.ymin), _.insertPoint2D(0, -1, d2), l2) {
    _.addPath(r, n6, true);
    const e5 = new x3();
    u < h2 ? e5.setShiftCoords(o2, 0) : e5.setShiftCoords(-o2, 0), r.getImpl().applyTransformationToPath(e5, n6), _.addPath(r, n6, true);
    const a3 = new Tm(), m3 = a3.addGeometry(_);
    Dl(a3, m3, t2, 0, 2, true, s4.xmin), Dl(a3, m3, t2, 0, 2, true, s4.xmax), _ = a3.getGeometry(m3);
    const l3 = Dt2(_, s4);
    l3.inflateCoords(0, 1);
    const g3 = wt2(null, l3, true).total();
    _ = f2(_, s4, g3, Number.NaN, i2);
  } else _.addPath(r, n6, true);
  return _;
}
function xm2(t2, s4, n6, r) {
  const i2 = new n4();
  n6.queryEnvelope(i2);
  const o2 = zt2(null, n6, true).total();
  if (s4.xmin - i2.xmin <= o2 && i2.xmax - s4.xmax <= o2) return n6;
  const a2 = n6.createInstance();
  let h2 = n6.createInstance();
  const m2 = new n4(), l2 = n6.getPathCount();
  for (let e5 = 0; e5 < l2; e5++) n6.queryPathEnvelope(e5, m2), s4.xmin - m2.xmin <= o2 && m2.xmax - s4.xmax <= o2 ? a2.addPath(n6, e5, true) : (h2.setEmpty(), h2.addPath(n6, e5, true), h2 = mm2(t2, s4, h2, true, r), a2.add(h2, true));
  return a2;
}
function ym2(e5, t2, s4) {
  const n6 = e5.getPannableExtent(), r = ei.construct(t2, 0);
  n6.centerAt(r);
  const i2 = n6.width(), o2 = 0.5 * i2, a2 = new ei();
  a2.setNAN();
  let h2 = Number.NaN;
  for (let m2 = 0; m2 < s4.getPathCount(); m2++) for (let e6 = s4.getPathStart(m2); e6 < s4.getPathEnd(m2); e6++) {
    const t3 = s4.getXY(e6), r2 = pc(t3.y, n6.ymax) || pc(n6.ymin, t3.y);
    e6 === s4.getPathStart(m2) ? (a2.setNAN(), h2 = 0) : a2.isNAN() || r2 || (h2 = Pm2(t3.x, a2.x, o2, i2, h2)), t3.x += h2, s4.setXY(e6, t3), r2 || a2.setCoordsPoint2D(t3);
  }
  s4.getImpl().notifyModifiedFlags(2001);
}
function Pm2(e5, t2, s4, n6, r) {
  return r + e5 - t2 > s4 ? r -= n6 : t2 - (r + e5) > s4 && (r += n6), r;
}
function Em2(e5, t2, s4, n6, r, i2) {
  const o2 = t2.getAttributeStreamRef(0), a2 = t2.getPointCount();
  let h2 = false;
  const m2 = new ei();
  for (let P5 = 0; P5 < a2; ++P5) {
    if (o2.queryPoint2D(2 * P5, m2), 1 & i2 && m2.y >= s4) {
      h2 = true;
      break;
    }
    if (2 & i2 && m2.y <= -s4) {
      h2 = true;
      break;
    }
  }
  if (!h2) return false;
  let l2 = false;
  e5 && (l2 = t2.getImpl().isClosedPathInXYPlane(0));
  const g2 = new Tm(), u = g2.addGeometry(t2), c = g2.getFirstPath(u);
  let _ = -1, d2 = true;
  const p3 = new ei(), f3 = new ee();
  let x4 = bm;
  const y2 = wm2 * r / 360;
  for (let P5 = g2.getFirstVertex(c); P5 !== bm; P5 = g2.getNextVertex(P5)) {
    g2.queryXY(P5, m2);
    let e6 = 1 & i2 && m2.y >= s4 ? 1 : 0;
    if (e6 |= 2 & i2 && m2.y <= -s4 ? 2 : 0, _ > 0 && _ !== e6) {
      if (p3.x !== m2.x) {
        const e7 = g2.getPrevVertex(P5);
        g2.queryPoint(e7, f3);
        const t3 = g2.insertVertex(c, P5, f3);
        p3.x = m2.x, g2.setXY(t3, p3);
      }
      if (l2) {
        let e7 = x4 !== bm ? g2.getNextVertex(x4) : g2.getFirstVertex(c);
        const t3 = g2.getPrevVertex(P5);
        for (; e7 !== t3; ) e7 = g2.removeVertex(e7, false);
        if (x4 !== bm) {
          const e8 = g2.getXY(x4), s5 = g2.getXY(t3);
          if (Math.abs(e8.x - s5.x) > y2) {
            g2.queryPoint(x4, f3);
            const n7 = g2.insertVertex(c, t3, f3);
            e8.x = Q(e8.x, s5.x, 0.5), g2.setXY(n7, e8);
          }
        }
      }
      x4 = bm;
    }
    if (e6 && (m2.y = B2(n6, m2.y), g2.setXY(P5, m2), !d2 && _ !== e6)) if (m2.x !== p3.x) {
      g2.queryPoint(P5, f3);
      const e7 = g2.insertVertex(c, P5, f3);
      g2.setXYCoords(e7, p3.x, m2.y), x4 = e7;
    } else x4 = P5;
    _ = e6, p3.assign(m2), d2 = false;
  }
  if (l2) {
    if (x4 !== bm) {
      let e7 = g2.getNextVertex(x4);
      for (; e7 !== bm; ) e7 = g2.removeVertex(e7, false);
    }
    const e6 = g2.getFirstVertex(c);
    let t3 = g2.getLastVertex(c);
    const s5 = g2.getXY(e6), n7 = g2.getXY(t3);
    if (!s5.equals(n7) && (g2.queryPoint(e6, f3), t3 = g2.insertVertex(c, bm, f3), Math.abs(s5.x - n7.x) > y2)) {
      const e7 = g2.insertVertex(c, t3, f3);
      s5.x = Q(s5.x, n7.x, 0.5), g2.setXY(e7, s5);
    }
  }
  return t2.assignCopy(g2.getGeometry(u)), true;
}
function Cm2(e5, t2) {
  let s4 = new eh({ vd: e5 });
  s4.addEnvelope(t2, false);
  const n6 = t2.width() / 180;
  return s4 = new o().execute(s4, n6, 0, 0, null), s4;
}
function Sm2(e5, t2) {
  const s4 = e5.getPannableExtent();
  return Number.isNaN(t2) || s4.centerAtCoords(t2, 0), s4;
}
function Im2(e5, t2, s4) {
  const n6 = Gu();
  t2.querySpheroidData(n6);
  const r = t2.getGCS() !== t2 ? t2.getSRToGCSTransform() : null, i2 = Rt(ei, 100), o2 = new X2(0, 0, 0), a2 = e5.getPointCount(), h2 = t2.getGCS().getUnit().getUnitToBaseFactor();
  for (let u = 0, c = a2; u < c; ) {
    const t3 = Math.min(100, c - u);
    e5.queryCoordinates(i2, t3, u, u + t3), r && new kh2().transform(r, i2, t3, i2, false);
    for (let e6 = 0; e6 < t3; e6++) {
      if (i2[e6].isNAN()) continue;
      i2[e6].scale(h2);
      const t4 = us3(n6.majorSemiAxis, n6.e2, i2[e6]);
      o2.addThis(t4);
    }
    u += t3;
  }
  const m2 = fs2(n6.majorSemiAxis, n6.e2, o2);
  m2.scale(1 / h2);
  const l2 = e5;
  if (!new lm2(t2.getGCS(), m2).project(l2)) return 0;
  s4.length = e5.getPathCount();
  const g2 = l2.calculateArea2D() < 0;
  for (let u = 0, c = e5.getPathCount(); u < c; u++) {
    const e6 = l2.calculateRingArea2D(u), t3 = g2 ? e6 < 0 : e6 > 0;
    s4[u] = t3;
  }
  return g2 ? -1 : 1;
}
function bm2(e5, t2, s4, n6, r) {
  if (!t2.isPannable() || e5.isEmpty()) return e5;
  const i2 = e5.getGeometryType();
  i2 === a.enumGeometryCollection && z("not yet impl for geometry collection");
  const a2 = t2.getPannableExtent();
  Number.isNaN(s4) && (s4 = a2.getCenterX());
  const h2 = a2.width(), u = 0.5 * h2, c = r > 0, _ = e5.queryInterval(0, 0);
  if (!c && _.width() < u || !y(e5.getGeometryType())) {
    const t3 = _.getCenter();
    if (Math.abs(t3 - s4) <= u) return e5;
    {
      const n7 = new x3(), r2 = S((s4 - t3) / h2) * h2;
      n7.setShiftCoords(r2, 0);
      const i3 = e5.clone();
      return i3.applyTransformation(n7), i3;
    }
  }
  if (i2 === a.enumPolygon) {
    let i3 = new Na({ vd: e5.getDescription() });
    i3.addAndExplicitlyOpenAllPaths(e5, false), c && (i3 = Mh2(i3, t2, 2, r, Number.NaN, null, true));
    const o2 = [];
    if (!n6) {
      {
        let s5 = e5;
        c && (s5 = new eh(), s5.add(i3, false));
        const n7 = Im2(e5, t2, o2);
        if (n7) n7 < 0 && i3.reverseAllPaths();
        else {
          const e6 = s5.getPathCount();
          for (let t3 = 0; t3 < e6; t3++) o2.push(s5.calculateRingArea2D(t3) > 0);
        }
      }
      n6 = o2;
    }
    return new vm2(null, n6, i3, null, t2, s4, 3, 0, null).geoNormalizePolygonGeometry(true);
  }
  if (i2 === a.enumPolyline) {
    let n7 = new Na({ vd: e5.getDescription() });
    n7.addAndExplicitlyOpenAllPaths(e5, false), c && (n7 = Mh2(n7, t2, 2, r, Number.NaN, null, true));
    return new vm2(null, null, n7, null, t2, s4, 3, 0, null).geoNormalizePolylineGeometry(true);
  }
  if (i2 === a.enumMultiPoint) {
    const t3 = e5, n7 = t3.getAttributeStreamRef(0);
    let r2, i3 = null, o2 = s4, a3 = 0;
    const m2 = 0.1 * h2;
    for (let s5 = 0, l2 = t3.getPointCount(); s5 < l2; s5++) {
      const t4 = n7.read(2 * s5);
      let l3 = t4 - o2;
      if (Math.abs(l3) > u && (l3 = S(l3 / h2) * h2, a3 -= l3, Math.abs(a3) < m2 && (a3 = 0)), 0 !== a3) {
        i3 || (r2 = e5.clone(), i3 = r2.getAttributeStreamRef(0));
        const n8 = t4 + a3;
        i3.write(2 * s5, n8);
      }
      o2 = t4;
    }
    return i3 ? (r2.notifyModified(), r2) : e5;
  }
  b("");
}
var wm2 = 210;
var vm2 = class {
  constructor(e5, t2, n6, r, i2, o2, a2, h2, m2) {
    this.m_bAdjustedAtPoles = 0, this.m_inputPoly = n6, this.m_progressTracker = m2, this.m_originalGeometry = e5, this.m_originalSR = r, this.m_polygonRingFlags = t2, this.m_pannableSR = i2, this.m_poleSnappingTolerance = h2, this.m_poleFlags = a2, this.m_bAdjustedAtPoles = 0, this.m_pannableExtent = Sm2(this.m_pannableSR, o2), this.m_centralLongitude = Number.isNaN(o2) ? this.m_pannableExtent.getCenterX() : o2, this.m_width360 = this.m_pannableExtent.width(), this.m_degree = this.m_width360 / 360, this.m_GCSLargeDelta = wm2 * this.m_degree, n2(null === this.m_originalGeometry && null === this.m_originalSR || null !== this.m_originalGeometry && null !== this.m_originalSR);
  }
  geonormalizeRing(e5, t2, n6, r, i2, o2, a2) {
    let h2 = n6;
    const m2 = new Na({ vd: this.m_inputPoly.getDescription() });
    m2.addPath(this.m_inputPoly, e5, true), 0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= Em2(true, m2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, this.m_pannableExtent.width(), this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (h2 = false));
    let l2 = -1;
    h2 && (l2 = this.m_originalGeometry.getPathStart(e5));
    const u = m2.getAttributeStreamRef(0), c = m2.getPointCount();
    let _ = 0, d2 = u.read(0), p3 = 0;
    const f3 = 3 * this.m_pannableSR.getTolerance(0);
    let x4 = false;
    const y2 = new ei(), P5 = new ei();
    let E2 = false;
    const C2 = m2.hasNonLinearSegments(), S3 = new ei();
    for (let s4 = 1; s4 < c; ++s4) {
      u.queryPoint2D(2 * s4, S3);
      const e6 = S3.x;
      let t3 = e6 + _;
      const n7 = t3 - d2;
      if (S3.x = t3, Math.abs(n7) > this.m_GCSLargeDelta) {
        if (h2) {
          const e7 = l2 + s4 - 1, t4 = l2 + (s4 + 1 < c ? s4 : 0), i3 = o2.read(2 * e7), a3 = (o2.read(2 * t4) - i3) * r;
          Math.abs(n7 - a3) > 1 * this.m_degree && (h2 = false);
        }
        if (!h2) {
          _ -= B2(this.m_width360, t3 - d2), t3 = e6 + _, ++p3, E2 = 0 !== _, S3.x = t3;
        }
      } else x4 || Et2(y2, P5, S3, f3) && (x4 = true);
      E2 && (C2 && b("error in geonormalize_ring_ for curves"), u.write(2 * s4, t3)), d2 = t3, y2.setCoordsPoint2D(P5), P5.setCoordsPoint2D(S3);
    }
    p3 && m2.notifyModified();
    const I5 = m2.getXY(0), w4 = m2.getXY(c - 1);
    if (ei.distance(I5, w4) < f3) {
      const e6 = this.finalizeGeoNormalizeClosedRing(m2, x4, i2);
      a2.add(e6, false);
    } else {
      if (t2 < 0) if (null !== this.m_originalGeometry) {
        n2(null !== this.m_originalGeometry);
        t2 = this.m_originalGeometry.calculateRingArea2D(e5) > 0 ? 1 : 0;
      } else t2 = 1;
      const n7 = this.finalizeGeoNormalizeOpenedRing(t2 > 0, m2);
      a2.add(n7, false);
    }
  }
  geoNormalizePolygonGeometry(t2) {
    n2(this.m_originalSR && this.m_originalGeometry || !this.m_originalGeometry && !this.m_originalSR), n2(this.m_pannableSR.isPannable());
    let n6 = null, r = Number.NaN;
    const i2 = !!this.m_originalSR && this.m_originalSR.isPannable();
    i2 && (n6 = this.m_originalGeometry.getAttributeStreamRef(0), r = this.m_width360 / this.m_originalSR.getPannableExtent().width()), this.m_bAdjustedAtPoles = 0;
    const o2 = new eh({ vd: this.m_inputPoly.getDescription() });
    for (let e5 = 0, s4 = this.m_inputPoly.getPathCount(); e5 < s4; ++e5) {
      const s5 = this.m_polygonRingFlags ? this.m_polygonRingFlags[e5] ? 1 : 0 : -1;
      this.geonormalizeRing(e5, s5, i2, r, t2, n6, o2);
    }
    const a2 = this.m_pannableSR.getTolerance(0), h2 = this.m_pannableExtent.width() / 180;
    Ml(o2, this.m_pannableExtent, 0.1 * a2, false);
    const m2 = n4.constructEmpty();
    if (m2.setCoords({ env2D: this.m_pannableExtent }), t2) {
      let t3 = true;
      for (let s4 = 0; s4 < 2; s4++) {
        t3 = true;
        const s5 = n4.constructEmpty();
        for (let e5 = 0, n7 = o2.getPathCount(); e5 < n7; e5++) if (o2.queryPathEnvelope(e5, s5), !(m2.xmin <= s5.xmin && m2.xmax >= s5.xmax || s5.xmin >= m2.xmax || s5.xmax <= m2.xmin)) {
          t3 = false;
          break;
        }
        if (t3) break;
        m2.move(0.5 * this.m_width360, 0);
      }
      t3 || m2.setCoords({ env2D: this.m_pannableExtent });
    }
    let l2 = f2(o2, m2, a2, h2, this.m_progressTracker), g2 = o2 !== l2;
    const u = this.m_originalGeometry ? this.m_originalGeometry.calculateArea2D() : 1, c = l2.calculateArea2D();
    let _ = 0;
    if (c > 0 && u < 0) _ = 1;
    else if (c <= 0 && u > 0) if (0 === c) {
      if (this.m_originalSR) {
        let e5 = Number.NaN;
        2 === this.m_originalSR.getCoordinateSystemType() ? e5 = this.m_originalSR.getPCSHorizon().calculateArea2D() : 1 === this.m_originalSR.getCoordinateSystemType() && (e5 = this.m_originalSR.getPannableExtent().getArea()), u > 0.99 * e5 && (_ = -1);
      }
    } else _ = -1;
    if (0 !== _) {
      const e5 = Cm2(l2.getDescription(), m2);
      e5.add(l2, false), g2 = true, l2 = e5;
    }
    return g2 && (l2 = new fh2().execute(l2, this.m_pannableSR, false, this.m_progressTracker)), l2;
  }
  geoNormalizePolylineGeometry(t2) {
    n2(this.m_pannableSR.isPannable());
    let n6 = null;
    const r = this.m_originalSR && this.m_originalSR.isPannable();
    let i2 = 1;
    r && (n2(this.m_originalGeometry), i2 = this.m_width360 / this.m_originalSR.getPannableExtent().width(), n6 = this.m_originalGeometry.getAttributeStreamRef(0));
    const o2 = this.m_pannableExtent.width(), a2 = o2 * Ss() * 4;
    let h2 = t2, m2 = Number.NaN;
    const l2 = x2.constructEmpty();
    this.m_bAdjustedAtPoles = 0;
    let u = new Na({ vd: this.m_inputPoly.getDescription() });
    for (let d2 = 0, p3 = this.m_inputPoly.getPathCount(); d2 < p3; ++d2) {
      let t3 = r;
      const c2 = new Na({ vd: this.m_inputPoly.getDescription() });
      c2.addPath(this.m_inputPoly, d2, true);
      const _2 = this.m_inputPoly.isClosedPath(d2);
      0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= Em2(_2, c2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, o2, this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (t3 = false));
      let p4 = -1;
      const f3 = c2.getPointCount();
      let x4 = false;
      t3 && (p4 = this.m_originalGeometry.getPathStart(d2), x4 = this.m_originalGeometry.isClosedPath(d2));
      const y2 = c2.getAttributeStreamRef(0);
      let P5 = 0, E2 = y2.read(0), C2 = 0;
      const S3 = new ei(), I5 = new ei();
      let w4 = false;
      const v3 = c2.hasNonLinearSegments(), N2 = new ei();
      for (let e5 = 1; e5 < f3; ++e5) {
        y2.queryPoint2D(2 * e5, N2);
        const s4 = N2.x;
        let r2 = s4 + P5;
        const o3 = r2 - E2;
        if (N2.x = r2, Math.abs(o3) > this.m_GCSLargeDelta) {
          if (t3) {
            const s5 = p4 + e5 - 1;
            let r3 = p4;
            (!x4 || e5 + 1 < f3) && (r3 += e5);
            const a3 = n6.read(2 * s5), h3 = (n6.read(2 * r3) - a3) * i2;
            Math.abs(o3 - h3) > 1 * this.m_degree && (t3 = false);
          }
          if (!t3) {
            P5 -= B2(this.m_width360, r2 - E2), r2 = s4 + P5, ++C2, w4 = 0 !== P5, N2.x = r2;
          }
        }
        w4 && (v3 && b("error in geonormalize_ring_ for curves"), y2.write(2 * e5, r2)), E2 = r2, S3.setCoordsPoint2D(I5), I5.setCoordsPoint2D(N2);
      }
      if (C2 && c2.notifyModified(), h2) {
        let t4 = false;
        if (!c2.isEmpty()) {
          const n7 = n4.constructEmpty();
          if (c2.queryEnvelope(n7), n7.width() >= o2 || n7.ymin <= this.m_pannableExtent.ymin || n7.ymax >= this.m_pannableExtent.ymax) t4 = true;
          else {
            if (Number.isNaN(m2)) {
              const e6 = this.m_centralLongitude - 0.5 * o2;
              m2 = n7.xmin, m2 += Math.round((e6 - n7.xmin) / o2) * o2, m2 > e6 && (m2 -= o2), n2(m2 <= e6), m2 < e6 && (m2 += o2), n2(m2 >= e6);
            }
            let e5 = Math.round((m2 - n7.xmin) / o2) * o2;
            if (n7.xmin + e5 > m2 + a2 && (e5 -= o2), n7.xmin + e5 < m2 - a2 && (e5 += o2), l2.mergeCoordinate(n7.xmin + e5), l2.mergeCoordinate(n7.xmax + e5), t4 = l2.width() >= o2, !t4) {
              const t5 = new x3();
              t5.setShiftCoords(e5, 0), c2.applyTransformation(t5);
            }
          }
        }
        u.add(c2, false), t4 && (u = (() => {
          const e5 = new Na({ vd: u.getDescription() });
          for (let t5 = 0, s4 = u.getPathCount(); t5 < s4; ++t5) {
            const s5 = new Na({ vd: u.getDescription() });
            s5.addPath(u, t5, true);
            const n7 = Sl(s5, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
            e5.add(n7, false);
          }
          return e5;
        })(), h2 = false);
      } else {
        const e5 = Sl(c2, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
        u.add(e5, false);
      }
    }
    if (h2) return u;
    const c = this.m_pannableSR.getTolerance(0), _ = this.m_pannableExtent.width() / 180;
    Ml(u, this.m_pannableExtent, 0.1 * c, false);
    return f2(u, this.m_pannableExtent, c, _, this.m_progressTracker);
  }
  finalizeGeoNormalizeOpenedRing(t2, n6) {
    const r = n6.getPointCount(), i2 = n6.getXY(0), o2 = n6.getXY(r - 1);
    {
      const e5 = Math.abs(o2.x - i2.x), t3 = Math.round(e5 / this.m_width360) * this.m_width360;
      n2(Math.abs(e5 - t3) < this.m_pannableSR.getTolerance(0));
    }
    const a2 = X(o2.x - i2.x), h2 = n4.constructEmpty();
    n6.queryLooseEnvelope(h2);
    const m2 = this.m_pannableExtent.getCenterX();
    let l2 = 0, g2 = m2 - this.m_width360, u = m2 + this.m_width360;
    if (a2 >= 0) {
      let e5 = Math.ceil((g2 - h2.xmin) / this.m_width360);
      for (e5 *= this.m_width360; g2 > h2.xmin + e5; ) e5 += this.m_width360;
      for (; g2 < h2.xmax + e5; ) e5 -= this.m_width360;
      for (l2 = e5, h2.width() > 720 && (u = g2 + 360 * Math.ceil(h2.width() / 360)); u < h2.xmax; ) u += this.m_width360;
    } else {
      let e5 = Math.ceil((u - h2.xmax) / this.m_width360);
      for (e5 *= this.m_width360; u < h2.xmax + e5; ) e5 -= this.m_width360;
      for (; u > h2.xmin + e5; ) e5 += this.m_width360;
      for (l2 = e5, h2.width() > 720 && (g2 = u - 360 * Math.ceil(h2.width() / 360)); g2 > h2.xmin; ) g2 -= this.m_width360;
    }
    const c = Math.round(Math.abs(o2.x - i2.x) / this.m_width360) * this.m_width360, _ = a2 * c, d2 = h2.clone();
    d2.move(l2, 0);
    const p3 = new ei(0, 0), f3 = new x3();
    f3.setShiftCoords(l2, 0), n6.applyTransformation(f3);
    const x4 = new Na({ vd: n6.getDescription() });
    x4.add(n6, false), p3.assign(n6.getXY(r - 1));
    let y2 = 0, P5 = x4.getXY(0).x;
    for (; a2 > 0 ? d2.xmax < u : d2.xmin > g2; ) d2.move(_, 0), f3.xd = _, n6.applyTransformation(f3), P5 += _, this.m_pannableExtent.xmin <= P5 && this.m_pannableExtent.xmax >= P5 && (y2 = x4.getPointCount() - 1), n6.setXY(0, p3), p3.assign(n6.getXY(r - 1)), x4.addSegmentsFromPath(n6, 0, 0, r - 1, false);
    const E2 = new eh({ vd: x4.getDescription() });
    E2.add(x4, false);
    const C2 = x4.getXY(0), S3 = x4.getXY(x4.getPointCount() - 1), w4 = a2 < 0 ? t2 : !t2, v3 = E2.getPointCount() - 1;
    if (w4) {
      const e5 = new ei(S3.x, this.m_pannableExtent.ymax);
      E2.lineTo(e5);
      const t3 = new ei(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymax);
      E2.lineTo(t3);
      const s4 = new ei(C2.x, this.m_pannableExtent.ymax);
      E2.lineTo(s4);
    } else {
      const e5 = new ei(S3.x, this.m_pannableExtent.ymin);
      E2.lineTo(e5);
      const t3 = new ei(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymin);
      E2.lineTo(t3);
      const s4 = new ei(C2.x, this.m_pannableExtent.ymin);
      E2.lineTo(s4);
    }
    if (E2.interpolateAttributesPath(0, v3, 0), E2.getImpl().changeRingStartPoint(y2), c > this.m_width360) {
      const e5 = new eh({ copy: E2 });
      f3.setShiftCoords(this.m_width360, 0), e5.applyTransformation(f3), E2.add(e5, false);
    }
    return E2;
  }
  finalizeGeoNormalizeClosedRing(t2, s4, n6) {
    const r = new eh({ vd: t2.getDescription() });
    r.add(t2, false);
    const i2 = () => {
      const e5 = r.getPointCount() - 2;
      return r.getSegmentType(e5) !== a.enumLine;
    };
    if (r.hasNonLinearSegments() && i2()) {
      const e5 = new nu(), t3 = r.getPointCount() - 2;
      r.getSegmentBuffer(t3, e5, false), r.removePointFromPath(0, t3 + 1), r.closeLastPathWithSegment(e5.get());
    } else r.removePointFromPath(0, r.getPointCount() - 1);
    const a2 = n4.constructEmpty();
    r.queryLooseEnvelope(a2);
    let h2 = Math.ceil((this.m_pannableExtent.xmin - a2.xmin) / this.m_width360);
    for (h2 *= this.m_width360; this.m_pannableExtent.xmin > a2.xmin + h2; ) h2 += this.m_width360;
    for (; this.m_pannableExtent.xmin < a2.xmax + h2; ) h2 -= this.m_width360;
    if (h2 += this.m_width360, 0 !== h2) {
      a2.move(h2, 0);
      const e5 = new x3();
      e5.setShiftCoords(h2, 0), r.applyTransformation(e5);
    }
    if (this.m_pannableExtent.xmin <= a2.xmin && this.m_pannableExtent.xmax >= a2.xmax) {
      if (s4) {
        const e6 = r.calculateArea2D(), t3 = new fh2().execute(r, this.m_pannableSR, true, this.m_progressTracker);
        if (t3 !== r) {
          const s5 = t3.calculateArea2D();
          X(e6) !== X(s5) && t3.reverseAllPaths(), r.assignMove(t3);
        }
      }
      let e5;
      if (e5 = new eh(n6 ? { copy: r } : { move: r }), n6) for (; a2.xmin < this.m_pannableExtent.xmax; ) {
        a2.move(this.m_width360, 0);
        const t3 = new x3();
        t3.setShiftCoords(this.m_width360, 0), r.applyTransformation(t3), e5.add(r, false);
      }
      return e5;
    }
    let m2 = new eh({ vd: t2.getDescription() });
    m2.add(r, false);
    const l2 = s4 || a2.width() > this.m_width360 - 10 * this.m_pannableSR.getTolerance(0);
    for (; a2.xmin < this.m_pannableExtent.xmax; ) {
      a2.move(this.m_width360, 0);
      const e5 = new x3();
      e5.setShiftCoords(this.m_width360, 0), r.applyTransformation(e5), m2.add(r, false);
    }
    if (l2) {
      const e5 = m2.calculateArea2D();
      m2.setFillRule(1), m2 = new fh2().execute(m2, this.m_pannableSR, true, this.m_progressTracker);
      const t3 = m2.calculateArea2D();
      X(e5) !== X(t3) && m2.reverseAllPaths();
    }
    return m2;
  }
  geonormalize_ring_(e5, t2, n6, r, i2, o2, a2) {
    n2(0);
  }
};
function Nm2(e5) {
  n2(0);
  const t2 = su2(e5), n6 = new Dm2();
  return n6.setVertProj_(t2), n6;
}
function Tm2(e5, t2 = true) {
  return n2(0), {};
}
function Gm2(e5) {
  return xu();
}
var Dm2 = class {
  constructor() {
    this.m_hashCode = 0, this.m_peVertSysVal = null, this.m_verticalUnit = new Eu(), this.m_verticalShift = 0, this.m_userVerticalWKID = 0, this.m_bIsDepth = false;
  }
  getType() {
    return n2(0), 0;
  }
  getID() {
    return n2(0), 0;
  }
  getLatestID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getLatestID() : 0;
  }
  getOldID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getOldID() : 0;
  }
  getText() {
    return n2(0), "";
  }
  getTextExtended(e5) {
    return n2(0), "";
  }
  getText2(e5) {
    return n2(0), "";
  }
  getUnit() {
    return n2(0), {};
  }
  equals(e5) {
    return n2(0), false;
  }
  equalForProjection(e5) {
    return n2(0), false;
  }
  getPeVertcsCopy() {
    return n2(0), {};
  }
  getOneMeter() {
    return 1 / this.m_verticalUnit.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return n2(0), 0;
  }
  isDepth() {
    return n2(0), false;
  }
  getVerticalShift() {
    return n2(0), 0;
  }
  isCustomWkid() {
    return !!this.m_peVertSysVal && this.m_peVertSysVal.isCustomWkid();
  }
  getHashCode() {
    return this.m_hashCode;
  }
  setVertProj_(e5) {
    this.m_peVertSysVal = e5;
  }
  getPEVerticalCoordSys() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.m_peVertcs : null;
  }
};
function Vm2(e5, t2, s4, n6, r) {
  if (e5.equals(t2)) return false;
  if (n6) {
    let s5 = 1, i3 = 0, o3 = 1, a2 = 1, h2 = 0, m2 = 1;
    Number.isNaN(e5.m_heightMetersPerUnit) || (s5 = e5.m_heightMetersPerUnit, i3 = e5.m_heightZ0, o3 = e5.m_heightSign, a2 = t2.m_heightMetersPerUnit, h2 = t2.m_heightZ0, m2 = t2.m_heightSign);
    const l2 = o3 * m2 * s5 / a2;
    for (let e6 = 0; e6 < r; e6++) n6[e6] = (n6[e6] - i3) * l2 + h2;
  }
  let i2 = 1, o2 = 0;
  if (Number.isNaN(e5.m_XYToRadians) || (i2 = e5.m_XYToRadians / t2.m_XYToRadians, o2 = e5.m_PrimeMeridianDegrees - t2.m_PrimeMeridianDegrees, 0 !== o2 && (o2 = Ga(o2), o2 /= t2.m_XYToRadians)), Array.isArray(s4)) {
    const e6 = s4;
    for (let t3 = 0; t3 < r; t3++) e6[t3][0] = e6[t3][0] * i2 + o2, e6[t3][1] = e6[t3][1] * i2;
  } else {
    const e6 = s4;
    for (let t3 = 0; t3 < r; t3++) {
      const s5 = t3 << 1;
      e6[s5] = e6[s5] * i2 + o2, e6[s5 + 1] = e6[s5 + 1] * i2;
    }
  }
  return true;
}
function Fm2() {
  return { m_heightMetersPerUnit: 0, m_heightSign: 0, m_heightZ0: 0, m_XYToRadians: 0, m_PrimeMeridianDegrees: 0, assign(e5) {
    this.m_heightMetersPerUnit = e5.m_heightMetersPerUnit, this.m_heightSign = e5.m_heightSign, this.m_heightZ0 = e5.m_heightZ0, this.m_XYToRadians = e5.m_XYToRadians, this.m_PrimeMeridianDegrees = e5.m_PrimeMeridianDegrees;
  }, equals(e5) {
    return rs(this.m_heightSign, e5.m_heightSign) && rs(this.m_heightMetersPerUnit, e5.m_heightMetersPerUnit) && rs(this.m_heightZ0, e5.m_heightZ0) && rs(this.m_XYToRadians, e5.m_XYToRadians) && rs(this.m_PrimeMeridianDegrees, e5.m_PrimeMeridianDegrees);
  }, initFromGcsAndVcsPe(e5, t2) {
    this.m_heightSign = 1, this.m_heightMetersPerUnit = Number.NaN, this.m_heightZ0 = 0, this.m_XYToRadians = Number.NaN, this.m_PrimeMeridianDegrees = Number.NaN, t2 && n2(0), e5 && (this.m_XYToRadians = e5.getUnit().getUnitFactor(), this.m_PrimeMeridianDegrees = e5.getPrimem().getLongitude());
  }, initFromGcsAndVcs(e5, t2) {
    const s4 = e5 ? e5.getPECoordSys() : null, n6 = t2 ? t2.getPEVerticalCoordSys() : null;
    this.initFromGcsAndVcsPe(s4, n6);
  }, processUnitParams(e5) {
    Number.isNaN(this.m_heightMetersPerUnit) && (this.m_heightMetersPerUnit = e5.m_heightMetersPerUnit, this.m_heightSign = e5.m_heightSign, this.m_heightZ0 = e5.m_heightZ0), Number.isNaN(this.m_XYToRadians) && (this.m_XYToRadians = e5.m_XYToRadians, this.m_PrimeMeridianDegrees = e5.m_PrimeMeridianDegrees);
  } };
}
var Hm2 = class {
  constructor(e5) {
    this.m_constantsLoaded = -1, this.m_isUsable = -1, this.m_inputSR = null, this.m_outputSR = null, this.m_inputSRHorz = null, this.m_outputSRHorz = null, this.m_inputVCS = null, this.m_outputVCS = null, this.m_hashCode = 0, this.m_areaOfUse = new re(), this.m_inputUnitParams = Fm2(), this.m_outputUnitParams = Fm2(), n2(e5), this.m_geogTran = e5, this.m_vertTran = null, this.m_latestID = Pc.getCode(this.m_geogTran), this.m_latestID < 0 && (this.m_latestID = 0);
    const t2 = this.m_geogTran.getGeogcs1();
    Pc.getCode(t2);
    const n6 = this.m_geogTran.getGeogcs2();
    Pc.getCode(n6), this.initUnitParams();
  }
  getLatestId() {
    return this.m_latestID;
  }
  getText() {
    return this.m_geogTran ? this.m_geogTran.toString() : (n2(0), "");
  }
  getGeogtran() {
    return this.m_geogTran;
  }
  getVerttran() {
    return null;
  }
  loadConstants(e5) {
    let t2 = this.m_constantsLoaded;
    if (-1 === t2) {
      if (!e5) {
        this.m_geogTran || b("vcs not impl");
        const t3 = this.m_geogTran.getParameters();
        null !== t3[Ec.PE_PARM_ND] && (e5 = 0 === t3[Ec.PE_PARM_ND].getValue());
      }
      t2 = this.m_geogTran.loadConstants() ? 1 : 0, this.m_constantsLoaded = t2;
    }
    return 0 !== t2;
  }
  isUsable() {
    let e5 = this.m_isUsable;
    return -1 === e5 && (this.m_geogTran ? this.m_isUsable = e5 = this.m_geogTran ? 1 : 0 : this.m_isUsable = e5 = this.m_vertTran ? 1 : 0), 1 === e5;
  }
  getInputSr(e5) {
    return this.updateSrs(), e5 ? this.m_inputSR : this.m_inputSRHorz;
  }
  getOutputSr(e5) {
    return this.updateSrs(), e5 ? this.m_outputSR : this.m_outputSRHorz;
  }
  getHashCode() {
    let e5 = this.m_hashCode;
    return 0 === e5 && (e5 = this.m_latestID > 0 ? ws(this.m_latestID) : Ts(this.getText()), 0 === e5 && (e5 = 345), this.m_hashCode = e5), e5;
  }
  isGeogtran() {
    return null !== this.m_geogTran;
  }
  prepareOrThrow() {
  }
  getName() {
    return this.isGeogtran() ? this.getGeogtran().getName() : (z("vcs not impl"), "");
  }
  updateSrs() {
    if (this.m_inputSR || this.m_inputVCS) return;
    let e5, t2, n6, r, i2, o2;
    if (this.m_geogTran) {
      const s4 = this.m_geogTran.getGeogcs1(), a2 = eu2(s4), h2 = this.m_geogTran.getGeogcs2(), m2 = eu2(h2);
      let l2 = -1, g2 = -1;
      l2 = a2.getVcsCode(), g2 = m2.getVcsCode(), n6 = qu(s4, null, null, 1), r = qu(h2, null, null, 1), l2 > 0 && g2 > 0 ? (i2 = Nm2(l2), o2 = Nm2(g2), e5 = Ru(), t2 = Ru()) : (e5 = n6, t2 = r);
    } else n2(0);
    this.m_inputSR || this.m_inputVCS || (this.m_inputSR = e5, this.m_outputSR = t2, this.m_inputSRHorz = n6, this.m_outputSRHorz = r, this.m_inputVCS = i2, this.m_outputVCS = o2);
  }
  initUnitParams() {
    if (this.m_inputUnitParams.m_heightSign = 1, this.m_inputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_inputUnitParams.m_heightZ0 = 0, this.m_outputUnitParams.m_heightSign = 1, this.m_outputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_outputUnitParams.m_heightZ0 = 0, this.m_inputUnitParams.m_XYToRadians = Number.NaN, this.m_inputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_outputUnitParams.m_XYToRadians = Number.NaN, this.m_outputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_vertTran) n2(0);
    else if (this.m_geogTran) {
      const e5 = this.m_geogTran;
      let t2 = e5.getGeogcs1();
      this.m_inputUnitParams.m_XYToRadians = t2.getUnit().getUnitFactor(), this.m_inputUnitParams.m_PrimeMeridianDegrees = t2.getPrimem().getLongitude(), t2 = e5.getGeogcs2(), this.m_outputUnitParams.m_XYToRadians = t2.getUnit().getUnitFactor(), this.m_outputUnitParams.m_PrimeMeridianDegrees = t2.getPrimem().getLongitude();
    }
  }
};
function km2(e5, t2, s4, n6, r, i2, o2) {
  let a2 = null;
  if (t2) {
    a2 = t2.getPEVerticalCoordSys();
  }
  let h2 = null;
  if (e5) {
    h2 = e5.getPECoordSys();
  }
  let m2 = null;
  if (n6) {
    m2 = n6.getPEVerticalCoordSys();
  }
  let l2 = null;
  if (s4) {
    l2 = s4.getPECoordSys();
  }
  if (!(h2 || a2 || l2 || m2)) return false;
  const g2 = Fm2();
  g2.initFromGcsAndVcsPe(h2, a2);
  const u = Fm2();
  return u.initFromGcsAndVcsPe(l2, m2), Vm2(g2, u, r, i2, o2);
}
function Am2(e5, t2, s4, n6, r, i2, o2, a2) {
  const h2 = t2, m2 = e5, l2 = Fm2();
  l2.initFromGcsAndVcsPe(m2, h2), a2.assign(n6 ? s4.m_outputUnitParams : s4.m_inputUnitParams), a2.processUnitParams(l2), l2.processUnitParams(a2), o2 > 0 && Vm2(l2, a2, r, i2, o2);
}
function Mm2(e5, t2, s4, n6, r, i2, o2, a2) {
  const h2 = Fm2();
  h2.assign(s4 ? t2.m_inputUnitParams : t2.m_outputUnitParams), h2.processUnitParams(e5);
  let m2 = null, l2 = null;
  if (n6) {
    l2 = n6.getPECoordSys();
  }
  const g2 = Fm2();
  g2.initFromGcsAndVcsPe(l2, m2), g2.processUnitParams(h2), h2.processUnitParams(g2), a2 > 0 && Vm2(h2, g2, i2, o2, a2);
}
function Um2(e5, t2, s4, n6, r, i2, o2, a2, h2) {
  const m2 = Fm2(), l2 = Fm2();
  m2.assign(s4 ? t2.m_inputUnitParams : t2.m_outputUnitParams), l2.assign(r ? n6.m_outputUnitParams : n6.m_inputUnitParams), m2.processUnitParams(e5), l2.processUnitParams(m2), m2.processUnitParams(l2), a2 > 0 && Vm2(m2, l2, i2, o2, a2), h2.assign(l2);
}
function qm2(e5, t2, s4, n6, r, i2, o2) {
  const a2 = t2.getVerttran(), h2 = t2.getGeogtran();
  if (o2.assign(s4 ? t2.m_inputUnitParams : t2.m_outputUnitParams), o2.processUnitParams(e5), i2 > 0) {
    t2.prepareOrThrow();
    const e6 = s4 ? Ec.PE_TRANSFORM_2_TO_1 : Ec.PE_TRANSFORM_1_TO_2;
    a2 ? gg() : ug(h2, i2, n6, r, e6);
  }
}
function Om2(e5, t2, s4, n6, r) {
  const i2 = e5.getVerttran(), o2 = e5.getGeogtran();
  if (r > 0) {
    e5.prepareOrThrow();
    const a2 = t2 ? Ec.PE_TRANSFORM_2_TO_1 : Ec.PE_TRANSFORM_1_TO_2;
    i2 ? gg() : ug(o2, r, s4, n6, a2);
  }
}
var Bm2 = class {
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t2, s4) {
    return Rm2(e5, t2, s4);
  }
  canAccelerateGeometry(e5) {
    return Ym2(e5);
  }
};
function Rm2(e5, t2, s4) {
  if (!Ym2(e5)) return false;
  St2(t2, e5, false);
  let n6 = 0;
  const r = e5.getGeometryType();
  return h(r) && As(e5) && 0 !== s4 && (n6 |= e5.getImpl().buildQuadTreeAccelerator(s4) ? 1 : 0), h(r) && Ts2(e5) && 0 !== s4 && (n6 |= e5.getImpl().buildQuadTreeForPathsAccelerator(s4) ? 1 : 0), n6 > 0;
}
function Ym2(e5) {
  return As(e5) || Ts2(e5);
}
var Xm2 = class extends Bm2 {
  getOperatorType() {
    return 8;
  }
  execute(e5, t2, s4, n6) {
    return Vr2(e5, t2, s4, 1, n6);
  }
};
function Lm2(s4, n6, r, i2) {
  if (s4.isEmpty() || n6.isEmpty()) return s4;
  const h2 = s4.getDimension(), m2 = n6.getDimension();
  if (h2 > m2) return s4;
  const l2 = s4.getGeometryType(), g2 = n6.getGeometryType(), u = new n4(), c = new n4(), _ = new n4();
  s4.queryEnvelope(u), n6.queryEnvelope(c), _.setCoords({ env2D: u }), _.mergeEnvelope2D(c);
  const d2 = wt2(r, _, true), p3 = Pt2(d2), f3 = new n4();
  if (f3.setCoords({ env2D: u }), f3.inflateCoords(p3, p3), !f3.isIntersecting(c)) return s4;
  if (1 === h2 && 2 === m2) {
    const e5 = sl(s4, n6, g2, r, i2);
    if (e5) return e5;
  }
  if (l2 === a.enumPoint) {
    let e5;
    switch (f(g2) ? (e5 = new Na({ vd: n6.getDescription() }), e5.addSegment(n6, true)) : e5 = n6, g2) {
      case a.enumPolygon:
        return jm2(s4, e5, d2);
      case a.enumPolyline:
        return Zm2(s4, e5, d2);
      case a.enumMultiPoint:
        return Km2(s4, e5, d2);
      case a.enumEnvelope:
        return Qm2(s4, e5, d2);
      case a.enumPoint:
        return Jm2(s4, e5, d2);
      default:
        P("invalid shape type");
    }
  } else if (l2 === a.enumMultiPoint) switch (g2) {
    case a.enumPolygon:
      return $m2(s4, n6, d2);
    case a.enumEnvelope:
      return el(s4, n6, d2);
    case a.enumPoint:
      return tl(s4, n6, d2);
  }
  const x4 = new n4(u);
  x4.inflate(100 * d2.total());
  return Ua2(s4, f2(n6, x4, 0, 0, i2), r, i2);
}
var zm2 = class {
  getOperatorType() {
    return 10002;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t2, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t2, s4, n6) {
    return new Wm2(e5, t2, s4, n6);
  }
  execute(e5, t2, s4, n6) {
    return this.executeMany(new s2([e5]), new s2([t2]), s4, n6).next();
  }
};
var Wm2 = class extends t {
  constructor(e5, t2, s4, n6) {
    super(), this.m_progressTracker = n6, this.m_index = -1, this.m_inputGeoms = e5, this.m_spatialReference = s4;
    const r = t2.next();
    this.m_geomSubtractor = r || new eh();
  }
  next() {
    const e5 = this.m_inputGeoms.next();
    return e5 ? (j(e5), L(e5), this.m_index = this.m_inputGeoms.getGeometryID(), Lm2(e5, this.m_geomSubtractor, this.m_spatialReference, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function jm2(e5, t2, s4, n6) {
  return 0 === Bo2(t2, e5, s4.total()) ? e5 : e5.createInstance();
}
function Zm2(t2, s4, n6, r) {
  const i2 = t2.getXY(), o2 = s4.querySegmentIterator(), a2 = Pt2(n6), h2 = a2 * a2;
  for (; o2.nextPath(); ) for (; o2.hasNextSegment(); ) {
    const s5 = o2.nextSegment(), r2 = new n4();
    if (s5.queryEnvelope(r2), r2.inflateCoords(a2, a2), !r2.contains(i2)) continue;
    if (s5.isIntersectingPoint(i2, n6.total())) return t2.createInstance();
    let m2 = s5.getStartXY();
    if (ei.sqrDistance(i2, m2) <= h2) return t2.createInstance();
    if (m2 = s5.getEndXY(), ei.sqrDistance(i2, m2) <= h2) return t2.createInstance();
  }
  return t2;
}
function Km2(e5, t2, s4, n6) {
  const r = t2.getImpl().getAttributeStreamRef(0), i2 = t2.getPointCount(), o2 = e5.getXY(), a2 = Pt2(s4), h2 = a2 * a2, m2 = new ei();
  for (let l2 = 0; l2 < i2; l2++) {
    r.queryPoint2D(2 * l2, m2);
    if (ei.sqrDistance(m2, o2) <= h2) return e5.createInstance();
  }
  return e5;
}
function Qm2(t2, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o2 = t2.getXY();
  return i2.contains(o2) ? t2.createInstance() : t2;
}
function Jm2(e5, t2, s4, n6) {
  const r = Pt2(s4), i2 = r * r, o2 = e5.getXY(), a2 = t2.getXY();
  return ei.sqrDistance(o2, a2) <= i2 ? e5.createInstance() : e5;
}
function $m2(t2, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o2 = t2.getPointCount();
  let a2 = false;
  const h2 = Lt(o2, false), m2 = new ei();
  for (let e5 = 0; e5 < o2; e5++) {
    if (t2.queryXY(e5, m2), !i2.contains(m2)) continue;
    0 !== Ro2(s4, m2, n6.total()) && (a2 = true, h2[e5] = true);
  }
  if (!a2) return t2;
  const l2 = t2.createInstance();
  for (let e5 = 0; e5 < o2; e5++) h2[e5] || l2.addPoints(t2, e5, e5 + 1);
  return l2;
}
function el(t2, s4, n6, r) {
  const i2 = new n4();
  s4.queryEnvelope(i2), i2.inflate(n6.total());
  const o2 = t2.getPointCount();
  let a2 = false;
  const h2 = Lt(o2, false), m2 = new ei();
  for (let e5 = 0; e5 < o2; e5++) t2.queryXY(e5, m2), i2.contains(m2) && (a2 = true, h2[e5] = true);
  if (!a2) return t2;
  const l2 = t2.createInstance();
  for (let e5 = 0; e5 < o2; e5++) h2[e5] || l2.addPoints(t2, e5, e5 + 1);
  return l2;
}
function tl(e5, t2, s4, n6) {
  const r = e5.getImpl().getAttributeStreamRef(0), i2 = e5.getPointCount(), o2 = t2.getXY();
  let a2 = false;
  const h2 = Lt(i2, false), m2 = Pt2(s4), l2 = m2 * m2, g2 = new ei();
  for (let c = 0; c < i2; c++) {
    r.queryPoint2D(2 * c, g2);
    ei.sqrDistance(g2, o2) <= l2 && (a2 = true, h2[c] = true);
  }
  if (!a2) return e5;
  const u = e5.createInstance();
  for (let c = 0; c < i2; c++) h2[c] || u.addPoints(e5, c, c + 1);
  return u;
}
function sl(t2, s4, n6, r, i2) {
  const a2 = new re();
  t2.queryEnvelope(a2);
  const h2 = new n4();
  s4.queryEnvelope(h2), a2.merge(h2);
  const m2 = 0.1 * a2.width(), l2 = 0.1 * a2.height();
  a2.inflateCoords(m2, l2);
  const g2 = new eh();
  g2.addEnvelope(a2, false);
  const u = g2.getImpl();
  if (n6 === a.enumPolygon) {
    const e5 = s4.getImpl();
    u.add(e5, true);
  } else u.addEnvelope(s4, true);
  return new Ph2(g2, r, -1, i2).tryFastImplementation(t2);
}
var nl = class {
  getOperatorType() {
    return 10001;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e5, t2, s4) {
    return false;
  }
  canAccelerateGeometry(e5) {
    return false;
  }
  executeMany(e5, t2, s4, n6 = 0) {
    return new al(e5, t2, s4, n6);
  }
  execute(e5, t2, s4, n6) {
    const r = new s2([e5, t2]), i2 = new al(r, s4, n6, 0).next();
    return i2 || b("null output"), i2;
  }
};
function rl() {
  return { geom: null, vertexCount: -1, bUnioned: false, location: new ei() };
}
function il(e5, t2) {
  return ei.compareZorder(e5.location, t2.location) ? -1 : e5.location.equals(t2.location) ? 0 : 1;
}
var ol = class {
  constructor() {
    this.binVertexCount = 0, this.geometries = [];
  }
  addPair(e5) {
    this.binVertexCount += e5.vertexCount, this.geometries.push(e5);
  }
  sort() {
    this.geometries.sort((e5, t2) => il(e5, t2));
  }
  geomCount() {
    return this.geometries.length;
  }
  geomPairs() {
    return this.geometries;
  }
  clear() {
    this.binVertexCount = 0, this.geometries.length = 0;
  }
  getBinVertexCount() {
    return this.binVertexCount;
  }
};
var al = class _al extends t {
  constructor(e5, t2, s4, n6, r = false) {
    super(), this.m_index = -1, this.m_currentDim = -1, this.m_bDone = false, this.m_unionBins = [], this.m_readyGeoms = Ft(4), this.m_dimGeomCounts = Lt(4, 0), this.m_addedGeoms = 0, this.m_maxDimension = -1, this.m_bHadGeometry = Lt(4, false), this.m_complexUnionGeoms = Ft(4), this.m_totalNonEmptyGeomCounters = Lt(4, 0), this.m_progressTracker = s4, this.m_bUnionAllDimensions = !!(4 & n6), this.m_bPreserveAllPathEnds = !!(8 & n6), this.m_inputGeoms = e5, this.m_spatialReference = t2, this.m_options = n6, this.m_bIs3D = r;
  }
  next() {
    if (this.m_bDone && this.m_currentDim === this.m_maxDimension) return null;
    for (; !this.step_(); ) ;
    if (-1 === this.m_maxDimension) return null;
    if (this.m_bUnionAllDimensions) {
      if (-1 === this.m_currentDim) {
        for (let e5 = 0; e5 <= this.m_maxDimension; e5++) if (this.m_bHadGeometry[e5]) {
          this.m_complexUnionGeoms[e5] = this.getResultGeometry(e5);
          for (let t2 = e5 + 1; t2 <= this.m_maxDimension; t2++) this.m_complexUnionGeoms[t2] = this.getResultGeometry(t2), this.m_bHadGeometry[t2] && !this.m_complexUnionGeoms[t2].isEmpty() && (this.m_bIs3D ? n2(0) : this.m_complexUnionGeoms[e5] = new zm2().execute(this.m_complexUnionGeoms[e5], this.m_complexUnionGeoms[t2], this.m_spatialReference, this.m_progressTracker));
        }
      }
      for (; this.m_currentDim++, (this.m_currentDim > this.m_maxDimension || this.m_currentDim < 0) && b(""), !this.m_bHadGeometry[this.m_currentDim]; ) ;
      if (this.m_index++, 0 === this.m_currentDim && this.m_complexUnionGeoms[this.m_currentDim].getGeometryType() === a.enumPoint) {
        const e5 = new Ce({ vd: this.m_complexUnionGeoms[this.m_currentDim].getDescription() });
        return this.m_complexUnionGeoms[this.m_currentDim].isEmpty() || e5.add(this.m_complexUnionGeoms[this.m_currentDim]), e5;
      }
      return this.m_complexUnionGeoms[this.m_currentDim];
    }
    return this.m_index = 0, this.m_currentDim = this.m_maxDimension, this.getResultGeometry(this.m_maxDimension);
  }
  getGeometryID() {
    return this.m_index;
  }
  getRank() {
    return 1;
  }
  tock() {
    return this.step_();
  }
  getResultGeometry(e5) {
    return this.m_readyGeoms[e5];
  }
  finishDim(e5, t2, n6) {
    let r = t2;
    if (!n6) return 16 & this.m_options ? (r = Xa2([r], 1, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D), r) : r;
    if (1 & this.m_options) return r;
    if (1 === e5) {
      if (!(8 & this.m_options) && (!!(16 & this.m_options) || this.m_totalNonEmptyGeomCounters[e5] > 1)) {
        r = Xa2([r], 1, this.m_spatialReference, this.m_progressTracker, 16 | this.m_options, this.m_bIs3D);
        const e6 = [0], t3 = r.getImpl().getIsSimple(0, e6);
        n2(this.m_bIs3D || Ot2(t3));
      } else 1 === this.m_totalNonEmptyGeomCounters[e5] && (this.m_bIs3D ? n2(0) : r = new fh2().execute(r, this.m_spatialReference, false, this.m_progressTracker));
    } else this.m_bIs3D ? n2(0) : r = new fh2().execute(r, this.m_spatialReference, false, this.m_progressTracker);
    if (0 === e5 && r.getGeometryType() === a.enumPoint) {
      const e6 = new Ce({ vd: r.getDescription() });
      r.isEmpty() || e6.add(r), r = e6;
    }
    return r;
  }
  static getLevel(e5) {
    const t2 = 4, s4 = w(e5);
    let n6 = s4 > 0 ? (Math.log(s4) - Math.log(32)) / Math.log(t2) : 0;
    return n6 < 0 && (n6 = 0), Math.floor(n6);
  }
  step_() {
    if (this.m_bDone) return true;
    let e5;
    if (this.m_inputGeoms ? (e5 = this.m_inputGeoms.next(), null === e5 ? (this.m_bDone = true, this.m_inputGeoms = null) : (this.checkAndThrow(e5), e5.isEmpty() || this.m_totalNonEmptyGeomCounters[e5.getDimension()]++)) : e5 = null, null !== e5) {
      const t2 = e5.getDimension();
      this.m_bHadGeometry[t2] = true, (t2 >= this.m_maxDimension || this.m_bUnionAllDimensions) && (this.addGeom(t2, false, e5), t2 > this.m_maxDimension && !this.m_bUnionAllDimensions && this.removeAllBinsWithLowerDimension(t2));
    }
    if (this.m_addedGeoms > 0) for (let t2 = 0; t2 <= this.m_maxDimension; t2++) {
      for (; this.m_dimGeomCounts[t2] > 1; ) {
        const e6 = this.collectGeometriesToUnion(t2);
        if (null === e6) break;
        {
          let s4;
          s4 = 1 & this.m_options ? Xa2(e6, e6.length, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D) : La2(e6, e6.length, this.m_spatialReference, this.m_progressTracker, 8 | this.m_options, this.m_bIs3D), this.addGeom(t2, true, s4);
        }
      }
      if (this.m_bDone && (n2(this.m_dimGeomCounts[t2] <= 1), 0 !== this.m_dimGeomCounts[t2])) {
        const e6 = this.m_unionBins[t2].entries().next().value, s4 = e6[1].geomPairs()[0].geom, n6 = e6[1].geomPairs()[0].bUnioned;
        this.m_unionBins[t2].clear(), this.m_readyGeoms[t2] = this.finishDim(t2, s4, n6);
      }
    }
    return this.m_bDone;
  }
  addGeom(t2, s4, n6) {
    const r = rl();
    r.geom = n6;
    const i2 = w(n6);
    r.vertexCount = i2;
    const o2 = n4.constructEmpty();
    n6.queryEnvelope(o2), r.location = i2 > 0 ? o2.getCenter() : new ei(0, 0);
    const a2 = _al.getLevel(n6);
    if (t2 + 1 > this.m_unionBins.length) for (; this.m_unionBins.length < Math.max(2, t2 + 1); ) this.m_unionBins.push(/* @__PURE__ */ new Map());
    let h2 = null;
    const m2 = this.m_unionBins[t2].get(a2);
    m2 && (h2 = m2), null === h2 && (h2 = new ol(), this.m_unionBins[t2].set(a2, h2)), r.bUnioned = s4, h2.addPair(r), this.m_dimGeomCounts[t2]++, this.m_addedGeoms++, this.m_maxDimension = Math.max(this.m_maxDimension, t2);
  }
  removeAllBinsWithLowerDimension(e5) {
    for (let t2 = 0; t2 < e5; t2++) this.m_unionBins[t2].clear(), this.m_addedGeoms -= this.m_dimGeomCounts[t2], this.m_dimGeomCounts[t2] = 0;
  }
  collectGeometriesToUnion(e5) {
    if (1 & this.m_options && !this.m_bDone) return null;
    let t2 = null;
    const s4 = [];
    for (const n6 of this.m_unionBins[e5].keys()) s4.push(n6);
    Et(s4);
    for (let n6 = 0; n6 < s4.length; n6++) {
      if (-1 === s4[n6]) continue;
      const r = this.m_unionBins[e5].get(s4[n6]);
      {
        const i2 = 5e3, o2 = 4, a2 = r.getBinVertexCount() > i2 && r.geomCount() >= o2;
        if (this.m_bDone || a2) {
          for (let r2 = 0; r2 < n6; r2++) {
            if (-1 === s4[r2]) continue;
            const n7 = this.m_unionBins[e5].get(s4[r2]);
            n7.sort(), this.m_dimGeomCounts[e5] -= n7.geomCount(), this.m_addedGeoms -= n7.geomCount();
            for (const e6 of n7.geomPairs()) t2 || (t2 = new Array()), t2.push(e6.geom);
            n7.clear(), this.m_unionBins[e5].delete(s4[r2]), s4[r2] = -1;
          }
          r.sort(), this.m_dimGeomCounts[e5] -= r.geomCount(), this.m_addedGeoms -= r.geomCount();
          for (const e6 of r.geomPairs()) t2 || (t2 = new Array()), t2.push(e6.geom);
          if (r.clear(), this.m_unionBins[e5].delete(s4[n6]), s4[n6] = -1, !this.m_bDone) break;
        }
      }
    }
    return t2;
  }
  checkAndThrow(e5) {
    this.m_bIs3D && (e5.getDimension() > 1 && B(), e5.hasAttribute(1) || P("Geometry must have Zs")), j(e5);
  }
};
var hl = class extends Bm2 {
  getOperatorType() {
    return 3;
  }
  execute(e5, t2, s4, n6 = null) {
    return Vr2(e5, t2, s4, 4, n6);
  }
};
function ml(t2, s4, n6) {
  const r = s4.getGCSSplitLines();
  if (null === r) return t2;
  const i2 = s4.getGCS(), o2 = i2.getPannableExtent().width(), a2 = n4.constructEmpty();
  t2.queryLooseEnvelope(a2);
  const h2 = x2.constructEmpty();
  a2.queryIntervalX(h2);
  const m2 = r.querySegmentIterator();
  let l2 = null;
  const g2 = new x3();
  for (; m2.nextPath(); ) for (; m2.hasNextSegment(); ) {
    const e5 = m2.nextSegment(), t3 = e5.queryInterval(0, 0), s5 = x2.constructEmpty();
    s5.setCoordsFromEnvelope(t3);
    let n7 = 0;
    for (; s5.vmax > h2.vmin; ) s5.move(-o2), n7--;
    for (; s5.vmin <= h2.vmax; ) {
      if (s5.isIntersecting(h2)) {
        null === l2 && (l2 = new Na());
        const t4 = new su({ start: e5.getStartXY(), end: e5.getEndXY() });
        0 !== n7 && (g2.setShiftCoords(n7 * o2, 0), t4.applyTransformation(g2)), l2.addSegment(t4, true);
      }
      s5.move(o2), ++n7;
    }
  }
  if (null !== l2) {
    const e5 = zt2(i2, l2, true);
    return kn2(t2, l2, Pt2(e5), n6);
  }
  return t2;
}
function ll(e5, t2, s4) {
  let n6 = e5.getName();
  return Ju(n6) || (s4 || t2 > 0 ? (n6 = e5.toString(Ec.PE_STR_NAME_CANON | Ec.PE_STR_AUTH_NONE), n6 = dl(n6)) : n6 = e5.toString(Ec.PE_STR_AUTH_TOP)), n6;
}
function gl(e5, t2, n6, r) {
  return n2(0), "";
}
function ul(e5, s4 = -1) {
  if ((s4 > 1 || s4 < -1) && P("verbosity"), -1 === s4) return e5.toString();
  {
    const t2 = 0 === s4 ? Ec.PE_STR_AUTH_TOP : Ec.PE_STR_AUTH_ALL;
    return e5.toString(t2);
  }
}
function cl(e5, s4) {
  (s4 > 1 || s4 < -1) && P("verbosity");
  let n6 = Ec.PE_STR_FMT_WKT2;
  return -1 !== s4 && (n6 |= 0 === s4 ? Ec.PE_STR_AUTH_TOP : Ec.PE_STR_AUTH_ALL), e5.toString(n6);
}
function _l(e5) {
  return n2(0), "";
}
function dl(e5) {
  return e5.toLocaleUpperCase("en-US");
}
function pl(e5, s4, n6) {
  const r = e5.getPCSHorizon();
  if (r.getGeometryType() !== a.enumPolygon) if (r.getGeometryType() !== a.enumEnvelope) P("");
  else {
    const e6 = r;
    for (let t2 = 0; t2 < n6; t2++) e6.contains(s4[t2]) || s4[t2].setNAN();
  }
  else {
    const t2 = e5.getDefaultPrecisionSR().getTolerance(0), i2 = r;
    for (let e6 = 0; e6 < n6; e6++) 1 !== Ro2(i2, s4[e6], t2) && s4[e6].setNAN();
  }
}
function fl(e5, t2, s4, n6) {
  for (let r = 0; r < t2; r++) {
    if (e5[r].y < s4.ymin || e5[r].y > s4.ymax) {
      e5[r].setNAN();
      continue;
    }
    const t3 = e5[r].x;
    e5[r].x = wl(t3, s4, n6);
  }
}
function xl(t2, s4, n6, r) {
  if (t2.isEmpty() || 1 === n6) return t2;
  const i2 = t2.getGeometryType();
  if (i2 === a.enumPoint) {
    const e5 = t2, r2 = e5.getXY();
    return 0 === Cl([r2], 1, s4, n6) || r2.isNAN() ? e5.setEmpty() : e5.setXY(r2), t2;
  }
  if (i2 === a.enumMultiPoint) {
    const e5 = t2, r2 = t2.createInstance(), i3 = e5.getPointCount();
    r2.reserve(i3);
    const o2 = e5.getAttributeStreamRef(0), a3 = e5.getDescription().getAttributeCount() > 1, h2 = new ee(), m3 = Float64Array.from(o2.getArray());
    if (Cl(m3, i3, s4, n6) > 0) for (let t3 = 0, s5 = 2 * i3; t3 < s5; t3 += 2) Number.isNaN(m3[t3]) || (a3 ? (e5.getPointByVal(t3 >> 1, h2), h2.setXYCoords(m3[t3], m3[t3 + 1]), r2.add(h2)) : r2.addXY(m3[t3], m3[t3 + 1]));
    return r2;
  }
  let a2 = t2;
  const m2 = s4.getOneDegreeGCSUnit(), l2 = 90 * m2, u = 180 * m2, c = 360 * m2, _ = s4.getCentralMeridian(), d2 = 0.5 * m2, p3 = n4.constructEmpty();
  a2.queryEnvelope(p3);
  const f3 = s4.getGCSHorizon(), x4 = s4.getGCSHorisonIsInclusive(), y2 = f3.getGeometryType() === a.enumEnvelope, P5 = n4.constructEmpty();
  f3.queryEnvelope(P5);
  const E2 = s4.getGCS();
  if (2 !== n6 && 4 !== n6 || (P5.xmin = _ - u, P5.xmax = P5.xmin + c), 4 === n6) {
    if (!(p3.width() > c - m2)) {
      const t3 = n4.constructEmpty();
      t3.setCoords({ xmin: p3.xmin - m2, ymin: P5.ymin, xmax: p3.xmax + m2, ymax: P5.ymax }), a2 = new I4().execute(a2, t3, E2, r);
      let s5 = Math.floor((_ - p3.getCenterX()) / c);
      for (p3.move(s5 * c, 0); p3.xmin > P5.xmax; ) s5 -= 1, p3.move(-c, 0);
      for (; p3.xmin < P5.xmin; ) s5 += 1, p3.move(c, 0);
      if (0 !== s5) {
        const e5 = new x3();
        e5.setShiftCoords(s5 * c, 0), a2.applyTransformation(e5);
      }
      return a2;
    }
    n6 = 2;
  }
  if (2 === n6 && (P5.xmin = _ - u, P5.xmax = P5.xmin + c), p3.ymin < -l2 || p3.ymax > l2) {
    const t3 = n4.constructEmpty();
    if (t3.setCoords({ xmin: p3.xmin - m2, ymin: -l2, xmax: p3.xmax + m2, ymax: l2 }), a2 = new I4().execute(a2, t3, E2, r), a2.isEmpty()) return a2;
    a2.queryEnvelope(p3);
  }
  if (x4 && (P5.ymax < p3.ymin || P5.ymin > p3.ymax)) return a2.createInstance();
  p3.width() > c && (a2 = kl(a2, _ - u, c, E2, true, 0, true, r), a2.queryEnvelope(p3));
  let C2 = Hl(p3.xmin, p3.xmax, P5.xmin, P5.xmax, c);
  if (0 !== C2 && p3.move(C2, 0), p3.xmax > P5.xmax || p3.xmin < P5.xmin) {
    if (p3.xmax > P5.xmax) for (; p3.xmin >= P5.xmax; ) p3.move(-c, 0), C2 -= c;
    for (; p3.xmin < P5.xmax - c; ) p3.move(c, 0), C2 += c;
  }
  const S3 = St2(E2, f3, false);
  if (0 !== C2) {
    const e5 = new x3();
    e5.setShiftCoords(C2, 0), a2.applyTransformation(e5), C2 = 0;
  }
  if (x4) {
    if (y2 && P5.containsEnvelope(p3)) return a2;
    const e5 = new Array(2);
    for (let t3 = 0; t3 < 2; t3++) {
      let s5;
      if (y2 ? s5 = h(i2) ? f2(a2, P5, S3, d2, r) : f2(a2, P5, S3, 0, r) : (s5 = new Ch2().execute(a2, f3, E2, r), s5 === f3 && (s5 = s5.clone())), P5.xmin <= p3.xmin && P5.xmax >= p3.xmax) return s5;
      if (P5.xmin >= p3.xmin && P5.xmax <= p3.xmax) return s5;
      if (e5[t3] = s5, 0 === t3) {
        p3.move(-c, 0);
        const e6 = new x3();
        e6.setShiftCoords(-c, 0), a2.applyTransformation(e6);
      }
    }
    return h(i2) ? e5[0].add(e5[1], false) : b("intersect_with_GCS_horizon: unexpected geometry type"), e5[0];
  }
  {
    if (P5.ymax < p3.ymin || P5.ymin > p3.ymax) return a2;
    let e5 = 0;
    for (; !a2.isEmpty() && p3.xmax > P5.xmin; ) {
      if (0 !== e5) {
        const t3 = new x3();
        t3.setShiftCoords(e5, 0), a2.applyTransformation(t3);
      }
      if (!new hl().execute(a2, f3, E2, r)) {
        a2 = new zm2().execute(a2, f3, E2, r), f3 === a2 && (a2 = a2.clone());
      }
      if (0 !== e5) {
        const t3 = new x3();
        t3.setShiftCoords(-e5, 0), a2.applyTransformation(t3);
      }
      e5 -= c, p3.move(-c, 0);
    }
    return a2;
  }
}
function yl(e5, t2, s4, n6, r, i2) {
  const o2 = { stack: [], error: void 0, hasError: false };
  try {
    if (2 === i2) {
      return vs2(e5, t2, s4, n6, r);
    }
    if (Math.abs(s4.x - n6.x) >= Math.PI || !Tg(s4.x, n6.x, r)) return Number.NaN;
    s4.x > n6.x && (n6 = Mt(s4, s4 = n6));
    const a2 = n(o2, new yc(), false), h2 = n(o2, new yc(), false), m2 = n(o2, new yc(), false), l2 = s4.clone();
    vc.geodeticDistance(e5, t2, s4.x, s4.y, n6.x, n6.y, h2, a2, null, i2);
    const g2 = h2.val;
    let u = 0, c = 1;
    for (; g2 * (c - u) > 1e-12 * e5; ) {
      const o3 = 0.5 * (u + c);
      if (vc.geodeticCoordinate(e5, t2, s4.x, s4.y, g2 * o3, a2.val, h2, m2, i2), l2.x = h2.val, l2.y = m2.val, l2.x === r) return l2.y;
      if (Tg(s4.x, l2.x, r)) c = o3;
      else {
        if (!Tg(n6.x, l2.x, r)) return Number.NaN;
        u = o3;
      }
    }
    return l2.y;
  } catch (a2) {
    o2.error = a2, o2.hasError = true;
  } finally {
    s(o2);
  }
}
function Pl(e5, t2) {
  let s4;
  if (Array.isArray(e5)) {
    const n6 = e5;
    s4 = new Float64Array(2 * t2);
    for (let e6 = 0, r = 0; e6 < t2; e6++, r += 2) s4[r] = n6[e6].x, s4[r + 1] = n6[e6].y;
  } else s4 = e5;
  return s4;
}
function El(e5, t2, s4, n6) {
  for (let r = 0, i2 = 0; r < n6; r++, i2 += 2) t2[s4 + r].x = e5[i2], t2[s4 + r].y = e5[i2 + 1];
}
function Cl(t2, s4, n6, r) {
  if (0 === s4 || 1 === r) return s4;
  const i2 = Pl(t2, s4);
  if (2 === r) {
    const e5 = n6.getPannableExtentInGCS();
    let r2 = s4;
    for (let t3 = 0, n7 = 2 * s4; t3 < n7; t3 += 2) (i2[t3 + 1] > e5.ymax || i2[t3 + 1] < e5.ymin) && (i2[t3] = Number.NaN, r2--);
    return r2 ? (Al(i2, s4, e5.xmin, e5.width(), true), t2 !== i2 && El(i2, t2, 0, s4), r2) : 0;
  }
  const a2 = n6.getOneDegreeGCSUnit(), h2 = 90 * a2, m2 = 180 * a2, l2 = 360 * a2;
  let g2 = s4;
  for (let e5 = 0, o2 = 2 * s4; e5 < o2; e5 += 2) (i2[e5 + 1] > h2 || i2[e5 + 1] < -h2) && (i2[e5] = Number.NaN, g2--);
  if (!g2) return 0;
  const u = n4.constructEmpty();
  u.setFromPoints(i2, s4);
  const c = n6.getGCSHorizon(), _ = n6.getGCSHorisonIsInclusive(), d2 = c.getGeometryType() === a.enumEnvelope, p3 = n4.constructEmpty();
  if (c.queryEnvelope(p3), _ && (p3.ymax < u.ymin || p3.ymin > u.ymax)) return 0;
  if (_) {
    if (Al(i2, s4, p3.getCenterX() - m2, l2, true), g2 = s4, d2) for (let e5 = 0, t3 = 2 * s4; e5 < t3; e5 += 2) p3.containsCoords(i2[e5], i2[e5 + 1]) || (i2[e5] = Number.NaN, g2--);
    else {
      const e5 = St2(n6.getGCS(), c, false), t3 = new ei();
      for (let n7 = 0, r2 = 2 * s4; n7 < r2; n7 += 2) {
        t3.setCoords(i2[n7], i2[n7 + 1]);
        0 !== Ro2(c, t3, e5) || (i2[n7] = Number.NaN, g2--);
      }
    }
  } else {
    Al(i2, s4, -m2, l2, true), g2 = s4;
    const e5 = St2(n6.getGCS(), c, false), t3 = new ei();
    for (let n7 = 0, r2 = 2 * s4; n7 < r2; n7 += 2) {
      t3.setCoords(i2[n7], i2[n7 + 1]), t3.isNAN() && g2--;
      const s5 = Fl(t3.x, p3.xmin, p3.xmax, l2);
      t3.x += s5;
      0 !== Ro2(c, t3, e5) && (i2[n7] = Number.NaN, g2--);
    }
  }
  return g2 > 0 && Array.isArray(t2) && El(i2, t2, 0, s4), g2;
}
function Sl(e5, s4, n6, r, i2, o2) {
  if (s4.isPannable() || P("fold_into_360_degree_range"), e5.isEmpty()) return e5;
  let a2, h2;
  if (2 === s4.getCoordinateSystemType()) {
    const e6 = s4.getPannableExtent();
    h2 = e6.xmin, a2 = e6.width();
  } else {
    const e6 = s4.getOneDegreeGCSUnit();
    a2 = 360 * e6, h2 = n6 - 180 * e6;
  }
  return kl(e5, h2, a2, s4, r, i2, true, o2);
}
function Il(e5, t2, s4, n6) {
  let r, i2;
  if (2 === s4.getCoordinateSystemType()) {
    const e6 = s4.getPannableExtent();
    r = e6.xmin, i2 = e6.width();
  } else {
    const e6 = s4.getOneDegreeGCSUnit();
    i2 = 360 * e6, r = n6 - 180 * e6;
  }
  Al(e5, t2, r, i2);
}
function bl(e5, t2) {
  const s4 = t2.width();
  let n6 = ct(e5 - t2.vmin, s4);
  n6 < 0 && (n6 += s4);
  return t2.snapClip(n6 + t2.vmin);
}
function wl(e5, t2, s4) {
  return e5 > t2.xmax && e5 - t2.xmax < s4 ? t2.xmax : e5 < t2.xmin && t2.xmin - e5 < s4 ? t2.xmin : e5;
}
function vl(e5, t2, s4) {
  if (e5[0] < t2.vmin || e5[0] > t2.vmax || s4 && e5[0] === t2.vmax) {
    const s5 = t2.width();
    return e5[0] += Math.ceil((t2.vmin - e5[0]) / s5) * s5, e5[0] = t2.snapClip(e5[0]), true;
  }
  return false;
}
function Nl(e5, t2, s4, n6, r, i2, o2, a2, h2) {
  return new vm2(e5, null, s4, t2, n6, r, o2, a2, i2).geoNormalizePolygonGeometry(h2);
}
function Tl(e5, t2, s4, n6, r, i2, o2, a2, h2) {
  return new vm2(e5, null, s4, t2, n6, r, o2, a2, i2).geoNormalizePolylineGeometry(h2);
}
function Gl(e5, t2, s4, n6, r) {
  const i2 = new Tm(), o2 = i2.addGeometry(e5);
  return Dl(i2, o2, t2, St2(t2, e5, false), s4, n6, r), i2.getGeometry(o2);
}
function Dl(e5, t2, n6, r, i2, o2, a2) {
  const h2 = { stack: [], error: void 0, hasError: false };
  try {
    n2(Hu()), n6.isPannable() || C("insert_geodetic_points");
    const m2 = n6.getPannableExtent(), l2 = n6.getGCS(), g2 = Gu();
    l2.querySpheroidData(g2);
    const u = l2.getUnit().getUnitToBaseFactor(), c = g2.majorSemiAxis, _ = g2.e2;
    let p3 = 0;
    const f3 = new x2();
    m2.queryIntervalX(f3);
    let x4 = null;
    const y2 = Lt(4, Number.NaN);
    2 === n6.getCoordinateSystemType() ? (x4 = n6.getPECoordSys(), o2 ? (y2[0] = bl(a2, f3), y2[1] = m2.getCenterY(), Cc.projToGeog(x4, 1, y2), p3 = y2[0] * u) : (y2[0] = m2.getCenterX(), y2[1] = a2, Cc.projToGeog(x4, 1, y2), p3 = y2[1] * u)) : p3 = a2 * u, o2 || 0 === p3 || 2 === i2 || C("insert_geodetic_points: 1");
    const P5 = n(h2, new yc(), false), E2 = new ei(), C2 = new ei(), S3 = new ei(), I5 = new ei(), b2 = new ei(), w4 = new ei();
    for (let s4 = e5.getFirstPath(t2); s4 !== bm; s4 = e5.getNextPath(s4)) {
      const t3 = e5.getFirstVertex(s4);
      e5.queryXY(t3, S3);
      let h3 = false;
      const m3 = e5.getNextVertex(t3);
      for (let s5 = m3; s5 !== bm; s5 = e5.getNextVertex(s5)) {
        if (s5 === m3) {
          if (h3) break;
          h3 = true;
        }
        if (e5.queryXY(s5, I5), o2 && (r < a2 - S3.x && I5.x - a2 > r || r < a2 - I5.x && S3.x - a2 > r) || !o2 && (0 !== a2 || r < -S3.y && I5.y > r || r < -I5.y && S3.y > r)) do {
          if (Math.abs(S3.x - I5.x) >= 0.5 * f3.width()) break;
          2 === n6.getCoordinateSystemType() ? (y2[0] = bl(S3.x, f3), y2[1] = S3.y, y2[2] = bl(I5.x, f3), y2[3] = I5.y, ng(x4, 2, y2, 0), b2.x = y2[0] * u, b2.y = y2[1] * u, w4.y = y2[3] * u) : (b2.x = S3.x * u, b2.y = S3.y * u, w4.y = I5.y * u), w4.x = (I5.x - S3.x) * Math.PI * 2 / f3.width() + b2.x;
          let t4 = 0;
          const r2 = Rt(ei, 2);
          if (o2) {
            if (C2.x = p3, C2.y = yl(c, _, b2, w4, p3, i2), Number.isNaN(C2.y)) break;
            r2[0] = C2, t4 = 1;
          } else if (2 === i2) {
            const e6 = [0, 0];
            if (t4 = Ns2(c, _, b2, w4, p3, e6), !t4) break;
            r2[0].x = e6[0], r2[0].y = p3, 2 === t4 && (r2[1].x = e6[1], r2[1].y = p3);
          } else {
            if (C2.x = Gg(c, _, b2, w4, i2), Number.isNaN(C2.x)) break;
            C2.y = 0, r2[0] = C2, t4 = 1;
          }
          let h4 = -1;
          for (let m4 = 0; m4 < t4; m4++) {
            vc.geodeticDistance(c, _, b2.x, b2.y, w4.x, w4.y, P5, null, null, i2);
            const t5 = P5.val;
            vc.geodeticDistance(c, _, b2.x, b2.y, r2[m4].x, r2[m4].y, P5, null, null, i2);
            const l3 = P5.val;
            2 === n6.getCoordinateSystemType() ? (y2[0] = r2[m4].x / u, y2[1] = r2[m4].y / u, Cc.geogToProj(x4, 1, y2), o2 ? (E2.y = y2[1], E2.x = a2) : (E2.x = Dg(y2[0], S3.x, I5.x, f3), E2.y = a2)) : o2 ? (E2.x = a2, E2.y = r2[m4].y / u) : (E2.x = Dg(r2[m4].x / u, S3.x, I5.x, f3), E2.y = a2);
            const g3 = t5 > 0 ? ks(l3 / t5, 0, 1) : 0.5;
            if (0 === g3 || 1 === g3) continue;
            if (h4 > g3) continue;
            const d2 = e5.getPrevVertex(s5);
            e5.splitSegment(d2, [g3], 1);
            const p4 = e5.getNextVertex(d2);
            e5.setXYCoords(p4, E2.x, E2.y), h4 = g3;
          }
        } while (0);
        S3.setCoordsPoint2D(I5);
      }
    }
  } catch (m2) {
    h2.error = m2, h2.hasError = true;
  } finally {
    s(h2);
  }
}
function Vl(t2, n6) {
  n2(n6.isPannable());
  const r = n6.getPannableExtent();
  if (t2.getGeometryType() === a.enumPoint) {
    const e5 = t2.getY();
    return r.ymin <= e5 && e5 <= r.ymax ? t2 : t2.createInstance();
  }
  const i2 = n4.constructEmpty();
  t2.queryEnvelope(i2);
  const a2 = n4.constructEmpty();
  a2.setCoords({ env2D: r }), a2.xmin = i2.xmin, a2.xmax = i2.xmax, a2.inflateCoords(0.01 * a2.height(), 0);
  const h2 = Bt2(n6, i2, false);
  let m2;
  return m2 = a2.containsEnvelope(i2) ? t2 : f2(t2, a2, h2, 0, null), m2;
}
function Fl(e5, t2, s4, n6) {
  return S((0.5 * (s4 + t2) - e5) / n6) * n6;
}
function Hl(e5, t2, s4, n6, r) {
  if (e5 >= s4 && t2 <= n6) return 0;
  return Fl(0.5 * (t2 + e5), s4, n6, r);
}
function kl(t2, s4, n6, r, i2, a2, h2, m2) {
  const l2 = t2.getGeometryType(), g2 = x2.constructEmpty();
  g2.setCoords(s4, s4 + n6);
  const u = [0];
  if (l2 === a.enumPoint) {
    const e5 = t2;
    if (u[0] = e5.getX(), vl(u, g2, h2)) {
      const e6 = i2 ? t2 : t2.clone();
      return e6.setX(u[0]), e6;
    }
    return t2;
  }
  const c = n4.constructEmpty();
  if (t2.queryEnvelope(c), c.isEmpty()) return t2;
  if (l2 === a.enumMultiPoint) {
    const e5 = i2 ? t2 : t2.clone(), s5 = e5.getImpl(), n7 = s5.getAttributeStreamRef(0), r2 = 2 * s5.getPointCount();
    let o2 = false;
    for (let t3 = 0; t3 < r2; t3 += 2) u[0] = n7.read(t3), vl(u, g2, h2) && (n7.write(t3, u[0]), o2 = true);
    return o2 && s5.notifyModifiedFlags(2001), e5;
  }
  const _ = x2.constructEmpty();
  if (c.queryIntervalX(_), g2.contains(_)) return g2.vmax, _.vmax, t2;
  const d2 = n4.constructEmpty();
  if (d2.setCoords({ env2D: c }), 0 === _.width()) {
    let e5 = _.vmin;
    e5 += Math.ceil((g2.vmin - e5) / n6) * n6, e5 = g2.snapClip(e5);
    const s5 = i2 ? t2 : t2.clone();
    return s5.setAttributeBasic(0, 0, e5), s5;
  }
  if (l2 === a.enumEnvelope) {
    const e5 = i2 ? t2 : t2.clone();
    return c.intersect(d2), e5.setEnvelope(c), e5;
  }
  const p3 = 0.1 * Math.max(c.height(), c.width()) * 1;
  d2.inflateCoords(0, p3);
  let f3 = t2;
  const x4 = r.getTolerance(0), y2 = new x3();
  for (; ; ) {
    const e5 = Math.floor((_.vmin - s4) / n6), t3 = Math.ceil((_.vmax - s4) / n6);
    if (!(t3 - e5 > 3)) break;
    {
      const i3 = Math.floor(0.5 * (t3 + e5));
      d2.xmin = c.xmin - p3, d2.xmax = s4 + n6 * i3;
      const h3 = f2(f3, d2, x4, a2, m2);
      d2.xmin = d2.xmax, d2.xmax = c.xmax + p3;
      const g3 = f2(f3, d2, x4, a2, m2);
      y2.setShiftCoords((i3 - t3) * n6, 0), g3.applyTransformation(y2), l2 === a.enumPolygon ? f3 = new nl().execute(h3, g3, r, m2) : (f3 = h3, f3.add(g3, false)), f3.queryEnvelope(c), c.queryIntervalX(_);
    }
  }
  d2.xmin = s4, d2.xmax = s4 + n6;
  const P5 = n4.constructEmpty();
  P5.setCoords({ env2D: d2 }), P5.inflateCoords(x4, 0);
  const E2 = Math.floor((c.xmin - d2.xmin) / n6) * n6;
  let C2;
  E2 ? (d2.move(E2, 0), y2.setShiftCoords(-E2, 0)) : y2.setIdentity(), C2 = l2 === a.enumPolyline ? new Na({ vd: f3.getDescription() }) : new eh({ vd: f3.getDescription() });
  const S3 = n4.constructEmpty(), w4 = n4.constructEmpty();
  for (; c.xmax > d2.xmin; ) {
    const e5 = f2(f3, d2, x4, 0, m2);
    e5.queryEnvelope(w4);
    let t3 = false;
    t3 = l2 === a.enumPolyline ? !e5.isEmpty() && (w4.width() > x4 || w4.height() > x4) : !e5.isEmpty() && (l2 !== a.enumPolygon || w4.width() > x4), t3 && (e5.applyTransformation(y2), e5.queryEnvelope(w4), C2.queryEnvelope(S3), S3.inflateCoords(x4, x4), S3.isIntersecting(w4) && l2 === a.enumPolygon ? C2 = new nl().execute(C2, e5, r, m2) : C2.add(e5, false)), d2.move(n6, 0), y2.shiftCoords(-n6, 0);
  }
  return C2;
}
function Al(e5, t2, s4, n6, r = true) {
  const i2 = new x2();
  i2.setCoords(s4, s4 + n6);
  const o2 = [0];
  if (Array.isArray(e5)) {
    const s5 = e5;
    for (let e6 = 0; e6 < t2; e6++) i2.containsRightExclusive(s5[e6].x) || (o2[0] = s5[e6].x, vl(o2, i2, r), s5[e6].x = o2[0]);
  } else {
    const s5 = e5;
    for (let e6 = 0; e6 < t2; e6++) {
      const t3 = e6 << 1;
      i2.containsRightExclusive(s5[t3]) || (o2[0] = s5[t3], vl(o2, i2, r), s5[t3] = o2[0]);
    }
  }
}
function Ml(t2, n6, r, i2 = true) {
  if (t2.isEmpty()) return;
  const a2 = t2.getGeometryType();
  if (!i2 || a2 !== a.enumPolygon) if (y(a2)) {
    let e5 = false;
    if (h(a2) && t2.hasNonLinearSegments()) {
      const i3 = t2.getImpl(), o2 = i3.getAttributeStreamRef(0), a3 = i3.getSegmentFlagsStreamRef();
      n2(null !== a3);
      for (let t3 = 0, s4 = i3.getPathCount(); t3 < s4; t3++) {
        let s5 = true;
        const h2 = i3.isClosedPath(t3), m2 = i3.getPathEnd(t3);
        if (h2 && i3.getPathSize(t3) > 0) {
          s5 = 1 === (31 & a3.read(m2 - 1));
        }
        for (let l2 = i3.getPathStart(t3); l2 < m2; l2++) {
          if (1 === (31 & a3.read(l2))) {
            if (s5) {
              const t4 = o2.read(2 * l2), s6 = wl(t4, n6, r);
              s6 !== t4 && (e5 = true, o2.write(2 * l2, s6));
            }
            s5 = true;
          } else s5 = false;
        }
      }
    } else {
      const s4 = t2.getImpl(), i3 = s4.getAttributeStreamRef(0);
      for (let t3 = 0, o2 = s4.getPointCount(); t3 < o2; t3++) {
        const s5 = i3.read(2 * t3), o3 = wl(s5, n6, r);
        o3 !== s5 && (e5 = true, i3.write(2 * t3, o3));
      }
    }
    e5 && t2.getImpl().notifyModifiedFlags(2001);
  } else if (a2 === a.enumEnvelope) {
    const s4 = t2, i3 = n4.constructEmpty();
    s4.queryEnvelope(i3), i3.xmin = wl(i3.xmin, n6, r), i3.xmax = wl(i3.xmax, n6, r), s4.setEnvelope(i3);
  } else if (a2 === a.enumPoint) {
    const e5 = t2;
    e5.setX(wl(e5.getX(), n6, r));
  } else b("");
}
function Ul(e5, t2, s4) {
  const n6 = new ei();
  return n6.x = wl(e5.x, t2, s4), n6.y = e5.y, n6;
}
function ql(t2, s4) {
  if (s4.isEmpty()) return 0;
  const n6 = t2.getPECoordSys();
  if (n6.getProjection().getCode() === Ec.PE_PRJ_AZIMUTHAL_EQUIDISTANT) {
    const r = Gu();
    t2.querySpheroidData(r);
    const i2 = n6.getParameters();
    if (null === i2[Ec.PE_PARM_LAM0]) return 0;
    if (null === i2[Ec.PE_PARM_PHI0]) return 0;
    const o2 = [i2[Ec.PE_PARM_LAM0].getValue(), i2[Ec.PE_PARM_PHI0].getValue()];
    Cc.geogToProj(n6, 1, o2);
    const a2 = new ei(o2[0], o2[1]), h2 = n4.constructEmpty();
    s4.queryEnvelope(h2);
    const m2 = Rt(ei, 4);
    h2.queryCorners(m2);
    let l2 = 0;
    const g2 = t2.getOneMeter();
    let u = Math.max(r.majorSemiAxis, r.minorSemiAxis) * Math.PI, c = Math.min(r.majorSemiAxis, r.minorSemiAxis) * Math.PI;
    c -= u / 180, u *= g2, c *= g2;
    for (let e5 = 0; e5 < 4; e5++) {
      const t3 = ei.distance(m2[e5], a2);
      if (t3 > u) l2++;
      else if (t3 > c) return -1;
    }
    if (0 === l2) return 1;
    if (4 === l2) {
      const t3 = n4.constructEmpty();
      return t3.setCoords({ center: a2, width: u, height: u }), h2.isIntersectingNe(t3) ? -1 : 0;
    }
    return -1;
  }
  return -1;
}
function Ol(t2, n6, r, i2) {
  const a2 = t2.getGeometryType();
  n2(a2 === a.enumPolygon || a2 === a.enumPolyline || a2 === a.enumMultiPoint);
  const h2 = n6.getCoordinateSystemType();
  if (2 === h2) {
    let s4 = t2;
    if (0 === r) {
      const r2 = ql(n6, t2);
      if (0 === r2) return t2.createInstance();
      if (1 === r2) return t2;
      const a3 = n6.getPCSHorizon(), h3 = a3.getGeometryType(), m2 = n6.getDefaultPrecisionSR();
      if (h3 === a.enumEnvelope) {
        const r3 = n4.constructEmpty();
        a3.queryEnvelope(r3);
        const o2 = Bt2(m2, r3, false);
        s4 = f2(t2, r3, o2, 5e4 * n6.getOneMeterPCSUnit(), i2);
      } else new Xm2().execute(a3, t2, m2, i2) || (s4 = new Ch2().execute(s4, a3, m2, i2), s4 === a3 && (s4 = s4.clone()));
    } else if (n6.isPannable()) {
      const t3 = n4.constructEmpty();
      s4.queryEnvelope(t3);
      const h3 = n6.getPannableExtent();
      h3.containsEnvelope(t3) || (Ml(s4, h3, n6.getTolerance(0)), 2 !== r && 4 !== r || (s4 = Vl(s4, n6)), 4 !== r ? s4 = Sl(s4, n6, 0, true, 1e5 * n6.getOneMeterPCSUnit(), i2) : a2 === a.enumPolygon && t3.width() > 2 * h3.width() && (s4 = kl(s4, -2 * h3.width(), 2 * h3.width(), n6, true, 0, true, i2)));
    }
    return s4;
  }
  if (n2(1 === h2), a2 === a.enumMultiPoint) return Ml(t2, n6.getPannableExtent(), n6.getTolerance(0)), t2;
  {
    const s4 = n4.constructEmpty();
    t2.queryEnvelope(s4);
    let r2 = t2;
    const h3 = n6.getPannableExtent();
    if (s4.ymin < h3.ymin || s4.ymax > h3.ymax) {
      const t3 = Math.max(1, s4.calculateToleranceFromEnvelope()), o2 = new n4(s4.xmin - t3, h3.ymin, s4.xmax + t3, h3.ymax);
      if (r2 = new I4().execute(r2, o2, n6, i2), r2.isEmpty()) return r2;
    }
    return a2 === a.enumPolygon && s4.width() > 2 * h3.width() && (r2 = kl(r2, -2 * h3.width(), 2 * h3.width(), n6, true, 0, true, i2)), r2;
  }
}
function Bl(e5, t2, n6, r, i2, o2) {
  const a2 = r.getCoordinateSystemType();
  if (2 === a2) {
    if (0 === i2) n6 !== e5 && Bt(n6, e5, t2), pl(r, n6, t2);
    else if (n6 !== e5 && Bt(n6, e5, t2), r.isPannable()) {
      const e6 = r.getTolerance(0);
      fl(n6, t2, r.getPannableExtent(), e6), Il(n6, t2, r, 0);
    }
  } else {
    n2(1 === a2);
    const i3 = r.getTolerance(0), o3 = r.getPannableExtent();
    for (let s4 = 0; s4 < t2; s4++) n6[s4].assign(Ul(e5[s4], o3, i3));
  }
}
function Rl(e5, t2) {
  const s4 = t2.getPointCount();
  if (!s4) return;
  const n6 = t2.getImpl(), r = n6.getAttributeStreamRef(0), i2 = e5;
  Cc.geogToProj(i2, s4, r.getArray()), n6.notifyModifiedFlags(2001);
}
function Yl(e5, t2, s4, n6) {
  if (!s4) return;
  const r = e5.getPECoordSys();
  if (1 === s4) {
    const s5 = [t2[0].x, t2[0].y];
    if (Cc.geogToProj(r, 1, s5), n6) {
      const { first: n7, second: r2 } = e5.m_peCoordSysVal.getGeogToProjFactors();
      s5[0] = n7 * (t2[0].x - e5.getCentralMeridian()) + r2;
    }
    return void t2[0].setCoords(s5[0], s5[1]);
  }
  const i2 = e5.isPannable(), o2 = i2 ? e5.getPannableExtent().width() : 0, a2 = 179 * o2 / 360;
  let h2 = 0;
  i2 && (h2 = e5.getCentralMeridian());
  const m2 = 256, l2 = new Float64Array(2 * m2);
  for (let g2 = 0; g2 < s4; ) {
    for (let e6 = g2; e6 < s4 && t2[e6].isNAN(); ++e6) g2++;
    let u = Math.min(m2, s4 - g2);
    if (u > 0) {
      for (let e6 = 1, s5 = g2 + 1; e6 < u; ++e6, ++s5) if (t2[s5].isNAN()) {
        u = e6;
        break;
      }
      for (let e6 = 0; e6 < u; ++e6) {
        const s5 = e6 << 1;
        l2[s5] = t2[g2 + e6].x, l2[s5 + 1] = t2[g2 + e6].y;
      }
      if (Cc.geogToProj(r, u, l2), n6) {
        const { first: s5, second: n7 } = e5.m_peCoordSysVal.getGeogToProjFactors();
        for (let e6 = 0; e6 < u; ++e6) {
          l2[e6 << 1] = s5 * (t2[g2 + e6].x - h2) + n7;
        }
      }
      if (i2) for (let e6 = 0, s5 = g2; e6 < u; e6++, s5++) {
        const n7 = e6 << 1, r2 = l2[n7], i3 = X(r2), m3 = t2[s5].x - h2;
        i3 * X(m3) < 0 && Math.abs(r2) > a2 && (l2[n7] -= i3 * o2);
      }
      El(l2, t2, g2, u), g2 += u;
    }
  }
}
function Xl(e5, t2, s4, n6) {
  const r = e5.getSRToGCSTransform();
  return new kh2().transform(r, t2, s4, n6, false);
}
function Ll(t2, s4, n6, r) {
  const i2 = new Ce({ vd: s4.getDescription() });
  let o2;
  i2.addPoints(s4, 0, -1), o2 = new kh2().execute(i2, t2, r);
  const a2 = s4.getPointCount();
  if (n6.setEmpty(), t2.getInputSR().isPannable()) {
    if (a2 !== o2.getPointCount()) return false;
    const r2 = new n4();
    s4.queryEnvelope(r2);
    const i3 = new n4();
    o2.queryEnvelope(i3);
    const h2 = r2.width(), m2 = i3.width();
    if (0 !== h2 && 0 !== m2) {
      const e5 = m2 / h2, s5 = t2.getOutputSR().getPannableExtent().width() / t2.getInputSR().getPannableExtent().width();
      if (Math.abs(e5 / s5 - 1) > 1e-10) return false;
    } else if (0 !== h2 || 0 !== m2) return false;
    n6.add(s4, false);
    for (let e5 = 0; e5 < a2; e5++) {
      const t3 = o2.getXY(e5);
      n6.setXY(e5, t3);
    }
    return true;
  }
  return false;
}
function zl(e5, t2, n6) {
  n2(!n6 || e5.isPannable());
  const r = t2.getPointCount();
  if (!r) return;
  const i2 = t2.getImpl(), o2 = i2.getAttributeStreamRef(0), a2 = e5.getPECoordSys();
  let h2 = 0;
  const m2 = o2.readRange(0, 2 * r);
  let l2 = () => {
    Cc.geogToProj(a2, r, m2);
  };
  const g2 = e5.isPannable() && !n6, u = g2 ? e5.getPannableExtent().width() : 0, c = 179 * u / 360;
  if (e5.isPannable() && (h2 = e5.getCentralMeridian(), n6)) {
    const t3 = e5.m_peCoordSysVal.getGeogToProjFactors(), s4 = t3.first, n7 = t3.second;
    l2 = () => {
      Cc.geogToProj(a2, r, m2);
      for (let e6 = 0; e6 < r; e6++) {
        const t4 = e6 << 1, r2 = o2.read(t4), i3 = s4 * (r2 - h2) + n7;
        m2[t4] = i3;
      }
    };
  }
  if (l2(), g2) for (let s4 = 0; s4 < r; s4++) {
    const e6 = s4 << 1, t3 = m2[e6], n7 = X(t3), r2 = o2.read(e6) - h2;
    n7 * X(r2) < 0 && Math.abs(t3) > c && (m2[e6] += -n7 * u);
  }
  o2.writeRangeFromArray(0, 2 * r, m2, true, 1), i2.notifyModifiedFlags(2001);
}
function Wl(e5, t2, s4) {
  switch (t2.getGeometryType()) {
    case a.enumLine:
      return void Pg(e5, t2, s4);
    case a.enumBezier:
      return void wg(e5, t2, s4);
    case a.enumEllipticArc:
      return void Cg(e5, t2, s4);
    case a.enumBezier2:
      return void vg();
    case a.enumRationalBezier2:
      return void Ng();
    default:
      b("");
  }
}
function jl(e5, t2, n6) {
  if (!t2.hasNonLinearSegments()) return void zl(e5, t2, n6);
  if (n2(!n6 || e5.isPannable()), t2.isEmpty()) return;
  const r = 0, i2 = e5.getPECoordSys(), o2 = e5.isPannable(), a2 = o2 ? e5.getPannableExtent().width() : 0, h2 = 179 * a2 / 360;
  let m2 = 0;
  o2 && (m2 = e5.getCentralMeridian());
  const l2 = t2.createInstance();
  l2.reserveParts(t2.getPointCount(), t2.getPathCount());
  const g2 = t2.getImpl(), u = new nu();
  for (let s4 = 0, c = t2.getPathCount(); s4 < c; ++s4) if (g2.hasNonLinearSegmentsPath(s4)) {
    let t3 = true, r2 = -1;
    const i3 = g2.getPathStart(s4), o3 = i3 + g2.getSegmentCountPath(s4);
    g2.isClosedPath(s4) && (r2 = o3 - 1);
    const a3 = new ei();
    for (let s5 = i3; s5 < o3; ++s5) {
      if (g2.getSegmentBuffer(s5, u, false), Wl(e5, u.get(), n6), !t3) {
        u.get().getStartXY().equals(a3) || u.get().moveTo(a3);
      }
      if (s5 !== r2) l2.addSegment(u.get(), t3);
      else {
        if (t3) {
          const e6 = new ee();
          u.get().queryStart(e6), l2.startPathPoint(e6);
        }
        l2.closeLastPathWithSegment(u.get());
      }
      a3.assign(u.get().getEndXY()), t3 = false;
    }
  } else {
    const e6 = 1024;
    let n7, u2 = g2.getPathSize(s4), c2 = Math.min(u2, e6);
    l2.insertPath(-1, t2, s4, true);
    const _ = g2.getAttributeStreamRef(0), d2 = l2.getAttributeStreamRef(0);
    for (let t3 = g2.getPathStart(s4), l3 = g2.getPathEnd(s4); t3 < l3; ) {
      if (n7 = _.readRange(t3, c2), Cc.geogToProj(i2, c2, n7), o2) for (let e7 = 0; e7 < c2; e7++) {
        const t4 = e7 << 1, s5 = n7[t4], i3 = X(s5), o3 = _.read(2 * (r + e7)) - m2;
        i3 * X(o3) < 0 && Math.abs(s5) > h2 && (n7[t4] += -i3 * a2);
      }
      d2.writeRangeFromArray(t3, c2, n7, true, 1), t3 += c2, u2 -= c2, c2 = Math.min(u2, e6);
    }
  }
  t2.assignMove(l2);
}
function Zl(e5, t2, s4) {
  const n6 = 1e3;
  let r = s4.getPointCount();
  if (!r) return;
  const i2 = s4.getImpl(), o2 = i2.getAttributeStreamRef(0);
  let a2 = Math.min(r, n6), h2 = 0;
  const m2 = e5.getPECoordSys();
  Number.isNaN(t2) && (t2 = 0);
  const l2 = e5.isPannable(), g2 = e5.getOneDegreeGCSUnit(), u = 360 * g2, c = 179 * g2;
  let _;
  for (; r; ) {
    if (_ = o2.readRange(2 * h2, 2 * a2), ng(m2, a2, _, t2), l2) for (let e6 = 0; e6 < a2; e6++) {
      const s5 = e6 << 1, n7 = _[s5] - t2, r2 = X(n7), i3 = o2.read(2 * (h2 + e6));
      r2 * X(i3) < 0 && Math.abs(n7) > c && (_[s5] += -r2 * u);
    }
    o2.writeRangeFromArray(2 * h2, 2 * a2, _, true, 1), h2 += a2, r -= a2, a2 = Math.min(r, n6);
  }
  i2.notifyModifiedFlags(2001);
}
function Kl(e5, t2, s4) {
  switch (s4.getGeometryType()) {
    case a.enumLine:
      return void Ql(e5, t2, s4);
    case a.enumBezier:
      return void eg(e5, t2, s4);
    case a.enumEllipticArc:
      return void Jl(e5, t2, s4);
    case a.enumBezier2:
      return void tg();
    case a.enumRationalBezier2:
      return void sg();
    default:
      b("");
  }
}
function Ql(e5, t2, s4) {
  const n6 = [s4.getStartXY(), s4.getEndXY()];
  ig(e5, t2, n6, 2), s4.setStartXY(n6[0]), s4.setEndXY(n6[1]), s4.normalizeAfterEndpointChange();
}
function Jl(e5, t2, s4) {
  if (0 === s4.projectionBehavior()) $l(e5, t2, s4);
  else {
    const n6 = s4.isClosed() && s4.isMajor(), r = [s4.getStartXY(), n6 ? s4.getCenter() : s4.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    Sg(e5, t2, i2, 2);
    const o2 = new x3();
    o2.initializeFromTwoPointsArray(r, i2), s4.applyTransformation(o2);
    const a2 = n6 ? 0 : 1;
    s4.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function $l(e5, t2, s4) {
  Ig(false, e5, t2, s4, false);
}
function eg(e5, t2, s4) {
  const n6 = Rt(ei, 4);
  s4.queryControlPoints(n6), Sg(e5, t2, n6, 4), s4.setControlPoints(n6);
}
function tg(e5, t2, n6) {
  n2(0);
}
function sg(e5, t2, n6) {
  n2(0);
}
function ng(e5, t2, n6, r) {
  const i2 = Cc.projToGeogCenter(e5, t2, n6, r);
  for (let o2 = 0; o2 < t2; ++o2) {
    const e6 = o2 << 1;
    n2(Number.isFinite(n6[e6] + n6[e6 + 1]));
  }
  return i2;
}
function rg(e5, t2, s4) {
  if (!s4.hasNonLinearSegments()) return void Zl(e5, t2, s4);
  if (s4.isEmpty()) return;
  const n6 = e5.getPECoordSys();
  Number.isNaN(t2) && (t2 = 0);
  const r = e5.isPannable(), i2 = e5.getOneDegreeGCSUnit(), o2 = 360 * i2, a2 = 179 * i2, h2 = s4.createInstance();
  h2.reserveParts(s4.getPointCount(), s4.getPathCount());
  const m2 = s4.getImpl(), l2 = new nu();
  for (let g2 = 0, u = s4.getPathCount(); g2 < u; ++g2) if (m2.hasNonLinearSegmentsPath(g2)) {
    let s5 = true, n7 = -1;
    const r2 = m2.getPathStart(g2), i3 = r2 + m2.getSegmentCountPath(g2);
    m2.isClosedPath(g2) && (n7 = i3 - 1);
    const o3 = new ei();
    for (let a3 = r2; a3 < i3; ++a3) {
      if (m2.getSegmentBuffer(a3, l2, false), Kl(e5, t2, l2.get()), !s5) {
        l2.get().getStartXY().equals(o3) || l2.get().moveTo(o3);
      }
      if (a3 !== n7) h2.addSegment(l2.get(), s5);
      else {
        if (s5) {
          const e6 = new ee();
          l2.get().queryStart(e6), h2.startPathPoint(e6);
        }
        h2.closeLastPathWithSegment(l2.get());
      }
      o3.assign(l2.get().getEndXY()), s5 = false;
    }
  } else {
    const e6 = 1e3;
    let i3, l3 = m2.getPathSize(g2), u2 = Math.min(l3, e6);
    h2.insertPath(-1, s4, g2, true);
    const c = m2.getAttributeStreamRef(0), _ = h2.getAttributeStreamRef(0);
    for (let s5 = m2.getPathStart(g2), h3 = m2.getPathEnd(g2); s5 < h3; ) {
      if (i3 = c.readRange(2 * s5, 2 * u2), ng(n6, u2, i3, t2), r) for (let e7 = 0; e7 < u2; e7++) {
        const n7 = e7 << 1, r2 = i3[n7] - t2, h4 = X(r2), m3 = c.read(2 * s5);
        h4 * X(m3) < 0 && Math.abs(r2) > a2 && (i3[n7] += -h4 * o2);
      }
      _.writeRangeFromArray(2 * s5, 2 * u2, i3, true, 1), s5 += u2, l3 -= u2, u2 = Math.min(l3, e6);
    }
  }
  s4.assignMove(h2);
}
function ig(e5, t2, s4, n6) {
  const r = e5.getPECoordSys();
  Number.isNaN(t2) && (t2 = 0);
  const i2 = e5.isPannable(), o2 = e5.getOneDegreeGCSUnit(), a2 = 360 * o2, h2 = 179 * o2, m2 = 256, l2 = new Float64Array(2 * m2);
  for (let g2 = 0; g2 < n6; ) {
    for (let t3 = g2; t3 < n6 && s4[t3].isNAN(); ++t3) g2++;
    let e6 = Math.min(m2, n6 - g2);
    if (e6 > 0) {
      for (let t3 = 1, n7 = g2 + 1; t3 < e6; ++t3, ++n7) if (s4[n7].isNAN()) {
        e6 = t3;
        break;
      }
      for (let t3 = 0; t3 < e6; t3++) {
        const e7 = t3 << 1;
        l2[e7] = s4[g2 + t3].x, l2[e7 + 1] = s4[g2 + t3].y;
      }
      if (ng(r, e6, l2, t2), i2) for (let n7 = 0, r2 = g2; n7 < e6; ++n7, ++r2) {
        const e7 = n7 << 1, i3 = s4[r2].x, o3 = l2[e7] - t2, m3 = X(o3);
        m3 * X(i3) < 0 && Math.abs(o3) > h2 && (l2[e7] -= m3 * a2);
      }
      for (let t3 = 0; t3 < e6; t3++) {
        const e7 = t3 << 1;
        s4[g2 + t3].x = l2[e7], s4[g2 + t3].y = l2[e7 + 1];
      }
      g2 += e6;
    }
  }
}
function og(e5, t2, n6, r) {
  n2(0);
}
function ag(e5, t2, s4) {
  let n6 = t2.getPointCount();
  if (!n6) return false;
  const r = t2.getImpl(), i2 = r.getAttributeStreamRef(0);
  let o2 = null;
  const a2 = e5.getInputSR(), h2 = e5.getOutputSR();
  a2.getVCS(), h2.getVCS();
  const m2 = a2.getOneDegreeGCSUnit(), l2 = h2.getOneDegreeGCSUnit(), g2 = e5.isVertical();
  g2 && t2.hasAttribute(1) && (o2 = r.getAttributeStreamRef(1));
  const u = e5.getDatumTransformation(), c = !!u && 1 === u.getType();
  if (c || null === o2 || (og(o2.getArray()), o2 = null), !u || 0 === u.count()) {
    const e6 = a2.getGcsUnitFactor() / h2.getGcsUnitFactor(), t3 = (a2.getPrimeMeridian() - h2.getPrimeMeridian()) * l2, s5 = -90 * m2, o3 = 90 * m2;
    let g3 = 0;
    const u2 = i2.getArray(), c2 = [0];
    for (let r2 = 1, i3 = 2 * n6; r2 < i3; ) c2[0] = u2[r2], g3 |= Ls(c2, s5, o3) ? 1 : 0, u2[r2] = c2[0], r2 += 2;
    if (0 !== t3 || 1 !== e6) {
      g3 = 1;
      const s6 = i2.getArray();
      for (let r2 = 0, i3 = 2 * n6; r2 < i3; ) {
        let n7 = s6[r2];
        n7 *= e6, n7 += t3, s6[r2] = n7, s6[r2 + 1] *= e6, r2 += 2;
      }
    }
    return 0 !== g3 && r.notifyModifiedFlags(2001), !!g3;
  }
  const _ = 1e3;
  let d2 = Math.min(n6, _);
  const p3 = Lt(d2, Number.NaN), f3 = Lt(d2, Number.NaN);
  let x4 = null;
  null !== o2 && (x4 = new Float64Array(d2));
  let y2 = 0, P5 = Number.NaN, E2 = Number.NaN;
  const C2 = 360 * l2, S3 = l2 / m2;
  s4 && (E2 = 90 * l2, P5 = 89.9 * m2, f3.fill(0));
  let I5 = true, b2 = 0;
  for (; n6; ) {
    let e6 = false;
    const t3 = i2.readRange(2 * y2, 2 * d2);
    for (let s5 = 0; s5 < d2; s5++) p3[s5] = t3[s5 << 1];
    if (s4) for (let s5 = 0; s5 < d2; s5++) {
      const n7 = 1 + (s5 << 1), r3 = Math.abs(t3[n7]) - P5;
      if (r3 > 0) {
        const i3 = t3[n7];
        t3[n7] = B2(P5, i3), f3[s5] = B2(r3, i3), e6 = true;
      }
    }
    const r2 = t3[0];
    if (c) {
      const e7 = u;
      x4 && o2.queryRange(y2, d2, x4, true, 1), e7.transform(false, t3, x4, d2), x4 && o2.writeRangeFromArray(y2, d2, x4, true, 1);
    } else {
      u.transform(false, t3, d2);
    }
    I5 && (b2 = t3[0] - S3 * r2, I5 = false);
    for (let s5 = 0; s5 < d2; s5++) {
      const e7 = s5 << 1, n7 = t3[e7] - p3[s5] * S3 - b2;
      Math.abs(n7) > 200 && (t3[e7] += n7 > 0 ? -C2 : C2);
    }
    if (e6) {
      for (let e7 = 0; e7 < d2; e7++) if (f3[e7]) {
        const s5 = 1 + (e7 << 1);
        t3[s5] += S3 * f3[e7], t3[s5] > E2 ? t3[s5] = E2 : t3[s5] < -E2 && (t3[s5] = -E2);
      }
      f3.fill(0);
    }
    i2.writeRangeFromArray(2 * y2, 2 * d2, t3, true, 1), g2 && o2 && o2.writeRangeFromArray(y2, d2, x4, true, 1), y2 += d2, n6 -= d2, d2 = Math.min(n6, _);
  }
  return r.notifyModifiedFlags(2001), true;
}
function hg(e5, t2, s4) {
  switch (t2.getGeometryType()) {
    case a.enumLine:
      return _g(e5, t2, s4);
    case a.enumBezier:
      return fg(e5, t2, s4);
    case a.enumEllipticArc:
      return dg(e5, t2, s4);
    case a.enumBezier2:
      return xg();
    case a.enumRationalBezier2:
      return yg();
    default:
      b("");
  }
}
function mg(e5, t2, s4) {
  if (!t2.hasNonLinearSegments()) return ag(e5, t2, s4);
  if (t2.isEmpty()) return false;
  const n6 = t2.createInstance();
  n6.reserveParts(t2.getPointCount(), t2.getPathCount());
  const r = t2.getImpl(), i2 = new nu();
  for (let o2 = 0, a2 = t2.getPathCount(); o2 < a2; ++o2) {
    let t3 = true, a3 = -1;
    const h2 = r.getPathStart(o2), m2 = h2 + r.getSegmentCountPath(o2);
    r.isClosedPath(o2) && (a3 = m2 - 1);
    const l2 = new ei();
    for (let o3 = h2; o3 < m2; ++o3) {
      if (r.getSegmentBuffer(o3, i2, false), hg(e5, i2.get(), s4), !t3) {
        i2.get().getStartXY().equals(l2) || i2.get().moveTo(l2);
      }
      if (o3 !== a3) n6.addSegment(i2.get(), t3);
      else {
        if (t3) {
          const e6 = new ee();
          i2.get().queryStart(e6), n6.startPathPoint(e6);
        }
        n6.closeLastPathWithSegment(i2.get());
      }
      l2.assign(i2.get().getEndXY()), t3 = false;
    }
  }
  return t2.assignMove(n6), true;
}
function lg(e5, t2, s4, n6, r, i2) {
  if (e5.isIdentityGeogToGeog()) {
    const s5 = 90 * e5.getInputSR().getOneDegreeGCSUnit();
    let r2 = 0;
    const i3 = [0];
    for (let e6 = 0; e6 < n6; e6++) i3[0] = t2[e6].y, r2 |= Ls(i3, -s5, s5) ? 1 : 0, t2[e6].y = i3[0];
    return r2;
  }
  const o2 = e5.getInputSR(), a2 = e5.getOutputSR(), h2 = o2.getVCS(), m2 = a2.getVCS(), l2 = o2.getOneDegreeGCSUnit(), g2 = 90 * l2, u = a2.getOneDegreeGCSUnit(), c = e5.isVertical(), _ = e5.getDatumTransformation(), d2 = !!_ && 1 === _.getType();
  if (c || (s4 = null), !_ || 0 === _.count()) {
    let e6 = 0;
    const r2 = [0];
    for (let s5 = 0; s5 < n6; s5++) r2[0] = t2[s5].y, e6 |= Ls(r2, -g2, g2) ? 1 : 0, t2[s5].y = r2[0];
    return e6 |= km2(o2.getGCS(), h2, a2.getGCS(), m2, t2, s4, n6) ? 1 : 0, e6;
  }
  d2 || null === s4 || og();
  const p3 = 1024;
  let f3 = Math.min(n6, p3);
  const x4 = Lt(f3, Number.NaN), y2 = Lt(f3, Number.NaN);
  let P5 = 0, E2 = Number.NaN, C2 = Number.NaN;
  const S3 = 360 * u, I5 = u / l2;
  r && (C2 = 90 * u, E2 = 89.9 * l2);
  let b2 = true, w4 = 0, v3 = n6;
  for (; v3; ) {
    let e6 = false;
    for (let s5 = 0; s5 < f3; s5++) x4[s5] = t2[s5 + P5].x;
    if (r) for (let s5 = 0; s5 < f3; s5++) {
      const n8 = Math.abs(t2[s5 + P5].y) - E2;
      if (n8 > 0) {
        const r2 = t2[s5 + P5].y;
        t2[s5 + P5].y = B2(E2, r2), y2[s5] = B2(n8, r2), e6 = true;
      }
    }
    const n7 = t2[0].x;
    if (d2) {
      _.transform(false, t2, s4, f3);
    } else {
      _.transform(false, t2, f3);
    }
    b2 && (w4 = t2[0].x - I5 * n7, b2 = false);
    for (let s5 = 0; s5 < f3; s5++) {
      const e7 = t2[P5 + s5].x - x4[s5] * I5 - w4;
      Math.abs(e7) > 200 && (e7 > 0 ? t2[P5 + s5].x -= S3 : t2[P5 + s5].x += S3);
    }
    if (e6) {
      for (let e7 = 0; e7 < f3; e7++) y2[e7] && (t2[P5 + e7].y += I5 * y2[e7], t2[P5 + e7].y > C2 ? t2[P5 + e7].y = C2 : t2[P5 + e7].y < -C2 && (t2[P5 + e7].y = -C2));
      y2.fill(0, 0, f3);
    }
    P5 += f3, v3 -= f3, f3 = Math.min(v3, p3);
  }
  return 1;
}
function gg(e5, t2, n6, r, i2) {
  return n2(0), 0;
}
function ug(e5, t2, n6, r, i2) {
  n2(null === r), n2(t2 < 2147483647);
  const o2 = Array.isArray(n6);
  let a2;
  a2 = o2 ? si(n6) : n6;
  const h2 = Sc.geogToGeog(e5, t2, a2, null, i2);
  return o2 && ti(a2, n6), h2;
}
function cg(e5, t2, s4, n6, r, i2) {
  let o2 = 0, a2 = true, h2 = 0;
  for (let m2 = 0; m2 < n6; ++m2) t2[m2].isNAN() ? a2 || (o2 |= lg(e5, t2.slice(h2, m2 - h2), s4 ? s4.slice(h2, m2 - h2) : null, m2 - h2, r), h2 = m2, a2 = true) : a2 && (h2 = m2, a2 = false);
  return a2 || (o2 |= lg(e5, 0 === h2 ? t2 : t2.slice(h2), s4 ? 0 === h2 ? s4 : s4.slice(h2) : null, n6 - h2, r)), 0 !== o2;
}
function _g(e5, t2, s4) {
  const n6 = [t2.getStartXY(), t2.getEndXY()], r = [0, 0];
  let i2 = null;
  t2.hasAttribute(1) && (i2 = r, i2[0] = t2.getAttributeAsDbl(0, 1, 0), i2[1] = t2.getAttributeAsDbl(1, 1, 0));
  const o2 = cg(e5, n6, i2, 2, s4);
  return t2.setStartXY(n6[0]), t2.setEndXY(n6[1]), i2 && (t2.setStartAttribute(1, 0, i2[0]), t2.setEndAttribute(1, 0, i2[1])), t2.normalizeAfterEndpointChange(), o2;
}
function dg(e5, t2, s4) {
  if (0 === t2.projectionBehavior()) return pg(e5, t2, s4);
  const n6 = t2.getStartXY().equals(t2.getEndXY()), r = Rt(ei, 3), i2 = Rt(ei, 3), o2 = [0, 0, 0];
  let a2 = null;
  r[0].assign(t2.getStartXY()), r[1].assign(n6 ? t2.getCenter() : t2.getEndXY());
  let h2 = false;
  t2.hasAttribute(1) && (a2 = o2, a2[0] = t2.getAttributeAsDbl(0, 1, 0), a2[1] = t2.getAttributeAsDbl(1, 1, 0), a2[2] = Q(a2[0], a2[1], 0.5), n6 && (a2[1] = a2[2])), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]);
  const m2 = new x3();
  if (n6 || t2.isDegenerateToLine()) h2 = cg(e5, i2, a2, 2, s4), m2.initializeFromTwoPoints(r[0], r[1], i2[0], i2[1]);
  else {
    const n7 = new ei();
    t2.queryCoord2D(0.5, n7), r[2].setCoordsPoint2D(n7), i2[2].setCoordsPoint2D(n7), h2 = cg(e5, i2, a2, 3, s4), m2.setFromTwoTriangles(r, i2);
  }
  return m2.isIdentity() || (t2.applyTransformation(m2), t2.setStartXY(i2[0]), t2.setEndXY(n6 ? i2[0] : i2[1]), t2.normalizeAfterEndpointChange()), a2 && (t2.setStartAttribute(1, 0, a2[0]), t2.setEndAttribute(1, 0, n6 ? a2[0] : a2[1])), h2;
}
function pg(e5, t2, s4) {
  const n6 = [t2.getStartXY(), t2.getEndXY(), t2.getInteriorPoint(), t2.getCenter()];
  let r = 4;
  t2.isDegenerateToLine() && (r = 2);
  const i2 = [0, 0, 0, 0];
  let o2 = null;
  if (t2.hasAttribute(1)) {
    o2 = i2, o2[0] = t2.getAttributeAsDbl(0, 1, 0), o2[1] = t2.getAttributeAsDbl(1, 1, 0);
    const e6 = Q(o2[0], o2[1], 0.5);
    o2[2] = e6, o2[3] = e6;
  }
  const a2 = t2.getStartXY().equals(t2.getEndXY()) && !t2.isDegenerateToLine(), h2 = cg(e5, n6, o2, r, s4);
  return a2 ? t2.constructCircleCenterAndPoint(n6[3], n6[0], !t2.isClockwise()) : t2.isDegenerateToLine() ? t2.constructLineCircularArc(n6[0], n6[1]) : t2.constructCircularArcThreePoint(n6[0], n6[1], n6[2]), o2 && (t2.setStartAttribute(1, 0, o2[0]), t2.setEndAttribute(1, 0, o2[1])), h2;
}
function fg(e5, t2, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6);
  const r = [0, 0, 0, 0];
  let i2 = null;
  t2.hasAttribute(1) && (i2 = r, i2[0] = t2.getAttributeAsDbl(0, 1, 0), i2[3] = t2.getAttributeAsDbl(1, 1, 0), i2[1] = Q(i2[0], i2[3], 0.5), i2[2] = i2[1]);
  const o2 = cg(e5, n6, i2 || null, n6.length, s4);
  return t2.setControlPoints(n6), i2 && (t2.setStartAttribute(1, 0, i2[0]), t2.setEndAttribute(1, 0, i2[3])), t2.normalizeAfterEndpointChange(), o2;
}
function xg(e5, t2, n6) {
  return n2(0), false;
}
function yg(e5, t2, n6) {
  return n2(0), false;
}
function Pg(e5, t2, s4) {
  const n6 = [t2.getStartXY(), t2.getEndXY()];
  Yl(e5, n6, 2, s4), t2.setStartXY(n6[0]), t2.setEndXY(n6[1]), t2.normalizeAfterEndpointChange();
}
function Eg(e5, t2, s4, n6) {
  Yl(e5, t2, s4, n6);
}
function Cg(e5, t2, s4) {
  if (0 === t2.projectionBehavior()) bg(e5, t2, s4);
  else {
    const n6 = t2.isClosed() && t2.isMajor(), r = [t2.getStartXY(), n6 ? t2.getCenter() : t2.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    Eg(e5, i2, 2, s4);
    const o2 = new x3();
    o2.initializeFromTwoPointsArray(r, i2), t2.applyTransformation(o2);
    const a2 = n6 ? 0 : 1;
    t2.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function Sg(t2, s4, n6, r) {
  ig(t2, s4, n6, r);
  const i2 = new n4();
  i2.setFromPoints(n6, r);
  const o2 = t2.getOneDegreeGCSUnit(), a2 = 360 * o2, h2 = 180 * o2;
  if (i2.width() > h2) {
    for (let e5 = 0; e5 < r; e5++) for (; n6[e5].x < s4; ) n6[e5].x += a2;
    if (i2.setFromPoints(n6, r), i2.xmax > h2 + s4) for (let e5 = 0; e5 < r; e5++) n6[e5].x -= a2;
  }
}
function Ig(e5, t2, s4, n6, r) {
  const i2 = Rt(ei, 3);
  let o2 = 0, a2 = false, h2 = false;
  const m2 = n6.isDegenerateToLine();
  m2 ? (i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getEndXY()), i2[2].setCoords(0, 0), o2 = 2) : n6.isClosed() && n6.isMajor() ? (a2 = true, h2 = !n6.isClockwise(), i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getCenter()), i2[2].setCoords(0, 0), o2 = 2) : (i2[0].assign(n6.getStartXY()), i2[1].assign(n6.getEndXY()), i2[2].assign(n6.getInteriorPoint()), o2 = 3), e5 ? Eg(t2, i2, o2, r) : Sg(t2, s4, i2, o2), m2 ? n6.constructLineCircularArc(i2[0], i2[1]) : a2 ? n6.constructCircleCenterAndPoint(i2[1], i2[0], h2) : n6.constructCircularArcThreePoint(i2[0], i2[1], i2[2]);
}
function bg(e5, t2, s4) {
  Ig(true, e5, 0, t2, s4);
}
function wg(e5, t2, s4) {
  const n6 = Rt(ei, 4);
  t2.queryControlPoints(n6), Eg(e5, n6, 4, s4), t2.setControlPoints(n6);
}
function vg(e5, t2, n6) {
  n2(0);
}
function Ng(e5, t2, n6) {
  n2(0);
}
function Tg(e5, t2, s4) {
  const n6 = Wa(e5), r = Wa(t2), i2 = Ha(n6, r), o2 = Ha(n6, Wa(s4));
  return 0 === o2 || (i2 > 0 && o2 > 0 && o2 <= i2 || i2 < 0 && o2 < 0 && o2 >= i2);
}
function Gg(e5, t2, n6, r, i2) {
  const o2 = { stack: [], error: void 0, hasError: false };
  try {
    const a2 = n6.clone(), h2 = r.clone();
    if (2 === i2) {
      const s4 = [0, 0];
      return Ns2(e5, t2, a2, h2, 0, s4), s4[0];
    }
    if (a2.y > h2.y) {
      const e6 = new ei();
      e6.assign(a2), a2.assign(h2), h2.assign(e6);
    }
    const m2 = n(o2, new yc(), false), l2 = n(o2, new yc(), false), g2 = n(o2, new yc(), false), u = new x2();
    if (u.setCoords(a2.y, h2.y), !u.containsCoordinate(0) || Math.abs(a2.x - h2.x) >= Math.PI) return Number.NaN;
    if (a2.x === h2.x) return a2.x;
    vc.geodeticDistance(e5, t2, a2.x, a2.y, h2.x, h2.y, l2, m2, null, i2);
    const c = l2.val;
    let _ = 0, d2 = 1;
    const p3 = a2.clone();
    for (; c * (d2 - _) > 1e-12 * e5; ) {
      const n7 = 0.5 * (_ + d2);
      if (vc.geodeticCoordinate(e5, t2, a2.x, a2.y, c * n7, m2.val, l2, g2, i2), p3.x = l2.val, p3.y = g2.val, u.setCoords(a2.y, p3.y), 0 === p3.y) return p3.x;
      if (u.containsCoordinate(0)) d2 = n7;
      else {
        if (u.setCoords(h2.y, p3.y), !u.containsCoordinate(0)) return n2(false), Number.NaN;
        _ = n7;
      }
    }
    return p3.x;
  } catch (a2) {
    o2.error = a2, o2.hasError = true;
  } finally {
    s(o2);
  }
}
function Dg(e5, t2, s4, n6) {
  const r = new x2();
  r.setCoords(t2, s4);
  const i2 = n6.width();
  let o2 = Math.floor((e5 - t2) / i2) * i2 + e5;
  const a2 = r.getCenter();
  for (; Math.abs(o2 - a2) > Math.abs(o2 + i2 - a2); ) o2 += i2;
  return o2;
}
var Vg = class extends t {
  constructor() {
    super(), this.m_geometryDeque = [], this.m_index = -1;
  }
  next() {
    if (this.m_geometryDeque.length > 0) {
      this.m_index++;
      const e5 = this.m_geometryDeque[0];
      return this.m_geometryDeque.shift(), e5;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tick(e5) {
    this.m_geometryDeque.push(e5);
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Fg(e5, t2) {
  return e5 === t2 || null !== e5 && null !== t2 && (e5.m_csType === t2.m_csType && (0 === e5.m_WKID && 0 === t2.m_WKID ? e5.m_hashCode === t2.m_hashCode && e5.m_canonicalWkt === t2.m_canonicalWkt : e5.m_WKID === t2.m_WKID));
}
function Hg(e5, t2) {
  return e5 === t2 || null !== e5 && null !== t2 && (e5.m_csType === t2.m_csType && (0 === e5.m_WKID && 0 === t2.m_WKID ? 1 === e5.m_csType ? e5.m_peCoordSys.isEqual(t2.m_peCoordSys) : e5.m_peCoordSys === t2.m_peCoordSys : e5.m_WKID === t2.m_WKID));
}
var kg = class {
  constructor(n6, r = true) {
    this.m_PCSHorizon = null, this.m_GCSHorizon = null, this.m_GCSSplitLines = null, this.m_bGCSHorisonIsInclusive = false, this.m_oneMeterPCS = 0, this.m_oneDegreeGCS = 0, this.m_gcsUnitFactor = 0, this.m_northPole = ei.getNAN(), this.m_southPole = ei.getNAN(), this.m_polesUpdated = 0, this.m_domain = n4.constructEmpty(), this.m_primeMeridian = Number.NaN, this.m_geogToProjFactor = 1, this.m_geogToProjOffset = 0, this.m_geogToProjFactorsUpdated = 0, this.m_oneMillimeter = 0, this.m_centralMeridian = 0, this.m_pPCSInfoNoDomain = null, this.m_oldWKID = -1973, this.m_vcsWKID = -1, this.m_bIsPannable = false, this.m_bCached = false, this.m_pannableExtent = n4.constructEmpty(), this.m_pannableExtentGCS = n4.constructEmpty(), this.m_areaOfUse = null, this.m_canonicalWkt = "", this.m_peCoordSys = n6, this.m_WKID = Pc.getCode(n6), this.m_WKID <= 0 ? (this.m_WKID = 0, this.m_canonicalWkt = ll(n6, 0, true), this.m_hashCode = Ts(this.m_canonicalWkt)) : this.m_hashCode = qs(this.m_WKID);
    const i2 = this.m_peCoordSys.getType();
    this.m_csType = i2 === Ec.PE_TYPE_PROJCS ? 2 : 1, n2(i2 === Ec.PE_TYPE_PROJCS || i2 === Ec.PE_TYPE_GEOGCS), i2 === Ec.PE_TYPE_PROJCS && (n6.loadConstants() || P("PeProjcs.loadConstants failed"));
    const o2 = i2 === Ec.PE_TYPE_GEOGCS ? this.m_peCoordSys : this.m_peCoordSys.getGeogcs();
    i2 !== Ec.PE_TYPE_GEOGCS && Pc.getCode(o2), this.m_unit = os3(n6), this.m_primeMeridian = o2.getPrimem().getLongitude();
    {
      const e5 = o2.getUnit().getUnitFactor();
      this.m_gcsUnitFactor = e5;
      let t2 = Math.PI / (180 * e5);
      Math.abs(t2 - 1) < 1e-10 && (t2 = 1), this.m_oneDegreeGCS = t2;
    }
    if (i2 === Ec.PE_TYPE_PROJCS) {
      const e5 = this.m_peCoordSys, t2 = e5.getUnit().getUnitFactor();
      this.m_oneMeterPCS = 1 / t2, this.m_oneMillimeter = 1e-3 / t2, this.m_pPCSInfoNoDomain = Ic.generate(e5, Ic.PE_PCSINFO_OPTION_NONE), this.m_pPCSInfoNoDomain || b("cannot create pcs info"), this.m_bIsPannable = this.m_pPCSInfoNoDomain.isPannableRectangle(), this.m_centralMeridian = this.m_pPCSInfoNoDomain.getCentralMeridian();
    } else {
      this.m_bIsPannable = true, this.m_polesUpdated = 1, this.m_oneMeterPCS = 0;
      const e5 = 1 / o2.getUnit().getUnitFactor(), t2 = o2.getDatum().getSpheroid().getAxis();
      this.m_oneMillimeter = 1e-3 / t2 * e5, this.m_centralMeridian = 0;
    }
    this.m_bIsPannable && (this.updateGCSHorizon(), this.updatePCSHorizon(), this.updatePoles(), this.updateDomain(), this.updatePannableExtent(), this.updatePannableExtentGCS());
  }
  [Symbol.dispose]() {
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getPCSHorizonPannable() {
    return this.m_PCSHorizon;
  }
  getGCSHorizonPannable() {
    return this.m_GCSHorizon;
  }
  getPCSInfo() {
    return n2(this.m_pPCSInfoNoDomain), this.m_pPCSInfoNoDomain;
  }
  getCentralMeridian() {
    return this.m_centralMeridian;
  }
  updateGCSHorizon() {
    if (this.m_peCoordSys.getType() !== Ec.PE_TYPE_PROJCS) return;
    let t2 = true;
    const n6 = this.m_peCoordSys, r = n6.getGeogcs(), i2 = n6.horizonGcsGenerate();
    if (!i2) return;
    n2(i2.length > 0);
    const o2 = i2[0].getNump(), a2 = i2[0].getKind();
    let h2, m2;
    t2 = i2[0].getInclusive() > 0;
    const l2 = this.getOneDegreeGCSUnit(), g2 = 90 * l2, u = 360 * l2, c = 370 * l2, _ = 180 * l2 * Ec.PE_HORIZON_DELTA / Math.PI, d2 = n4.constructEmpty();
    let p3 = null;
    if (o2 > 1) {
      for (let e5 = 1; e5 < o2; e5++) if (i2[e5].getKind() === Ec.PE_HORIZON_LINE) {
        p3 || (p3 = new Na());
        const t3 = i2[e5].getCoord();
        p3.startPathCoords(t3[0][0], t3[0][1]), p3.lineToCoords(t3[1][0], t3[1][1]);
      }
    }
    if (a2 === Ec.PE_HORIZON_RECT) {
      const e5 = i2[0].getCoord();
      if (d2.setFromPoints([new ei(e5[0][0], e5[0][1]), new ei(e5[1][0], e5[1][1])], 2), Math.abs(d2.ymax - g2) < 1e-7 * _ && (d2.ymax = g2), Math.abs(d2.ymin + g2) < 1e-7 * _ && (d2.ymin = -g2), d2.width() > c) {
        const e6 = -400 * l2, t3 = e6 + 5 * u;
        d2.setCoords({ xmin: e6, ymin: d2.ymin, xmax: t3, ymax: d2.ymax });
      }
      const s4 = new re({ env2D: d2 });
      this.m_GCSHorizon || (this.m_GCSHorizon = s4, this.m_bGCSHorisonIsInclusive = t2);
    } else {
      let n7 = this.getPCSInfo().isGcsHorizonMultiOverlap();
      const a3 = qu(r, null, null, 1), c2 = [], _2 = new x2();
      for (let t3 = 0; t3 < o2; t3++) {
        if (i2[t3].getKind() !== Ec.PE_HORIZON_POLY) continue;
        h2 = i2[t3].getSize();
        const s4 = i2[t3].getCoord(), n8 = n4.constructEmpty();
        n8.setFromPoints(ii(s4), h2), c2.push(new x2(n8.xmin, n8.xmax)), n8.width(), _2.merge(c2.at(-1));
      }
      let d3 = false;
      const f3 = new x2();
      _2.width() > u && c2.length > 1 ? (f3.vmin = this.getCentralMeridian() - u, f3.vmax = f3.vmin + 2 * u, d3 = true, n7 = true) : (f3.vmin = _2.vmin, f3.vmax = f3.vmin + u);
      const x4 = (e5) => {
        let t3 = 0;
        for (; c2[e5].vmin + t3 < f3.vmin; ) t3 += u;
        for (; c2[e5].vmax + t3 - u > f3.vmin; ) t3 -= u;
        return t3;
      };
      let y2 = new eh();
      if (n7) {
        const e5 = new Vg(), t3 = new nl().executeMany(e5, a3, null);
        for (let s4 = 0; s4 < o2; s4++) {
          if (i2[s4].getKind() !== Ec.PE_HORIZON_POLY) continue;
          h2 = i2[s4].getSize();
          const n8 = i2[s4].getCoord();
          m2 = i2[s4].getInclusive() > 0;
          const r2 = new eh();
          if (r2.addPathPoint2D(ii(n8), h2 - 1, true), d3) {
            const t4 = x4(s4), n9 = c2[s4].clone();
            n9.move(t4);
            let i3 = t4;
            const o3 = new x3();
            do {
              o3.setShiftCoords(i3, 0);
              const t5 = r2.clone();
              t5.applyTransformation(o3), e5.tick(t5), e5.tock(), i3 += u, n9.move(u);
            } while (n9.vmin < f3.vmax);
          } else e5.tick(r2), t3.tock();
        }
        y2 = t3.next();
      } else {
        y2 = new eh();
        for (let e5 = 0; e5 < o2; e5++) {
          if (i2[e5].getKind() !== Ec.PE_HORIZON_POLY) continue;
          h2 = i2[e5].getSize();
          const n8 = i2[e5].getCoord();
          if (m2 = i2[e5].getInclusive() > 0, n2(m2 === t2), d3) {
            const t3 = new eh();
            t3.addPathPoint2D(ii(n8), h2 - 1, true);
            const s4 = x4(e5), r2 = c2[e5].clone();
            r2.move(s4);
            let i3 = s4;
            const o3 = new x3();
            do {
              if (0 !== i3) {
                o3.setShiftCoords(i3, 0);
                const e6 = new eh({ copy: t3 });
                e6.applyTransformation(o3), y2.addPath(e6, 0, true);
              } else y2.addPath(t3, 0, true);
              i3 += u, r2.move(u);
            } while (r2.vmin < f3.vmax);
          } else y2.addPathPoint2D(ii(n8), h2 - 1, true);
        }
      }
      d3 && (y2 = new I4().execute(y2, new n4(f3.vmin, -g2 - l2, f3.vmax, g2 + l2), a3, null)), t2 ? new Ch2().accelerateGeometry(y2, a3, 1) : new zm2().accelerateGeometry(y2, a3, 1), new hl().accelerateGeometry(y2, a3, 1), null === this.m_GCSHorizon && (this.m_GCSHorizon = y2, this.m_bGCSHorisonIsInclusive = t2, this.m_GCSSplitLines = p3);
    }
  }
  updateAreaOfUse() {
    return null;
  }
  updatePCSHorizon() {
    if (this.m_peCoordSys.getType() !== Ec.PE_TYPE_PROJCS) return;
    const t2 = this.m_peCoordSys.horizonPcsGenerate();
    if (!t2) return;
    let n6;
    this.getPCSInfo();
    const r = t2[0].getKind();
    t2[0].getInclusive();
    const i2 = n4.constructEmpty(), o2 = t2[0].getNump();
    let a2 = false;
    if (r === Ec.PE_HORIZON_RECT) {
      const e5 = t2[0].getCoord();
      i2.setFromPoints(ii(e5), 2), n6 = new re({ env2D: i2 });
    } else {
      let e5 = -1;
      for (let s4 = 0; s4 < o2; s4++) t2[s4].getKind() === Ec.PE_HORIZON_POLY && (e5 = s4);
      n2(e5 >= 0);
      const r2 = t2[e5].getSize() - 1, i3 = t2[e5].getCoord(), h2 = new eh();
      n6 = h2, h2.addPathPoint2D(ii(i3), r2, true), a2 = true;
    }
    if (this.getPCSInfo().isDensificationNeeded()) {
      n2(r !== Ec.PE_HORIZON_RECT);
      const e5 = 1e5 * this.getOneMeterPCSUnit();
      n6 = new o().execute(n6, e5, 0, 0, null);
    }
    if (a2) {
      {
        const e5 = new re();
        n6.queryEnvelope(e5), n6.calculateArea2D(), n6.calculateLength2D(), n6.getExteriorRingCount();
      }
      new Ch2().accelerateGeometry(n6, null, 1);
    }
    null === this.m_PCSHorizon && (this.m_PCSHorizon = n6);
  }
  updatePannableExtent() {
    const t2 = this.m_peCoordSys.getType();
    if (t2 === Ec.PE_TYPE_PROJCS) {
      const t3 = this.m_peCoordSys, s4 = this.getPCSInfo().getCentralMeridian(), n6 = t3.getGeogcs();
      n6 || b("");
      const r = [s4 + 1 / n6.getUnit().getUnitFactor() * Math.PI, 0];
      Cc.geogToProj(t3, 1, r);
      const i2 = r[0], o2 = t3.getParameters()[Ec.PE_PARM_X0].getValue(), a2 = this.getPCSHorizon(), h2 = n4.constructEmpty();
      a2.queryEnvelope(h2);
      const m2 = Math.abs(i2 - o2), l2 = m2 + o2, u = -1 * m2 + o2, c = h2.ymax, _ = h2.ymin;
      this.m_pannableExtent.setCoords({ xmin: u, ymin: _, xmax: l2, ymax: c });
    } else if (t2 === Ec.PE_TYPE_GEOGCS) {
      const e5 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtent.setCoords({ xmin: -e5, ymin: -e5 / 2, xmax: e5, ymax: e5 / 2 });
    } else b("");
  }
  updatePannableExtentGCS() {
    const t2 = this.m_peCoordSys.getType();
    if (t2 === Ec.PE_TYPE_PROJCS) {
      const t3 = this.m_peCoordSys, s4 = this.m_centralMeridian, n6 = t3.getGeogcs();
      n6 || b("");
      const r = 1 / n6.getUnit().getUnitFactor() * Math.PI, i2 = this.getGCSHorizon(), o2 = n4.constructEmpty();
      i2.queryEnvelope(o2), this.m_pannableExtentGCS.setCoords({ xmin: s4 - r, ymin: o2.ymin, xmax: s4 + r, ymax: o2.ymax });
    } else if (t2 === Ec.PE_TYPE_GEOGCS) {
      const e5 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtentGCS.setCoords({ xmin: -e5, ymin: -e5 / 2, xmax: e5, ymax: e5 / 2 });
    } else b("");
  }
  updateDomain() {
    if (1 === this.m_csType) {
      const t2 = 400 * this.getOneDegreeGCSUnit();
      this.m_domain = n4.construct(-t2, -t2, t2, t2);
    } else {
      n2(2 === this.m_csType);
      const t2 = Ic.generate(this.m_peCoordSys, Ic.PE_PCSINFO_OPTION_DOMAIN);
      t2 || b("generate pcs info failed");
      const n6 = new n4(t2.getDomainMinx(), t2.getDomainMiny(), t2.getDomainMaxx(), t2.getDomainMaxy());
      this.m_domain.isEmpty() && this.m_domain.setCoords({ env2D: n6 });
    }
  }
  updatePoles() {
    if (this.m_peCoordSys.getType() === Ec.PE_TYPE_PROJCS) {
      const e5 = 90 * this.getOneDegreeGCSUnit(), t2 = [[0, e5], [0, -e5]];
      Cc.geogToProj(this.m_peCoordSys, 2, t2);
      const s4 = this.getPCSInfo().getNorthPoleLocation() !== Ic.PE_POLE_OUTSIDE_BOUNDARY, n6 = this.getPCSInfo().getSouthPoleLocation() !== Ic.PE_POLE_OUTSIDE_BOUNDARY;
      this.m_polesUpdated || (s4 && this.m_northPole.setCoords(t2[0][0], t2[0][1]), n6 && this.m_southPole.setCoords(t2[1][0], t2[1][1]), this.m_polesUpdated = 1);
    } else this.m_polesUpdated = 1;
  }
  updateGeogToProjFactors() {
    if (this.m_peCoordSys.getType() === Ec.PE_TYPE_PROJCS) {
      const e5 = this.getOneDegreeGCSUnit(), t2 = this.m_pPCSInfoNoDomain.getCentralMeridian(), n6 = [0, 0, 0, 0];
      n6[0] = t2, n6[1] = 0, n6[2] = t2 + e5, n6[3] = 0;
      const r = Cc.geogToProj(this.m_peCoordSys, 2, n6);
      n2(2 === r);
      const i2 = (n6[2] - n6[0]) / e5, o2 = n6[0];
      0 === this.m_geogToProjFactorsUpdated && (this.m_geogToProjFactor = i2, this.m_geogToProjOffset = o2, this.m_geogToProjFactorsUpdated = 1);
    } else this.m_geogToProjFactorsUpdated = 1;
  }
  getOneMeterPCSUnit() {
    return this.m_oneMeterPCS;
  }
  getOneDegreeGCSUnit() {
    return this.m_oneDegreeGCS;
  }
  getGcsUnitFactor() {
    return this.m_gcsUnitFactor;
  }
  getUnitsPerMillimeter() {
    return this.m_oneMillimeter;
  }
  getGCSSplitLines() {
    return this.m_bIsPannable ? null : (this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSSplitLines);
  }
  getGCSHorizon() {
    return this.m_bIsPannable ? this.getGCSHorizonPannable() : (null !== this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSHorizon);
  }
  getGCSHorisonIsInclusive() {
    return this.m_bIsPannable || this.getGCSHorizon(), this.m_bGCSHorisonIsInclusive;
  }
  getPCSHorizon() {
    return this.m_bIsPannable ? this.getPCSHorizonPannable() : (null !== this.m_PCSHorizon || this.updatePCSHorizon(), this.m_PCSHorizon);
  }
  getPole(e5) {
    return this.m_bIsPannable || 0 !== this.m_polesUpdated || this.updatePoles(), e5 ? this.m_southPole : this.m_northPole;
  }
  getGeogToProjFactors() {
    return 0 === this.m_geogToProjFactorsUpdated && this.updateGeogToProjFactors(), Qt(this.m_geogToProjFactor, this.m_geogToProjOffset);
  }
  getDomainXY() {
    if (this.m_bIsPannable) return this.m_domain.clone();
    let e5 = false;
    return e5 = this.m_domain.isEmpty(), e5 && this.updateDomain(), this.m_domain.clone();
  }
  getPrimeMeridian() {
    return this.m_primeMeridian;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e5 = this.m_oldWKID;
    if (e5 < 0) {
      if (e5 = 0, this.m_WKID > 0) {
        const t2 = [0], s4 = [0];
        kc(this.m_peCoordSys.getType(), this.m_WKID, t2, s4) || b("query_code_change"), e5 = t2[0];
      }
      this.m_oldWKID = e5;
    }
    return e5;
  }
  isCustomWkid() {
    return false;
  }
  isPannable() {
    return this.m_bIsPannable;
  }
  getPannableExtent() {
    return this.m_pannableExtent.clone();
  }
  getPannableExtentGCS() {
    return this.m_pannableExtentGCS.clone();
  }
  getAreaOfUse() {
    return null !== this.m_areaOfUse ? this.m_areaOfUse : this.updateAreaOfUse();
  }
  getVcsCode() {
    return 0;
  }
  saveMemory() {
  }
  getCSType() {
    return this.m_csType;
  }
  getUnit() {
    return this.m_unit;
  }
  setCached() {
    this.m_bCached = true;
  }
  getCached() {
    return this.m_bCached;
  }
  static equal(e5, t2) {
    return false;
  }
  static equal_for_projection(e5, t2) {
    return false;
  }
};
var Ag = class {
  constructor(e5, t2 = true) {
    this.m_oneMeter = 0, this.m_WKID = -1, this.m_oldWKID = -1, this.m_canonicalWkt = "not yet implemented", this.m_model = 0, this.m_unit = new Eu(), this.m_cached = false;
  }
  setCached(e5 = true) {
    this.m_cached = e5;
  }
  getCached() {
    return this.m_cached;
  }
  getOneMeterUnit() {
    return 0;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e5 = this.m_oldWKID;
    return e5 < 0 && (e5 = 0, this.m_WKID > 0 && (e5 = this.m_WKID), this.m_oldWKID = e5), e5;
  }
  getModel() {
    return 0;
  }
  isCustomWkid() {
    return false;
  }
  getVerticalUnit() {
    return this.m_unit;
  }
  static equal(e5, t2) {
    return false;
  }
  static equal_for_projection(e5, t2) {
    return false;
  }
};
function Mg(t2, s4, n6) {
  return Ug(t2, s4, n4.constructEmpty(), n6);
}
function Ug(e5, t2, s4, n6) {
  return Og(true, e5, t2, s4, n6);
}
function qg(e5, t2, s4, n6) {
  return Bg(true, e5, t2, s4, n6);
}
function Og(e5, t2, s4, n6, r) {
  Hu() || G("cannot create projection transformation");
  return t2.hasVCS() && s4.hasVCS() ? Xg() : Lg(t2, s4, n6, r);
}
function Bg(e5, t2, s4, n6, r, i2) {
  return Hu() || G("cannot create projection transformation"), new Kg(e5 ? 2 : 1, t2, s4, n6, r, i2);
}
function Rg(e5, s4, n6, r, i2, o2 = false) {
  s4 && n6 || P(""), Hu() || G("cannot obtain geotransformation list");
  if (1 === e5 && s4.hasVCS() && n6.hasVCS()) return z("hv xform not impl"), [];
  {
    const e6 = Wc(s4, n6, r, i2, o2), t2 = [];
    for (const s5 of e6) t2.push(s5);
    return t2;
  }
}
function Yg() {
  return { centralMeridianOfOutputGCS: Number.NaN, densificationStep: Number.NaN, clipWithInputHorizon: true, clipWithOutputHorizon: true, legacyHorizonClipping: false, normalizeResultGeometry: false, equals(e5) {
    return rs(this.centralMeridianOfOutputGCS, e5.centralMeridianOfOutputGCS) && rs(this.densificationStep, e5.densificationStep) && this.clipWithInputHorizon === e5.clipWithInputHorizon && this.clipWithOutputHorizon === e5.clipWithOutputHorizon && this.legacyHorizonClipping === e5.legacyHorizonClipping && this.normalizeResultGeometry === e5.normalizeResultGeometry;
  } };
}
function Xg(e5, t2, n6, r) {
  return n2(0), {};
}
function Lg(s4, n6, r, i2) {
  s4 && n6 || P("!inputSR || !outputSR");
  const o2 = s4.getLatestID(), a2 = n6.getLatestID();
  if (3857 === o2 && 4326 === a2) {
    if (s4.m_bDefaultDescriptor && n6.m_bDefaultDescriptor) return uu();
  } else if (4326 === o2 && 3857 === a2 && s4.m_bDefaultDescriptor && n6.m_bDefaultDescriptor) return cu();
  const h2 = n4.constructEmpty();
  h2.setCoords({ env2D: r });
  const m2 = s4.getCoordinateSystemType(), l2 = n6.getCoordinateSystemType();
  if (0 === m2 || 0 === l2) return zg(s4, n6);
  if (i2) {
    const e5 = i2.find(0, s4.getGCS(), n6.getGCS());
    if (e5) return zg(s4, n6, e5);
  }
  const g2 = s4.getGCS().getLatestID(), u = n6.getGCS().getLatestID();
  if (g2 > 0 && g2 === u) return zg(s4, n6);
  const c = new iu(s4, n6, r);
  {
    const e5 = au(c);
    if (e5) return e5;
  }
  const _ = Rg(0, s4, n6, h2, 1, true);
  return hu(c, zg(s4, n6, _.length ? _[0] : void 0));
}
function zg(e5, t2, s4, n6, r) {
  return new Kg(1, e5, t2, s4, n6, r);
}
function Wg() {
  return { flagsMask: 0, setFlag(e5, t2) {
    t2 ? this.flagsMask |= e5 : this.flagsMask &= ~e5;
  }, hasFlag(e5) {
    return !!(this.flagsMask & e5);
  } };
}
function jg() {
  return { m_extendedParams: Yg(), m_extendedParamsInternal: Wg() };
}
function Zg() {
  return jg();
}
var Kg = class e2 {
  constructor(e5, n6, r, i2, o2, a2) {
    let h2, m2;
    this.m_datumTran = null, this.m_bIdentity = true, this.m_bIdentityGeogToGeog = true, this.m_bVertical = false, this.m_bNormalize = false, n6 && r || P("!inputSR || !outputSR"), i2 && 0 === i2.getType() && (i2.m_bReadOnly = true), this.m_bNormalize = false, 1 !== e5 && (h2 = n6.getVCS(), m2 = r.getVCS(), this.m_bVertical = null != h2 && null != m2), this.m_inputSR = n6, this.m_outputSR = r, this.m_bIdentity = false, this.m_bIdentityGeogToGeog = false, n2(!this.m_params), o2 && (this.m_params = jg(), this.m_params.m_extendedParams = o2), a2 && (this.m_params || (this.m_params = jg()), this.m_params.m_extendedParamsInternal = a2);
    let l2 = false;
    const g2 = null != i2, u = n6.getCoordinateSystemType(), c = r.getCoordinateSystemType();
    if (r.isPannable() && 0 !== u && o2) {
      const e6 = o2.centralMeridianOfOutputGCS;
      if (!Number.isNaN(e6) && r.isPannable()) {
        const t2 = r.getPannableExtent(), s4 = t2.getCenterX();
        if (s4 !== e6) {
          const n7 = Math.ceil(t2.width());
          e6 + n7 !== s4 + n7 && (l2 = true);
        }
      }
    }
    const _ = o2 && o2.normalizeResultGeometry;
    if (n6.equals(r)) return this.m_bIdentity = !l2, this.m_bIdentityGeogToGeog = true, void this.updateProjector();
    const d2 = !g2 && n6.equalForProjection(r, this.m_bVertical);
    this.m_bIdentity = d2 && !l2, this.m_bIdentity ? this.m_bIdentityGeogToGeog = true : 0 !== u && 0 !== c && (_ && this.m_outputSR.isPannable() && (this.m_bNormalize = _), this.m_datumTran = i2 || null, this.m_bIdentityGeogToGeog = (!this.m_datumTran || 0 === this.m_datumTran.count()) && this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(), this.m_bVertical)), this.updateProjector();
  }
  getInputSR() {
    return this.m_inputSR;
  }
  getOutputSR() {
    return this.m_outputSR;
  }
  getDatumTransformation() {
    return this.m_datumTran;
  }
  getInverse() {
    var _a3;
    const t2 = new e2(1, this.m_outputSR, this.m_inputSR, (_a3 = this.m_datumTran) == null ? void 0 : _a3.createInverse());
    return t2.m_bIdentity = this.m_bIdentity, t2.m_bVertical = this.m_bVertical, t2.m_bIdentityGeogToGeog = this.m_bIdentityGeogToGeog, t2.updateProjector(), t2;
  }
  isIdentity() {
    return this.m_bIdentity;
  }
  getExtendedParams() {
    return this.m_params ? this.m_params.m_extendedParams : Zg().m_extendedParams;
  }
  equals(e5) {
    return n2(0), false;
  }
  isVertical() {
    return this.m_bVertical;
  }
  isMatchingTransformation(e5, t2) {
    return n2(0), false;
  }
  getGeographicTransformations() {
    return this.m_datumTran;
  }
  getExtendedParamsImpl() {
    return this.m_params ? this.m_params.m_extendedParams : Zg().m_extendedParams;
  }
  getExtendedParamsInternal() {
    return this.m_params ? this.m_params.m_extendedParamsInternal : Zg().m_extendedParamsInternal;
  }
  isIdentityGeogToGeog() {
    return this.m_bIdentityGeogToGeog;
  }
  normalizeOutput() {
    return this.m_bNormalize;
  }
  updateProjector() {
    this.m_projector = new Vh2(this);
  }
};
var Qg = /* @__PURE__ */ new Map();
var Jg = /* @__PURE__ */ new Map();
var $g = /* @__PURE__ */ new Map();
function eu2(e5) {
  let t2 = e5.getCode();
  if (t2 > 0) {
    const e6 = Pu(t2);
    return e6 || yu(Pc.coordsys(t2));
  }
  const s4 = e5.getName();
  if (Jg.has(s4)) {
    const t3 = Jg.get(s4);
    if (t3 && t3.deref()) {
      const s5 = t3.deref();
      if (s5.m_peCoordSys.isEqual(e5)) return s5;
    }
  }
  return t2 = Pc.getCode(e5), yu(t2 > 0 ? Pc.coordsys(t2) : e5);
}
function tu2(e5) {
  e5 <= 0 && R(e5);
  {
    const t3 = Pu(e5);
    if (t3) return t3;
  }
  const t2 = Gc(Pc.coordsys(e5));
  t2.get() || R(e5);
  const s4 = yu(t2.release());
  return s4.getLatestID() !== e5 && Qg.set(e5, new WeakRef(s4)), s4;
}
function su2(e5) {
  const t2 = new Ag({}, true);
  return t2.m_WKID = e5, t2;
}
function nu2(e5) {
  const t2 = Gc(Pc.fromString(Ec.PE_TYPE_COORDSYS, e5));
  return t2.get() || U(e5), eu2(t2.release());
}
function ru(e5) {
  Jg.delete(e5.m_peCoordSys.getName()), $g.delete(ll(e5.m_peCoordSys, 0, false));
}
var iu = class {
  constructor(e5, t2, s4) {
    this.m_hashCode = -1, e5 && (this.m_inputSR = e5, this.m_outputSR = t2, this.m_env = s4.clone(), this.m_hashCode = this.m_inputSR.getHashCode(), this.m_hashCode = gs(this.m_hashCode, this.m_outputSR.getHashCode()), this.m_env.isEmpty() || (this.m_hashCode = gs(this.m_hashCode, Ps(this.m_env.xmin)), this.m_hashCode = gs(this.m_hashCode, Ps(this.m_env.xmax)), this.m_hashCode = gs(this.m_hashCode, Ps(this.m_env.ymin)), this.m_hashCode = gs(this.m_hashCode, Ps(this.m_env.ymax))));
  }
  getHashCode() {
    return this.m_hashCode;
  }
  equals(e5) {
    return !(this.m_inputSR && !e5.m_inputSR || !this.m_inputSR && e5.m_inputSR) && (this.m_env.equals(e5.m_env) && this.m_inputSR.equals(e5.m_inputSR) && this.m_outputSR.equals(e5.m_outputSR));
  }
  clear() {
    this.m_inputSR = void 0, this.m_outputSR = void 0, this.m_hashCode = -1, this.m_env = void 0;
  }
};
var ou = /* @__PURE__ */ new Map();
function au(e5) {
  if (ou.has(e5.getHashCode())) return ou.get(e5.getHashCode());
}
function hu(e5, t2) {
  return ou.set(e5.getHashCode(), t2), t2;
}
var mu;
var lu;
var gu;
function uu() {
  return mu || (mu = qg(rc(), oc())), mu;
}
function cu() {
  return lu || (lu = uu().getInverse()), lu;
}
function _u() {
  return gu || (gu = Pc.unit(9001)), gu;
}
function du(e5) {
  return null !== Gc(Pc.coordsys(e5)).get();
}
var pu = /* @__PURE__ */ new Map();
function fu(e5) {
  if (pu.has(e5)) return pu.get(e5);
  {
    const t2 = du(e5);
    return pu.set(e5, t2), t2;
  }
}
function xu(e5) {
  return false;
}
function yu(e5) {
  const t2 = Gc(e5), s4 = e5.getCode();
  if (s4 > 0) {
    const e6 = Pu(s4);
    if (e6) return e6;
  }
  const n6 = e5.getName();
  let r = Jg.get(n6);
  if (r) {
    const t3 = r.deref();
    if (t3 && t3.m_peCoordSys.isEqual(e5)) return t3;
  }
  const i2 = new kg(t2.release());
  if (s4 > 0) return i2.setCached(), Qg.set(s4, new WeakRef(i2)), Jg.set(n6, new WeakRef(i2)), i2;
  const o2 = ll(e5, 0, false);
  if (r = $g.get(o2), r) {
    const e6 = r.deref();
    if (e6) return e6;
  }
  return i2.setCached(), $g.set(o2, new WeakRef(i2)), i2;
}
function Pu(e5) {
  const t2 = Qg.get(e5);
  if (t2) return t2.deref();
}
var Eu = class extends $t2 {
  constructor(e5) {
    return void 0 === e5 ? (super(), this.m_wkid = 9001, void (this.m_peUnit = null)) : "number" == typeof e5 ? (super(), this.m_factor = e5, void (this.m_wkid = 0)) : (super(e5), void (e5 || (this.m_factor = 1, this.m_wkid = 9001, this.m_peUnit = _u())));
  }
  getUnitType() {
    return 0;
  }
  convertFromMeters(e5) {
    return e5 / this.getUnitToBaseFactor();
  }
  convertToMeters(e5) {
    return e5 * this.getUnitToBaseFactor();
  }
};
var Cu = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
function Su(e5, t2, s4) {
  const n6 = Lt(t2, "R");
  let r = 0, i2 = 0;
  for (let o2 = 0; o2 < t2; o2++) {
    let s5 = e5[r] >> i2 & 31;
    if (i2 += 5, i2 > 31) {
      const t3 = 37 - i2;
      s5 &= (1 << t3) - 1, i2 -= 32, r++, s5 |= (e5[r] & (1 << i2) - 1) << t3;
    }
    const a2 = Cu[s5];
    n6[t2 - 1 - o2] = a2;
  }
  return s4 > t2 ? n6.push(..."0".repeat(s4 - t2)) : s4 < t2 && (n6.length = s4), n6.join("");
}
function Iu(e5, t2, n6, r, i2) {
  n2(r >> 5 < i2.length);
  let o2 = t2, a2 = n6;
  for (let s4 = r; s4 >= 0; s4 -= 2) {
    const t3 = 31 & s4, n7 = 0.5 * (a2 + o2);
    e5 >= n7 ? (i2[s4 >> 5] |= 1 << t3, o2 = n7) : a2 = n7;
  }
}
var bu = /* @__PURE__ */ new Set();
var wu = 2147483645n;
var vu = 9007199254740990n;
var Nu = "operation is not supported for unknown coordinate systems";
var Tu;
function Gu() {
  return { majorSemiAxis: 0, e2: 0, minorSemiAxis: 0, flattening: 0, isSphere() {
    return 0 === this.e2;
  } };
}
function Du(e5, t2, s4) {
  e5.majorSemiAxis = t2, e5.minorSemiAxis = t2 * (1 - s4), e5.e2 = s4 * (2 - s4), e5.flattening = s4;
}
function Vu(e5) {
  if (Pc) return;
  Hc(e5);
  const t2 = bu;
  bu = null, t2.forEach((e6) => {
    const t3 = e6.deref();
    t3 && t3.attachToPe();
  });
}
function Fu(e5) {
  Fc(e5);
}
function Hu() {
  return !!Pc;
}
function ku() {
  return !!Dc;
}
function Au() {
  return !!Pc || !!Dc;
}
function Mu(e5, t2, n6) {
  return n2(Au()), gc(e5, void 0 === t2 ? 0 : t2, null, false);
}
function Uu(e5, t2) {
  n2(Au());
  const n6 = new sc();
  let r;
  return Hu() ? (r = nu2(e5), n6.setHorzProj_(r), n6.m_vertcs = null, n6.m_userWKID = r.getLatestID()) : (r = Vc(e5), n6.m_unit = r.isPCS ? new Eu(r.metersOrRadiansPerUnit) : new ns2(r.metersOrRadiansPerUnit)), hc(n6.m_precisionDescriptor, r, null, 1), n6.m_bDefaultDescriptor = true, n6.m_userWKT = e5, n6.calculateHashCode(), n6.initDbgName(), n6;
}
function qu(e5, t2, s4, n6, r = true) {
  let i2 = null;
  return t2 && (i2 = Tm2(t2, r)), Ou(e5, i2, s4, n6, r);
}
function Ou(e5, s4, n6, r, i2) {
  e5 || P("!PE_coord_sys");
  const o2 = new sc();
  let a2;
  return a2 = i2 ? eu2(e5) : new kg(e5, false), hc(o2.m_precisionDescriptor, a2, s4, r), o2.m_bDefaultDescriptor = true, o2.setHorzProj_(a2), o2.m_vertcs = s4, o2.m_userWKID = a2.getLatestID(), o2.calculateHashCode(), o2.initDbgName(), o2;
}
function Bu(e5, s4, n6 = false) {
  3 === e5.getCoordinateSystemType() && P("image spatial reference cannot be altered");
  const r = new sc(), i2 = e5;
  return r.m_peCoordSysVal = i2.m_peCoordSysVal, r.m_vertcs = i2.m_vertcs, r.m_unit = i2.m_unit, r.m_precisionDescriptor.assign(s4), r.m_localZToXYFactor = i2.m_localZToXYFactor, (Number.isNaN(r.m_precisionDescriptor.m_falseX) || Number.isNaN(r.m_precisionDescriptor.m_falseY)) && (r.m_precisionDescriptor.m_falseX = i2.m_precisionDescriptor.m_falseX, r.m_precisionDescriptor.m_falseY = i2.m_precisionDescriptor.m_falseY), r.m_precisionDescriptor.snapPrecision(), r.m_precisionDescriptor.fixTolerance(), r.m_userWKID = i2.m_userWKID, r.m_precisionDescriptor.equals(i2.m_precisionDescriptor) ? r.m_bDefaultDescriptor = i2.m_bDefaultDescriptor : r.m_bDefaultDescriptor = false, n6 && (r.m_bDefaultDescriptor = true), r.calculateHashCode(), r.initDbgName(), r;
}
function Ru(e5, t2, s4) {
  return {};
}
function Yu(e5, s4, n6) {
  void 0 === s4 && (s4 = 1), (s4 <= 0 || !Number.isFinite(s4)) && P(""), e5 || 1 === s4 || P("null Unit has to have z_to_xy_factor equal to 1");
  const r = new sc();
  r.m_unit = e5;
  const i2 = e5 || new Eu(9001);
  return lc(r.m_precisionDescriptor, i2, null, 1), r.m_bDefaultDescriptor = true, Number.isNaN(r.m_precisionDescriptor.m_falseX) && P("NAN false X/Y are not allowed here"), r.m_localZToXYFactor = s4, r.calculateHashCode(), r.initDbgName(), r;
}
function Xu(e5, t2) {
  return e5.snapGeometry(t2);
}
function Lu(e5) {
  const t2 = e5.getCoordinateSystemType();
  return 1 === t2 ? e5 : (3 === t2 && n2(0), e5.getGCS());
}
function zu(e5) {
  return n2(Au()), ku() ? Ac(e5) : fu(e5);
}
function Wu(e5) {
  if (Hu()) {
    return null !== Gc(Pc.fromString(Ec.PE_TYPE_COORDSYS, e5)).get();
  }
  try {
    return Vc(e5), true;
  } catch (t2) {
  }
  return false;
}
var ju;
function Zu() {
  return ju || (ju = (() => {
    const e5 = Math.trunc(Math.random() * ls()), t2 = Date.now();
    return `|abba_000|${e5.toString(16)}|${t2.toString(16)}|`;
  })()), ju;
}
!function(e5) {
  e5[e5.utmDefault = 0] = "utmDefault", e5[e5.utmNorthSouth = 1] = "utmNorthSouth";
}(Tu || (Tu = {}));
var Ku = 0;
function Qu(e5 = "") {
  let t2 = `${Zu()}${Ku++}`;
  return "" !== e5 && (t2 += `|${e5}`), t2;
}
function Ju(e5) {
  return e5.startsWith(Zu());
}
var $u;
var ec;
var tc;
var sc = class e3 {
  destroy() {
    ru(this.m_peCoordSysVal), 1 === this.getCoordinateSystemType() || 2 === this.getCoordinateSystemType() ? this.getPECoordSys().destroy() : b("SpatialReference.destroy");
  }
  constructor() {
    this.m_vertcs = null, this.m_peCoordSysVal = null, this.m_userWKID = 0, this.m_userWKT = null, this.m_geogSpatialReference = null, this.m_srToGcs = null, this.m_gcsToSr = null, this.m_defaultPrecisionSR = null, this.m_localZToXYFactor = -1, this.m_precisionDescriptor = new nc(), this.m_hashCode = 0, this.m_bDefaultDescriptor = false, ac(this.m_precisionDescriptor), bu && bu.add(new WeakRef(this));
  }
  attachToPe() {
    (this.m_userWKID > 0 ? Mu(this.m_userWKID) : Uu(this.m_userWKT)).copyTo(this, false);
  }
  copyTo(e5, t2 = true) {
    (t2 || e5.m_bDefaultDescriptor) && (e5.m_bDefaultDescriptor = this.m_bDefaultDescriptor, e5.m_precisionDescriptor.assign(this.m_precisionDescriptor)), e5.m_defaultPrecisionSR = null, e5.m_gcsToSr = this.m_gcsToSr, e5.m_geogSpatialReference = this.m_geogSpatialReference, e5.m_hashCode = this.m_hashCode, e5.m_localZToXYFactor = this.m_localZToXYFactor, e5.m_peCoordSysVal = this.m_peCoordSysVal, e5.m_srToGcs = this.m_srToGcs, e5.m_userWKID = this.m_userWKID, e5.m_userWKT = this.m_userWKT, e5.m_vertcs = this.m_vertcs, e5.m_unit = this.m_unit;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getHashCodeHorizontal() {
    let e5 = 0;
    return e5 = this.m_peCoordSysVal ? this.m_peCoordSysVal.getHashCode() : this.m_unit ? this.m_unit.getHashCode() : 305419891, e5;
  }
  updateTransform(e5) {
    if (1 === this.getCoordinateSystemType()) return qg(this, this, null);
    let t2 = e5 ? this.m_srToGcs : this.m_gcsToSr;
    if (t2) return t2;
    const s4 = this.getGCS(), n6 = this;
    t2 = e5 ? qg(n6, s4, null) : qg(s4, n6, null);
    const r = t2, i2 = e5 ? this.m_srToGcs : this.m_gcsToSr;
    return i2 || (e5 ? this.m_srToGcs = r : this.m_gcsToSr = r, t2);
  }
  getHashCodeVertical() {
    return this.m_vertcs ? this.m_vertcs.getHashCode() : 0;
  }
  calculateHashCode() {
    let e5 = this.getHashCodeHorizontal();
    const t2 = this.getHashCodeVertical(), s4 = this.m_precisionDescriptor.getHashCode();
    e5 = gs(e5, t2), this.m_hashCode = gs(e5, s4);
  }
  initDbgName() {
  }
  setHorzProj_(e5) {
    this.m_peCoordSysVal = e5, this.m_unit = this.m_peCoordSysVal.getUnit();
  }
  getTolerance(e5 = 0) {
    return this.m_precisionDescriptor.getTolerance(e5);
  }
  getResolution(e5 = 0) {
    return this.m_precisionDescriptor.getResolution(e5);
  }
  getPECoordSys() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.m_peCoordSys : null;
  }
  getPCSInfo() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSInfo();
  }
  getCentralMeridian() {
    if (this.throwIfNotGCSOrPCS(), 1 === this.getCoordinateSystemType()) return 0;
    return this.getPCSInfo().getCentralMeridian();
  }
  getCoordinateSystemType() {
    const e5 = this.getPECoordSys();
    if (e5) {
      switch (e5.getType()) {
        case Ec.PE_TYPE_GEOGCS:
          return 1;
        case Ec.PE_TYPE_PROJCS:
          return 2;
        default:
          return 0;
      }
    } else {
      if ((this.m_userWKID > 0 || this.m_userWKT) && this.m_unit instanceof Eu) return 2;
      if (this.m_unit instanceof ns2) return 1;
    }
    return 0;
  }
  getID() {
    return this.m_userWKID;
  }
  getLatestID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getLatestID() : this.m_userWKID;
  }
  getOldID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getOldID() : this.m_userWKID;
  }
  getVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getLatestVerticalID() {
    return this.m_vertcs ? this.m_vertcs.getLatestID() : 0;
  }
  getOldVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getPEVerticalCoordSys() {
    return null;
  }
  getPole(e5) {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPole(e5);
  }
  getText() {
    const e5 = this.getPECoordSys();
    return e5 ? ul(e5) : this.m_userWKT ?? "";
  }
  getTextExtended(e5) {
    const t2 = this.getPECoordSys();
    return t2 ? this.getPEVerticalCoordSys() ? gl(null, t2, this.getPEVerticalCoordSys()) : ul(t2, e5) : this.m_userWKT ?? "";
  }
  getText2(e5 = -1) {
    const t2 = this.getPECoordSys();
    return t2 ? cl(t2, e5) : this.m_userWKT ?? "";
  }
  getUnit() {
    return this.m_unit;
  }
  getUnitsPerMillimeter() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getUnitsPerMillimeter() : this.m_unit instanceof Eu ? 1e-3 / this.m_unit.getUnitToBaseFactor() : this.m_unit instanceof ns2 ? 1e-3 / (Vc(this.m_userWKT ?? this.m_userWKID).semiMajor * this.m_unit.getUnitToBaseFactor()) : (C("sr object not in valid state"), 0);
  }
  getAuthorityName() {
    return this.getPECoordSys() ? _l() : "";
  }
  getVerticalUnit() {
    return z("vcs not implemented"), {};
  }
  getVCS() {
    return this.m_vertcs;
  }
  hasVCS() {
    return false;
  }
  getGCSHorisonIsInclusive() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorisonIsInclusive();
  }
  getGCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorizon();
  }
  getGCS() {
    const e5 = this.getCoordinateSystemType();
    if (0 === e5) C(Nu);
    else {
      if (1 === e5) return this;
      3 === e5 && C("image cs not supported");
    }
    if (this.m_geogSpatialReference) return this.m_geogSpatialReference;
    let t2;
    if (this === rc() || this === ic()) t2 = oc();
    else {
      n2(this.m_peCoordSysVal);
      const e6 = this.m_peCoordSysVal.m_peCoordSys.getGeogcs();
      e6 || b(""), t2 = qu(e6, this.m_vertcs, null, this.m_precisionDescriptor.getPrecision(), this.m_peCoordSysVal.getCached());
    }
    return this.m_geogSpatialReference ? t2 = this.m_geogSpatialReference : this.m_geogSpatialReference = t2, t2;
  }
  getGCSSplitLines() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSSplitLines();
  }
  toGCS(e5, n6) {
    if (0 === e5.length) return 0;
    e5.length > n6.length && P("coordsSrc.size() > coordsDst.size()");
    const r = this.getCoordinateSystemType();
    if (0 === r && C(Nu), 1 === r) return Bt(n6, e5, e5.length), e5.length;
    n2(this.m_peCoordSysVal);
    const i2 = this.getSRToGCSTransform();
    return new kh2().transform(i2, e5, e5.length, n6);
  }
  toGeohash(e5, t2 = 8) {
    const s4 = e5.clone();
    s4.scale(9102 === this.getGCS().getUnit().getID() ? 1 : this.getGCS().getUnit().getUnitToBaseFactor() / Math.PI * 180), s4.x < -180 ? (s4.x = ct(s4.x, 360), s4.x < -180 && (s4.x += 360)) : s4.x > 180 && (s4.x = ct(s4.x, 360), s4.x > 180 && (s4.x -= 360)), s4.y > 90 && (s4.y = 90), s4.y < -90 && (s4.y = -90);
    const n6 = 5 * t2, r = new Uint32Array(4);
    Iu(s4.x, -180, 180, n6 - 1, r), Iu(s4.y, -90, 90, n6 - 2, r);
    return Su(r, t2, t2);
  }
  isPannable() {
    const e5 = this.getCoordinateSystemType();
    return 0 !== e5 && 3 !== e5 && (n2(this.m_peCoordSysVal), this.m_peCoordSysVal.isPannable());
  }
  getPannableExtent() {
    return this.isPannable() || P("!is_pannable"), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtent();
  }
  getPannableExtentInGCS() {
    return this.isPannable() || P("!is_pannable"), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtentGCS();
  }
  throwIfNotGCSOrPCS() {
    const e5 = this.getCoordinateSystemType();
    1 !== e5 && 2 !== e5 && P("Not a GCS or PCS");
  }
  getDomainXY() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getDomainXY();
  }
  getFullWorldExtent() {
    return this.throwIfNotGCSOrPCS(), this.isPannable() ? this.getPannableExtent() : this.getDomainXY();
  }
  queryPrecisionDescriptor(e5) {
    if (e5.assign(this.m_precisionDescriptor), Number.isNaN(e5.m_falseX)) if (Hu() || G("cannot query precision descriptor"), n2(null !== this.m_peCoordSysVal), 2 !== this.m_precisionDescriptor.m_precision) {
      const t2 = this.m_peCoordSysVal.getDomainXY();
      e5.m_falseX = t2.xmin, e5.m_falseY = t2.ymin;
    } else e5.m_falseX = -Number.MAX_VALUE, e5.m_falseY = -Number.MAX_VALUE;
  }
  queryPrecisionDescriptorWithoutFalseXY(e5) {
    e5.assign(this.m_precisionDescriptor), e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  }
  queryDefaultPrecisionDescriptorWithoutFalseXY(e5) {
    if (this.m_bDefaultDescriptor) e5.assign(this.m_precisionDescriptor);
    else {
      const t2 = this.getCoordinateSystemType();
      0 === t2 ? lc(e5, this.m_unit, this.m_vertcs, this.m_precisionDescriptor.getPrecision()) : 3 === t2 ? z("image cs") : hc(e5, this.m_peCoordSysVal, this.m_vertcs, this.m_precisionDescriptor.getPrecision());
    }
    e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  }
  horizontalEqual(e5) {
    return Fg(this.m_peCoordSysVal, e5.m_peCoordSysVal);
  }
  verticalEqual(e5) {
    return null !== this.m_vertcs == (null !== e5.m_vertcs) && (!this.m_vertcs || this.m_vertcs.equals(e5.m_vertcs));
  }
  equals(e5) {
    const t2 = e5;
    if (this === t2) return true;
    if (!this.horizontalEqual(t2) || !this.verticalEqual(t2)) return false;
    if (!t2.m_peCoordSysVal) {
      if (n2(!this.m_peCoordSysVal), null !== this.m_unit != (null !== t2.m_unit)) return false;
      if (this.m_unit && !this.m_unit.equals(t2.m_unit)) return false;
      if (this.m_localZToXYFactor !== t2.m_localZToXYFactor) return false;
    }
    if (!this.m_bDefaultDescriptor || !t2.m_bDefaultDescriptor) {
      if (this.m_peCoordSysVal) {
        if (!this.m_precisionDescriptor.equalsWithoutFalseXY(t2.m_precisionDescriptor)) return false;
        n2(t2.m_peCoordSysVal);
        let e6 = this.m_precisionDescriptor.m_falseX, n6 = this.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(e6)) {
          const t3 = this.m_peCoordSysVal.getDomainXY();
          e6 = t3.xmin, n6 = t3.ymin;
        }
        let r = t2.m_precisionDescriptor.m_falseX, i2 = t2.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(r)) {
          const e7 = t2.m_peCoordSysVal.getDomainXY();
          r = e7.xmin, i2 = e7.ymin;
        }
        return e6 === r && n6 === i2;
      }
      return this.m_precisionDescriptor.equals(t2.m_precisionDescriptor);
    }
    return true;
  }
  equalForProjection(e5, t2) {
    if (this === e5) return true;
    const s4 = this.getCoordinateSystemType(), n6 = e5.getCoordinateSystemType();
    if (0 === s4 || 0 === n6) return 0 === s4 && 0 === n6 ? (!t2 || this.getZToXYFactor() === e5.getZToXYFactor()) && (!this.getUnit() || !e5.getUnit() || this.getUnit().equals(e5.getUnit())) : 3 !== s4 && 3 !== n6 && (null === this.getUnit() || null === e5.getUnit() || (!t2 || this.getZToXYFactor() === e5.getZToXYFactor()) && this.getUnit().equals(e5.getUnit()));
    if (s4 !== n6) return false;
    if (3 === s4) return this.equals(e5);
    if (Hg(this.m_peCoordSysVal, e5.m_peCoordSysVal)) {
      if (!t2) return true;
      if (null !== this.m_vertcs == (null !== e5.m_vertcs)) return !this.m_vertcs || this.m_vertcs.equalForProjection(e5.m_vertcs);
    }
    return false;
  }
  equalHorizontal(e5) {
    return this.horizontalEqual(e5);
  }
  equalVertical(e5) {
    return n2(0), false;
  }
  equalVerticalVCS(e5) {
    return n2(0), false;
  }
  convergenceAngle(e5) {
    return n2(0), 0;
  }
  getPeCoordsysCopy() {
    if (this.m_peCoordSysVal) {
      const e5 = this.m_peCoordSysVal.m_peCoordSys;
      return e5 || b("cannot clone coord sys"), e5;
    }
    return null;
  }
  getPeVertcsCopy() {
    return n2(0), 0;
  }
  throwIfLocal() {
    0 === this.getCoordinateSystemType() && P(Nu);
  }
  getPrimeMeridian() {
    return this.throwIfLocal(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPrimeMeridian();
  }
  getSRToGCSTransform() {
    return this.updateTransform(true);
  }
  getGCSToSRTransform() {
    return this.updateTransform(false);
  }
  getOneMeter() {
    return 1e3 * this.getUnitsPerMillimeter();
  }
  getOneMeterPCSUnit() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneMeterPCSUnit();
  }
  getDefaultPrecisionSR() {
    if (this.m_bDefaultDescriptor) return this;
    if (null === this.m_defaultPrecisionSR) {
      const e5 = new nc();
      this.queryDefaultPrecisionDescriptorWithoutFalseXY(e5), this.m_defaultPrecisionSR = Bu(this, e5, true);
    }
    return this.m_defaultPrecisionSR;
  }
  getPCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSHorizon();
  }
  getHorzUnitFactor() {
    return this.m_unit ? this.m_unit.getUnitToBaseFactor() : 1;
  }
  querySpheroidData(e5) {
    this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal);
    const t2 = this.getGCS().getPECoordSys().getDatum().getSpheroid(), n6 = t2.getFlattening();
    Du(e5, t2.getAxis(), n6);
  }
  getAreaOfUse() {
    0 === this.getCoordinateSystemType() && C(""), n2(this.m_peCoordSysVal);
    const e5 = this.m_peCoordSysVal.getAreaOfUse();
    return null === e5 ? new Jt2() : new Jt2({ geom: e5.clone(), sr: Mu(4326) });
  }
  getZToXYFactor() {
    return 1;
  }
  isCustomWkid() {
    return false;
  }
  getOneDegreeGCSUnit() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneDegreeGCSUnit();
  }
  getGcsUnitFactor() {
    return this.throwIfNotGCSOrPCS(), n2(this.m_peCoordSysVal), this.m_peCoordSysVal.getGcsUnitFactor();
  }
  snapGeometry(e5) {
    if (e5.isEmpty()) return false;
    if (2 === this.m_precisionDescriptor.getPrecision()) return false;
    const t2 = e5.getGeometryType();
    if (y(t2)) return this.snapMultiVertex_(e5);
    if (t2 === a.enumPoint) return this.snapPoint_(e5);
    if (t2 === a.enumEnvelope) return this.snapEnvelope_(e5);
    if (f(t2)) return this.snapSegment_(e5);
    if (t2 === a.enumGeometryCollection) {
      const t3 = e5;
      let s4 = false;
      for (let e6 = 0, n6 = t3.getGeometryCount(); e6 < n6; ++e6) s4 = this.snapGeometry(t3.getGeometry(e6)) || s4;
      return s4;
    }
    b("what else?");
  }
  snapMultiVertex_(e5) {
    if (n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision()), h(e5.getGeometryType())) {
      const t3 = e5;
      if (t3.hasNonLinearSegments()) return this.snapGeometryWithCurves_(t3);
    }
    const t2 = e5.getImpl(), n6 = t2.getDescription();
    let r = false;
    for (let s4 = 0, i2 = n6.getAttributeCount(); s4 < i2; s4++) {
      const e6 = n6.getSemantics(s4), i3 = t2.getAttributeStreamRef(e6);
      r = this.snapAttributes(e6, i3, 0, t2.getPointCount()) || r;
    }
    return r && t2.notifyModifiedFlags(2001), r;
  }
  snapPoint_(e5) {
    return false;
  }
  snapEnvelope_(e5) {
    return false;
  }
  snapSegment_(e5) {
    n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision());
    const t2 = new nc();
    this.queryPrecisionDescriptor(t2);
    const n6 = e5.getStartXY(), r = new ei();
    r.x = uc(n6.x, t2.getFalseX(), t2.getGridUnitsXY()), r.y = uc(n6.y, t2.getFalseY(), t2.getGridUnitsXY());
    let i2 = !r.equals(n6);
    const o2 = e5.getEndXY(), a2 = new ei();
    a2.x = uc(o2.x, t2.getFalseX(), t2.getGridUnitsXY()), a2.y = uc(o2.y, t2.getFalseY(), t2.getGridUnitsXY()), i2 || (i2 = !a2.equals(o2)), i2 && e5.changeEndPoints2D(r, a2);
    const h2 = (t3, s4, n7) => {
      let r2 = false;
      {
        const i3 = e5.getStartAttributeAsDbl(t3, 0), o3 = uc(i3, s4, n7), a3 = !rs(o3, i3);
        r2 || (r2 = a3), a3 && e5.setStartAttribute(t3, 0, o3);
      }
      {
        const i3 = e5.getEndAttributeAsDbl(t3, 0), o3 = uc(i3, s4, n7), a3 = !rs(o3, i3);
        r2 || (r2 = a3), a3 && e5.setEndAttribute(t3, 0, o3);
      }
      return r2;
    };
    let m2 = i2 ? 1 : 0;
    return e5.hasAttribute(1) && (m2 |= h2(1, t2.getFalseZ(), t2.getGridUnitsZ()) ? 1 : 0), e5.hasAttribute(2) && (m2 |= h2(2, t2.getFalseM(), t2.getGridUnitsM()) ? 1 : 0), !!m2;
  }
  snapGeometryWithCurves_(e5) {
    n2(!e5.isEmpty()), n2(2 !== this.m_precisionDescriptor.getPrecision());
    const t2 = e5.createInstance(), n6 = new nu();
    let r = 0;
    for (let s4 = 0, i2 = e5.getPathCount(); s4 < i2; ++s4) {
      const i3 = e5.getSegmentCountPath(s4);
      if (0 === i3) {
        if (t2.addPath(e5, s4, true), 1 === t2.getPathSize(s4)) {
          const e6 = new ee();
          t2.getPointByVal(t2.getPointCount() - 1, e6), r |= this.snapGeometry(e6) ? 1 : 0, t2.setPointByVal(t2.getPointCount() - 1, e6);
        }
        continue;
      }
      const o2 = e5.isClosedPath(s4);
      for (let a2 = 0, h2 = o2 ? i3 - 1 : i3; a2 < h2; ++a2) e5.getSegmentFromPath(s4, a2, n6, false), r |= this.snapGeometry(n6.get()) ? 1 : 0, t2.addSegment(n6.get(), 0 === a2);
      o2 && (e5.getSegmentFromPath(s4, i3 - 1, n6, false), r |= this.snapGeometry(n6.get()) ? 1 : 0, 1 === i3 ? t2.addPathFromClosedSegment(n6.get(), false) : t2.closeLastPathWithSegment(n6.get()));
    }
    return r && t2.copyTo(e5), !!r;
  }
  snapAttributes(t2, s4, n6, r) {
    let i2 = false;
    const o2 = new nc();
    if (this.queryPrecisionDescriptor(o2), 0 === t2) {
      const t3 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t3.read(2 * s5), r2 = e3.s_SnapValue(n7, o2.getFalseX(), o2.getGridUnitsXY()), a2 = t3.read(2 * s5 + 1), h2 = e3.s_SnapValue(a2, o2.getFalseY(), o2.getGridUnitsXY());
        i2 = i2 || r2 !== n7 || h2 !== a2, i2 && (t3.write(2 * s5, r2), t3.write(2 * s5 + 1, h2));
      }
    } else if (1 === t2) {
      const t3 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t3.read(s5), r2 = e3.s_SnapValue(n7, o2.getFalseZ(), o2.getGridUnitsZ());
        i2 = i2 || !rs(r2, n7), i2 && t3.write(s5, r2);
      }
    } else if (2 === t2) {
      const t3 = s4;
      for (let s5 = n6; s5 < r; s5++) {
        const n7 = t3.read(s5), r2 = e3.s_SnapValue(n7, o2.getFalseM(), o2.getGridUnitsM());
        i2 = i2 || !rs(r2, n7), i2 && t3.write(s5, r2);
      }
    }
    return i2;
  }
  static s_SnapValue(e5, t2, s4) {
    return S((e5 - t2) * s4) / s4 + t2;
  }
};
var nc = class _nc {
  constructor() {
    const e5 = vu, t2 = 1e-4, s4 = 1e-3, n6 = t2 * Number(e5) * 0.5;
    this.m_precision = 1, this.m_falseX = -n6, this.m_falseY = -n6, this.m_unitsXY = Number(e5) / (2 * n6), this.m_falseM = -1e5, this.m_unitsM = 1 / t2, this.m_falseZ = -1e5, this.m_unitsZ = 1 / t2, this.m_toleranceXY = s4, this.m_toleranceM = s4, this.m_toleranceZ = s4;
  }
  getHashCode() {
    let e5 = 7777, t2 = 7777;
    return t2 = gs(t2, this.m_falseM), t2 = gs(t2, this.m_unitsM), e5 = gs(e5, this.m_unitsXY), t2 = gs(t2, this.m_toleranceXY), e5 = gs(e5, this.m_falseZ), t2 = gs(t2, this.m_toleranceZ), e5 = gs(e5, this.m_unitsZ), t2 = gs(t2, this.m_toleranceM), e5 = gs(e5, this.m_precision), gs(e5, t2);
  }
  clone() {
    const e5 = new _nc();
    return e5.m_falseX = this.m_falseX, e5.m_falseY = this.m_falseY, e5.m_unitsXY = this.m_unitsXY, e5.m_falseZ = this.m_falseZ, e5.m_unitsZ = this.m_unitsZ, e5.m_falseM = this.m_falseM, e5.m_unitsM = this.m_unitsM, e5.m_toleranceXY = this.m_toleranceXY, e5.m_toleranceZ = this.m_toleranceZ, e5.m_toleranceM = this.m_toleranceM, e5.m_precision = this.m_precision, e5;
  }
  assign(e5) {
    return this.m_falseX = e5.m_falseX, this.m_falseY = e5.m_falseY, this.m_unitsXY = e5.m_unitsXY, this.m_falseZ = e5.m_falseZ, this.m_unitsZ = e5.m_unitsZ, this.m_falseM = e5.m_falseM, this.m_unitsM = e5.m_unitsM, this.m_toleranceXY = e5.m_toleranceXY, this.m_toleranceZ = e5.m_toleranceZ, this.m_toleranceM = e5.m_toleranceM, this.m_precision = e5.m_precision, this;
  }
  initialize2D(e5, t2) {
  }
  getTolerance(e5) {
    switch (e5) {
      case 0:
        return this.m_toleranceXY;
      case 1:
        return this.m_toleranceZ;
      case 2:
        return this.m_toleranceM;
      default:
        return 0;
    }
  }
  getResolution(e5) {
    if (2 === this.m_precision) return 0;
    switch (e5) {
      case 0:
        return 1 / this.m_unitsXY;
      case 1:
        return 1 / this.m_unitsZ;
      case 2:
        return 1 / this.m_unitsM;
      default:
        return 0;
    }
  }
  getFalseX() {
    return this.m_falseX;
  }
  getFalseY() {
    return this.m_falseY;
  }
  getFalseZ() {
    return this.m_falseZ;
  }
  getFalseM() {
    return this.m_falseM;
  }
  getGridUnitsXY() {
    return this.m_unitsXY;
  }
  getGridUnitsZ() {
    return this.m_unitsZ;
  }
  getGridUnitsM() {
    return this.m_unitsM;
  }
  getPrecision() {
    return this.m_precision;
  }
  static getLimit32() {
    return 2147483645;
  }
  static getLimit64() {
    return 9007199254740990n;
  }
  static getLimitFloat() {
    return 0;
  }
  getXYGridRange() {
    const t2 = new n4();
    switch (this.m_precision) {
      case 0:
        {
          const e5 = _nc.getLimit32() / this.getGridUnitsXY();
          t2.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + e5, ymax: this.getFalseY() + e5 });
        }
        break;
      case 1:
        {
          const e5 = Number(_nc.getLimit64()) / this.getGridUnitsXY();
          t2.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + e5, ymax: this.getFalseY() + e5 });
        }
        break;
      case 2:
        t2.setCoords({ xmin: -Number.MAX_VALUE, ymin: -Number.MAX_VALUE, xmax: Number.MAX_VALUE, ymax: Number.MAX_VALUE });
        break;
      default:
        t2.setEmpty(), b("");
    }
    return t2;
  }
  getZGridRange() {
    const e5 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t2 = _nc.getLimit32() / this.getGridUnitsZ();
          e5.setCoords(this.getFalseZ(), this.getFalseZ() + t2);
        }
        break;
      case 1:
        {
          const t2 = Number(_nc.getLimit64()) / this.getGridUnitsZ();
          e5.setCoords(this.getFalseZ(), this.getFalseZ() + t2);
        }
        break;
      case 2:
        e5.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e5.setEmpty(), b("");
    }
    return e5;
  }
  getMGridRange() {
    const e5 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t2 = _nc.getLimit32() / this.getGridUnitsM();
          e5.setCoords(this.getFalseM(), this.getFalseM() + t2);
        }
        break;
      case 1:
        {
          const t2 = Number(_nc.getLimit64()) / this.getGridUnitsM();
          e5.setCoords(this.getFalseM(), this.getFalseM() + t2);
        }
        break;
      case 2:
        e5.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e5.setEmpty(), b("");
    }
    return e5;
  }
  setTolerance(e5, s4) {
    switch (s4 < 0 && P("tol < 0"), Number.isFinite(s4) || P("tol is not finite"), e5) {
      case 0:
        this.m_toleranceXY = s4;
        break;
      case 1:
        this.m_toleranceZ = s4;
        break;
      case 2:
        this.m_toleranceM = s4;
        break;
      default:
        P("cannot set tolerance for this attribute");
    }
  }
  setGridParams(e5, s4, n6) {
    Number.isFinite(e5) && Number.isFinite(s4) && Number.isFinite(n6) || P("grid params are not finite"), n6 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseX = e5, this.m_falseY = s4, this.m_unitsXY = n6;
  }
  setZParams(e5, s4) {
    Number.isFinite(e5) && Number.isFinite(s4) || P("grid params are not finite"), s4 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseZ = e5, this.m_unitsZ = s4;
  }
  setMParams(e5, s4) {
    Number.isFinite(e5) && Number.isFinite(s4) || P("grid params are not finite"), s4 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseM = e5, this.m_unitsM = s4;
  }
  setPrecision(e5) {
  }
  equals(e5) {
    return this === e5 || rs(this.m_falseX, e5.m_falseX) && rs(this.m_falseY, e5.m_falseY) && this.equalsWithoutFalseXY(e5);
  }
  snapPrecision() {
    if (2 === this.m_precision) return;
    const e5 = (e6, t3, s4, n6) => {
      if (!Number.isFinite(t3) || !Number.isFinite(s4)) return s4;
      if (s4 < 1) return 1;
      if (!n6) return s4;
      const r = Number(e6) / s4;
      return Math.trunc((t3 + r - t3) * s4) > e6 && (s4 = e6 / (t3 + r - t3)), Math.max(1, s4);
    }, t2 = Number(0 === this.m_precision ? wu : vu);
    this.m_unitsXY = e5(t2, this.m_falseX, this.m_unitsXY, true), this.m_unitsXY = e5(t2, this.m_falseY, this.m_unitsXY, true), this.m_unitsZ = e5(t2, this.m_falseZ, this.m_unitsZ, false), this.m_unitsM = e5(t2, this.m_falseM, this.m_unitsM, false);
  }
  verifyPrecision() {
    if (2 === this.m_precision) return true;
    const e5 = (e6, t3, s4, n6) => {
      if (s4 < 1) return false;
      if (!Number.isFinite(t3) || !Number.isFinite(s4)) return false;
      if (!n6) return true;
      const r = Number(e6) / s4;
      return !(BigInt((t3 + r - t3) * s4) > e6);
    }, t2 = 0 === this.m_precision ? wu : vu;
    return !!e5(t2, this.m_falseX, this.m_unitsXY, true) && (!!e5(t2, this.m_falseY, this.m_unitsXY, true) && (!!e5(t2, this.m_falseZ, this.m_unitsZ, false) && !!e5(t2, this.m_falseM, this.m_unitsM, false)));
  }
  fixTolerance() {
    2 !== this.m_precision && (this.m_toleranceXY = Math.max(2 / this.m_unitsXY, this.m_toleranceXY), this.m_toleranceZ = Math.max(2 / this.m_unitsZ, this.m_toleranceZ), this.m_toleranceM = Math.max(2 / this.m_unitsM, this.m_toleranceM), (Number.isNaN(this.m_falseX) || Number.isNaN(this.m_falseY)) && (this.m_falseX = this.m_falseY = Number.NaN));
  }
  equalsWithoutFalseXY(e5) {
    return this === e5 || this.m_unitsXY === e5.m_unitsXY && this.m_falseZ === e5.m_falseZ && this.m_unitsZ === e5.m_unitsZ && this.m_falseM === e5.m_falseM && this.m_unitsM === e5.m_unitsM && this.m_toleranceXY === e5.m_toleranceXY && this.m_toleranceZ === e5.m_toleranceZ && this.m_toleranceM === e5.m_toleranceM && this.m_precision === e5.m_precision;
  }
  setBestXyDomainFromEnvelope(e5, t2) {
  }
  setBestZDomainFromZRange(e5, t2, s4) {
  }
  setBestMDomainFromMRange(e5, t2, s4) {
  }
};
function rc() {
  return (!$u || Hu() && null === $u.getPECoordSys()) && ($u = gc(3857, 0, null, true)), $u;
}
function ic() {
  return (!ec || Hu() && null === ec.getPECoordSys()) && (ec = gc(102100, 0, null, true)), ec;
}
function oc() {
  return (!tc || Hu() && null === tc.getPECoordSys()) && (tc = gc(4326, 0, null, true)), tc;
}
function ac(e5) {
  e5.m_falseX = 0, e5.m_falseY = 0, e5.m_unitsXY = 1, e5.m_falseZ = 0, e5.m_unitsZ = 1, e5.m_falseM = 0, e5.m_unitsM = 1, e5.m_toleranceXY = 100 * Ss(), e5.m_toleranceZ = 100 * Ss(), e5.m_toleranceM = 100 * Ss(), e5.m_precision = 2;
}
function hc(e5, s4, n6, r) {
  const i2 = s4 instanceof kg;
  ac(e5), e5.m_precision = r, e5.m_falseX = Number.NaN, e5.m_falseY = Number.NaN;
  const o2 = 1e-4, a2 = 1e-3, h2 = i2 ? s4.m_csType : s4.isPCS ? 2 : 1;
  if (1 === h2) {
    const t2 = (0 === r ? 1 / 18e5 : 1e-9) * (i2 ? s4.getOneDegreeGCSUnit() : Math.PI / s4.metersOrRadiansPerUnit / 180);
    e5.m_unitsXY = 1 / t2;
  } else if (2 === h2) {
    const t2 = (0 === r ? a2 : o2) * (i2 ? s4.getOneMeterPCSUnit() : 1 / s4.metersOrRadiansPerUnit);
    e5.m_unitsXY = 1 / t2;
  } else P("unrecognized cs type");
  e5.m_falseM = -1e5, e5.m_unitsM = 1 / (0 === r ? a2 : o2), e5.m_unitsM = Math.max(1, e5.m_unitsM), e5.m_unitsXY = Math.max(1, e5.m_unitsXY);
  let m2 = 0, l2 = 0;
  0 !== r && 1 !== r || (m2 = 2 / e5.m_unitsXY, l2 = 2 / e5.m_unitsM), e5.m_toleranceXY = Math.max(m2, i2 ? s4.getUnitsPerMillimeter() : 2 === h2 ? 1e-3 / s4.metersOrRadiansPerUnit : 1e-3 / (s4.semiMajor * s4.metersOrRadiansPerUnit)), e5.m_toleranceM = Math.max(a2, l2), mc(e5, n6);
}
function mc(e5, t2) {
  const s4 = 1e-4, n6 = 1e-3;
  if (e5.m_falseZ = -1e5, t2) {
    const r2 = (0 === e5.m_precision ? n6 : s4) * t2.getOneMeter();
    e5.m_unitsZ = 1 / r2;
  } else e5.m_unitsZ = 1 / (0 === e5.m_precision ? n6 : s4);
  e5.m_unitsZ = Math.max(1, e5.m_unitsZ);
  let r = 0;
  0 !== e5.m_precision && 1 !== e5.m_precision || (r = 2 / e5.m_unitsZ), e5.m_toleranceZ = Math.max(t2 ? t2.getOneMeter() * n6 : n6, r);
}
function lc(e5, t2, s4, n6) {
  ac(e5), e5.m_precision = n6;
  const r = 0 === n6 ? wu : vu, i2 = 1e-4, o2 = 1e-3;
  let a2 = 1, h2 = 1, m2 = 1e-3;
  t2 && (h2 = t2.getUnitToBaseFactor()), t2 && 1 === t2.getUnitType() ? (a2 = 400 * Math.PI / 180, m2 = 8983152841195215e-24 * Math.PI / 180 / h2) : (a2 = (0 === n6 ? o2 : i2) * Number(r) * 0.5, m2 = o2 / h2), a2 /= h2, e5.m_falseX = -a2, e5.m_falseY = -a2, e5.m_unitsXY = Number(r) / (2 * a2), e5.m_falseM = -1e5, e5.m_unitsM = 1 / (0 === n6 ? o2 : i2), e5.m_unitsM = Math.max(1, e5.m_unitsM), e5.snapPrecision();
  let l2 = 0, g2 = 0;
  0 !== e5.m_precision && 1 !== e5.m_precision || (g2 = 2 / e5.m_unitsM, l2 = 2 / e5.m_unitsXY), e5.m_toleranceXY = Math.max(l2, m2), e5.m_toleranceM = Math.max(o2, g2), mc(e5, s4);
}
function gc(e5, t2, s4, n6) {
  if (!n6 && t2 <= 0) {
    if (3857 === e5) return rc();
    if (102100 === e5) return ic();
    if (4326 === e5) return oc();
  }
  const r = new sc();
  let i2, o2 = null;
  return Hu() ? (i2 = tu2(e5), t2 > 0 ? o2 = null : t2 = 0, r.setHorzProj_(i2), r.m_vertcs = o2) : (i2 = Vc(e5), r.m_unit = i2.isPCS ? new Eu(i2.metersOrRadiansPerUnit) : new ns2(i2.metersOrRadiansPerUnit)), hc(r.m_precisionDescriptor, i2, o2, 1), r.m_bDefaultDescriptor = true, r.m_userWKID = e5, r.calculateHashCode(), r.initDbgName(), r;
}
function uc(e5, t2, s4) {
  return S((e5 - t2) * s4) / s4 + t2;
}
var cc = null;
var _c = 3552713678800501e-30;
function dc(e5, t2, s4) {
  return e5 === t2 || Math.abs(e5 - t2) <= s4 * (1 + (Math.abs(e5) + Math.abs(t2)) / 2);
}
function pc(e5, t2) {
  return dc(e5, t2, _c);
}
function fc(e5, t2) {
  return 0 === e5 || Math.abs(e5) <= t2;
}
function xc(e5) {
  return fc(e5, _c);
}
var yc;
var Pc;
var Ec;
var Cc;
var Sc;
var Ic;
var bc;
var wc;
var vc;
var Nc;
var Tc;
function Gc(e5) {
  return { _this: e5, get() {
    return this._this;
  }, reset(e6) {
    this._this = e6;
  }, release() {
    const e6 = this._this;
    return this._this = null, e6;
  } };
}
var Dc = null;
function Vc(e5) {
  n2(Dc);
  const t2 = Dc(e5);
  return t2.semiMajor = t2.isPCS ? Number.NaN : qc(e5), t2;
}
function Fc(e5) {
  Dc = e5, n2(Dc);
}
function Hc(e5) {
  const t2 = e5;
  Pc = t2.PeFactory, n2(Pc), Tc = t2.PeGCSExtent, n2(Tc), vc = t2.PeLineType, n2(vc), Nc = t2.PeMath, n2(Nc), yc = t2.PeDouble, n2(yc), Ec = t2.PeDefs, n2(Ec), Cc = t2.PeCSTransformations, n2(Cc), Sc = t2.PeGTTransformations, n2(Sc), Ic = t2.PePCSInfo, n2(Ic), bc = t2.PeGTlistExtended, n2(bc), Pc.initialize(), wc = t2.PeGTlistExtendedEntry, n2(wc), Ec.PE_TYPE_ANGUNIT = 512, Ec.PE_STR_AUTH_ALL = 2, Ic.PE_POLE_LINE_STRAIGHT = 2, Ic.PE_POLE_LINE_CURVED = 3, Ec.PE_PARM_LAM0 = 2, Ec.PE_PARM_PHI0 = 6, Ec.PE_PRJ_AZIMUTHAL_EQUIDISTANT = 43032, Ec.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA = 43033, Ec.PE_PRJ_ALBERS = 43007, Ec.PE_PRJ_CYLINDRICAL_EQAREA = 43034, Ec.PE_TYPE_VERTCS = 8, Ec.PE_LINETYPE_GEODESIC = 0, Ec.PE_LINETYPE_LOXODROME = 1, Ec.PE_LINETYPE_GREAT_ELLIPTIC = 2, Ec.PE_LINETYPE_NORMAL_SECTION = 3, bc.PE_GTLIST_OPTS_USABLE = 1, Dc = null;
}
function kc(e5, t2, s4, n6) {
  return t2 <= 0 ? (s4[0] = 0, n6[0] = 0, false) : (s4[0] = t2, n6[0] = t2, true);
}
function Ac(e5) {
  n2(ku());
  return !!Dc(e5).isPCS || Mc(e5);
}
function Mc(e5) {
  return Pc && C("pe has been loaded. no-pe methods should not be used at this point."), cc || Oc(), cc.has(e5);
}
var Uc = /(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;
function qc(e5) {
  if (Pc && C("pe has been loaded. no-pe methods should not be used at this point."), "string" == typeof e5) {
    const s4 = e5.match(Uc);
    s4 && 2 === s4.length || P("bad gcs wkt");
    const n6 = Number.parseFloat(s4[1]);
    return Number.isFinite(n6) || P("bad gcs wkt"), n6;
  }
  return cc || Oc(), cc.has(e5) || C("gcs wkid not found"), cc.get(e5);
}
function Oc() {
  cc = /* @__PURE__ */ new Map();
  for (const e5 in ts2) {
    const t2 = Number.parseFloat(e5), s4 = ts2[e5];
    if (Array.isArray(s4)) for (const e6 of s4) cc.set(e6, t2);
    else cc.set(s4, t2);
  }
  ss2();
}
function Bc(e5, t2) {
  const s4 = Pc.geogtran(e5);
  s4 || R(e5);
  return new zc(s4, t2);
}
function Rc(e5, t2) {
  const s4 = Pc.fromString(Ec.PE_TYPE_GEOGTRAN, e5);
  s4 || U(e5);
  return new zc(s4, t2);
}
function Yc(e5, t2) {
  return new zc(e5, t2);
}
var Xc = ws(0);
var Lc = ws(1);
var zc = class e4 {
  constructor(t2, s4) {
    if (t2 instanceof e4) return this.m_geogTranWrapper = t2.m_geogTranWrapper, this.m_bInverted = s4 ? !t2.m_bInverted : t2.m_bInverted, void (this.m_hashCode = gs(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Lc : Xc));
    this.m_geogTranWrapper = new Hm2(t2), this.m_bInverted = s4, this.m_hashCode = gs(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Lc : Xc);
  }
  getID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getLatestID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getText() {
    return this.m_geogTranWrapper.getText();
  }
  getTextExtended(e5) {
    if (!this.m_geogTranWrapper.getGeogtran()) return "";
    if (-1 === e5) return this.m_geogTranWrapper.getGeogtran().toString();
    {
      const t2 = 0 === e5 ? Ec.PE_STR_AUTH_TOP : Ec.PE_STR_AUTH_ALL;
      return this.m_geogTranWrapper.getGeogtran().toString(t2);
    }
  }
  getText2(e5 = -1) {
    let t2 = Ec.PE_STR_FMT_WKT2;
    return -1 !== e5 && (t2 |= 0 === e5 ? Ec.PE_STR_AUTH_TOP : Ec.PE_STR_AUTH_ALL), this.m_geogTranWrapper.getGeogtran().toString(t2);
  }
  getName() {
    return this.m_geogTranWrapper && this.m_geogTranWrapper.getGeogtran() ? this.m_geogTranWrapper.getGeogtran().getName() : "";
  }
  getInputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getOutputSr(false) : this.m_geogTranWrapper.getInputSr(false);
  }
  getOutputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getInputSr(false) : this.m_geogTranWrapper.getOutputSr(false);
  }
  getInverse() {
    return new e4(this, true);
  }
  isInverted() {
    return this.m_bInverted;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  GetPeGeogtran() {
    return this.m_geogTranWrapper.getGeogtran();
  }
  equals(e5) {
    const t2 = e5;
    return t2 === this || this.m_bInverted === t2.m_bInverted && (this.GetPeGeogtran() === t2.GetPeGeogtran() || this.getID() === t2.getID() && !(0 === this.getID() && !this.GetPeGeogtran().isEqual(t2.GetPeGeogtran())));
  }
  referencesMissingData() {
    return !!this.m_geogTranWrapper && !this.m_geogTranWrapper.isUsable();
  }
  getWrapper() {
    return this.m_geogTranWrapper;
  }
};
function Wc(e5, t2, n6, r, i2) {
  const o2 = e5.getGCS(), a2 = t2.getGCS(), h2 = o2.getPECoordSys(), m2 = a2.getPECoordSys();
  let l2 = null;
  if (!n6.isEmpty()) {
    const t3 = n6.clone();
    if (!t3.isEmpty() && 2 === e5.getCoordinateSystemType()) {
      let s4 = new re({ env2D: t3 });
      const n7 = qg(e5, o2, null);
      s4 = new kh2().execute(s4, n7, null), s4.queryEnvelope(t3);
    }
    if (!t3.isEmpty()) {
      const e6 = h2.getPrimem().getLongitude(), s4 = h2.getUnit().getUnitFactor();
      l2 = new Tc(t3.xmin, t3.ymin, t3.xmax, t3.ymax, e6, s4);
    }
  }
  let g2 = r;
  g2 >= ls() && (g2 = 0);
  const u = [];
  let c = bc.PE_GTLIST_OPTS_COMMON;
  i2 || (c &= ~bc.PE_GTLIST_OPTS_USABLE);
  for (let _ = 0; _ < 2; _++) {
    u.length = 0;
    const e6 = g2, t3 = bc.getGTlist(h2, m2, 2, c, l2, e6);
    let n7 = false;
    if (t3 && t3.length > 0) for (let o3 = 0, a3 = t3.length; o3 < a3; o3++) {
      const e7 = jc([t3[o3]]);
      if (n2(e7), i2 && e7.referencesMissingData()) n7 = true;
      else if (u.push(e7), r > 0 && u.length === r) break;
    }
    if (!n7) break;
    0 === g2 || (g2 = 0);
  }
  return l2 && l2.destroy(), u;
}
function jc(e5) {
  n2(null !== e5);
  const t2 = new Kc(), n6 = e5[0].getSteps();
  if (n6) {
    const s4 = e5[0].getEntries();
    for (let e6 = 0; e6 < n6; e6++) {
      const n7 = 0 !== s4[e6].getDirection(), r = Yc(s4[e6].getGeogtran(), n7);
      t2.add(r);
    }
    return t2.create();
  }
  return null;
}
var Zc = class {
  constructor(e5, t2, s4, n6) {
    this.m_bReadOnly = true, this.m_name = "", this.m_fastTrack = -1, this.m_bNameIsSet = false, this.m_transforms = e5, t2 && (this.m_name = t2, this.m_bNameIsSet = true), this.m_inputSr = s4, this.m_outputSr = n6;
  }
  getType() {
    return 0;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e5 = "";
    for (const t2 of this.m_transforms) e5.length > 0 && (e5 += " + "), t2.isInverted() && (e5 += "~"), e5 += t2.getName();
    return e5;
  }
  count() {
    return this.m_transforms.length;
  }
  createInverse() {
    return this.getInverse();
  }
  getHashCode() {
    let e5 = 1973;
    for (let t2 = 0; t2 < this.m_transforms.length; t2++) e5 = gs(e5, this.m_transforms[t2].getHashCode());
    return e5;
  }
  equals(e5) {
    return n2(0), false;
  }
  referencesMissingData() {
    if (0 === this.m_transforms.length) return false;
    for (const e5 of this.m_transforms) if (e5.referencesMissingData()) return true;
    return false;
  }
  isMatchingTransformation(e5, t2) {
    return n2(0), false;
  }
  validateTransformation(e5, t2) {
    return n2(0), false;
  }
  nameIsSet() {
    return n2(0), false;
  }
  getInputSpatialReference() {
    return this.m_inputSr;
  }
  getOutputSpatialReference() {
    return this.m_outputSr;
  }
  getStep(e5) {
    return (e5 < 0 || e5 > this.count()) && A(""), this.m_transforms[e5];
  }
  getInverse() {
    const e5 = new Kc();
    return e5.addSteps(this, true), e5.setInputSpatialReference(this.m_outputSr), e5.setOutputSpatialReference(this.m_inputSr), e5.create();
  }
  transform(e5, t2, s4) {
    if (0 === this.count()) return;
    let n6 = this.m_inputSr, r = this.m_outputSr;
    if (e5 && (r = Mt(n6, n6 = r)), 0 === this.m_transforms.length) return void km2(n6, null, r, null, t2, null, s4);
    let i2 = this.m_fastTrack;
    if (1 === i2) return void le(e5, this.m_transforms, (n7) => {
      Om2(n7.getWrapper(), e5 !== n7.isInverted(), t2, null, s4);
    });
    const o2 = Fm2();
    -1 === i2 && o2.initFromGcsAndVcs(n6, null);
    const a2 = Fm2();
    let h2 = e5 ? this.m_transforms.length - 1 : 0;
    const m2 = e5 ? -1 : 1;
    for (let g2 = 0, u = this.m_transforms.length; g2 < u; g2++, h2 += m2) {
      if (0 === g2) {
        const r3 = this.m_transforms[h2];
        Am2(n6.getPECoordSys(), null, r3.getWrapper(), e5 !== r3.isInverted(), t2, null, s4, a2), -1 === i2 && (o2.equals(a2) || (i2 = 0)), o2.assign(a2);
      } else {
        const n7 = this.m_transforms[h2 - m2], r3 = this.m_transforms[h2];
        Um2(o2, n7.getWrapper(), e5 !== n7.isInverted(), r3.getWrapper(), e5 !== r3.isInverted(), t2, null, s4, a2), -1 === i2 && (o2.equals(a2) || (i2 = 0)), o2.assign(a2);
      }
      const r2 = this.m_transforms[h2];
      qm2(o2, r2.getWrapper(), e5 !== r2.isInverted(), t2, null, s4, a2), o2.assign(a2);
    }
    const l2 = this.m_transforms[h2 - m2];
    Mm2(o2, l2.getWrapper(), e5 !== l2.isInverted(), r, null, t2, null, s4), -1 === i2 && (a2.initFromGcsAndVcs(r, null), o2.equals(a2) || (i2 = 0)), this.m_fastTrack = 0 === i2 ? 0 : 1;
  }
};
var Kc = class {
  constructor() {
    this.m_transforms = [], this.m_inputGCS = null, this.m_outputGCS = null, this.m_name = "", this.m_bNameIsSet = false;
  }
  getInputSpatialReference() {
    return null !== this.m_inputGCS ? this.m_inputGCS : this.count() > 0 ? this.m_transforms[0].getInputSpatialReference() : null;
  }
  setInputSpatialReference(e5) {
    this.m_inputGCS = e5 ? e5.getGCS() : null;
  }
  getOutputSpatialReference() {
    return null !== this.m_outputGCS ? this.m_outputGCS : this.count() > 0 ? this.m_transforms.at(-1).getOutputSpatialReference() : null;
  }
  setOutputSpatialReference(e5) {
    this.m_outputGCS = e5 ? e5.getGCS() : null;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e5 = "";
    for (const t2 of this.m_transforms) e5.length > 0 && (e5 += " + "), t2.isInverted() && (e5 += "~"), e5 += t2.getName();
    return e5;
  }
  count() {
    return this.m_transforms.length;
  }
  getStep(e5) {
    return (e5 < 0 || e5 > this.count()) && A(""), this.m_transforms[e5];
  }
  setStep(e5, t2) {
    n2(0);
  }
  add(e5) {
    this.m_transforms.push(e5);
  }
  addSteps(e5, t2) {
    if (t2) for (let s4 = e5.count() - 1; s4 >= 0; --s4) this.add(e5.getStep(s4).getInverse());
    else for (let s4 = 0; s4 < e5.count(); ++s4) this.add(e5.getStep(s4));
  }
  clear() {
    this.m_transforms = [], this.m_name = "", this.m_bNameIsSet = false, this.m_inputGCS = null, this.m_outputGCS = null;
  }
  remove(e5) {
    n2(0);
  }
  create() {
    const e5 = this.getInputSpatialReference(), t2 = this.getOutputSpatialReference(), s4 = new Zc(this.m_transforms, this.m_bNameIsSet ? this.m_name : null, e5, t2);
    return s4.m_bReadOnly = true, this.clear(), s4;
  }
};
var Qc = Object.freeze(Object.defineProperty({ __proto__: null, SpatialReference: sc, SpatialReferencePrecisionDescriptor: nc, create: Mu, createFromWKT: Uu, createImplFromPe: qu, createLocal: Yu, createWithNewPrecision: Bu, createWithNewVCS: Ru, getGCS: Lu, getTempName: Qu, hasNoPe: ku, hasPe: Hu, injectNoPe: Fu, injectPe: Vu, isInitialized: Au, isTempName: Ju, isValidWkid: zu, isValidWkt: Wu, makeSpheroidData: Gu, snapGeometry: Xu, webMercator: rc, webMercator102100: ic, wgs84: oc }, Symbol.toStringTag, { value: "Module" }));
var Jc = Object.freeze(Object.defineProperty({ __proto__: null, OperatorProject: kh2 }, Symbol.toStringTag, { value: "Module" }));
var $c = Object.freeze(Object.defineProperty({ __proto__: null, CompositeGeographicTransformation: Zc, CompositeGeographicTransformationEditor: Kc, createImpl: jc, queryGtListImpl: Wc }, Symbol.toStringTag, { value: "Module" }));
var e_ = Object.freeze(Object.defineProperty({ __proto__: null, GeographicTransformation: zc, create: Bc, createFromPe: Yc, createFromWKT: Rc }, Symbol.toStringTag, { value: "Module" }));
var t_ = Object.freeze(Object.defineProperty({ __proto__: null, ProjectionTransformation: Kg, create: Mg, createEx: qg, createFromAoi: Ug, createImplEx: Bg, makeExtendedParams: Yg, makeExtendedParamsInternal: Wg, queryTransformationList: Rg }, Symbol.toStringTag, { value: "Module" }));

export {
  n4 as n,
  X2 as X,
  Q2 as Q,
  j3 as j,
  J,
  K,
  $2 as $,
  bt,
  Dt2 as Dt,
  Ct2 as Ct,
  It2 as It,
  Tt2 as Tt,
  wt2 as wt,
  zt2 as zt,
  Bt2 as Bt,
  Pt2 as Pt,
  kt2 as kt,
  Vt2 as Vt,
  ee,
  re,
  ce,
  Ce,
  ss,
  Ys2 as Ys,
  Ln,
  mo,
  Na,
  Va,
  eh,
  sh,
  ah,
  vh,
  jh,
  tm,
  em,
  bm,
  Tm,
  Im,
  Ym,
  Xm,
  qm,
  su,
  nu,
  f2 as f,
  I4 as I,
  o,
  Jt2 as Jt,
  rs3 as rs,
  ls3 as ls,
  us3 as us,
  fs2 as fs,
  Ps3 as Ps,
  Es3 as Es,
  Is3 as Is,
  Vs3 as Vs,
  ks3 as ks,
  As2 as As,
  qs3 as qs,
  Js2 as Js,
  $s2 as $s,
  zn2 as zn,
  Qn2 as Qn,
  $n2 as $n,
  sr2 as sr,
  Vr2 as Vr,
  Ro2 as Ro,
  Xo2 as Xo,
  Wo2 as Wo,
  ra2 as ra,
  ia2 as ia,
  aa2 as aa,
  la2 as la,
  ga2 as ga,
  ua2 as ua,
  ca2 as ca,
  da2 as da,
  xa2 as xa,
  Ta2 as Ta,
  Da2 as Da,
  Fa2 as Fa,
  qa2 as qa,
  za2 as za,
  $a2 as $a,
  th2 as th,
  rh,
  fh2 as fh,
  Ch2 as Ch,
  bh2 as bh,
  kh2 as kh,
  Mh2 as Mh,
  Uh2 as Uh,
  qh2 as qh,
  Oh2 as Oh,
  Bh2 as Bh,
  Rh2 as Rh,
  hm2 as hm,
  mm2 as mm,
  lm2 as lm,
  Gm2 as Gm,
  Bm2 as Bm,
  Rm2 as Rm,
  Ym2,
  Xm2,
  zm2 as zm,
  nl,
  hl,
  ml,
  bl,
  Dl,
  Vl,
  kl,
  Ol,
  Rl,
  Yl,
  Xl,
  Ll,
  ig,
  cg,
  Vg,
  qg,
  Bg,
  Yg,
  Wg,
  Gu,
  Fu,
  Hu,
  Mu,
  Uu,
  Bu,
  Yu,
  Xu,
  zu,
  Wu,
  Qu,
  nc,
  pc,
  yc,
  Pc,
  Ec,
  Cc,
  vc,
  Nc,
  Qc,
  Jc,
  $c,
  e_,
  t_
};
//# sourceMappingURL=chunk-GSEBXRMV.js.map
