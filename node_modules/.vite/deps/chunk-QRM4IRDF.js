import {
  j as j4
} from "./chunk-CAN2PXNV.js";
import {
  j as j3
} from "./chunk-XG7T2Y7N.js";
import {
  S,
  j,
  j2
} from "./chunk-IVS2JCO6.js";
import {
  g
} from "./chunk-4GOW35CM.js";
import {
  V,
  Y,
  r as r2,
  re,
  s2 as s,
  x
} from "./chunk-TEJXT4W6.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import {
  r
} from "./chunk-SCZRL2WP.js";

// node_modules/@arcgis/core/geometry/Circle.js
var f;
var g2 = f = class extends j3 {
  constructor(e) {
    super(e), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  initialize() {
    const e = this.center, o = this.numberOfPoints;
    if (this.hasZ = (e == null ? void 0 : e.hasZ) ?? false, 0 !== this.rings.length || !e) return;
    const c = x(this.radius, this.radiusUnit, "meters"), n = e.spatialReference;
    let p, l = "geographic";
    if (n.isWebMercator ? l = "webMercator" : (null != (n.wkid && r2[n.wkid]) || (n.wkt2 || n.wkt) && re(n.wkt2 || n.wkt)) && (l = "projected"), this.geodesic) {
      let r3;
      switch (l) {
        case "webMercator":
          r3 = S(e);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r3 = e;
      }
      p = this._createGeodesicCircle(r3, c, o), "webMercator" === l && (p = j(p));
    } else {
      let r3;
      "webMercator" === l || "projected" === l ? r3 = c / V(e.spatialReference) : "geographic" === l && (r3 = Y(c, "meters", s(e.spatialReference).radius)), p = this._createPlanarCircle(e, r3, o);
    }
    this.spatialReference = p.spatialReference, this.addRing(p.rings[0]);
  }
  clone() {
    const { center: e, numberOfPoints: r3, radius: t, radiusUnit: s2, geodesic: i } = this;
    return new f({ center: e == null ? void 0 : e.clone(), numberOfPoints: r3, radius: t, radiusUnit: s2, geodesic: i });
  }
  _createGeodesicCircle(e, r3, t) {
    const s2 = [], i = [e.x, e.y];
    for (let o = 0; o < 360; o += 360 / t) {
      const t2 = this.hasZ ? [0, 0, e.z ?? 0] : [0, 0];
      j4(t2, i, o, r3, g.WGS84), s2.push(t2);
    }
    return s2.push(s2[0]), new j3({ rings: [s2] });
  }
  _createPlanarCircle(e, r3, t) {
    const s2 = [], i = 2 * Math.PI / t;
    for (let o = 0; o < t; ++o) {
      const t2 = i * o, c = [e.x + Math.cos(-t2) * r3, e.y + Math.sin(-t2) * r3];
      this.hasZ && c.push(e.z ?? 0), s2.push(c);
    }
    return s2.push(s2[0]), new j3({ spatialReference: e.spatialReference, rings: [s2] });
  }
};
r([m({ type: j2 })], g2.prototype, "center", void 0), r([m()], g2.prototype, "geodesic", void 0), r([m()], g2.prototype, "numberOfPoints", void 0), r([m()], g2.prototype, "radius", void 0), r([m()], g2.prototype, "radiusUnit", void 0), g2 = f = r([a("esri.geometry.Circle")], g2);
var b = g2;

export {
  b
};
//# sourceMappingURL=chunk-QRM4IRDF.js.map
