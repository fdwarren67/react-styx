import {
  e,
  n,
  s
} from "./chunk-7LRZLRAB.js";

// node_modules/color-string/node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// node_modules/color-string/index.js
var reverseNames = /* @__PURE__ */ Object.create(null);
for (const name in color_name_default) {
  if (Object.hasOwn(color_name_default, name)) {
    reverseNames[color_name_default[name]] = name;
  }
}
var cs = {
  to: {},
  get: {}
};
cs.get = function(string) {
  const prefix = string.slice(0, 3).toLowerCase();
  let value;
  let model;
  switch (prefix) {
    case "hsl": {
      value = cs.get.hsl(string);
      model = "hsl";
      break;
    }
    case "hwb": {
      value = cs.get.hwb(string);
      model = "hwb";
      break;
    }
    default: {
      value = cs.get.rgb(string);
      model = "rgb";
      break;
    }
  }
  if (!value) {
    return null;
  }
  return { model, value };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  const abbr = /^#([a-f\d]{3,4})$/i;
  const hex = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
  const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
  const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
  const keyword = /^(\w+)$/;
  let rgb = [0, 0, 0, 1];
  let match;
  let i;
  let hexAlpha;
  if (match = string.match(hex)) {
    hexAlpha = match[2];
    match = match[1];
    for (i = 0; i < 3; i++) {
      const i2 = i * 2;
      rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);
    }
    if (hexAlpha) {
      rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i = 0; i < 3; i++) {
      rgb[i] = Number.parseInt(match[i] + match[i], 16);
    }
    if (hexAlpha) {
      rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = Number.parseInt(match[i + 1], 10);
    }
    if (match[4]) {
      rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
    }
  } else if (match = string.match(per)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);
    }
    if (match[4]) {
      rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!Object.hasOwn(color_name_default, match[1])) {
      return null;
    }
    rgb = color_name_default[match[1]];
    rgb[3] = 1;
    return rgb;
  } else {
    return null;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] = clamp(rgb[i], 0, 255);
  }
  rgb[3] = clamp(rgb[3], 0, 1);
  return rgb;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  const match = string.match(hsl);
  if (match) {
    const alpha = Number.parseFloat(match[4]);
    const h2 = (Number.parseFloat(match[1]) % 360 + 360) % 360;
    const s3 = clamp(Number.parseFloat(match[2]), 0, 100);
    const l = clamp(Number.parseFloat(match[3]), 0, 100);
    const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h2, s3, l, a];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  const match = string.match(hwb);
  if (match) {
    const alpha = Number.parseFloat(match[4]);
    const h2 = (Number.parseFloat(match[1]) % 360 + 360) % 360;
    const w2 = clamp(Number.parseFloat(match[2]), 0, 100);
    const b = clamp(Number.parseFloat(match[3]), 0, 100);
    const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h2, w2, b, a];
  }
  return null;
};
cs.to.hex = function(...rgba) {
  return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function(...rgba) {
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function(...rgba) {
  const r = Math.round(rgba[0] / 255 * 100);
  const g2 = Math.round(rgba[1] / 255 * 100);
  const b = Math.round(rgba[2] / 255 * 100);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g2 + "%, " + b + "%)" : "rgba(" + r + "%, " + g2 + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function(...hsla) {
  return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function(...hwba) {
  let a = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(...rgb) {
  return reverseNames[rgb.slice(0, 3)];
};
function clamp(number_, min, max) {
  return Math.min(Math.max(min, number_), max);
}
function hexDouble(number_) {
  const string_ = Math.round(number_).toString(16).toUpperCase();
  return string_.length < 2 ? "0" + string_ : string_;
}
var color_string_default = cs;

// node_modules/color/node_modules/color-name/index.js
var color_name_default2 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// node_modules/color/node_modules/color-convert/conversions.js
var reverseKeywords = {};
for (const key of Object.keys(color_name_default2)) {
  reverseKeywords[color_name_default2[key]] = key;
}
var convert = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var conversions_default = convert;
var LAB_FT = (6 / 29) ** 3;
for (const model of Object.keys(convert)) {
  if (!("channels" in convert[model])) {
    throw new Error("missing channels property: " + model);
  }
  if (!("labels" in convert[model])) {
    throw new Error("missing channel labels property: " + model);
  }
  if (convert[model].labels.length !== convert[model].channels) {
    throw new Error("channel and label counts mismatch: " + model);
  }
  const { channels, labels } = convert[model];
  delete convert[model].channels;
  delete convert[model].labels;
  Object.defineProperty(convert[model], "channels", { value: channels });
  Object.defineProperty(convert[model], "labels", { value: labels });
}
convert.rgb.hsl = function(rgb) {
  const r = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min = Math.min(r, g2, b);
  const max = Math.max(r, g2, b);
  const delta = max - min;
  let h2;
  let s3;
  switch (max) {
    case min: {
      h2 = 0;
      break;
    }
    case r: {
      h2 = (g2 - b) / delta;
      break;
    }
    case g2: {
      h2 = 2 + (b - r) / delta;
      break;
    }
    case b: {
      h2 = 4 + (r - g2) / delta;
      break;
    }
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  const l = (min + max) / 2;
  if (max === min) {
    s3 = 0;
  } else if (l <= 0.5) {
    s3 = delta / (max + min);
  } else {
    s3 = delta / (2 - max - min);
  }
  return [h2, s3 * 100, l * 100];
};
convert.rgb.hsv = function(rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h2;
  let s3;
  const r = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g2, b);
  const diff = v - Math.min(r, g2, b);
  const diffc = function(c2) {
    return (v - c2) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h2 = 0;
    s3 = 0;
  } else {
    s3 = diff / v;
    rdif = diffc(r);
    gdif = diffc(g2);
    bdif = diffc(b);
    switch (v) {
      case r: {
        h2 = bdif - gdif;
        break;
      }
      case g2: {
        h2 = 1 / 3 + rdif - bdif;
        break;
      }
      case b: {
        h2 = 2 / 3 + gdif - rdif;
        break;
      }
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return [
    h2 * 360,
    s3 * 100,
    v * 100
  ];
};
convert.rgb.hwb = function(rgb) {
  const r = rgb[0];
  const g2 = rgb[1];
  let b = rgb[2];
  const h2 = convert.rgb.hsl(rgb)[0];
  const w2 = 1 / 255 * Math.min(r, Math.min(g2, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g2, b));
  return [h2, w2 * 100, b * 100];
};
convert.rgb.cmyk = function(rgb) {
  const r = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k2 = Math.min(1 - r, 1 - g2, 1 - b);
  const c2 = (1 - r - k2) / (1 - k2) || 0;
  const m = (1 - g2 - k2) / (1 - k2) || 0;
  const y2 = (1 - b - k2) / (1 - k2) || 0;
  return [c2 * 100, m * 100, y2 * 100, k2 * 100];
};
function comparativeDistance(x2, y2) {
  return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
}
convert.rgb.keyword = function(rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Number.POSITIVE_INFINITY;
  let currentClosestKeyword;
  for (const keyword of Object.keys(color_name_default2)) {
    const value = color_name_default2[keyword];
    const distance = comparativeDistance(rgb, value);
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert.keyword.rgb = function(keyword) {
  return color_name_default2[keyword];
};
convert.rgb.xyz = function(rgb) {
  let r = rgb[0] / 255;
  let g2 = rgb[1] / 255;
  let b = rgb[2] / 255;
  r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
  b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
  const x2 = r * 0.4124564 + g2 * 0.3575761 + b * 0.1804375;
  const y2 = r * 0.2126729 + g2 * 0.7151522 + b * 0.072175;
  const z2 = r * 0.0193339 + g2 * 0.119192 + b * 0.9503041;
  return [x2 * 100, y2 * 100, z2 * 100];
};
convert.rgb.lab = function(rgb) {
  const xyz = convert.rgb.xyz(rgb);
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > LAB_FT ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > LAB_FT ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > LAB_FT ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l = 116 * y2 - 16;
  const a = 500 * (x2 - y2);
  const b = 200 * (y2 - z2);
  return [l, a, b];
};
convert.hsl.rgb = function(hsl) {
  const h2 = hsl[0] / 360;
  const s3 = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t3;
  let value;
  if (s3 === 0) {
    value = l * 255;
    return [value, value, value];
  }
  const t2 = l < 0.5 ? l * (1 + s3) : l + s3 - l * s3;
  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    t3 = h2 + 1 / 3 * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      value = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      value = t2;
    } else if (3 * t3 < 2) {
      value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      value = t1;
    }
    rgb[i] = value * 255;
  }
  return rgb;
};
convert.hsl.hsv = function(hsl) {
  const h2 = hsl[0];
  let s3 = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s3;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s3 *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s3) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s3 / (l + s3);
  return [h2, sv * 100, v * 100];
};
convert.hsv.rgb = function(hsv) {
  const h2 = hsv[0] / 60;
  const s3 = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h2) % 6;
  const f = h2 - Math.floor(h2);
  const p = 255 * v * (1 - s3);
  const q2 = 255 * v * (1 - s3 * f);
  const t = 255 * v * (1 - s3 * (1 - f));
  v *= 255;
  switch (hi) {
    case 0: {
      return [v, t, p];
    }
    case 1: {
      return [q2, v, p];
    }
    case 2: {
      return [p, v, t];
    }
    case 3: {
      return [p, q2, v];
    }
    case 4: {
      return [t, p, v];
    }
    case 5: {
      return [v, p, q2];
    }
  }
};
convert.hsv.hsl = function(hsv) {
  const h2 = hsv[0];
  const s3 = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s3) * v;
  const lmin = (2 - s3) * vmin;
  sl = s3 * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h2, sl * 100, l * 100];
};
convert.hwb.rgb = function(hwb) {
  const h2 = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  const i = Math.floor(6 * h2);
  const v = 1 - bl;
  f = 6 * h2 - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  const n2 = wh + f * (v - wh);
  let r;
  let g2;
  let b;
  switch (i) {
    default:
    case 6:
    case 0: {
      r = v;
      g2 = n2;
      b = wh;
      break;
    }
    case 1: {
      r = n2;
      g2 = v;
      b = wh;
      break;
    }
    case 2: {
      r = wh;
      g2 = v;
      b = n2;
      break;
    }
    case 3: {
      r = wh;
      g2 = n2;
      b = v;
      break;
    }
    case 4: {
      r = n2;
      g2 = wh;
      b = v;
      break;
    }
    case 5: {
      r = v;
      g2 = wh;
      b = n2;
      break;
    }
  }
  return [r * 255, g2 * 255, b * 255];
};
convert.cmyk.rgb = function(cmyk) {
  const c2 = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y2 = cmyk[2] / 100;
  const k2 = cmyk[3] / 100;
  const r = 1 - Math.min(1, c2 * (1 - k2) + k2);
  const g2 = 1 - Math.min(1, m * (1 - k2) + k2);
  const b = 1 - Math.min(1, y2 * (1 - k2) + k2);
  return [r * 255, g2 * 255, b * 255];
};
convert.xyz.rgb = function(xyz) {
  const x2 = xyz[0] / 100;
  const y2 = xyz[1] / 100;
  const z2 = xyz[2] / 100;
  let r;
  let g2;
  let b;
  r = x2 * 3.2404542 + y2 * -1.5371385 + z2 * -0.4985314;
  g2 = x2 * -0.969266 + y2 * 1.8760108 + z2 * 0.041556;
  b = x2 * 0.0556434 + y2 * -0.2040259 + z2 * 1.0572252;
  r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
  g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
  b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g2 = Math.min(Math.max(0, g2), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g2 * 255, b * 255];
};
convert.xyz.lab = function(xyz) {
  let x2 = xyz[0];
  let y2 = xyz[1];
  let z2 = xyz[2];
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > LAB_FT ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > LAB_FT ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > LAB_FT ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
  const l = 116 * y2 - 16;
  const a = 500 * (x2 - y2);
  const b = 200 * (y2 - z2);
  return [l, a, b];
};
convert.lab.xyz = function(lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x2;
  let y2;
  let z2;
  y2 = (l + 16) / 116;
  x2 = a / 500 + y2;
  z2 = y2 - b / 200;
  const y22 = y2 ** 3;
  const x22 = x2 ** 3;
  const z22 = z2 ** 3;
  y2 = y22 > LAB_FT ? y22 : (y2 - 16 / 116) / 7.787;
  x2 = x22 > LAB_FT ? x22 : (x2 - 16 / 116) / 7.787;
  z2 = z22 > LAB_FT ? z22 : (z2 - 16 / 116) / 7.787;
  x2 *= 95.047;
  y2 *= 100;
  z2 *= 108.883;
  return [x2, y2, z2];
};
convert.lab.lch = function(lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h2;
  const hr = Math.atan2(b, a);
  h2 = hr * 360 / 2 / Math.PI;
  if (h2 < 0) {
    h2 += 360;
  }
  const c2 = Math.sqrt(a * a + b * b);
  return [l, c2, h2];
};
convert.lch.lab = function(lch) {
  const l = lch[0];
  const c2 = lch[1];
  const h2 = lch[2];
  const hr = h2 / 360 * 2 * Math.PI;
  const a = c2 * Math.cos(hr);
  const b = c2 * Math.sin(hr);
  return [l, a, b];
};
convert.rgb.ansi16 = function(args, saturation = null) {
  const [r, g2, b] = args;
  let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert.hsv.ansi16 = function(args) {
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function(args) {
  const r = args[0];
  const g2 = args[1];
  const b = args[2];
  if (r >> 4 === g2 >> 4 && g2 >> 4 === b >> 4) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert.ansi16.rgb = function(args) {
  args = args[0];
  let color = args % 10;
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }
    color = color / 10.5 * 255;
    return [color, color, color];
  }
  const mult = (Math.trunc(args > 50) + 1) * 0.5;
  const r = (color & 1) * mult * 255;
  const g2 = (color >> 1 & 1) * mult * 255;
  const b = (color >> 2 & 1) * mult * 255;
  return [r, g2, b];
};
convert.ansi256.rgb = function(args) {
  args = args[0];
  if (args >= 232) {
    const c2 = (args - 232) * 10 + 8;
    return [c2, c2, c2];
  }
  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g2, b];
};
convert.rgb.hex = function(args) {
  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  const string = integer.toString(16).toUpperCase();
  return "000000".slice(string.length) + string;
};
convert.hex.rgb = function(args) {
  const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  let colorString = match[0];
  if (match[0].length === 3) {
    colorString = [...colorString].map((char) => char + char).join("");
  }
  const integer = Number.parseInt(colorString, 16);
  const r = integer >> 16 & 255;
  const g2 = integer >> 8 & 255;
  const b = integer & 255;
  return [r, g2, b];
};
convert.rgb.hcg = function(rgb) {
  const r = rgb[0] / 255;
  const g2 = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(Math.max(r, g2), b);
  const min = Math.min(Math.min(r, g2), b);
  const chroma = max - min;
  let hue;
  const grayscale = chroma < 1 ? min / (1 - chroma) : 0;
  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g2 - b) / chroma % 6;
  } else if (max === g2) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g2) / chroma;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert.hsl.hcg = function(hsl) {
  const s3 = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c2 = l < 0.5 ? 2 * s3 * l : 2 * s3 * (1 - l);
  let f = 0;
  if (c2 < 1) {
    f = (l - 0.5 * c2) / (1 - c2);
  }
  return [hsl[0], c2 * 100, f * 100];
};
convert.hsv.hcg = function(hsv) {
  const s3 = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c2 = s3 * v;
  let f = 0;
  if (c2 < 1) {
    f = (v - c2) / (1 - c2);
  }
  return [hsv[0], c2 * 100, f * 100];
};
convert.hcg.rgb = function(hcg) {
  const h2 = hcg[0] / 360;
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  if (c2 === 0) {
    return [g2 * 255, g2 * 255, g2 * 255];
  }
  const pure = [0, 0, 0];
  const hi = h2 % 1 * 6;
  const v = hi % 1;
  const w2 = 1 - v;
  let mg = 0;
  switch (Math.floor(hi)) {
    case 0: {
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    }
    case 1: {
      pure[0] = w2;
      pure[1] = 1;
      pure[2] = 0;
      break;
    }
    case 2: {
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    }
    case 3: {
      pure[0] = 0;
      pure[1] = w2;
      pure[2] = 1;
      break;
    }
    case 4: {
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    }
    default: {
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w2;
    }
  }
  mg = (1 - c2) * g2;
  return [
    (c2 * pure[0] + mg) * 255,
    (c2 * pure[1] + mg) * 255,
    (c2 * pure[2] + mg) * 255
  ];
};
convert.hcg.hsv = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const v = c2 + g2 * (1 - c2);
  let f = 0;
  if (v > 0) {
    f = c2 / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert.hcg.hsl = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const l = g2 * (1 - c2) + 0.5 * c2;
  let s3 = 0;
  if (l > 0 && l < 0.5) {
    s3 = c2 / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s3 = c2 / (2 * (1 - l));
  }
  return [hcg[0], s3 * 100, l * 100];
};
convert.hcg.hwb = function(hcg) {
  const c2 = hcg[1] / 100;
  const g2 = hcg[2] / 100;
  const v = c2 + g2 * (1 - c2);
  return [hcg[0], (v - c2) * 100, (1 - v) * 100];
};
convert.hwb.hcg = function(hwb) {
  const w2 = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c2 = v - w2;
  let g2 = 0;
  if (c2 < 1) {
    g2 = (v - c2) / (1 - c2);
  }
  return [hwb[0], c2 * 100, g2 * 100];
};
convert.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert.gray.hsl = function(args) {
  return [0, 0, args[0]];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert.gray.hex = function(gray) {
  const value = Math.round(gray[0] / 100 * 255) & 255;
  const integer = (value << 16) + (value << 8) + value;
  const string = integer.toString(16).toUpperCase();
  return "000000".slice(string.length) + string;
};
convert.rgb.gray = function(rgb) {
  const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [value / 255 * 100];
};

// node_modules/color/node_modules/color-convert/route.js
function buildGraph() {
  const graph = {};
  const models2 = Object.keys(conversions_default);
  for (let { length } = models2, i = 0; i < length; i++) {
    graph[models2[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length > 0) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions_default[current]);
    for (let { length } = adjacents, i = 0; i < length; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function(args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions_default[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions_default[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
function route(fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models2 = Object.keys(graph);
  for (let { length } = models2, i = 0; i < length; i++) {
    const toModel = models2[i];
    const node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
}
var route_default = route;

// node_modules/color/node_modules/color-convert/index.js
var convert2 = {};
var models = Object.keys(conversions_default);
function wrapRaw(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result = fn(args);
    if (typeof result === "object") {
      for (let { length } = result, i = 0; i < length; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
for (const fromModel of models) {
  convert2[fromModel] = {};
  Object.defineProperty(convert2[fromModel], "channels", { value: conversions_default[fromModel].channels });
  Object.defineProperty(convert2[fromModel], "labels", { value: conversions_default[fromModel].labels });
  const routes = route_default(fromModel);
  const routeModels = Object.keys(routes);
  for (const toModel of routeModels) {
    const fn = routes[toModel];
    convert2[fromModel][toModel] = wrapRounded(fn);
    convert2[fromModel][toModel].raw = wrapRaw(fn);
  }
}
var color_convert_default = convert2;

// node_modules/color/index.js
var skippedModels = [
  // To be honest, I don't really feel like keyword belongs in color convert, but eh.
  "keyword",
  // Gray conflicts with some method names, and has its own method defined.
  "gray",
  // Shouldn't really be in color-convert either...
  "hex"
];
var hashedModelKeys = {};
for (const model of Object.keys(color_convert_default)) {
  hashedModelKeys[[...color_convert_default[model].labels].sort().join("")] = model;
}
var limiters = {};
function Color(object, model) {
  if (!(this instanceof Color)) {
    return new Color(object, model);
  }
  if (model && model in skippedModels) {
    model = null;
  }
  if (model && !(model in color_convert_default)) {
    throw new Error("Unknown model: " + model);
  }
  let i;
  let channels;
  if (object == null) {
    this.model = "rgb";
    this.color = [0, 0, 0];
    this.valpha = 1;
  } else if (object instanceof Color) {
    this.model = object.model;
    this.color = [...object.color];
    this.valpha = object.valpha;
  } else if (typeof object === "string") {
    const result = color_string_default.get(object);
    if (result === null) {
      throw new Error("Unable to parse color from string: " + object);
    }
    this.model = result.model;
    channels = color_convert_default[this.model].channels;
    this.color = result.value.slice(0, channels);
    this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
  } else if (object.length > 0) {
    this.model = model || "rgb";
    channels = color_convert_default[this.model].channels;
    const newArray = Array.prototype.slice.call(object, 0, channels);
    this.color = zeroArray(newArray, channels);
    this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
  } else if (typeof object === "number") {
    this.model = "rgb";
    this.color = [
      object >> 16 & 255,
      object >> 8 & 255,
      object & 255
    ];
    this.valpha = 1;
  } else {
    this.valpha = 1;
    const keys = Object.keys(object);
    if ("alpha" in object) {
      keys.splice(keys.indexOf("alpha"), 1);
      this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
    }
    const hashedKeys = keys.sort().join("");
    if (!(hashedKeys in hashedModelKeys)) {
      throw new Error("Unable to parse color from object: " + JSON.stringify(object));
    }
    this.model = hashedModelKeys[hashedKeys];
    const { labels } = color_convert_default[this.model];
    const color = [];
    for (i = 0; i < labels.length; i++) {
      color.push(object[labels[i]]);
    }
    this.color = zeroArray(color);
  }
  if (limiters[this.model]) {
    channels = color_convert_default[this.model].channels;
    for (i = 0; i < channels; i++) {
      const limit = limiters[this.model][i];
      if (limit) {
        this.color[i] = limit(this.color[i]);
      }
    }
  }
  this.valpha = Math.max(0, Math.min(1, this.valpha));
  if (Object.freeze) {
    Object.freeze(this);
  }
}
Color.prototype = {
  toString() {
    return this.string();
  },
  toJSON() {
    return this[this.model]();
  },
  string(places) {
    let self = this.model in color_string_default.to ? this : this.rgb();
    self = self.round(typeof places === "number" ? places : 1);
    const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];
    return color_string_default.to[self.model](...arguments_);
  },
  percentString(places) {
    const self = this.rgb().round(typeof places === "number" ? places : 1);
    const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];
    return color_string_default.to.rgb.percent(...arguments_);
  },
  array() {
    return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
  },
  object() {
    const result = {};
    const { channels } = color_convert_default[this.model];
    const { labels } = color_convert_default[this.model];
    for (let i = 0; i < channels; i++) {
      result[labels[i]] = this.color[i];
    }
    if (this.valpha !== 1) {
      result.alpha = this.valpha;
    }
    return result;
  },
  unitArray() {
    const rgb = this.rgb().color;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;
    if (this.valpha !== 1) {
      rgb.push(this.valpha);
    }
    return rgb;
  },
  unitObject() {
    const rgb = this.rgb().object();
    rgb.r /= 255;
    rgb.g /= 255;
    rgb.b /= 255;
    if (this.valpha !== 1) {
      rgb.alpha = this.valpha;
    }
    return rgb;
  },
  round(places) {
    places = Math.max(places || 0, 0);
    return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
  },
  alpha(value) {
    if (value !== void 0) {
      return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
    }
    return this.valpha;
  },
  // Rgb
  red: getset("rgb", 0, maxfn(255)),
  green: getset("rgb", 1, maxfn(255)),
  blue: getset("rgb", 2, maxfn(255)),
  hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
  saturationl: getset("hsl", 1, maxfn(100)),
  lightness: getset("hsl", 2, maxfn(100)),
  saturationv: getset("hsv", 1, maxfn(100)),
  value: getset("hsv", 2, maxfn(100)),
  chroma: getset("hcg", 1, maxfn(100)),
  gray: getset("hcg", 2, maxfn(100)),
  white: getset("hwb", 1, maxfn(100)),
  wblack: getset("hwb", 2, maxfn(100)),
  cyan: getset("cmyk", 0, maxfn(100)),
  magenta: getset("cmyk", 1, maxfn(100)),
  yellow: getset("cmyk", 2, maxfn(100)),
  black: getset("cmyk", 3, maxfn(100)),
  x: getset("xyz", 0, maxfn(95.047)),
  y: getset("xyz", 1, maxfn(100)),
  z: getset("xyz", 2, maxfn(108.833)),
  l: getset("lab", 0, maxfn(100)),
  a: getset("lab", 1),
  b: getset("lab", 2),
  keyword(value) {
    if (value !== void 0) {
      return new Color(value);
    }
    return color_convert_default[this.model].keyword(this.color);
  },
  hex(value) {
    if (value !== void 0) {
      return new Color(value);
    }
    return color_string_default.to.hex(...this.rgb().round().color);
  },
  hexa(value) {
    if (value !== void 0) {
      return new Color(value);
    }
    const rgbArray = this.rgb().round().color;
    let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
    if (alphaHex.length === 1) {
      alphaHex = "0" + alphaHex;
    }
    return color_string_default.to.hex(...rgbArray) + alphaHex;
  },
  rgbNumber() {
    const rgb = this.rgb().color;
    return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
  },
  luminosity() {
    const rgb = this.rgb().color;
    const lum = [];
    for (const [i, element] of rgb.entries()) {
      const chan = element / 255;
      lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
    }
    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },
  contrast(color2) {
    const lum1 = this.luminosity();
    const lum2 = color2.luminosity();
    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }
    return (lum2 + 0.05) / (lum1 + 0.05);
  },
  level(color2) {
    const contrastRatio = this.contrast(color2);
    if (contrastRatio >= 7) {
      return "AAA";
    }
    return contrastRatio >= 4.5 ? "AA" : "";
  },
  isDark() {
    const rgb = this.rgb().color;
    const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
    return yiq < 128;
  },
  isLight() {
    return !this.isDark();
  },
  negate() {
    const rgb = this.rgb();
    for (let i = 0; i < 3; i++) {
      rgb.color[i] = 255 - rgb.color[i];
    }
    return rgb;
  },
  lighten(ratio) {
    const hsl = this.hsl();
    hsl.color[2] += hsl.color[2] * ratio;
    return hsl;
  },
  darken(ratio) {
    const hsl = this.hsl();
    hsl.color[2] -= hsl.color[2] * ratio;
    return hsl;
  },
  saturate(ratio) {
    const hsl = this.hsl();
    hsl.color[1] += hsl.color[1] * ratio;
    return hsl;
  },
  desaturate(ratio) {
    const hsl = this.hsl();
    hsl.color[1] -= hsl.color[1] * ratio;
    return hsl;
  },
  whiten(ratio) {
    const hwb = this.hwb();
    hwb.color[1] += hwb.color[1] * ratio;
    return hwb;
  },
  blacken(ratio) {
    const hwb = this.hwb();
    hwb.color[2] += hwb.color[2] * ratio;
    return hwb;
  },
  grayscale() {
    const rgb = this.rgb().color;
    const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    return Color.rgb(value, value, value);
  },
  fade(ratio) {
    return this.alpha(this.valpha - this.valpha * ratio);
  },
  opaquer(ratio) {
    return this.alpha(this.valpha + this.valpha * ratio);
  },
  rotate(degrees) {
    const hsl = this.hsl();
    let hue = hsl.color[0];
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    hsl.color[0] = hue;
    return hsl;
  },
  mix(mixinColor, weight) {
    if (!mixinColor || !mixinColor.rgb) {
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    }
    const color1 = mixinColor.rgb();
    const color2 = this.rgb();
    const p = weight === void 0 ? 0.5 : weight;
    const w2 = 2 * p - 1;
    const a = color1.alpha() - color2.alpha();
    const w1 = ((w2 * a === -1 ? w2 : (w2 + a) / (1 + w2 * a)) + 1) / 2;
    const w22 = 1 - w1;
    return Color.rgb(
      w1 * color1.red() + w22 * color2.red(),
      w1 * color1.green() + w22 * color2.green(),
      w1 * color1.blue() + w22 * color2.blue(),
      color1.alpha() * p + color2.alpha() * (1 - p)
    );
  }
};
for (const model of Object.keys(color_convert_default)) {
  if (skippedModels.includes(model)) {
    continue;
  }
  const { channels } = color_convert_default[model];
  Color.prototype[model] = function(...arguments_) {
    if (this.model === model) {
      return new Color(this);
    }
    if (arguments_.length > 0) {
      return new Color(arguments_, model);
    }
    return new Color([...assertArray(color_convert_default[this.model][model].raw(this.color)), this.valpha], model);
  };
  Color[model] = function(...arguments_) {
    let color = arguments_[0];
    if (typeof color === "number") {
      color = zeroArray(arguments_, channels);
    }
    return new Color(color, model);
  };
}
function roundTo(number, places) {
  return Number(number.toFixed(places));
}
function roundToPlace(places) {
  return function(number) {
    return roundTo(number, places);
  };
}
function getset(model, channel, modifier) {
  model = Array.isArray(model) ? model : [model];
  for (const m of model) {
    (limiters[m] || (limiters[m] = []))[channel] = modifier;
  }
  model = model[0];
  return function(value) {
    let result;
    if (value !== void 0) {
      if (modifier) {
        value = modifier(value);
      }
      result = this[model]();
      result.color[channel] = value;
      return result;
    }
    result = this[model]().color[channel];
    if (modifier) {
      result = modifier(result);
    }
    return result;
  };
}
function maxfn(max) {
  return function(v) {
    return Math.max(0, Math.min(max, v));
  };
}
function assertArray(value) {
  return Array.isArray(value) ? value : [value];
}
function zeroArray(array, length) {
  for (let i = 0; i < length; i++) {
    if (typeof array[i] !== "number") {
      array[i] = 0;
    }
  }
  return array;
}
var color_default = Color;

// node_modules/@esri/calcite-components/dist/chunks/utils4.js
var w = {
  channel: "channel",
  channels: "channels",
  colorField: "color-field",
  colorFieldScope: "scope--color-field",
  colorMode: "color-mode",
  colorModeContainer: "color-mode-container",
  container: "container",
  control: "control",
  controlAndScope: "control-and-scope",
  controlSection: "control-section",
  deleteColor: "delete-color",
  header: "header",
  hexAndChannelsGroup: "hex-and-channels-group",
  hexOptions: "color-hex-options",
  hueScope: "scope--hue",
  hueSlider: "hue-slider",
  opacityScope: "scope--opacity",
  opacitySlider: "opacity-slider",
  preview: "preview",
  previewAndSliders: "preview-and-sliders",
  saveColor: "save-color",
  savedColor: "saved-color",
  savedColors: "saved-colors",
  savedColorsButtons: "saved-colors-buttons",
  savedColorsSection: "saved-colors-section",
  scope: "scope",
  section: "section",
  slider: "slider",
  sliders: "sliders",
  splitSection: "section--split"
};
var y = color_default("#007AC2");
var z = "calcite-color-";
var X = {
  r: 255,
  g: 255,
  b: 255
};
var B = {
  h: 360,
  s: 100,
  v: 100
};
var N = B.h - 1;
var O = {
  min: 0,
  max: 100
};
var G = {
  s: {
    gap: parseInt(e),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 20
    },
    minWidth: 200
  },
  m: {
    gap: parseInt(n),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 24
    },
    minWidth: 240
  },
  l: {
    gap: parseInt(s),
    slider: {
      height: 12
    },
    thumb: {
      radius: 7
    },
    preview: {
      size: 32
    },
    minWidth: 304
  }
};
var P = 1;
var D = /^[0-9A-F]$/i;
var E = /^#[0-9A-F]{3}$/i;
var M = /^#[0-9A-F]{6}$/i;
var $ = /^#[0-9A-F]{4}$/i;
var x = /^#[0-9A-F]{8}$/i;
var U = (t) => Number((t * 100).toFixed());
var q = (t) => Number((t / 100).toFixed(2));
function C(t, n2 = false) {
  return h(t, n2) || F(t, n2);
}
function g(t, n2, r) {
  return t ? t.length === n2 && r.test(t) : false;
}
function h(t, n2 = false) {
  return g(t, n2 ? 5 : 4, n2 ? $ : E);
}
function F(t, n2 = false) {
  return g(t, n2 ? 9 : 7, n2 ? x : M);
}
function Y(t, n2 = false, r = false) {
  if (t = t.toLowerCase(), t.startsWith("#") || (t = `#${t}`), h(t, n2))
    return A(H(t, n2));
  if (n2 && r && C(
    t,
    false
    /* we only care about RGB hex for conversion */
  )) {
    const i = h(t, false);
    return A(H(`${t}${i ? "f" : "ff"}`, true));
  }
  return t;
}
function j(t, n2 = false) {
  return n2 ? t.hexa() : t.hex();
}
function A(t) {
  const { r: n2, g: r, b: i } = t, o = S(n2), a = S(r), d = S(i), l = "a" in t ? S(t.a * 255) : "";
  return `#${o}${a}${d}${l}`.toLowerCase();
}
function S(t) {
  return t.toString(16).padStart(2, "0");
}
function k(t) {
  const n2 = {
    ...t,
    a: t.alpha ?? 1
    /* Color() will omit alpha if 1 */
  };
  return delete n2.alpha, n2;
}
function K(t) {
  const n2 = { ...t, alpha: t.a ?? 1 };
  return delete n2.a, n2;
}
function H(t, n2 = false) {
  if (!C(t, n2))
    return null;
  t = t.replace("#", "");
  let r, i, o, a;
  if (t.length === 3 || t.length === 4) {
    const [l, p, f, u] = t.split("");
    r = parseInt(`${l}${l}`, 16), i = parseInt(`${p}${p}`, 16), o = parseInt(`${f}${f}`, 16), a = parseInt(`${u}${u}`, 16) / 255;
  } else
    r = parseInt(t.slice(0, 2), 16), i = parseInt(t.slice(2, 4), 16), o = parseInt(t.slice(4, 6), 16), a = parseInt(t.slice(6, 8), 16) / 255;
  return isNaN(a) ? { r, g: i, b: o } : { r, g: i, b: o, a };
}
var L = (t) => t;
var e2 = L({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css"
});
var s2 = L({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva"
});
function Z(t) {
  if (typeof t == "string") {
    if (t.startsWith("#")) {
      const { length: n2 } = t;
      if (n2 === 4 || n2 === 7)
        return e2.HEX;
      if (n2 === 5 || n2 === 9)
        return e2.HEXA;
    }
    if (t.startsWith("rgba("))
      return e2.RGBA_CSS;
    if (t.startsWith("rgb("))
      return e2.RGB_CSS;
    if (t.startsWith("hsl("))
      return e2.HSL_CSS;
    if (t.startsWith("hsla("))
      return e2.HSLA_CSS;
  }
  if (typeof t == "object") {
    if (c(t, "r", "g", "b"))
      return c(t, "a") ? s2.RGBA : s2.RGB;
    if (c(t, "h", "s", "l"))
      return c(t, "a") ? s2.HSLA : s2.HSL;
    if (c(t, "h", "s", "v"))
      return c(t, "a") ? s2.HSVA : s2.HSV;
  }
  return null;
}
function c(t, ...n2) {
  return n2.every((r) => r && t && `${r}` in t);
}
function J(t, n2) {
  return (t == null ? void 0 : t.rgb().array().toString()) === (n2 == null ? void 0 : n2.rgb().array().toString());
}
function Q(t) {
  return t === e2.HEXA || t === e2.RGBA_CSS || t === e2.HSLA_CSS || t === s2.RGBA || t === s2.HSLA || t === s2.HSVA;
}
function V(t) {
  return t === e2.HEX ? e2.HEXA : t === e2.RGB_CSS ? e2.RGBA_CSS : t === e2.HSL_CSS ? e2.HSLA_CSS : t === s2.RGB ? s2.RGBA : t === s2.HSL ? s2.HSLA : t === s2.HSV ? s2.HSVA : t;
}
function tt(t) {
  return t === e2.HEXA ? e2.HEX : t === e2.RGBA_CSS ? e2.RGB_CSS : t === e2.HSLA_CSS ? e2.HSL_CSS : t === s2.RGBA ? s2.RGB : t === s2.HSLA ? s2.HSL : t === s2.HSVA ? s2.HSV : t;
}
var T = 1;
var _ = T * 2;
function nt(t, n2, r) {
  const i = r ? G.l.preview.size : n2.preview.size, o = t - _, a = n2.gap * 3;
  return Math.max(o - a - i, 0);
}
function et(t) {
  const r = t - _;
  return {
    width: Math.max(r, 0),
    height: Math.max(Math.floor(r / 1.8), 0)
  };
}

export {
  color_default,
  w,
  y,
  z,
  X,
  B,
  N,
  O,
  G,
  P,
  D,
  U,
  q,
  C,
  h,
  F,
  Y,
  j,
  A,
  k,
  K,
  H,
  e2 as e,
  Z,
  J,
  Q,
  V,
  tt,
  nt,
  et
};
/*! Bundled license information:

@esri/calcite-components/dist/chunks/utils4.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=chunk-R3C42XIH.js.map
