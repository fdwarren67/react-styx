import {
  p as p3,
  t
} from "./chunk-XBF3Q5CM.js";
import {
  x
} from "./chunk-BSQH3I7W.js";
import {
  o as o3
} from "./chunk-PHUXOQ5V.js";
import {
  C as C2
} from "./chunk-RMOE6XHW.js";
import {
  m as m2
} from "./chunk-QAXPIBME.js";
import {
  te
} from "./chunk-XZDT5RTS.js";
import {
  l,
  p
} from "./chunk-DJ5HVIE7.js";
import {
  p as p2
} from "./chunk-RO66CZDO.js";
import {
  b,
  j
} from "./chunk-KMVZXZBR.js";
import {
  u
} from "./chunk-7HSZJLYU.js";
import {
  a as a5
} from "./chunk-RPPIM555.js";
import {
  q
} from "./chunk-I3JB2EVB.js";
import {
  g
} from "./chunk-TCV7UF6X.js";
import {
  a as a4
} from "./chunk-SPVEONZ2.js";
import {
  y
} from "./chunk-KGTLNUPW.js";
import {
  C,
  d
} from "./chunk-UKY33OJN.js";
import {
  r as r3
} from "./chunk-K7TZXQ7O.js";
import {
  o as o2
} from "./chunk-FZPO5AYT.js";
import {
  o
} from "./chunk-FSFEOCO5.js";
import {
  r as r2
} from "./chunk-ZVIMKAJW.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a3
} from "./chunk-BM4B3CH5.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import {
  a as a2
} from "./chunk-7LCEUMDD.js";
import {
  a,
  e,
  n2 as n
} from "./chunk-6II7WQ2F.js";
import {
  has
} from "./chunk-L7QO6TDW.js";

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p4 = class extends a4.ClonableMixin(S) {
  constructor(o5) {
    super(o5), this.expression = null, this.title = null, this.returnType = null;
  }
};
r([m({ type: String, json: { write: true } })], p4.prototype, "expression", void 0), r([m({ type: String, json: { write: true } })], p4.prototype, "title", void 0), r([m({ type: String, json: { write: true } })], p4.prototype, "returnType", void 0), p4 = r([a3("esri.layers.support.ExpressionInfo")], p4);
var i = p4;

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p5;
var n2 = p5 = class extends S {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p5({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
r([m({ type: Boolean, json: { write: true } })], n2.prototype, "isAutoGenerated", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "name", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "alias", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "onStatisticField", void 0), r([m({ type: i, json: { write: true } })], n2.prototype, "onStatisticExpression", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "statisticType", void 0), n2 = p5 = r([a3("esri.layers.support.AggregateField")], n2);
var a6 = n2;

// node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var j2;
var v = j2 = class extends t {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o2("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e2, r4, o5) {
    const i2 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(o5, i2, r4);
  }
  readRenderer(e2, r4, o5) {
    var _a;
    const t2 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    return t2 ? o3(t2, r4, o5) ?? void 0 : te(r4, o5);
  }
  clone() {
    return new j2({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer), binType: a(this.binType), size: this.size });
  }
};
r([r3({ binning: "binning" })], v.prototype, "type", void 0), r([r3({ geohash: "geohash", square: "square" }), m({ type: ["geohash", "square"] })], v.prototype, "binType", void 0), r([m({ type: Number, json: { write: true } })], v.prototype, "fixedBinLevel", void 0), r([m({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], v.prototype, "labelingInfo", void 0), r([m(p)], v.prototype, "labelsVisible", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], v.prototype, "maxScale", void 0), r([m(l)], v.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], v.prototype, "popupTemplate", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)) })], v.prototype, "size", void 0), r([m({ type: [a6], json: { write: true } })], v.prototype, "fields", void 0), r([r2("fields")], v.prototype, "writeFields", null), r([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], v.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], v.prototype, "readRenderer", null), v = j2 = r([a3("esri.layers.support.FeatureReductionBinning")], v);
var w = v;

// node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var S2;
function w2(e2) {
  var _a;
  return "simple" === e2.type && !((_a = e2.visualVariables) == null ? void 0 : _a.length);
}
var I = S2 = class extends S {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o2("80px"), this.clusterMinSize = o2("12px"), this.clusterMaxSize = o2("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e2, r4, t2) {
    var _a, _b;
    const o5 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    return ((_b = o5 == null ? void 0 : o5.authoringInfo) == null ? void 0 : _b.isAutoGenerated) ? null : o5 ? w2(o5) ? null : o3(o5, r4, t2) ?? void 0 : te(r4, t2);
  }
  readSymbol(e2, r4, t2) {
    var _a, _b;
    const o5 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    if ((_b = o5 == null ? void 0 : o5.authoringInfo) == null ? void 0 : _b.isAutoGenerated) return null;
    if (o5 && w2(o5)) {
      const e3 = o3(o5, r4, t2);
      return e3 == null ? void 0 : e3.symbol;
    }
    return null;
  }
  writeSymbol(e2, r4, t2, o5) {
    var _a, _b;
    const s2 = (_b = (_a = this.renderer) == null ? void 0 : _a.authoringInfo) == null ? void 0 : _b.isAutoGenerated;
    if (!this.renderer || s2) {
      const t3 = new p2({ symbol: e2 });
      r4.drawingInfo = { renderer: t3.write({}, o5) };
    }
  }
  writeFields(e2, r4, t2) {
    const o5 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(t2, o5, r4);
  }
  readFields(e2, r4, t2) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => a6.fromJSON(e3));
  }
  clone() {
    return new S2({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
r([m({ type: ["cluster"], readOnly: true, json: { write: true } })], I.prototype, "type", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)), json: { write: true } })], I.prototype, "clusterRadius", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMinSize", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMaxSize", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], I.prototype, "maxScale", void 0), r([m(l)], I.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], I.prototype, "popupTemplate", void 0), r([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], I.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], I.prototype, "readRenderer", null), r([m({ types: g })], I.prototype, "symbol", void 0), r([o("symbol", ["drawingInfo.renderer"])], I.prototype, "readSymbol", null), r([r2("symbol")], I.prototype, "writeSymbol", null), r([m({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], I.prototype, "labelingInfo", void 0), r([m(p)], I.prototype, "labelsVisible", void 0), r([m({ type: [a6], json: { write: true } })], I.prototype, "fields", void 0), r([r2("fields")], I.prototype, "writeFields", null), r([o("fields")], I.prototype, "readFields", null), I = S2 = r([a3("esri.layers.support.FeatureReductionCluster")], I);
var v2 = I;

// node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o4 = { key: "type", base: t, typeMap: { cluster: v2, binning: w } };
var p6 = { types: { key: "type", base: t, typeMap: { selection: p3, cluster: v2, binning: w } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o4 }, "portal-item": { types: o4 }, "web-scene": { types: { key: "type", base: t, typeMap: { selection: p3 } }, name: "layerDefinition.featureReduction", write: { layerContainerTypes: a5 } } } } };

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l2 = () => n.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u2 = has("esri-cluster-arcade-enabled");
var p7 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d2(e2, r4) {
  let s2 = r4.clone();
  if (!m3(s2)) return s2;
  if (r4.symbols.some((e3) => p7.has(e3.type)) && (s2 = new p2({ symbol: new y() })), s2.authoringInfo || (s2.authoringInfo = new j()), s2.authoringInfo.isAutoGenerated = true, "visualVariables" in s2) {
    const r5 = (s2.visualVariables || []).filter((e3) => "$view.scale" !== e3.valueExpression);
    r5.forEach((r6) => {
      "rotation" === r6.type ? r6.field ? r6.field = v3(e2, r6.field, "avg_angle", "number") : r6.valueExpression && (r6.field = c(e2, r6.valueExpression, "avg_angle", "number"), r6.valueExpression = null) : r6.normalizationField ? (r6.field = v3(e2, r6.field, "avg_norm", "number", r6.normalizationField), r6.normalizationField = null) : r6.field ? r6.field = v3(e2, r6.field, "avg", "number") : r6.valueExpression && (r6.field = c(e2, r6.valueExpression, "avg", "number"), r6.valueExpression = null);
    }), s2.visualVariables = r5;
  }
  switch (s2.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const r5 of s2.attributes) r5.field ? r5.field = v3(e2, r5.field, "sum", "number") : r5.valueExpression && (r5.field = c(e2, r5.valueExpression, "sum", "number"), r5.valueExpression = null);
      break;
    case "unique-value":
      s2.field ? s2.field = v3(e2, s2.field, "mode", "string") : s2.valueExpression && (s2.field = c(e2, s2.valueExpression, "mode", "string"), s2.valueExpression = null);
      break;
    case "class-breaks":
      s2.normalizationField ? (s2.field = v3(e2, s2.field, "avg_norm", "number", s2.normalizationField), s2.normalizationField = null) : s2.field ? s2.field = v3(e2, s2.field, "avg", "number") : s2.valueExpression && (s2.field = c(e2, s2.valueExpression, "avg", "number"), s2.valueExpression = null);
  }
  return s2;
}
var m3 = (r4) => {
  const s2 = (s3) => l2().error(new s("Unsupported-renderer", s3, { renderer: r4 }));
  if (!r4) return false;
  switch (r4.type) {
    case "unique-value":
      if (r4.field2 || r4.field3) return s2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (r4.normalizationField) {
        const e2 = r4.normalizationType;
        if ("field" !== e2) return s2(`FeatureReductionCluster does not support a normalizationType of ${e2}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return s2(`FeatureReductionCluster does not support renderers of type ${r4.type}`), false;
  }
  if (!u2) {
    if ("valueExpression" in r4 && r4.valueExpression) return s2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in r4 && r4.visualVariables || []).some((e2) => !(!("valueExpression" in e2) || !e2.valueExpression))) return s2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function f(e2, r4, i2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r4}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r4}`;
    case "mode":
      return `cluster_type_${r4}`;
    case "avg_norm": {
      const e3 = i2, n3 = "field", t2 = r4.toLowerCase() + ",norm:" + n3 + "," + e3.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function c(e2, r4, t2, a7) {
  const o5 = x(r4), l3 = "mode" === t2 ? `cluster_type_${o5}` : "sum" === t2 ? `cluster_sum_${o5}` : `cluster_avg_${o5}`;
  return e2.some((e3) => e3.name === l3) || e2.push(new a6({ name: l3, isAutoGenerated: true, onStatisticExpression: new i({ expression: r4, returnType: a7 }), statisticType: t2 })), l3;
}
function v3(e2, r4, s2, t2, a7) {
  if ("cluster_count" === r4 || e2.some((e3) => e3.name === r4)) return r4;
  const o5 = f(s2, r4, a7);
  return e2.some((e3) => e3.name === o5) || ("avg_norm" === s2 ? e2.push(new a6({ name: o5, isAutoGenerated: true, onStatisticExpression: new i({ expression: `$feature.${r4} / $feature.${a7}`, returnType: t2 }), statisticType: "avg" })) : e2.push(new a6({ name: o5, isAutoGenerated: true, onStatisticField: r4, statisticType: s2 }))), o5;
}

// node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var d3 = (d4) => {
  let f2 = class extends d4 {
    constructor(...e2) {
      super(...e2), this.addHandles(d(() => this.renderer, () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, C));
    }
    set featureReduction(e2) {
      const r4 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r4);
    }
    set renderer(e2) {
    }
    _withClusterVariable(e2, r4, t2) {
      const s2 = e2.clone();
      if ("visualVariables" in s2) {
        s2.visualVariables || (s2.visualVariables = []);
        s2.visualVariables.some((e3) => "size" === e3.type) || s2.visualVariables.push(new b({ field: "cluster_count", stops: [new u({ value: 1 }), new u({ useMinValue: true, size: r4 }), new u({ useMaxValue: true, size: t2 })] }));
      }
      return s2;
    }
    _normalizeFeatureReduction(e2) {
      var _a;
      if ("cluster" !== (e2 == null ? void 0 : e2.type)) return e2;
      const r4 = e2.clone(), t2 = [new a6({ name: "cluster_count", alias: "cluster_count", isAutoGenerated: true, statisticType: "count" })], s2 = (r4.fields ?? []).filter((e3) => !e3.isAutoGenerated), i2 = e2.renderer && !((_a = e2.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated), { clusterMinSize: o5, clusterMaxSize: n3 } = r4;
      if (i2) {
        r4.fields = [...t2, ...s2];
        const e3 = this._withClusterVariable(r4.renderer, o5, n3);
        return r4.effectiveFeatureRenderer = e3, r4.effectiveClusterRenderer = e3, r4;
      }
      if (e2.symbol) {
        if (r4.fields = [...t2, ...s2], r4.renderer = null, !this.renderer) return r4.effectiveFeatureRenderer = null, r4.effectiveClusterRenderer = null, r4;
        const i3 = d2(t2, this.renderer), a7 = this._withClusterVariable(i3, o5, n3), l4 = "visualVariables" in a7 && a7.visualVariables ? a7.visualVariables : [], d6 = new p2({ symbol: e2.symbol, visualVariables: l4 });
        return r4.fields = [...t2, ...s2], r4.effectiveFeatureRenderer = a7, r4.effectiveClusterRenderer = d6, r4;
      }
      if (!this.renderer) return e2;
      const l3 = d2(t2, this.renderer);
      r4.fields = [...t2, ...s2], r4.renderer = l3;
      const d5 = this._withClusterVariable(l3, o5, n3);
      return r4.effectiveFeatureRenderer = d5, r4.effectiveClusterRenderer = d5, r4;
    }
  };
  return r([m(p6)], f2.prototype, "featureReduction", null), f2 = r([a3("esri.layers.mixins.FeatureReductionLayer")], f2), f2;
};

export {
  a6 as a,
  p6 as p,
  d3 as d
};
//# sourceMappingURL=chunk-TRBU6WLM.js.map
