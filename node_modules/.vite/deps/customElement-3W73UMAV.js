import {
  repeat
} from "./chunk-G4USGCXL.js";
import {
  Q
} from "./chunk-ZHGVMVCT.js";
import {
  B,
  D,
  O,
  W
} from "./chunk-VLJE74YV.js";
import {
  T,
  v
} from "./chunk-YJUTXVD7.js";
import {
  m,
  p
} from "./chunk-VBBJGZOS.js";
import {
  keyed
} from "./chunk-KZXUV47B.js";
import "./chunk-A7MNUVGI.js";
import {
  m as m2
} from "./chunk-2GIEDWQ6.js";
import {
  ref
} from "./chunk-LTKIMXCE.js";
import {
  s
} from "./chunk-RZAGQ6CT.js";
import "./chunk-VQ5234AM.js";
import "./chunk-PXZ2RU65.js";
import "./chunk-S3EVYUV4.js";
import {
  S
} from "./chunk-B7E2AREE.js";
import {
  LitElement,
  createEvent,
  css,
  html,
  nothing,
  safeClassMap,
  stringOrBoolean
} from "./chunk-MALSDV7D.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@esri/calcite-components/dist/components/calcite-input-time-zone/customElement.js
var ee = {
  offset: "offset"
};
var te = 60;
function x(t) {
  return t.replace(":15", ".25").replace(":30", ".5").replace(":45", ".75").replace("âˆ’", "-");
}
function oe(t, e) {
  const o = O2(t, "en-US", e).replace("GMT", "");
  return o === "" ? 0 : Number(x(o)) * te;
}
function se() {
  return (/* @__PURE__ */ new Date()).getTimezoneOffset() * -1;
}
function ae() {
  return new Intl.DateTimeFormat().resolvedOptions().timeZone;
}
async function ie(t) {
  if (t === "offset")
    return (o) => o;
  const { normalize: e } = await import("./time-zones-A3YD2FG3.js");
  return e;
}
async function ne(t, e, o, s2, n) {
  if (o === "name") {
    const { groupByName: a } = await import("./groupByName-JWICB7R5.js");
    return (await a()).map(({ label: i }) => ({
      label: i,
      value: i,
      metadata: {
        filterValue: i
      }
    })).filter((i) => !!i).sort();
  }
  const r = n === "user" ? t : (
    // we use locales that will always yield a short offset that matches `standardTime`
    n === "utc" ? "fr" : "en-GB"
  ), f = s2.getTime();
  if (o === "region") {
    const [{ groupByRegion: a }, { getCountry: c, global: i }] = await Promise.all([
      import("./groupByRegion-OS6LFHLY.js"),
      import("./region-LQ4NMAAB.js")
    ]);
    return (await a()).map(({ label: m3, tzs: u }) => (u.sort((h, d) => {
      const T2 = I(h, e), C = I(d, e), p2 = "Etc/GMT";
      if (h.startsWith(p2) && d.startsWith(p2)) {
        const b = h.substring(p2.length), F = d.substring(p2.length), E = b === "" ? 0 : parseInt(b);
        return (F === "" ? 0 : parseInt(F)) - E;
      }
      return T2.localeCompare(C);
    }), {
      label: $(e, m3),
      items: u.map((h) => {
        const d = x(
          O2(h, r, f)
        ), T2 = I(h, e), C = m3 === i ? (
          // we rely on the label for search since GMT items have their signs inverted (see https://en.wikipedia.org/wiki/Tz_database#Area)
          // in addition to the label we also add "Global" and "Etc" to allow searching for these items
          `${I(i, e)} Etc`
        ) : D2(h), p2 = c(h), b = $(e, p2);
        return {
          label: T2,
          value: h,
          metadata: {
            country: b === T2 ? void 0 : b,
            filterValue: C,
            offset: d
          }
        };
      })
    })).sort(
      (m3, u) => m3.label === i ? -1 : u.label === i ? 1 : m3.label.localeCompare(u.label)
    );
  }
  const [{ groupByOffset: y }, { DateEngine: P }] = await Promise.all([
    import("./groupByOffset-VNERBG74.js"),
    import("./native-2VBABJ3A.js")
  ]), w = await y({
    dateEngine: new P(),
    groupDateRange: 1,
    startDate: new Date(f).toISOString()
  }), z = new Intl.ListFormat(t, { style: "long", type: "conjunction" }), S2 = ["Factory", "Etc/UTC"];
  return w.forEach((a) => {
    const c = [];
    let i = 0;
    a.tzs.forEach((l, m3) => {
      S2.includes(l) && i++, c[m3] = i;
    }), a.tzs = a.tzs.filter((l) => !S2.includes(l)), a.labelTzIdx = a.labelTzIdx.map((l) => l - c[l]).filter((l) => l >= 0 && l < a.tzs.length);
  }), w.map(({ labelTzIdx: a, tzs: c }) => {
    const i = c[0], l = x(
      O2(i, r, f)
    ), m3 = oe(i, f), u = a.map((d) => I(c[d], e));
    return {
      label: ce(e, l, z.format(u)),
      value: m3,
      metadata: {
        filterValue: c.map((d) => D2(d))
      }
    };
  }).filter((a) => !!a).sort((a, c) => a.value - c.value);
}
function I(t, e) {
  return e[t] || re(t);
}
function le(t, e, o) {
  return o.timeZoneRegionLabel.replace("{city}", t).replace("{country}", $(o, e));
}
function $(t, e) {
  return t[e] || e;
}
function re(t) {
  return t.split("/").pop();
}
function D2(t) {
  return t.replace(/_/g, " ");
}
function ce(t, e, o) {
  return t.timeZoneLabel.replace("{offset}", e).replace("{cities}", o);
}
function O2(t, e, o = Date.now()) {
  return t === "Factory" && (t = "Etc/GMT"), Q(e, { timeZone: t, timeZoneName: "shortOffset" }).formatToParts(o).find(({ type: r }) => r === "timeZoneName").value;
}
function me(t) {
  return t.items !== void 0;
}
function he(t) {
  return me(t[0]) ? t.flatMap((e) => e.items) : t;
}
function B2(t, e, o) {
  return o == null ? null : he(t).find(
    (s2) => (
      // intentional == to match string to number
      s2[e] == o
    )
  );
}
var de = css`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:block}.offset{white-space:nowrap}:host([hidden]){display:none}[hidden]{display:none}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}::slotted(input[slot=hidden-form-input]){margin:0!important;opacity:0!important;outline:none!important;padding:0!important;position:absolute!important;inset:0!important;transform:none!important;-webkit-appearance:none!important;z-index:-1!important}`;
var _fe = class _fe extends LitElement {
  constructor() {
    super(...arguments), this.clearable = false, this.disabled = false, this.maxItems = 0, this.messages = s({ blocking: true }), this.mode = "offset", this.offsetStyle = "user", this.open = false, this.overlayPositioning = "absolute", this.readOnly = false, this.required = false, this.scale = "m", this.status = "idle", this.validity = {
      valid: false,
      badInput: false,
      customError: false,
      patternMismatch: false,
      rangeOverflow: false,
      rangeUnderflow: false,
      stepMismatch: false,
      tooLong: false,
      tooShort: false,
      typeMismatch: false,
      valueMissing: false
    }, this.calciteInputTimeZoneBeforeClose = createEvent({ cancelable: false }), this.calciteInputTimeZoneBeforeOpen = createEvent({ cancelable: false }), this.calciteInputTimeZoneChange = createEvent({ cancelable: false }), this.calciteInputTimeZoneClose = createEvent({ cancelable: false }), this.calciteInputTimeZoneOpen = createEvent({ cancelable: false });
  }
  /**
   * The component's value, where the value is the time zone offset or the difference, in minutes, between the selected time zone and UTC.
   *
   * If no value is provided, the user's time zone offset will be selected by default.
   *
   * @see [Identifying time zones and zone offsets](https://www.w3.org/International/core/2005/09/timezone.html#:~:text=What%20is%20a%20%22zone%20offset,or%20%22%2D%22%20from%20UTC).
   */
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e;
  }
  // #endregion
  // #region Public Methods
  /** Sets focus on the component. */
  async setFocus() {
    await m2(this), await this.comboboxEl.setFocus();
  }
  // #endregion
  // #region Lifecycle
  connectedCallback() {
    super.connectedCallback(), D(this), v(this);
  }
  async load() {
    this.normalizer = await ie(this.mode), await this.updateTimeZoneItems();
    const e = this.value, o = this.normalizeValue(e);
    this.value = o || (e === "" ? o : void 0), this.updateTimeZoneSelection();
    const s2 = this.selectedTimeZoneItem ? `${this.selectedTimeZoneItem.value}` : "";
    O(this, s2), this.value = s2;
  }
  willUpdate(e) {
    e.has("value") && this.hasUpdated && this.handleValueChange(this.value, e.get("value")), (e.has("messages") || e.has("mode") && (this.hasUpdated || this.mode !== "offset") || e.has("referenceDate")) && this.handleTimeZoneItemPropsChange(), e.has("open") && (this.hasUpdated || this.open !== false) && this.openChanged();
  }
  updated() {
    m(this);
  }
  loaded() {
    this.overrideSelectedLabelForRegion(this.open), this.openChanged();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), W(this), T(this);
  }
  // #endregion
  // #region Private Methods
  async handleTimeZoneItemPropsChange() {
    !this.timeZoneItems || !this.hasUpdated || (await this.updateTimeZoneItems(), this.updateTimeZoneSelection());
  }
  openChanged() {
    this.comboboxEl && (this.comboboxEl.open = this.open);
  }
  async handleValueChange(e, o) {
    const s2 = this.normalizeValue(e);
    if (!s2) {
      if (this.clearable) {
        this._value = s2, this.selectedTimeZoneItem = null;
        return;
      }
      this._value = o, this.selectedTimeZoneItem = this.findTimeZoneItem(o);
      return;
    }
    const n = this.findTimeZoneItem(s2);
    if (!n) {
      this._value = o;
      return;
    }
    this._value = s2, this.selectedTimeZoneItem = n, s2 !== e && (await this.updateComplete, this.overrideSelectedLabelForRegion(this.open));
  }
  onLabelClick() {
    this.setFocus();
  }
  setComboboxRef(e) {
    this.comboboxEl = e;
  }
  /**
   * Helps override the selected item's label for region mode outside of item rendering logic to avoid flickering text change
   *
   * @param open
   * @private
   */
  overrideSelectedLabelForRegion(e) {
    if (this.mode !== "region" || !this.selectedTimeZoneItem)
      return;
    const { label: o, metadata: s2 } = this.selectedTimeZoneItem;
    this.comboboxEl.selectedItems[0].textLabel = !s2.country || e ? o : le(o, s2.country, this.messages);
  }
  onComboboxBeforeClose(e) {
    e.stopPropagation(), this.overrideSelectedLabelForRegion(false), this.calciteInputTimeZoneBeforeClose.emit();
  }
  onComboboxBeforeOpen(e) {
    e.stopPropagation(), this.overrideSelectedLabelForRegion(true), this.calciteInputTimeZoneBeforeOpen.emit();
  }
  onComboboxChange(e) {
    e.stopPropagation();
    const s2 = e.target.selectedItems[0];
    if (!s2) {
      this._value = "", this.selectedTimeZoneItem = null, this.calciteInputTimeZoneChange.emit();
      return;
    }
    const n = this.findTimeZoneItemByLabel(s2.getAttribute("data-label")), r = `${n.value}`;
    this.value === r && n.label === this.selectedTimeZoneItem.label || (this._value = r, this.selectedTimeZoneItem = n, this.calciteInputTimeZoneChange.emit());
  }
  onComboboxClose(e) {
    e.stopPropagation(), this.open = false, this.calciteInputTimeZoneClose.emit();
  }
  onComboboxOpen(e) {
    this.open = true, e.stopPropagation(), this.calciteInputTimeZoneOpen.emit();
  }
  findTimeZoneItem(e) {
    return B2(this.timeZoneItems, "value", e);
  }
  findTimeZoneItemByLabel(e) {
    return B2(this.timeZoneItems, "label", e);
  }
  async updateTimeZoneItems() {
    this.timeZoneItems = await this.createTimeZoneItems();
  }
  updateTimeZoneSelection() {
    if (this.value === "" && this.clearable) {
      this.selectedTimeZoneItem = null;
      return;
    }
    const e = this.mode === "offset" ? se() : ae(), o = this.value === "" || !this.value ? e : this.value;
    this.selectedTimeZoneItem = this.findTimeZoneItem(o) || this.findTimeZoneItem(e);
  }
  async createTimeZoneItems() {
    return !this.messages._lang || !this.messages ? [] : ne(this.messages._lang, this.messages, this.mode, this.referenceDate instanceof Date ? this.referenceDate : new Date(this.referenceDate ?? Date.now()), this.offsetStyle);
  }
  normalizeValue(e) {
    return e = e === void 0 ? "" : e, e && this.normalizer(e);
  }
  // #endregion
  // #region Rendering
  render() {
    return p({ disabled: this.disabled, children: html`<calcite-combobox .clearDisabled=${!this.clearable} .disabled=${this.disabled} .label=${this.messages.chooseTimeZone} lang=${this.messages._lang ?? nothing} .maxItems=${this.maxItems} @calciteComboboxBeforeClose=${this.onComboboxBeforeClose} @calciteComboboxBeforeOpen=${this.onComboboxBeforeOpen} @calciteComboboxChange=${this.onComboboxChange} @calciteComboboxClose=${this.onComboboxClose} @calciteComboboxOpen=${this.onComboboxOpen} .overlayPositioning=${this.overlayPositioning} .placeholder=${this.mode === "name" ? this.messages.namePlaceholder : this.mode === "offset" ? this.messages.offsetPlaceholder : this.messages.regionPlaceholder} placeholder-icon=search .readOnly=${this.readOnly} .scale=${this.scale} .selectionMode=${this.clearable ? "single" : "single-persist"} .status=${this.status} .validationIcon=${this.validationIcon} .validationMessage=${this.validationMessage} ${ref(this.setComboboxRef)}>${this.renderItems()}</calcite-combobox>${B({ component: this })}` });
  }
  renderItems() {
    return this.mode === "region" ? this.renderRegionItems() : repeat(this.timeZoneItems, ({ label: e }) => e, (e) => {
      const o = this.selectedTimeZoneItem === e, { label: s2, metadata: n, value: r } = e;
      return html`<calcite-combobox-item data-label=${s2 ?? nothing} .metadata=${n} .selected=${o} .textLabel=${s2} .value=${r}></calcite-combobox-item>`;
    });
  }
  renderRegionItems() {
    return this.timeZoneItems.flatMap(({ label: e, items: o }) => keyed(e, html`<calcite-combobox-item-group .label=${e}>${repeat(o, ({ label: s2 }) => s2, (s2) => {
      const n = this.selectedTimeZoneItem === s2, { label: r, metadata: f, value: y } = s2;
      return html`<calcite-combobox-item data-label=${r ?? nothing} .description=${f.country} .metadata=${f} .selected=${n} .textLabel=${r} .value=${y}><span class=${safeClassMap(ee.offset)} slot=content-end>${f.offset}</span></calcite-combobox-item>`;
    })}</calcite-combobox-item-group>`));
  }
};
_fe.properties = { clearable: 7, disabled: 7, form: 3, maxItems: 11, messageOverrides: 0, mode: 3, name: 3, offsetStyle: 3, open: 7, overlayPositioning: 3, readOnly: 7, referenceDate: 1, required: 7, scale: 3, status: 3, validationIcon: [3, { converter: stringOrBoolean }], validationMessage: 1, validity: 0, value: 1 };
_fe.shadowRootOptions = { mode: "open", delegatesFocus: true };
_fe.styles = de;
var fe = _fe;
S("calcite-input-time-zone", fe);
export {
  fe as InputTimeZone
};
/*! Bundled license information:

@esri/calcite-components/dist/components/calcite-input-time-zone/customElement.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=customElement-3W73UMAV.js.map
