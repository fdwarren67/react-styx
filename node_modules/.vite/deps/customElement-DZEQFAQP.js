import {
  g,
  m as m3,
  o
} from "./chunk-7KANSCZF.js";
import {
  B,
  G,
  J,
  K,
  N,
  O,
  P,
  Q,
  U,
  V,
  X,
  Y,
  Z,
  color_default,
  e,
  et,
  j,
  k,
  nt,
  q,
  tt,
  w,
  y,
  z
} from "./chunk-R3C42XIH.js";
import "./chunk-7LRZLRAB.js";
import {
  repeat
} from "./chunk-G4USGCXL.js";
import {
  m,
  p
} from "./chunk-VBBJGZOS.js";
import {
  throttle_default
} from "./chunk-F5MHH7JA.js";
import {
  keyed
} from "./chunk-KZXUV47B.js";
import {
  t
} from "./chunk-A7MNUVGI.js";
import {
  m as m2
} from "./chunk-2GIEDWQ6.js";
import {
  ref
} from "./chunk-LTKIMXCE.js";
import {
  s
} from "./chunk-RZAGQ6CT.js";
import {
  b
} from "./chunk-6JIDXA46.js";
import {
  It,
  gt,
  mt
} from "./chunk-VQ5234AM.js";
import "./chunk-PXZ2RU65.js";
import "./chunk-S3EVYUV4.js";
import {
  S
} from "./chunk-B7E2AREE.js";
import {
  LitElement,
  createEvent,
  css,
  html,
  nothing,
  safeClassMap,
  safeStyleMap
} from "./chunk-MALSDV7D.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@esri/calcite-components/dist/components/calcite-color-picker/customElement.js
var xe = css`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal);inline-size:var(--calcite-internal-color-picker-min-width);min-inline-size:var(--calcite-internal-color-picker-min-width)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}:host([scale=s]){--calcite-internal-color-picker-min-width: 200px;--calcite-color-picker-spacing: 8px}:host([scale=s]) .saved-colors{gap:.25rem;grid-template-columns:repeat(auto-fill,20px)}:host([scale=m]){--calcite-internal-color-picker-min-width: 240px;--calcite-color-picker-spacing: 12px}:host([scale=l]){--calcite-internal-color-picker-min-width: 304px;--calcite-color-picker-spacing: 16px;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]) .section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}:host([scale=l]) .saved-colors{grid-template-columns:repeat(auto-fill,32px)}:host([scale=l]) .control-section{display:flex;flex-direction:column;flex-wrap:wrap;align-items:baseline}:host([scale=l]) .color-hex-options{inline-size:100%;display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around}:host([scale=l]) .color-mode-container{flex-shrink:3}.container{background-color:var(--calcite-color-foreground-1);display:flex;flex-direction:column;block-size:min-content;border:1px solid var(--calcite-color-border-1)}.control-and-scope{position:relative;display:flex;cursor:pointer;touch-action:none}.color-field,.control-and-scope{-webkit-user-select:none;user-select:none}.scope{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);block-size:1px;inline-size:1px;border-radius:9999px;background-color:transparent;font-size:var(--calcite-font-size--1);outline-color:transparent}.scope:focus{outline:2px solid var(--calcite-color-focus, var(--calcite-ui-focus-color, var(--calcite-color-brand)));outline-offset:calc(2px*(1 - (2*clamp(0,var(--calcite-offset-invert-focus),1))));outline-offset:6px}.hex-and-channels-group{display:flex;inline-size:100%;flex-direction:column;flex-wrap:wrap}.section{padding-block:0 var(--calcite-color-picker-spacing);padding-inline:var(--calcite-color-picker-spacing)}.section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}.sliders{display:flex;flex-direction:column;justify-content:space-between;margin-inline-start:var(--calcite-color-picker-spacing);gap:var(--calcite-spacing-xxs)}.preview-and-sliders{display:flex;align-items:center;padding:var(--calcite-color-picker-spacing)}.color-hex-options,.section--split{flex-grow:1}.header{display:flex;align-items:center;justify-content:space-between;color:var(--calcite-color-text-1)}.color-mode-container{padding-block-start:var(--calcite-color-picker-spacing)}.channels{display:flex}.channel{flex-grow:1}.channel[data-channel-index="3"]{margin-inline-start:-1px;min-inline-size:81px}:host([scale=s]) .channel[data-channel-index="3"]{min-inline-size:68px}:host([scale=l]) .channel[data-channel-index="3"]{min-inline-size:88px}.saved-colors{display:grid;gap:.5rem;padding-block-start:var(--calcite-color-picker-spacing);grid-template-columns:repeat(auto-fill,24px)}.saved-colors-buttons{display:flex}.saved-color{outline-offset:0;outline-color:transparent;cursor:pointer}.saved-color:focus{outline:2px solid var(--calcite-color-brand);outline-offset:2px}.saved-color:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-color-border-2);outline-offset:2px}:host([hidden]){display:none}[hidden]{display:none}`;
var q2 = 16;
var _Ae = class _Ae extends LitElement {
  // #endregion
  // #region Lifecycle
  constructor() {
    super(), this._color = y, this.internalColorUpdateContext = null, this.isActiveChannelInputEmpty = false, this.mode = e.HEX, this.resizeObserver = b("resize", (e2) => this.resizeCanvas(e2)), this.shiftKeyChannelAdjustment = 0, this.upOrDownArrowKeyTracker = null, this._valueWasSet = false, this.channelMode = "rgb", this.channels = this.toChannels(y), this.staticDimensions = G.m, this.savedColors = [], this.allowEmpty = false, this.alphaChannel = false, this.channelsDisabled = false, this.clearable = false, this.disabled = false, this.format = "auto", this.hexDisabled = false, this.messages = s({ blocking: true }), this.savedDisabled = false, this.scale = "m", this.calciteColorPickerChange = createEvent({ cancelable: false }), this.calciteColorPickerInput = createEvent({ cancelable: false }), this.captureColorFieldColor = (e2, t2, i = true) => {
      const { width: o2, height: a } = this.dynamicDimensions.colorField, s2 = Math.round(B.s / o2 * e2), l = Math.round(B.v / a * (a - t2));
      this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(s2).value(l), i);
    }, this.drawColorControls = throttle_default((e2 = "all") => {
      (e2 === "all" || e2 === "color-field") && this.colorFieldRenderingContext && this.drawColorField(), (e2 === "all" || e2 === "hue-slider") && this.hueSliderRenderingContext && this.drawHueSlider(), this.alphaChannel && (e2 === "all" || e2 === "opacity-slider") && this.opacitySliderRenderingContext && this.drawOpacitySlider();
    }, q2), this.globalPointerMoveHandler = (e2) => {
      const { activeCanvasInfo: t2, el: i } = this;
      if (!i.isConnected || !t2)
        return;
      const { context: o2, bounds: a } = t2;
      let s2, l;
      const { clientX: r, clientY: h } = e2;
      o2.canvas.matches(":hover") ? (s2 = r - a.x, l = h - a.y) : (r < a.x + a.width && r > a.x ? s2 = r - a.x : r < a.x ? s2 = 0 : s2 = a.width, h < a.y + a.height && h > a.y ? l = h - a.y : h < a.y ? l = 0 : l = a.height), o2 === this.colorFieldRenderingContext ? this.captureColorFieldColor(s2, l, false) : o2 === this.hueSliderRenderingContext ? this.captureHueSliderColor(s2) : o2 === this.opacitySliderRenderingContext && this.captureOpacitySliderValue(s2);
    }, this.globalPointerUpHandler = (e2) => {
      if (!It(e2))
        return;
      const t2 = this.activeCanvasInfo;
      this.activeCanvasInfo = null, this.drawColorControls(), t2 && this.calciteColorPickerChange.emit();
    }, this.resizeCanvas = throttle_default((e2) => {
      if (!this.hasUpdated)
        return;
      const [t2] = e2, i = Math.floor(t2.contentBoxSize[0].inlineSize);
      this.dynamicDimensions.colorField.width !== i && (this.updateDynamicDimensions(i), this.updateCanvasSize(), this.drawColorControls());
    }, q2), this.updateDynamicDimensions = (e2) => {
      const t2 = {
        width: nt(e2, this.staticDimensions, this.alphaChannel),
        height: this.staticDimensions.slider.height
      };
      this.dynamicDimensions = {
        colorField: et(e2),
        slider: t2
      };
    }, this.listen("keydown", this.handleChannelKeyUpOrDown, { capture: true }), this.listen("keyup", this.handleChannelKeyUpOrDown, { capture: true });
  }
  get baseColorFieldColor() {
    return this.color || this.previousColor || y;
  }
  get effectiveSliderWidth() {
    return this.dynamicDimensions.slider.width;
  }
  /**
   * Internal prop for advanced use-cases.
   *
   * @private
   */
  get color() {
    return this._color;
  }
  set color(e2) {
    const t2 = this._color;
    this._color = e2, this.handleColorChange(e2, t2);
  }
  /**
   * The component's value, where the value can be a CSS color string, or a RGB, HSL or HSV object.
   *
   * The type will be preserved as the color is updated.
   *
   * @default
   *
   * @see [CSS Color](https://developer.mozilla.org/en-US/docs/Web/CSS/color),
   * @see [ColorValue](https://github.com/Esri/calcite-design-system/blob/dev/packages/calcite-components/src/components/color-picker/interfaces.ts#L10).
   */
  get value() {
    return this._value;
  }
  set value(e2) {
    const t2 = this._value;
    this._value = e2, this.handleValueChange(e2, t2), this._valueWasSet = true;
  }
  // #endregion
  // #region Public Methods
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await m2(this), mt(this.el);
  }
  connectedCallback() {
    super.connectedCallback(), this.observeResize();
  }
  async load() {
    this._valueWasSet || (this._value ?? (this._value = Y(j(y, this.alphaChannel)))), this.handleAllowEmptyOrClearableChange();
    const { isClearable: e2, color: t2, format: i, value: o2 } = this, a = e2 && !o2, s2 = Z(o2), l = a || i === "auto" && s2 || i === s2, r = a ? null : l ? color_default(o2) : t2;
    l || this.showIncompatibleColorWarning(o2, i), this.setMode(i, false), this.internalColorSet(r, false, "initial"), this.updateStaticDimensions(this.scale), this.updateDynamicDimensions(G[this.scale].minWidth);
    const h = `${z}${this.storageId}`;
    this.storageId && localStorage.getItem(h) && (this.savedColors = JSON.parse(localStorage.getItem(h)));
  }
  willUpdate(e2) {
    (e2.has("allowEmpty") && (this.hasUpdated || this.allowEmpty !== false) || e2.has("clearable") && (this.hasUpdated || this.clearable !== false)) && this.handleAllowEmptyOrClearableChange(), e2.has("alphaChannel") && (this.hasUpdated || this.alphaChannel !== false) && this.handleAlphaChannelChange(this.alphaChannel), this.hasUpdated && (e2.has("alphaChannel") && this.alphaChannel !== false || e2.has("staticDimensions") && this.staticDimensions !== G.m) && this.handleAlphaChannelDimensionsChange(), (e2.has("alphaChannel") && (this.hasUpdated || this.alphaChannel !== false) || e2.has("format") && (this.hasUpdated || this.format !== "auto")) && this.handleFormatOrAlphaChannelChange(), e2.has("scale") && (this.hasUpdated || this.scale !== "m") && this.handleScaleChange(this.scale);
  }
  updated() {
    m(this);
  }
  loaded() {
    this.handleAlphaChannelDimensionsChange();
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback(), window.removeEventListener("pointermove", this.globalPointerMoveHandler), window.removeEventListener("pointerup", this.globalPointerUpHandler), (_a = this.resizeObserver) == null ? void 0 : _a.disconnect();
  }
  // #endregion
  // #region Private Methods
  observeResize() {
    var _a;
    (_a = this.resizeObserver) == null ? void 0 : _a.observe(this.el);
  }
  handleAllowEmptyOrClearableChange() {
    this.isClearable = this.clearable || this.allowEmpty;
  }
  handleAlphaChannelChange(e2) {
    const { format: t2 } = this;
    e2 && t2 !== "auto" && !Q(t2) && (console.warn(`ignoring alphaChannel as the current format (${t2}) does not support alpha`), this.alphaChannel = false);
  }
  handleAlphaChannelDimensionsChange() {
    this.drawColorControls();
  }
  handleColorChange(e2, t2) {
    this.drawColorControls(), this.updateChannelsFromColor(e2), this.previousColor = t2;
  }
  handleFormatOrAlphaChannelChange() {
    this.setMode(this.format), this.internalColorSet(this.color, false, "internal");
  }
  handleScaleChange(e2 = "m") {
    this.updateStaticDimensions(e2), this.updateCanvasSize(), this.drawColorControls();
  }
  handleValueChange(e2, t2) {
    const { isClearable: i, format: o2 } = this, a = !i || e2;
    let s2 = false;
    if (a) {
      const d = Z(e2);
      if (!d || o2 !== "auto" && d !== o2) {
        this.showIncompatibleColorWarning(e2, o2), this._value = t2;
        return;
      }
      s2 = this.mode !== d, this.setMode(d, this.internalColorUpdateContext === null);
    }
    const l = this.activeCanvasInfo;
    if (this.internalColorUpdateContext === "initial")
      return;
    if (this.internalColorUpdateContext === "user-interaction") {
      this.calciteColorPickerInput.emit(), l || this.calciteColorPickerChange.emit();
      return;
    }
    const r = i && !e2 ? null : color_default(e2 != null && typeof e2 == "object" && Q(this.mode) ? K(e2) : e2), h = !J(r, this.color);
    (s2 || h) && this.internalColorSet(r, this.alphaChannel && !(this.mode.endsWith("a") || this.mode.endsWith("a-css")) || this.internalColorUpdateContext === "internal", "internal");
  }
  handleTabActivate(e2) {
    this.channelMode = e2.currentTarget.getAttribute("data-color-mode"), this.updateChannelsFromColor(this.color);
  }
  handleColorFieldScopeKeyDown(e2) {
    const { key: t2 } = e2, i = {
      ArrowUp: { x: 0, y: -10 },
      ArrowRight: { x: 10, y: 0 },
      ArrowDown: { x: 0, y: 10 },
      ArrowLeft: { x: -10, y: 0 }
    };
    i[t2] && (e2.preventDefault(), this.scopeOrientation = t2 === "ArrowDown" || t2 === "ArrowUp" ? "vertical" : "horizontal", this.captureColorFieldColor(this.colorFieldScopeLeft + i[t2].x || 0, this.colorFieldScopeTop + i[t2].y || 0, false));
  }
  handleHueScopeKeyDown(e2) {
    const t2 = e2.shiftKey ? 10 : 1, { key: i } = e2, o2 = {
      ArrowUp: 1,
      ArrowRight: 1,
      ArrowDown: -1,
      ArrowLeft: -1
    };
    if (o2[i]) {
      e2.preventDefault();
      const a = o2[i] * t2, s2 = this.baseColorFieldColor.hue(), l = this.baseColorFieldColor.hue(s2 + a);
      this.internalColorSet(l, false);
    }
  }
  handleHexInputChange(e2) {
    e2.stopPropagation();
    const { isClearable: t2, color: i } = this, a = e2.target.value;
    if (t2 && !a) {
      this.internalColorSet(null);
      return;
    }
    const s2 = i && Y(j(i, Q(this.mode)));
    a !== s2 && this.internalColorSet(color_default(a));
  }
  handleSavedColorSelect(e2) {
    const t2 = e2.currentTarget;
    this.internalColorSet(color_default(t2.color));
  }
  handleChannelInput(e2) {
    const t2 = e2.currentTarget, i = Number(t2.getAttribute("data-channel-index")), a = i === 3 ? O.max : this.channelMode === "rgb" ? X[Object.keys(X)[i]] : B[Object.keys(B)[i]];
    let s2;
    if (!t2.value)
      s2 = "", this.isActiveChannelInputEmpty = true, this.upOrDownArrowKeyTracker = null;
    else {
      const r = Number(t2.value) + this.shiftKeyChannelAdjustment;
      s2 = m3(r, 0, a).toString();
    }
    t2.value = s2, s2 !== "" && this.shiftKeyChannelAdjustment !== 0 ? this.handleChannelChange(e2) : s2 !== "" && this.handleChannelChange(e2);
  }
  handleChannelBlur(e2) {
    var _a;
    const t2 = e2.currentTarget, i = Number(t2.getAttribute("data-channel-index")), o2 = [...this.channels];
    !t2.value && !this.isClearable && (t2.value = (_a = o2[i]) == null ? void 0 : _a.toString());
  }
  handleChannelFocus(e2) {
    e2.currentTarget.selectText();
  }
  // using @Listen as a workaround for VDOM listener not firing
  handleChannelKeyUpOrDown(e2) {
    this.shiftKeyChannelAdjustment = 0;
    const { key: t2 } = e2;
    if (t2 !== "ArrowUp" && t2 !== "ArrowDown" || !e2.composedPath().some((a) => {
      var _a;
      return (_a = a.classList) == null ? void 0 : _a.contains(w.channel);
    }))
      return;
    const { shiftKey: i } = e2;
    if (e2.preventDefault(), !this.color) {
      this.internalColorSet(this.previousColor), e2.stopPropagation();
      return;
    }
    const o2 = 9;
    this.shiftKeyChannelAdjustment = t2 === "ArrowUp" && i ? o2 : t2 === "ArrowDown" && i ? -9 : 0, t2 === "ArrowUp" && (this.upOrDownArrowKeyTracker = "up"), t2 === "ArrowDown" && (this.upOrDownArrowKeyTracker = "down");
  }
  getChannelInputLimit(e2) {
    return this.channelMode === "rgb" ? X[Object.keys(X)[e2]] : B[Object.keys(B)[e2]];
  }
  handleChannelChange(e2) {
    const t2 = e2.currentTarget, i = Number(t2.getAttribute("data-channel-index")), o2 = [...this.channels];
    if (this.isClearable && !t2.value) {
      this.channels = [null, null, null, null], this.internalColorSet(null);
      return;
    }
    const s2 = i === 3;
    this.isActiveChannelInputEmpty && this.upOrDownArrowKeyTracker && (t2.value = this.upOrDownArrowKeyTracker === "up" ? (o2[i] + 1 <= this.getChannelInputLimit(i) ? o2[i] + 1 : this.getChannelInputLimit(i)).toString() : (o2[i] - 1 >= 0 ? o2[i] - 1 : 0).toString(), this.isActiveChannelInputEmpty = false, this.upOrDownArrowKeyTracker = null);
    const l = t2.value ? Number(t2.value) : o2[i];
    o2[i] = s2 ? q(l) : l, this.updateColorFromChannels(o2);
  }
  handleSavedColorKeyDown(e2) {
    t(e2.key) && (e2.preventDefault(), this.handleSavedColorSelect(e2));
  }
  handleColorFieldPointerDown(e2) {
    this.handleCanvasControlPointerDown(e2, this.colorFieldRenderingContext, this.captureColorFieldColor, this.colorFieldScopeNode);
  }
  focusScope(e2) {
    requestAnimationFrame(() => {
      e2.focus();
    });
  }
  handleHueSliderPointerDown(e2) {
    this.handleCanvasControlPointerDown(e2, this.hueSliderRenderingContext, this.captureHueSliderColor, this.hueScopeNode);
  }
  handleOpacitySliderPointerDown(e2) {
    this.handleCanvasControlPointerDown(e2, this.opacitySliderRenderingContext, this.captureOpacitySliderValue, this.opacityScopeNode);
  }
  handleCanvasControlPointerDown(e2, t2, i, o2) {
    It(e2) && (window.addEventListener("pointermove", this.globalPointerMoveHandler), window.addEventListener("pointerup", this.globalPointerUpHandler, {
      once: true
    }), this.activeCanvasInfo = {
      context: t2,
      bounds: t2.canvas.getBoundingClientRect()
    }, i.call(this, e2.offsetX, e2.offsetY), this.focusScope(o2));
  }
  storeColorFieldScope(e2) {
    this.colorFieldScopeNode = e2;
  }
  storeHueScope(e2) {
    this.hueScopeNode = e2;
  }
  handleKeyDown(e2) {
    e2.key === "Enter" && e2.preventDefault();
  }
  showIncompatibleColorWarning(e2, t2) {
    console.warn(`ignoring color value (${e2}) as it is not compatible with the current format (${t2})`);
  }
  setMode(e2, t2 = true) {
    const i = e2 === "auto" ? this.mode : e2;
    this.mode = this.ensureCompatibleMode(i, t2);
  }
  ensureCompatibleMode(e2, t2) {
    const { alphaChannel: i } = this, o2 = Q(e2);
    if (i && !o2) {
      const a = V(e2);
      return t2 && console.warn(`setting format to (${a}) as the provided one (${e2}) does not support alpha`), a;
    }
    if (!i && o2) {
      const a = tt(e2);
      return t2 && console.warn(`setting format to (${a}) as the provided one (${e2}) does not support alpha`), a;
    }
    return e2;
  }
  captureHueSliderColor(e2) {
    const t2 = N / this.effectiveSliderWidth * e2;
    this.internalColorSet(this.baseColorFieldColor.hue(t2), false);
  }
  captureOpacitySliderValue(e2) {
    const t2 = q(O.max / this.effectiveSliderWidth * e2);
    this.internalColorSet(this.baseColorFieldColor.alpha(t2), false);
  }
  internalColorSet(e2, t2 = true, i = "user-interaction") {
    t2 && J(e2, this.color) || (this.internalColorUpdateContext = i, this.color = e2, this.value = this.toValue(e2), this.internalColorUpdateContext = null);
  }
  toValue(e2, t2 = this.mode) {
    if (!e2)
      return null;
    if (t2.includes("hex")) {
      const a = t2 === e.HEXA;
      return Y(j(e2.round(), a), a);
    }
    if (t2.includes("-css")) {
      const a = e2[t2.replace("-css", "").replace("a", "")]().round().string();
      if ((t2.endsWith("a") || t2.endsWith("a-css")) && e2.alpha() === 1) {
        const l = a.slice(0, 3), r = a.slice(4, -1);
        return `${l}a(${r}, ${e2.alpha()})`;
      }
      return a;
    }
    const o2 = (
      /* Color() does not support hsva, hsla nor rgba, so we use the non-alpha mode */
      e2[tt(t2)]().round().object()
    );
    return t2.endsWith("a") ? k(o2) : o2;
  }
  getSliderCapSpacing() {
    const { staticDimensions: { slider: { height: e2 }, thumb: { radius: t2 } } } = this;
    return t2 * 2 - e2;
  }
  updateStaticDimensions(e2 = "m") {
    this.staticDimensions = G[e2];
  }
  deleteColor() {
    const e2 = j(this.color, this.alphaChannel);
    if (!(this.savedColors.indexOf(e2) > -1))
      return;
    const i = this.savedColors.filter((a) => a !== e2);
    this.savedColors = i;
    const o2 = `${z}${this.storageId}`;
    this.storageId && localStorage.setItem(o2, JSON.stringify(i));
  }
  saveColor() {
    const e2 = j(this.color, this.alphaChannel);
    if (this.savedColors.indexOf(e2) > -1)
      return;
    const i = [...this.savedColors, e2];
    this.savedColors = i;
    const o2 = `${z}${this.storageId}`;
    this.storageId && localStorage.setItem(o2, JSON.stringify(i));
  }
  drawColorField() {
    const e2 = this.colorFieldRenderingContext, { width: t2, height: i } = this.dynamicDimensions.colorField;
    e2.fillStyle = this.baseColorFieldColor.hsv().saturationv(100).value(100).alpha(1).string(), e2.fillRect(0, 0, t2, i);
    const o2 = e2.createLinearGradient(0, 0, t2, 0);
    o2.addColorStop(0, "rgba(255,255,255,1)"), o2.addColorStop(1, "rgba(255,255,255,0)"), e2.fillStyle = o2, e2.fillRect(0, 0, t2, i);
    const a = e2.createLinearGradient(0, 0, 0, i);
    a.addColorStop(0, "rgba(0,0,0,0)"), a.addColorStop(1, "rgba(0,0,0,1)"), e2.fillStyle = a, e2.fillRect(0, 0, t2, i), this.drawActiveColorFieldColor();
  }
  setCanvasContextSize(e2, { height: t2, width: i }) {
    if (!e2)
      return;
    const o2 = window.devicePixelRatio || 1;
    e2.width = i * o2, e2.height = t2 * o2, e2.style.height = `${t2}px`, e2.style.width = `${i}px`, e2.getContext("2d").scale(o2, o2);
  }
  initColorField(e2) {
    e2 && (this.colorFieldRenderingContext = e2.getContext("2d"), this.updateCanvasSize("color-field"), this.drawColorControls());
  }
  initHueSlider(e2) {
    e2 && (this.hueSliderRenderingContext = e2.getContext("2d"), this.updateCanvasSize("hue-slider"), this.drawHueSlider());
  }
  initOpacitySlider(e2) {
    e2 && (this.opacitySliderRenderingContext = e2.getContext("2d"), this.updateCanvasSize("opacity-slider"), this.drawOpacitySlider());
  }
  updateCanvasSize(e2 = "all") {
    var _a, _b, _c;
    const { dynamicDimensions: t2, staticDimensions: i } = this;
    (e2 === "all" || e2 === "color-field") && this.setCanvasContextSize((_a = this.colorFieldRenderingContext) == null ? void 0 : _a.canvas, t2.colorField);
    const o2 = {
      width: this.effectiveSliderWidth,
      height: i.slider.height + (i.thumb.radius - t2.slider.height / 2) * 2
    };
    (e2 === "all" || e2 === "hue-slider") && this.setCanvasContextSize((_b = this.hueSliderRenderingContext) == null ? void 0 : _b.canvas, o2), (e2 === "all" || e2 === "opacity-slider") && this.setCanvasContextSize((_c = this.opacitySliderRenderingContext) == null ? void 0 : _c.canvas, o2);
  }
  drawActiveColorFieldColor() {
    const { color: e2 } = this;
    if (!e2)
      return;
    const t2 = e2.hsv(), { staticDimensions: { thumb: { radius: i } } } = this, { width: o2, height: a } = this.dynamicDimensions.colorField, s2 = t2.saturationv() / (B.s / o2), l = a - t2.value() / (B.v / a);
    requestAnimationFrame(() => {
      this.colorFieldScopeLeft = s2, this.colorFieldScopeTop = l;
    }), this.drawThumb(this.colorFieldRenderingContext, i, s2, l, t2, false);
  }
  drawThumb(e2, t2, i, o2, a, s2) {
    const r = 2 * Math.PI, h = 1;
    if (e2.beginPath(), e2.arc(i, o2, t2, 0, r), e2.fillStyle = "#fff", e2.fill(), e2.strokeStyle = "rgba(0,0,0,0.3)", e2.lineWidth = h, e2.stroke(), s2 && a.alpha() < 1) {
      const C = e2.createPattern(this.getCheckeredBackgroundPattern(), "repeat");
      e2.beginPath(), e2.arc(i, o2, t2 - 3, 0, r), e2.fillStyle = C, e2.fill();
    }
    e2.globalCompositeOperation = "source-atop", e2.beginPath(), e2.arc(i, o2, t2 - 3, 0, r);
    const d = s2 ? a.alpha() : 1;
    e2.fillStyle = a.rgb().alpha(d).string(), e2.fill(), e2.globalCompositeOperation = "source-over";
  }
  drawActiveHueSliderColor() {
    const { color: e2 } = this;
    if (!e2)
      return;
    const t2 = e2.hsv().saturationv(100).value(100), { staticDimensions: { thumb: { radius: i } } } = this, o2 = this.effectiveSliderWidth, a = t2.hue() / (N / o2), s2 = i, l = this.getSliderBoundX(a, o2, i);
    requestAnimationFrame(() => {
      this.hueScopeLeft = l;
    }), this.drawThumb(this.hueSliderRenderingContext, i, l, s2, t2, false);
  }
  drawHueSlider() {
    const e2 = this.hueSliderRenderingContext, { staticDimensions: { slider: { height: t2 }, thumb: { radius: i } } } = this, o2 = 0, a = i - t2 / 2, s2 = this.effectiveSliderWidth, l = e2.createLinearGradient(0, 0, s2, 0), r = [
      "red",
      "yellow",
      "lime",
      "cyan",
      "blue",
      "magenta",
      "#ff0004"
    ], h = 1 / (r.length - 1);
    let d = 0;
    r.forEach((C) => {
      l.addColorStop(d, color_default(C).string()), d += h;
    }), e2.clearRect(0, 0, s2, t2 + this.getSliderCapSpacing() * 2), this.drawSliderPath(e2, t2, s2, o2, a), e2.fillStyle = l, e2.fill(), e2.strokeStyle = "rgba(0,0,0,0.3)", e2.lineWidth = 1, e2.stroke(), this.drawActiveHueSliderColor();
  }
  drawOpacitySlider() {
    const e2 = this.opacitySliderRenderingContext, { baseColorFieldColor: t2, staticDimensions: { slider: { height: i }, thumb: { radius: o2 } } } = this, a = 0, s2 = o2 - i / 2, l = this.effectiveSliderWidth;
    e2.clearRect(0, 0, l, i + this.getSliderCapSpacing() * 2);
    const r = e2.createLinearGradient(0, s2, l, 0), h = t2.rgb().alpha(0), d = t2.rgb().alpha(0.5), C = t2.rgb().alpha(1);
    r.addColorStop(0, h.string()), r.addColorStop(0.5, d.string()), r.addColorStop(1, C.string()), this.drawSliderPath(e2, i, l, a, s2);
    const f = e2.createPattern(this.getCheckeredBackgroundPattern(), "repeat");
    e2.fillStyle = f, e2.fill(), e2.fillStyle = r, e2.fill(), e2.strokeStyle = "rgba(0,0,0,0.3)", e2.lineWidth = 1, e2.stroke(), this.drawActiveOpacitySliderColor();
  }
  drawSliderPath(e2, t2, i, o2, a) {
    const s2 = t2 / 2 + 1;
    e2.beginPath(), e2.moveTo(o2 + s2, a), e2.lineTo(o2 + i - s2, a), e2.quadraticCurveTo(o2 + i, a, o2 + i, a + s2), e2.lineTo(o2 + i, a + t2 - s2), e2.quadraticCurveTo(o2 + i, a + t2, o2 + i - s2, a + t2), e2.lineTo(o2 + s2, a + t2), e2.quadraticCurveTo(o2, a + t2, o2, a + t2 - s2), e2.lineTo(o2, a + s2), e2.quadraticCurveTo(o2, a, o2 + s2, a), e2.closePath();
  }
  getCheckeredBackgroundPattern() {
    if (this.checkerPattern)
      return this.checkerPattern;
    const e2 = document.createElement("canvas");
    e2.width = 10, e2.height = 10;
    const t2 = e2.getContext("2d");
    return t2.fillStyle = "#ccc", t2.fillRect(0, 0, 10, 10), t2.fillStyle = "#fff", t2.fillRect(0, 0, 5, 5), t2.fillRect(5, 5, 5, 5), this.checkerPattern = e2, e2;
  }
  drawActiveOpacitySliderColor() {
    const { color: e2 } = this;
    if (!e2)
      return;
    const t2 = e2, { staticDimensions: { thumb: { radius: i } } } = this, o2 = this.effectiveSliderWidth, a = U(t2.alpha()) / (O.max / o2), s2 = i, l = this.getSliderBoundX(a, o2, i);
    requestAnimationFrame(() => {
      this.opacityScopeLeft = l;
    }), this.drawThumb(this.opacitySliderRenderingContext, i, l, s2, t2, true);
  }
  getSliderBoundX(e2, t2, i) {
    const o2 = g(e2, t2, i);
    return o2 === 0 ? e2 : o2 === -1 ? o(e2, 0, t2, i, i * 2) : o(e2, 0, t2, t2 - i * 2, t2 - i);
  }
  storeOpacityScope(e2) {
    this.opacityScopeNode = e2;
  }
  handleOpacityScopeKeyDown(e2) {
    const t2 = e2.shiftKey ? 10 : 1, { key: i } = e2, o2 = {
      ArrowUp: 0.01,
      ArrowRight: 0.01,
      ArrowDown: -0.01,
      ArrowLeft: -0.01
    };
    if (o2[i]) {
      e2.preventDefault();
      const a = o2[i] * t2, s2 = this.baseColorFieldColor.alpha(), l = this.baseColorFieldColor.alpha(s2 + a);
      this.internalColorSet(l, false);
    }
  }
  updateColorFromChannels(e2) {
    this.internalColorSet(color_default(e2, this.channelMode));
  }
  updateChannelsFromColor(e2) {
    this.channels = e2 ? this.toChannels(e2) : [null, null, null, null];
  }
  toChannels(e2) {
    const { channelMode: t2 } = this, i = e2[t2]().array().map((o2, a) => a === 3 ? o2 : Math.floor(o2));
    return i.length === 3 && i.push(1), i;
  }
  getAdjustedScopePosition(e2, t2) {
    return [e2 - P / 2, t2 - P / 2];
  }
  // #endregion
  // #region Rendering
  render() {
    const { channelsDisabled: e2, color: t2, colorFieldScopeLeft: i, colorFieldScopeTop: o2, staticDimensions: { thumb: { radius: a } }, hexDisabled: s2, hueScopeLeft: l, messages: r, alphaChannel: h, opacityScopeLeft: d, savedColors: C, savedDisabled: f, scale: m4, scopeOrientation: w2 } = this, M = this.effectiveSliderWidth, z2 = t2 ? j(t2, h) : null, G2 = a, Y2 = l ?? M * y.hue() / B.h, J2 = a, Z2 = d ?? M * U(y.alpha()) / O.max, L = t2 === void 0, F = w2 === "vertical", [Q2, ee] = this.getAdjustedScopePosition(i, o2), [te, ie] = this.getAdjustedScopePosition(Y2, G2), [oe, ae] = this.getAdjustedScopePosition(Z2, J2);
    return p({ disabled: this.disabled, children: html`<div class=${safeClassMap(w.container)}><div class=${safeClassMap(w.controlAndScope)}><canvas class=${safeClassMap(w.colorField)} @pointerdown=${this.handleColorFieldPointerDown} ${ref(this.initColorField)}></canvas><div .ariaLabel=${F ? r.value : r.saturation} .ariaValueMax=${F ? B.v : B.s} aria-valuemin=0 .ariaValueNow=${(F ? t2 == null ? void 0 : t2.saturationv() : t2 == null ? void 0 : t2.value()) || "0"} class=${safeClassMap({ [w.scope]: true, [w.colorFieldScope]: true })} @keydown=${this.handleColorFieldScopeKeyDown} role=slider style=${safeStyleMap({
      top: `${ee || 0}px`,
      left: `${Q2 || 0}px`
    })} tabindex=0 ${ref(this.storeColorFieldScope)}></div></div><div class=${safeClassMap(w.previewAndSliders)}><calcite-color-picker-swatch class=${safeClassMap(w.preview)} .color=${z2} .scale=${this.alphaChannel ? "l" : this.scale}></calcite-color-picker-swatch><div class=${safeClassMap(w.sliders)}><div class=${safeClassMap(w.controlAndScope)}><canvas class=${safeClassMap({ [w.slider]: true, [w.hueSlider]: true })} @pointerdown=${this.handleHueSliderPointerDown} ${ref(this.initHueSlider)}></canvas><div .ariaLabel=${r.hue} .ariaValueMax=${B.h} aria-valuemin=0 .ariaValueNow=${(t2 == null ? void 0 : t2.round().hue()) || y.round().hue()} class=${safeClassMap({ [w.scope]: true, [w.hueScope]: true })} @keydown=${this.handleHueScopeKeyDown} role=slider style=${safeStyleMap({
      top: `${ie}px`,
      left: `${te}px`
    })} tabindex=0 ${ref(this.storeHueScope)}></div></div>${h ? html`<div class=${safeClassMap(w.controlAndScope)}><canvas class=${safeClassMap({ [w.slider]: true, [w.opacitySlider]: true })} @pointerdown=${this.handleOpacitySliderPointerDown} ${ref(this.initOpacitySlider)}></canvas><div .ariaLabel=${r.opacity} .ariaValueMax=${O.max} .ariaValueMin=${O.min} .ariaValueNow=${(t2 || y).round().alpha()} class=${safeClassMap({ [w.scope]: true, [w.opacityScope]: true })} @keydown=${this.handleOpacityScopeKeyDown} role=slider style=${safeStyleMap({
      top: `${ae}px`,
      left: `${oe}px`
    })} tabindex=0 ${ref(this.storeOpacityScope)}></div></div>` : null}</div></div>${s2 && e2 ? null : html`<div class=${safeClassMap({
      [w.controlSection]: true,
      [w.section]: true
    })}><div class=${safeClassMap(w.hexAndChannelsGroup)}>${s2 ? null : html`<div class=${safeClassMap(w.hexOptions)}><calcite-color-picker-hex-input .allowEmpty=${this.isClearable} .alphaChannel=${h} class=${safeClassMap(w.control)} .messages=${r} .numberingSystem=${this.numberingSystem} @calciteColorPickerHexInputChange=${this.handleHexInputChange} .scale=${m4} .value=${z2}></calcite-color-picker-hex-input></div>`}${e2 ? null : html`<calcite-tabs class=${safeClassMap({
      [w.colorModeContainer]: true,
      [w.splitSection]: true
    })} .scale=${m4 === "l" ? "m" : "s"}><calcite-tab-nav slot=title-group>${this.renderChannelsTabTitle("rgb")}${this.renderChannelsTabTitle("hsv")}</calcite-tab-nav>${this.renderChannelsTab("rgb")}${this.renderChannelsTab("hsv")}</calcite-tabs>`}</div></div>`}${f ? null : html`<div class=${safeClassMap({ [w.savedColorsSection]: true, [w.section]: true })}><div class=${safeClassMap(w.header)}><label>${r.saved}</label><div class=${safeClassMap(w.savedColorsButtons)}><calcite-button appearance=transparent class=${safeClassMap(w.deleteColor)} .disabled=${L} icon-start=minus kind=neutral .label=${r.deleteColor} @click=${this.deleteColor} .scale=${m4} type=button></calcite-button><calcite-button appearance=transparent class=${safeClassMap(w.saveColor)} .disabled=${L} icon-start=plus kind=neutral .label=${r.saveColor} @click=${this.saveColor} .scale=${m4} type=button></calcite-button></div></div>${C.length > 0 ? html`<div class=${safeClassMap(w.savedColors)}>${repeat(C, (T) => T, (T) => html`<calcite-color-picker-swatch class=${safeClassMap(w.savedColor)} .color=${T} @click=${this.handleSavedColorSelect} @keydown=${this.handleSavedColorKeyDown} .scale=${m4} tabindex=0></calcite-color-picker-swatch>`)}</div>` : null}</div>`}</div>` });
  }
  renderChannelsTabTitle(e2) {
    const { channelMode: t2, messages: i } = this, o2 = e2 === t2, a = e2 === "rgb" ? i.rgb : i.hsv;
    return keyed(e2, html`<calcite-tab-title class=${safeClassMap(w.colorMode)} data-color-mode=${e2 ?? nothing} @calciteTabsActivate=${this.handleTabActivate} .selected=${o2}>${a}</calcite-tab-title>`);
  }
  renderChannelsTab(e2) {
    const { isClearable: t2, channelMode: i, channels: o2, messages: a, alphaChannel: s2 } = this, l = e2 === i, h = e2 === "rgb" ? [a.red, a.green, a.blue] : [a.hue, a.saturation, a.value], d = gt(this.el), C = s2 ? o2 : o2.slice(0, 3);
    return keyed(e2, html`<calcite-tab class=${safeClassMap(w.control)} .selected=${l}><div class=${safeClassMap(w.channels)} dir=ltr>${C.map((f, m4) => {
      const w2 = m4 === 3;
      return w2 && (f = t2 && !f ? f : U(f)), this.renderChannel(f, m4, h[m4], d, w2 ? "%" : "");
    })}</div></calcite-tab>`);
  }
  renderChannel(e2, t2, i, o2, a) {
    return keyed(t2, html`<calcite-input-number class=${safeClassMap(w.channel)} data-channel-index=${t2 ?? nothing} dir=${o2 ?? nothing} .label=${i} lang=${this.messages._lang ?? nothing} number-button-type=none .numberingSystem=${this.numberingSystem} @keydown=${this.handleKeyDown} @calciteInputNumberChange=${this.handleChannelChange} @calciteInputNumberInput=${this.handleChannelInput} @calciteInternalInputNumberBlur=${this.handleChannelBlur} @calciteInternalInputNumberFocus=${this.handleChannelFocus} .scale=${this.scale === "l" ? "m" : "s"} style=${safeStyleMap({
      marginLeft: t2 > 0 && !(this.scale === "s" && this.alphaChannel && t2 === 3) ? "-1px" : ""
    })} .suffixText=${a} .value=${e2 == null ? void 0 : e2.toString()}></calcite-input-number>`);
  }
};
_Ae.properties = { channelMode: 16, channels: 16, colorFieldScopeLeft: 16, colorFieldScopeTop: 16, staticDimensions: 16, hueScopeLeft: 16, opacityScopeLeft: 16, savedColors: 16, scopeOrientation: 16, allowEmpty: 7, alphaChannel: 5, channelsDisabled: 5, clearable: 7, color: 0, disabled: 7, format: 3, hexDisabled: 5, messageOverrides: 0, numberingSystem: 3, savedDisabled: 7, scale: 3, storageId: 3, value: 1 };
_Ae.styles = xe;
var Ae = _Ae;
S("calcite-color-picker", Ae);
export {
  Ae as ColorPicker
};
/*! Bundled license information:

@esri/calcite-components/dist/components/calcite-color-picker/customElement.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=customElement-DZEQFAQP.js.map
