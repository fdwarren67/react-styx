import {
  A,
  C,
  D,
  F,
  O,
  U,
  Y,
  color_default,
  h,
  j,
  q
} from "./chunk-R3C42XIH.js";
import "./chunk-7LRZLRAB.js";
import {
  keyed
} from "./chunk-KZXUV47B.js";
import {
  m
} from "./chunk-2GIEDWQ6.js";
import {
  ref
} from "./chunk-LTKIMXCE.js";
import {
  tt
} from "./chunk-VQ5234AM.js";
import "./chunk-PXZ2RU65.js";
import "./chunk-S3EVYUV4.js";
import {
  S
} from "./chunk-B7E2AREE.js";
import {
  LitElement,
  createEvent,
  css,
  html,
  safeClassMap
} from "./chunk-MALSDV7D.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@esri/calcite-components/dist/components/calcite-color-picker-hex-input/customElement.js
var m2 = {
  container: "container",
  hexInput: "hex-input",
  opacityInput: "opacity-input"
};
var z = css`:host{display:block}.container{display:flex;inline-size:100%;flex-wrap:nowrap;align-items:center}.hex-input{flex-grow:1;text-transform:uppercase}.opacity-input{inline-size:100px;margin-inline-start:-1px}:host([hidden]){display:none}[hidden]{display:none}`;
var f = color_default();
var _U = class _U extends LitElement {
  constructor() {
    super(...arguments), this.internalColor = f, this.alphaChannel = false, this.allowEmpty = false, this.hexLabel = "Hex", this.scale = "m", this.value = Y(j(f, this.alphaChannel), this.alphaChannel, true), this.calciteColorPickerHexInputChange = createEvent({ cancelable: false });
  }
  // #endregion
  // #region Public Methods
  /** Sets focus on the component. */
  async setFocus() {
    return await m(this), tt(this.hexInputNode);
  }
  // #endregion
  // #region Lifecycle
  connectedCallback() {
    super.connectedCallback(), this.previousNonNullValue = this.value;
    const { allowEmpty: t, alphaChannel: e, value: a } = this;
    if (a) {
      const n = Y(a, e);
      C(n, e) && this.internalSetValue(n, n, false);
      return;
    }
    t && this.internalSetValue(void 0, void 0, false);
  }
  willUpdate(t) {
    t.has("value") && (this.hasUpdated || this.value !== Y(j(f, this.alphaChannel), this.alphaChannel, true)) && this.internalSetValue(this.value, t.get("value"), false);
  }
  // #endregion
  // #region Private Methods
  onHexInputBlur() {
    const t = this.hexInputNode, e = t.value, a = `#${e}`, { allowEmpty: n, internalColor: l } = this, s = n && !e, i = F(a);
    (h(a, true) || h(a, false)) && this.onHexInputChange(), !(s || C(a) && i) && (t.value = n && !l ? "" : this.formatHexForInternalInput(A(
      // always display hex input in RRGGBB format
      l.object()
    )));
  }
  onOpacityInputBlur() {
    const t = this.opacityInputNode, e = t.value, { allowEmpty: a, internalColor: n } = this;
    a && !e || (t.value = a && !n ? "" : this.formatOpacityForInternalInput(n));
  }
  onOpacityInputInput() {
    this.onOpacityInputChange();
  }
  onHexInputChange() {
    let e = this.hexInputNode.value;
    if (e) {
      const a = Y(e, false);
      if (C(a) && this.alphaChannel && this.internalColor) {
        const l = Y(this.internalColor.hexa(), true).slice(-2);
        e = `${a + l}`;
      }
    }
    this.internalSetValue(e, this.value);
  }
  onOpacityInputChange() {
    var _a;
    const t = this.opacityInputNode;
    let e;
    if (!t.value)
      e = t.value;
    else {
      const a = q(Number(t.value));
      e = (_a = this.internalColor) == null ? void 0 : _a.alpha(a).hexa();
    }
    this.internalSetValue(e, this.value);
  }
  onInputFocus(t) {
    t.type === "calciteInternalInputTextFocus" ? this.hexInputNode.selectText() : this.opacityInputNode.selectText();
  }
  onHexInputInput() {
    const t = `#${this.hexInputNode.value}`, e = this.value;
    C(t, this.alphaChannel) && F(t, this.alphaChannel) && this.internalSetValue(t, e);
  }
  onInputKeyDown(t) {
    const { altKey: e, ctrlKey: a, metaKey: n, shiftKey: l } = t, { alphaChannel: s, hexInputNode: i, internalColor: o, value: h2 } = this, { key: r } = t, y = t.composedPath();
    if (r === "Tab" && h(h2, this.alphaChannel) || r === "Enter") {
      y.includes(i) ? this.onHexInputChange() : this.onOpacityInputChange(), r === "Enter" && t.preventDefault();
      return;
    }
    const w = r === "ArrowDown" || r === "ArrowUp", v = this.value;
    if (w) {
      if (!h2) {
        this.internalSetValue(this.previousNonNullValue, v), t.preventDefault();
        return;
      }
      const E = r === "ArrowUp" ? 1 : -1, F2 = l ? 10 : 1;
      this.internalSetValue(j(this.nudgeRGBChannels(o, F2 * E, y.includes(i) ? "rgb" : "a"), s), v), t.preventDefault();
      return;
    }
    const N = e || a || n, S2 = r.length === 1, O2 = D.test(r);
    S2 && !N && !O2 && t.preventDefault();
  }
  onHexInputPaste(t) {
    const e = t.clipboardData.getData("text");
    C(e, this.alphaChannel) && F(e, this.alphaChannel) && (t.preventDefault(), this.hexInputNode.value = e.slice(1), this.internalSetValue(e, this.value));
  }
  internalSetValue(t, e, a = true) {
    if (t) {
      const { alphaChannel: n } = this, l = Y(t, n, n);
      if (C(l, n)) {
        const { internalColor: s } = this, i = color_default(l), o = Y(j(i, n), n), h2 = !s || o !== Y(j(s, n), n);
        this.internalColor = i, this.previousNonNullValue = o, this.value = o, h2 && a && this.calciteColorPickerHexInputChange.emit();
        return;
      }
    } else if (this.allowEmpty) {
      this.internalColor = void 0, this.value = void 0, a && this.calciteColorPickerHexInputChange.emit();
      return;
    }
    this.value = e;
  }
  storeHexInputRef(t) {
    this.hexInputNode = t;
  }
  storeOpacityInputRef(t) {
    this.opacityInputNode = t;
  }
  formatHexForInternalInput(t) {
    return t ? t.replace("#", "").slice(0, 6) : "";
  }
  formatOpacityForInternalInput(t) {
    return t ? `${U(t.alpha())}` : "";
  }
  nudgeRGBChannels(t, e, a) {
    let n;
    const l = t.array(), s = l.slice(0, 3);
    if (a === "rgb")
      n = [
        ...s.map((o) => o + e),
        this.alphaChannel ? l[3] : void 0
      ];
    else {
      const i = q(U(t.alpha()) + e);
      n = [...s, i];
    }
    return color_default(n);
  }
  // #endregion
  // #region Rendering
  render() {
    const { alphaChannel: t, hexLabel: e, internalColor: a, messages: n, scale: l, value: s } = this, i = this.formatHexForInternalInput(s), o = this.formatOpacityForInternalInput(a), h2 = l === "l" ? "m" : "s";
    return html`<div class=${safeClassMap(m2.container)}><calcite-input-text class=${safeClassMap(m2.hexInput)} .label=${(n == null ? void 0 : n.hex) || e} .maxLength=${this.alphaChannel ? 8 : 6} @keydown=${this.onInputKeyDown} @paste=${this.onHexInputPaste} @calciteInputTextChange=${this.onHexInputChange} @calciteInputTextInput=${this.onHexInputInput} @calciteInternalInputTextBlur=${this.onHexInputBlur} @calciteInternalInputTextFocus=${this.onInputFocus} prefix-text=# .scale=${h2} .value=${i} ${ref(this.storeHexInputRef)}></calcite-input-text>${t ? keyed("opacity-input", html`<calcite-input-number class=${safeClassMap(m2.opacityInput)} .label=${n == null ? void 0 : n.opacity} .max=${O.max} max-length=3 .min=${O.min} number-button-type=none .numberingSystem=${this.numberingSystem} @keydown=${this.onInputKeyDown} @calciteInputNumberInput=${this.onOpacityInputInput} @calciteInternalInputNumberBlur=${this.onOpacityInputBlur} @calciteInternalInputNumberFocus=${this.onInputFocus} .scale=${h2} suffix-text=% .value=${o} ${ref(this.storeOpacityInputRef)}></calcite-input-number>`) : null}</div>`;
  }
};
_U.properties = { internalColor: 16, alphaChannel: 5, allowEmpty: 5, hexLabel: 1, messages: 0, numberingSystem: 1, scale: 3, value: 3 };
_U.styles = z;
var U2 = _U;
S("calcite-color-picker-hex-input", U2);
export {
  U2 as ColorPickerHexInput
};
/*! Bundled license information:

@esri/calcite-components/dist/components/calcite-color-picker-hex-input/customElement.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=customElement-EVDWXXGE.js.map
