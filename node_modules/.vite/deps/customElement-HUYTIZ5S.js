import {
  repeat
} from "./chunk-G4USGCXL.js";
import {
  m as m2
} from "./chunk-DPQ7TENX.js";
import {
  $,
  B,
  D,
  O,
  W
} from "./chunk-VLJE74YV.js";
import {
  T,
  v
} from "./chunk-YJUTXVD7.js";
import {
  m,
  p
} from "./chunk-VBBJGZOS.js";
import {
  Y,
  ct,
  ft,
  ot as ot2,
  rt
} from "./chunk-T2GPF443.js";
import "./chunk-54EUENDV.js";
import {
  debounce_default,
  escapeRegExp_default
} from "./chunk-F5MHH7JA.js";
import {
  s as s2
} from "./chunk-GL5DQLAU.js";
import {
  ref
} from "./chunk-LTKIMXCE.js";
import {
  s
} from "./chunk-RZAGQ6CT.js";
import {
  b
} from "./chunk-6JIDXA46.js";
import {
  ot
} from "./chunk-VQ5234AM.js";
import {
  i
} from "./chunk-S3EVYUV4.js";
import {
  S
} from "./chunk-B7E2AREE.js";
import {
  LitElement,
  createEvent,
  css,
  html,
  nothing,
  safeClassMap,
  stringOrBoolean,
  useWatchAttributes
} from "./chunk-MALSDV7D.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@esri/calcite-components/dist/components/calcite-autocomplete/customElement.js
var G = css`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{position:relative;display:block}.input-container{position:relative;display:flex;flex:1 1 auto;flex-wrap:nowrap}.input{width:100%;--calcite-input-prefix-size: var(--calcite-autocomplete-input-prefix-size);--calcite-input-suffix-size: var(--calcite-autocomplete-input-suffix-size);--calcite-input-background-color: var(--calcite-autocomplete-input-background-color);--calcite-input-border-color: var(--calcite-autocomplete-input-border-color);--calcite-input-corner-radius: var(--calcite-autocomplete-input-corner-radius);--calcite-input-shadow: var(--calcite-autocomplete-input-shadow);--calcite-input-icon-color: var(--calcite-autocomplete-input-icon-color);--calcite-input-text-color: var(--calcite-autocomplete-input-text-color);--calcite-input-placeholder-text-color: var(--calcite-autocomplete-input-placeholder-text-color);--calcite-input-actions-background-color: var(--calcite-autocomplete-input-actions-background-color);--calcite-input-actions-background-color-hover: var(--calcite-autocomplete-input-actions-background-color-hover);--calcite-input-actions-background-color-press: var(--calcite-autocomplete-input-actions-background-color-press);--calcite-input-actions-icon-color: var(--calcite-autocomplete-input-actions-icon-color);--calcite-input-actions-icon-color-hover: var(--calcite-autocomplete-input-actions-icon-color-hover);--calcite-input-actions-icon-color-press: var(--calcite-autocomplete-input-actions-icon-color-press);--calcite-input-loading-background-color: var(--calcite-autocomplete-input-loading-background-color);--calcite-input-loading-fill-color: var(--calcite-autocomplete-input-loading-fill-color);--calcite-input-prefix-background-color: var(--calcite-autocomplete-input-prefix-background-color);--calcite-input-prefix-text-color: var(--calcite-autocomplete-input-prefix-text-color);--calcite-input-suffix-background-color: var(--calcite-autocomplete-input-suffix-background-color);--calcite-input-suffix-text-color: var(--calcite-autocomplete-input-suffix-text-color)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}.content-container{box-sizing:border-box;width:100%}.floating-ui-container{--calcite-floating-ui-z-index: var(--calcite-z-index-dropdown);inline-size:max-content;display:none;max-inline-size:100vw;max-block-size:100vh;inset-block-start:0;left:0;z-index:var(--calcite-floating-ui-z-index)}.floating-ui-container .calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:inset,left,opacity;opacity:0;box-shadow:0 0 16px #00000029;z-index:var(--calcite-z-index);border-radius:.25rem}.floating-ui-container[data-placement^=bottom] .calcite-floating-ui-anim{inset-block-start:-5px}.floating-ui-container[data-placement^=top] .calcite-floating-ui-anim{inset-block-start:5px}.floating-ui-container[data-placement^=left] .calcite-floating-ui-anim{left:5px}.floating-ui-container[data-placement^=right] .calcite-floating-ui-anim{left:-5px}.floating-ui-container[data-placement] .calcite-floating-ui-anim--active{opacity:1;inset-block-start:0;left:0}.content-container .calcite-floating-ui-anim{max-height:45vh;width:100%;overflow-y:auto;color:var(--calcite-autocomplete-text-color, var(--calcite-color-text-1));background-color:var(--calcite-autocomplete-background-color, var(--calcite-color-foreground-1));border-radius:var(--calcite-autocomplete-corner-radius, var(--calcite-corner-radius-round))}.content--hidden{display:none}@media (forced-colors: active){.floating-ui-container--active{border:1px solid canvasText}}.screen-readers-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.validation-container{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}:host([scale=m]) .validation-container,:host([scale=l]) .validation-container{padding-block-start:.5rem}:host([scale=s]) .validation-container{padding-block-start:.25rem}::slotted(input[slot=hidden-form-input]){margin:0!important;opacity:0!important;outline:none!important;padding:0!important;position:absolute!important;inset:0!important;transform:none!important;-webkit-appearance:none!important;z-index:-1!important}:host([hidden]){display:none}[hidden]{display:none}`;
var x = {
  contentBottom: "content-bottom",
  contentTop: "content-top"
};
var l = {
  inputContainer: "input-container",
  input: "input",
  contentContainer: "content-container",
  contentAnimation: "content-animation",
  content: "content",
  contentHidden: "content--hidden",
  floatingUIContainer: "floating-ui-container",
  floatingUIContainerActive: "floating-ui-container--active",
  screenReadersOnly: "screen-readers-only"
};
var q = {
  validationMessage: "autocompleteValidationMessage"
};
var W2 = "calcite-autocomplete-item-group";
var K = "calcite-autocomplete-item";
var _j = class _j extends LitElement {
  // #endregion
  // #region Lifecycle
  constructor() {
    super(), this.guid = i(), this.attributeWatch = useWatchAttributes(["autofocus", "enterkeyhint", "inputmode"], this.handleGlobalAttributesChanged), this.inputId = `autocomplete-input-${this.guid}`, this.listId = `autocomplete-list-${this.guid}`, this.messages = s(), this.transitionProp = "opacity", this.activeDescendant = "", this.activeIndex = -1, this.hasContentBottom = false, this.hasContentTop = false, this.items = [], this.groups = [], this.alignment = "start", this.disabled = false, this.iconFlipRtl = false, this.loading = false, this.open = false, this.overlayPositioning = "absolute", this.placement = ot2, this.readOnly = false, this.required = false, this.scale = "m", this.status = "idle", this.validity = {
      valid: false,
      badInput: false,
      customError: false,
      patternMismatch: false,
      rangeOverflow: false,
      rangeUnderflow: false,
      stepMismatch: false,
      tooLong: false,
      tooShort: false,
      typeMismatch: false,
      valueMissing: false
    }, this.value = "", this.calciteAutocompleteBeforeClose = createEvent({ cancelable: false }), this.calciteAutocompleteBeforeOpen = createEvent({ cancelable: false }), this.calciteAutocompleteChange = createEvent({ cancelable: false }), this.calciteAutocompleteClose = createEvent({ cancelable: false }), this.calciteAutocompleteOpen = createEvent({ cancelable: false }), this.calciteAutocompleteTextChange = createEvent({ cancelable: false }), this.calciteAutocompleteTextInput = createEvent({ cancelable: false }), this.mutationObserver = b("mutation", () => this.getAllItemsDebounced()), this.resizeObserver = b("resize", () => {
      this.setFloatingElSize();
    }), this.getAllItemsDebounced = debounce_default(this.getAllItems, 0), this.listenOn(document, "click", this.documentClickHandler), this.listen("calciteInternalAutocompleteItemSelect", this.handleInternalAutocompleteItemSelect);
  }
  get isOpen() {
    return this.open && (this.hasContentTop || this.hasContentBottom || this.items.length > 0);
  }
  get enabledItems() {
    return this.items.filter((t) => !t.disabled);
  }
  // #endregion
  // #region Public Methods
  /**
   * Updates the position of the component.
   *
   * @param delayed - `true` if the placement should be updated after the component is finished rendering.
   * @returns {Promise<void>}
   */
  async reposition(t = false) {
    const { floatingEl: e, referenceEl: o, placement: i2, overlayPositioning: n, flipPlacements: a } = this;
    return ft(this, {
      floatingEl: e,
      referenceEl: o,
      overlayPositioning: n,
      placement: i2,
      flipPlacements: a,
      type: "menu"
    }, t);
  }
  /**
   * Scrolls the component's content to a specified set of coordinates.
   *
   * @example
   * myAutocomplete.scrollContentTo({
   *   left: 0, // Specifies the number of pixels along the X axis to scroll the window or element.
   *   top: 0, // Specifies the number of pixels along the Y axis to scroll the window or element
   *   behavior: "auto" // Specifies whether the scrolling should animate smoothly (smooth), or happen instantly in a single jump (auto, the default value).
   * });
   * @param options - allows specific coordinates to be defined.
   * @returns - promise that resolves once the content is scrolled to.
   */
  async scrollContentTo(t) {
    var _a;
    (_a = this.transitionEl) == null ? void 0 : _a.scrollTo(t);
  }
  /**
   * Selects the text of the component's `value`.
   *
   * @returns {Promise<void>}
   */
  async selectText() {
    return this.referenceEl.selectText();
  }
  /**
   * Sets focus on the component's first focusable element.
   *
   * @returns {Promise<void>}
   */
  async setFocus() {
    return this.referenceEl.setFocus();
  }
  connectedCallback() {
    var _a;
    super.connectedCallback(), (_a = this.mutationObserver) == null ? void 0 : _a.observe(this.el, { childList: true, subtree: true }), v(this), D(this), this.defaultInputValue = this.inputValue || "", this.getAllItemsDebounced(), ct(this);
  }
  async load() {
    this.getAllItemsDebounced();
  }
  willUpdate(t) {
    t.has("disabled") && (this.hasUpdated || this.disabled !== false) && this.handleDisabledChange(this.disabled), t.has("flipPlacements") && this.reposition(true), t.has("open") && (this.hasUpdated || this.open !== false) && this.openHandler(), t.has("overlayPositioning") && (this.hasUpdated || this.overlayPositioning !== "absolute") && this.reposition(true), t.has("placement") && (this.hasUpdated || this.placement !== ot2) && this.reposition(true);
    let e = false;
    t.has("inputValue") && (this.hasUpdated || this.inputValue) && (this.inputValueMatchPattern = this.inputValue && new RegExp(`(${escapeRegExp_default(this.inputValue)})`, "i"), this.updateItems(), this.updateGroups(), e = true), !e && t.has("scale") && (this.hasUpdated || this.scale !== "m") && (this.updateItems(), this.updateGroups(), e = true), !e && t.has("activeIndex") && (this.hasUpdated || this.activeIndex !== -1) && this.updateItems();
  }
  updated() {
    m(this);
  }
  loaded() {
    O(this, this.value || ""), this.defaultInputValue = this.inputValue || "", ct(this);
  }
  disconnectedCallback() {
    var _a, _b;
    super.disconnectedCallback(), (_a = this.mutationObserver) == null ? void 0 : _a.disconnect(), (_b = this.resizeObserver) == null ? void 0 : _b.disconnect(), T(this), W(this), Y(this);
  }
  // #endregion
  // #region Private Methods
  setFloatingElSize() {
    const { referenceEl: t, floatingEl: e } = this;
    !t || !e || (e.style.inlineSize = `${t.clientWidth}px`);
  }
  handleGlobalAttributesChanged() {
    this.requestUpdate();
  }
  handleDisabledChange(t) {
    t || (this.open = false);
  }
  openHandler() {
    if (s2(this), this.open || (this.activeIndex = -1), this.disabled) {
      this.open = false;
      return;
    }
    this.setFloatingElSize(), this.reposition(true);
  }
  async documentClickHandler(t) {
    this.disabled || t.composedPath().includes(this.el) || (this.open = false);
  }
  async handleInternalAutocompleteItemSelect(t) {
    this.value = t.target.value, t.stopPropagation(), this.emitChange(), await this.setFocus(), this.open = false;
  }
  onLabelClick() {
    this.setFocus();
  }
  onFormReset() {
    this.inputValue = this.defaultInputValue;
  }
  onBeforeOpen() {
    this.calciteAutocompleteBeforeOpen.emit();
  }
  onOpen() {
    this.calciteAutocompleteOpen.emit();
  }
  onBeforeClose() {
    this.calciteAutocompleteBeforeClose.emit();
  }
  onClose() {
    this.calciteAutocompleteClose.emit();
  }
  emitChange() {
    this.calciteAutocompleteChange.emit();
  }
  updateGroups() {
    this.groups.forEach((t, e, o) => {
      t.scale = this.scale, e === 0 && (t.disableSpacing = true);
      const i2 = o[e + 1];
      i2 && (i2.disableSpacing = t.children.length === 0);
    });
  }
  updateItems() {
    let t = null;
    this.items.forEach((e) => {
      e.scale = this.scale, e.inputValueMatchPattern = this.inputValueMatchPattern;
    }), this.enabledItems.forEach((e, o) => {
      const i2 = o === this.activeIndex;
      i2 && (t = e.guid), e.active = i2;
    }), this.activeDescendant = t;
  }
  handleInputFocus() {
    this.open = true;
  }
  handleContentTopSlotChange(t) {
    this.hasContentTop = ot(t);
  }
  handleContentBottomSlotChange(t) {
    this.hasContentBottom = ot(t);
  }
  getAllItems() {
    const { el: t } = this;
    this.groups = Array.from(t.querySelectorAll(W2)), this.items = Array.from(t.querySelectorAll(K)), this.updateItems(), this.updateGroups();
  }
  setReferenceEl(t) {
    var _a;
    this.referenceEl = t, t && ((_a = this.resizeObserver) == null ? void 0 : _a.observe(t), ct(this));
  }
  keyDownHandler(t) {
    const { defaultPrevented: e, key: o } = t;
    if (e)
      return;
    const { open: i2, activeIndex: n, enabledItems: a } = this, u = a.length && n > -1 ? a[n] : null;
    switch (o) {
      case "Escape":
        i2 && (this.open = false, t.preventDefault());
        break;
      case "Tab":
        this.open = false;
        break;
      case "Enter":
        i2 && u ? (this.value = u.value, this.emitChange(), this.open = false, t.preventDefault()) : t.defaultPrevented || $(this) && t.preventDefault();
        break;
      case "ArrowDown":
        a.length && (this.open = true, this.activeIndex = n !== -1 ? Math.min(n + 1, a.length - 1) : 0, this.scrollToActiveItem(), t.preventDefault());
        break;
      case "ArrowUp":
        a.length && (this.open = true, this.activeIndex = n !== -1 ? Math.max(n - 1, 0) : a.length - 1, this.scrollToActiveItem(), t.preventDefault());
        break;
      case "Home":
        a.length && (this.open = true, this.activeIndex = 0, this.scrollToActiveItem(), t.preventDefault());
        break;
      case "End":
        a.length && (this.open = true, this.activeIndex = a.length - 1, this.scrollToActiveItem(), t.preventDefault());
        break;
    }
  }
  scrollToActiveItem() {
    var _a;
    (_a = this.enabledItems[this.activeIndex]) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }
  changeHandler(t) {
    t.stopPropagation(), this.inputValue = t.target.value, this.calciteAutocompleteTextChange.emit();
  }
  inputClickHandler(t) {
    t.defaultPrevented || (this.open = true);
  }
  inputHandler(t) {
    t.stopPropagation(), this.inputValue = t.target.value, this.calciteAutocompleteTextInput.emit();
  }
  setFloatingEl(t) {
    this.floatingEl = t, ct(this);
  }
  setTransitionEl(t) {
    t && (this.transitionEl = t);
  }
  // #endregion
  // #region Rendering
  render() {
    const { disabled: t, listId: e, inputId: o, isOpen: i2 } = this, n = this.el.autofocus, a = this.el.enterKeyHint, u = this.el.inputMode;
    return p({ disabled: t, children: html`<div class=${safeClassMap(l.inputContainer)}><calcite-input .alignment=${this.alignment} aria-activedescendant=${this.activeDescendant ?? nothing} aria-controls=${e ?? nothing} aria-owns=${e ?? nothing} aria-autocomplete=list .ariaExpanded=${i2} aria-haspopup=listbox .autocomplete=${this.autocomplete} .autofocus=${n} class=${safeClassMap(l.input)} clearable .disabled=${t} enterkeyhint=${a ?? nothing} .form=${this.form} .icon=${this.icon ?? true} .iconFlipRtl=${this.iconFlipRtl} id=${o ?? nothing} inputmode=${u ?? nothing} .label=${this.label} .loading=${this.loading} .maxLength=${this.maxLength} .messageOverrides=${this.messages} .minLength=${this.minLength} .name=${this.name} @click=${this.inputClickHandler} @keydown=${this.keyDownHandler} @calciteInputChange=${this.changeHandler} @calciteInputInput=${this.inputHandler} @calciteInternalInputFocus=${this.handleInputFocus} .pattern=${this.pattern} .placeholder=${this.placeholder} .prefixText=${this.prefixText} .readOnly=${this.readOnly} role=combobox .scale=${this.scale} .status=${this.status} .suffixText=${this.suffixText} type=search .value=${this.inputValue} ${ref(this.setReferenceEl)}></calcite-input>${this.renderListBox()}<div class=${safeClassMap({
      [l.contentContainer]: true,
      [l.floatingUIContainer]: true,
      [l.floatingUIContainerActive]: i2
    })} ${ref(this.setFloatingEl)}><div class=${safeClassMap({
      [l.contentAnimation]: true,
      [rt.animation]: true,
      [rt.animationActive]: i2
    })} ${ref(this.setTransitionEl)}><div class=${safeClassMap({ [l.content]: true, [l.contentHidden]: !i2 })}><slot name=${x.contentTop} @slotchange=${this.handleContentTopSlotChange}></slot><slot aria-hidden=true></slot><slot name=${x.contentBottom} @slotchange=${this.handleContentBottomSlotChange}></slot></div></div></div></div>${B({ component: this })}${this.validationMessage && this.status === "invalid" ? m2({ icon: this.validationIcon, id: q.validationMessage, message: this.validationMessage, scale: this.scale, status: this.status }) : null}` });
  }
  renderListBox() {
    return html`<ul aria-labelledby=${this.inputId ?? nothing} class=${safeClassMap(l.screenReadersOnly)} id=${this.listId ?? nothing} role=listbox tabindex=-1>${this.renderListBoxOptions()}</ul>`;
  }
  renderListBoxOptions() {
    return repeat(this.items.filter((t) => !!(t.label || t.heading)), (t) => t.guid, (t) => html`<li .ariaDisabled=${t.disabled} .ariaLabel=${t.label} id=${t.guid ?? nothing} role=option tabindex=-1>${t.heading}${t.description}</li>`);
  }
};
_j.properties = { activeDescendant: 16, activeIndex: 16, hasContentBottom: 16, hasContentTop: 16, items: 16, groups: 16, isOpen: 16, enabledItems: 16, alignment: 3, autocomplete: 0, disabled: 7, flipPlacements: 0, form: 3, icon: [3, { converter: stringOrBoolean }], iconFlipRtl: 7, inputValue: 1, label: 1, loading: 7, maxLength: 11, messageOverrides: 0, minLength: 11, name: 3, open: 7, overlayPositioning: 3, pattern: 1, placeholder: 1, placement: 3, prefixText: 1, readOnly: 7, required: 7, scale: 3, status: 3, suffixText: 1, validationIcon: [3, { converter: stringOrBoolean }], validationMessage: 1, validity: 0, value: 1 };
_j.styles = G;
var j = _j;
S("calcite-autocomplete", j);
export {
  j as Autocomplete
};
/*! Bundled license information:

@esri/calcite-components/dist/components/calcite-autocomplete/customElement.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=customElement-HUYTIZ5S.js.map
