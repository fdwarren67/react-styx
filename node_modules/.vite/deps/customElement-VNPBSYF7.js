import {
  E,
  H,
  L,
  S as S2,
  V,
  Z,
  b,
  g,
  j,
  q as q2
} from "./chunk-Y5WMMCVN.js";
import {
  FORMAT_DEFAULT,
  esm_default
} from "./chunk-XXFEQ7WW.js";
import "./chunk-E34MCIQH.js";
import {
  s as s2
} from "./chunk-7KANSCZF.js";
import {
  m as m4
} from "./chunk-4YU6FNSH.js";
import {
  m as m3
} from "./chunk-DPQ7TENX.js";
import {
  O,
  W as W2,
  q
} from "./chunk-ZHGVMVCT.js";
import {
  $,
  B,
  D,
  W
} from "./chunk-VLJE74YV.js";
import {
  I,
  T,
  v
} from "./chunk-YJUTXVD7.js";
import {
  m,
  p
} from "./chunk-VBBJGZOS.js";
import {
  e
} from "./chunk-A7MNUVGI.js";
import {
  m as m2,
  o
} from "./chunk-2GIEDWQ6.js";
import {
  ref
} from "./chunk-LTKIMXCE.js";
import {
  s
} from "./chunk-RZAGQ6CT.js";
import {
  mt
} from "./chunk-VQ5234AM.js";
import "./chunk-PXZ2RU65.js";
import "./chunk-S3EVYUV4.js";
import {
  S
} from "./chunk-B7E2AREE.js";
import {
  LitElement,
  createEvent,
  css,
  html,
  nothing,
  safeClassMap,
  stringOrBoolean
} from "./chunk-MALSDV7D.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/dayjs/esm/plugin/localizedFormat/utils.js
var t = function t2(format) {
  return format.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(_, a, b2) {
    return a || b2.slice(1);
  });
};
var englishFormats = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
var u = function u2(formatStr, formats) {
  return formatStr.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(_, a, b2) {
    var B2 = b2 && b2.toUpperCase();
    return a || formats[b2] || englishFormats[b2] || t(formats[B2]);
  });
};

// node_modules/dayjs/esm/plugin/customParseFormat/index.js
var formattingTokens = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g;
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match1to2 = /\d\d?/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /[+-]\d\d:?(\d\d)?|Z/;
var matchWord = /\d*[^-_:/,()\s\d]+/;
var locale = {};
var parseTwoDigitYear = function parseTwoDigitYear2(input) {
  input = +input;
  return input + (input > 68 ? 1900 : 2e3);
};
function offsetFromString(string) {
  if (!string) return 0;
  if (string === "Z") return 0;
  var parts = string.match(/([+-]|\d\d)/g);
  var minutes = +(parts[1] * 60) + (+parts[2] || 0);
  return minutes === 0 ? 0 : parts[0] === "+" ? -minutes : minutes;
}
var addInput = function addInput2(property) {
  return function(input) {
    this[property] = +input;
  };
};
var zoneExpressions = [matchOffset, function(input) {
  var zone = this.zone || (this.zone = {});
  zone.offset = offsetFromString(input);
}];
var getLocalePart = function getLocalePart2(name) {
  var part = locale[name];
  return part && (part.indexOf ? part : part.s.concat(part.f));
};
var meridiemMatch = function meridiemMatch2(input, isLowerCase) {
  var isAfternoon;
  var _locale = locale, meridiem = _locale.meridiem;
  if (!meridiem) {
    isAfternoon = input === (isLowerCase ? "pm" : "PM");
  } else {
    for (var i = 1; i <= 24; i += 1) {
      if (input.indexOf(meridiem(i, 0, isLowerCase)) > -1) {
        isAfternoon = i > 12;
        break;
      }
    }
  }
  return isAfternoon;
};
var expressions = {
  A: [matchWord, function(input) {
    this.afternoon = meridiemMatch(input, false);
  }],
  a: [matchWord, function(input) {
    this.afternoon = meridiemMatch(input, true);
  }],
  Q: [match1, function(input) {
    this.month = (input - 1) * 3 + 1;
  }],
  S: [match1, function(input) {
    this.milliseconds = +input * 100;
  }],
  SS: [match2, function(input) {
    this.milliseconds = +input * 10;
  }],
  SSS: [match3, function(input) {
    this.milliseconds = +input;
  }],
  s: [match1to2, addInput("seconds")],
  ss: [match1to2, addInput("seconds")],
  m: [match1to2, addInput("minutes")],
  mm: [match1to2, addInput("minutes")],
  H: [match1to2, addInput("hours")],
  h: [match1to2, addInput("hours")],
  HH: [match1to2, addInput("hours")],
  hh: [match1to2, addInput("hours")],
  D: [match1to2, addInput("day")],
  DD: [match2, addInput("day")],
  Do: [matchWord, function(input) {
    var _locale2 = locale, ordinal = _locale2.ordinal;
    var _input$match = input.match(/\d+/);
    this.day = _input$match[0];
    if (!ordinal) return;
    for (var i = 1; i <= 31; i += 1) {
      if (ordinal(i).replace(/\[|\]/g, "") === input) {
        this.day = i;
      }
    }
  }],
  w: [match1to2, addInput("week")],
  ww: [match2, addInput("week")],
  M: [match1to2, addInput("month")],
  MM: [match2, addInput("month")],
  MMM: [matchWord, function(input) {
    var months = getLocalePart("months");
    var monthsShort = getLocalePart("monthsShort");
    var matchIndex = (monthsShort || months.map(function(_) {
      return _.slice(0, 3);
    })).indexOf(input) + 1;
    if (matchIndex < 1) {
      throw new Error();
    }
    this.month = matchIndex % 12 || matchIndex;
  }],
  MMMM: [matchWord, function(input) {
    var months = getLocalePart("months");
    var matchIndex = months.indexOf(input) + 1;
    if (matchIndex < 1) {
      throw new Error();
    }
    this.month = matchIndex % 12 || matchIndex;
  }],
  Y: [matchSigned, addInput("year")],
  YY: [match2, function(input) {
    this.year = parseTwoDigitYear(input);
  }],
  YYYY: [match4, addInput("year")],
  Z: zoneExpressions,
  ZZ: zoneExpressions
};
function correctHours(time) {
  var afternoon = time.afternoon;
  if (afternoon !== void 0) {
    var hours = time.hours;
    if (afternoon) {
      if (hours < 12) {
        time.hours += 12;
      }
    } else if (hours === 12) {
      time.hours = 0;
    }
    delete time.afternoon;
  }
}
function makeParser(format) {
  format = u(format, locale && locale.formats);
  var array = format.match(formattingTokens);
  var length = array.length;
  for (var i = 0; i < length; i += 1) {
    var token = array[i];
    var parseTo = expressions[token];
    var regex = parseTo && parseTo[0];
    var parser = parseTo && parseTo[1];
    if (parser) {
      array[i] = {
        regex,
        parser
      };
    } else {
      array[i] = token.replace(/^\[|\]$/g, "");
    }
  }
  return function(input) {
    var time = {};
    for (var _i = 0, start = 0; _i < length; _i += 1) {
      var _token = array[_i];
      if (typeof _token === "string") {
        start += _token.length;
      } else {
        var _regex = _token.regex, _parser = _token.parser;
        var part = input.slice(start);
        var match = _regex.exec(part);
        var value = match[0];
        _parser.call(time, value);
        input = input.replace(value, "");
      }
    }
    correctHours(time);
    return time;
  };
}
var parseFormattedInput = function parseFormattedInput2(input, format, utc, dayjs) {
  try {
    if (["x", "X"].indexOf(format) > -1) return new Date((format === "X" ? 1e3 : 1) * input);
    var parser = makeParser(format);
    var _parser2 = parser(input), year = _parser2.year, month = _parser2.month, day = _parser2.day, hours = _parser2.hours, minutes = _parser2.minutes, seconds = _parser2.seconds, milliseconds = _parser2.milliseconds, zone = _parser2.zone, week = _parser2.week;
    var now = /* @__PURE__ */ new Date();
    var d = day || (!year && !month ? now.getDate() : 1);
    var y2 = year || now.getFullYear();
    var M = 0;
    if (!(year && !month)) {
      M = month > 0 ? month - 1 : now.getMonth();
    }
    var h = hours || 0;
    var m5 = minutes || 0;
    var s3 = seconds || 0;
    var ms = milliseconds || 0;
    if (zone) {
      return new Date(Date.UTC(y2, M, d, h, m5, s3, ms + zone.offset * 60 * 1e3));
    }
    if (utc) {
      return new Date(Date.UTC(y2, M, d, h, m5, s3, ms));
    }
    var newDate;
    newDate = new Date(y2, M, d, h, m5, s3, ms);
    if (week) {
      newDate = dayjs(newDate).week(week).toDate();
    }
    return newDate;
  } catch (e2) {
    return /* @__PURE__ */ new Date("");
  }
};
var customParseFormat_default = function(o2, C, d) {
  d.p.customParseFormat = true;
  if (o2 && o2.parseTwoDigitYear) {
    parseTwoDigitYear = o2.parseTwoDigitYear;
  }
  var proto = C.prototype;
  var oldParse = proto.parse;
  proto.parse = function(cfg) {
    var date = cfg.date, utc = cfg.utc, args = cfg.args;
    this.$u = utc;
    var format = args[1];
    if (typeof format === "string") {
      var isStrictWithoutLocale = args[2] === true;
      var isStrictWithLocale = args[3] === true;
      var isStrict = isStrictWithoutLocale || isStrictWithLocale;
      var pl = args[2];
      if (isStrictWithLocale) {
        pl = args[2];
      }
      locale = this.$locale();
      if (!isStrictWithoutLocale && pl) {
        locale = d.Ls[pl];
      }
      this.$d = parseFormattedInput(date, format, utc, d);
      this.init();
      if (pl && pl !== true) this.$L = this.locale(pl).$L;
      if (isStrict && date != this.format(format)) {
        this.$d = /* @__PURE__ */ new Date("");
      }
      locale = {};
    } else if (format instanceof Array) {
      var len = format.length;
      for (var i = 1; i <= len; i += 1) {
        args[1] = format[i - 1];
        var result = d.apply(this, args);
        if (result.isValid()) {
          this.$d = result.$d;
          this.$L = result.$L;
          this.init();
          break;
        }
        if (i === len) this.$d = /* @__PURE__ */ new Date("");
      }
    } else {
      oldParse.call(this, cfg);
    }
  };
};

// node_modules/dayjs/esm/plugin/localeData/index.js
var localeData_default = function(o2, c, dayjs) {
  var proto = c.prototype;
  var getLocalePart3 = function getLocalePart4(part) {
    return part && (part.indexOf ? part : part.s);
  };
  var getShort = function getShort2(ins, target, full, num, localeOrder) {
    var locale2 = ins.name ? ins : ins.$locale();
    var targetLocale = getLocalePart3(locale2[target]);
    var fullLocale = getLocalePart3(locale2[full]);
    var result = targetLocale || fullLocale.map(function(f) {
      return f.slice(0, num);
    });
    if (!localeOrder) return result;
    var weekStart = locale2.weekStart;
    return result.map(function(_, index) {
      return result[(index + (weekStart || 0)) % 7];
    });
  };
  var getDayjsLocaleObject = function getDayjsLocaleObject2() {
    return dayjs.Ls[dayjs.locale()];
  };
  var getLongDateFormat = function getLongDateFormat2(l, format) {
    return l.formats[format] || t(l.formats[format.toUpperCase()]);
  };
  var localeData = function localeData2() {
    var _this = this;
    return {
      months: function months(instance) {
        return instance ? instance.format("MMMM") : getShort(_this, "months");
      },
      monthsShort: function monthsShort(instance) {
        return instance ? instance.format("MMM") : getShort(_this, "monthsShort", "months", 3);
      },
      firstDayOfWeek: function firstDayOfWeek() {
        return _this.$locale().weekStart || 0;
      },
      weekdays: function weekdays(instance) {
        return instance ? instance.format("dddd") : getShort(_this, "weekdays");
      },
      weekdaysMin: function weekdaysMin(instance) {
        return instance ? instance.format("dd") : getShort(_this, "weekdaysMin", "weekdays", 2);
      },
      weekdaysShort: function weekdaysShort(instance) {
        return instance ? instance.format("ddd") : getShort(_this, "weekdaysShort", "weekdays", 3);
      },
      longDateFormat: function longDateFormat(format) {
        return getLongDateFormat(_this.$locale(), format);
      },
      meridiem: this.$locale().meridiem,
      ordinal: this.$locale().ordinal
    };
  };
  proto.localeData = function() {
    return localeData.bind(this)();
  };
  dayjs.localeData = function() {
    var localeObject = getDayjsLocaleObject();
    return {
      firstDayOfWeek: function firstDayOfWeek() {
        return localeObject.weekStart || 0;
      },
      weekdays: function weekdays() {
        return dayjs.weekdays();
      },
      weekdaysShort: function weekdaysShort() {
        return dayjs.weekdaysShort();
      },
      weekdaysMin: function weekdaysMin() {
        return dayjs.weekdaysMin();
      },
      months: function months() {
        return dayjs.months();
      },
      monthsShort: function monthsShort() {
        return dayjs.monthsShort();
      },
      longDateFormat: function longDateFormat(format) {
        return getLongDateFormat(localeObject, format);
      },
      meridiem: localeObject.meridiem,
      ordinal: localeObject.ordinal
    };
  };
  dayjs.months = function() {
    return getShort(getDayjsLocaleObject(), "months");
  };
  dayjs.monthsShort = function() {
    return getShort(getDayjsLocaleObject(), "monthsShort", "months", 3);
  };
  dayjs.weekdays = function(localeOrder) {
    return getShort(getDayjsLocaleObject(), "weekdays", null, null, localeOrder);
  };
  dayjs.weekdaysShort = function(localeOrder) {
    return getShort(getDayjsLocaleObject(), "weekdaysShort", "weekdays", 3, localeOrder);
  };
  dayjs.weekdaysMin = function(localeOrder) {
    return getShort(getDayjsLocaleObject(), "weekdaysMin", "weekdays", 2, localeOrder);
  };
};

// node_modules/dayjs/esm/plugin/localizedFormat/index.js
var localizedFormat_default = function(o2, c, d) {
  var proto = c.prototype;
  var oldFormat = proto.format;
  d.en.formats = englishFormats;
  proto.format = function(formatStr) {
    if (formatStr === void 0) {
      formatStr = FORMAT_DEFAULT;
    }
    var _this$$locale = this.$locale(), _this$$locale$formats = _this$$locale.formats, formats = _this$$locale$formats === void 0 ? {} : _this$$locale$formats;
    var result = u(formatStr, formats);
    return oldFormat.call(this, result);
  };
};

// node_modules/dayjs/esm/plugin/preParsePostFormat/index.js
var preParsePostFormat_default = function(option, dayjsClass) {
  var oldParse = dayjsClass.prototype.parse;
  dayjsClass.prototype.parse = function(cfg) {
    if (typeof cfg.date === "string") {
      var locale2 = this.$locale();
      cfg.date = locale2 && locale2.preparse ? locale2.preparse(cfg.date) : cfg.date;
    }
    return oldParse.bind(this)(cfg);
  };
  var oldFormat = dayjsClass.prototype.format;
  dayjsClass.prototype.format = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var result = oldFormat.call.apply(oldFormat, [this].concat(args));
    var locale2 = this.$locale();
    return locale2 && locale2.postformat ? locale2.postformat(result) : result;
  };
  var oldFromTo = dayjsClass.prototype.fromToBase;
  if (oldFromTo) {
    dayjsClass.prototype.fromToBase = function(input, withoutSuffix, instance, isFrom) {
      var locale2 = this.$locale() || instance.$locale();
      return oldFromTo.call(this, input, withoutSuffix, instance, isFrom, locale2 && locale2.postformat);
    };
  }
};

// node_modules/dayjs/esm/plugin/updateLocale/index.js
var updateLocale_default = function(option, Dayjs, dayjs) {
  dayjs.updateLocale = function(locale2, customConfig) {
    var localeList = dayjs.Ls;
    var localeConfig = localeList[locale2];
    if (!localeConfig) return;
    var customConfigKeys = customConfig ? Object.keys(customConfig) : [];
    customConfigKeys.forEach(function(c) {
      localeConfig[c] = customConfig[c];
    });
    return localeConfig;
  };
};

// node_modules/@esri/calcite-components/dist/components/calcite-input-time-picker/customElement.js
var se = css`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:inline-block;-webkit-user-select:none;user-select:none}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}::slotted(input[slot=hidden-form-input]){margin:0!important;opacity:0!important;outline:none!important;padding:0!important;position:absolute!important;inset:0!important;transform:none!important;-webkit-appearance:none!important;z-index:-1!important}:host([scale=s]){--calcite-toggle-spacing: .5rem;--calcite-internal-input-text-input-padding-inline-end: calc(var(--calcite-toggle-spacing) + 1rem)}:host([scale=m]){--calcite-toggle-spacing: .75rem;--calcite-internal-input-text-input-padding-inline-end: calc(var(--calcite-toggle-spacing) + 1.5rem)}:host([scale=l]){--calcite-toggle-spacing: 1rem;--calcite-internal-input-text-input-padding-inline-end: calc(var(--calcite-toggle-spacing) + 2rem)}.input-wrapper{position:relative}.toggle-icon{position:absolute;display:flex;cursor:pointer;align-items:center;inset-inline-end:0;inset-block:0;padding-inline:var(--calcite-toggle-spacing);--calcite-icon-color: var(--calcite-color-text-3)}.input-wrapper:hover .toggle-icon,calcite-input-text:focus+.toggle-icon{--calcite-icon-color: var(--calcite-color-text-1)}.validation-container{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}:host([scale=m]) .validation-container,:host([scale=l]) .validation-container{padding-block-start:.5rem}:host([scale=s]) .validation-container{padding-block-start:.25rem}:host([hidden]){display:none}[hidden]{display:none}`;
var ae = {
  toggleIcon: "toggle-icon"
};
var y = {
  validationMessage: "inputTimePickerValidationMessage"
};
var oe = /* @__PURE__ */ new Map([
  ["ar", () => import("./ar-6R7FGPLC.js")],
  ["bg", () => import("./bg-VN3MTNLZ.js")],
  ["bs", () => import("./bs-6MR2EHWP.js")],
  ["ca", () => import("./ca-N7GUK3AH.js")],
  ["cs", () => import("./cs-GH3PDJRP.js")],
  ["da", () => import("./da-L27VBC6X.js")],
  ["de", () => import("./de-LKUR5B6M.js")],
  ["de-at", () => import("./de-at-NWHUDMOZ.js")],
  ["de-ch", () => import("./de-ch-G253CUHZ.js")],
  ["el", () => import("./el-HFNTGYW6.js")],
  ["en", () => import("./en-CFKIIG5P.js")],
  ["en-au", () => import("./en-au-TOY7ITPP.js")],
  ["en-ca", () => import("./en-ca-N25YVMJI.js")],
  ["en-gb", () => import("./en-gb-2MBUKL4H.js")],
  ["es", () => import("./es-U7UQJOTM.js")],
  ["es-mx", () => import("./es-mx-ZZ2ZPLUY.js")],
  ["et", () => import("./et-IHRALJDH.js")],
  ["fi", () => import("./fi-HNVHAOAU.js")],
  ["fr", () => import("./fr-IULUFILR.js")],
  ["fr-ch", () => import("./fr-ch-ZINIJPSP.js")],
  ["he", () => import("./he-AM6GJ2ZH.js")],
  ["hi", () => import("./hi-LNAAVVI2.js")],
  ["hr", () => import("./hr-OQ7HQR2B.js")],
  ["hu", () => import("./hu-ZDBWJPIU.js")],
  ["id", () => import("./id-7C5LJDUY.js")],
  ["it", () => import("./it-AWMDEI5A.js")],
  ["it-ch", () => import("./it-ch-KDD3F3XH.js")],
  ["ja", () => import("./ja-KNYSAER3.js")],
  ["ko", () => import("./ko-7PUDUZ5K.js")],
  ["lt", () => import("./lt-P7CD3RJZ.js")],
  ["lv", () => import("./lv-3G7FSCUS.js")],
  ["mk", () => import("./mk-7PY3VEZ2.js")],
  ["nl", () => import("./nl-AKJD2WZ2.js")],
  ["nb", () => import("./nb-STE52PLO.js")],
  ["pl", () => import("./pl-GSGMOKQK.js")],
  ["pt", () => import("./pt-5LSWFJTF.js")],
  ["pt-br", () => import("./pt-br-BLBALAPX.js")],
  ["ro", () => import("./ro-SQRYTJ5L.js")],
  ["ru", () => import("./ru-F5S44S3A.js")],
  ["sk", () => import("./sk-EDCB4OQ6.js")],
  ["sl", () => import("./sl-IXOG465Y.js")],
  ["sr", () => import("./sr-JJL3JVDB.js")],
  ["sv", () => import("./sv-MDW7A4VD.js")],
  ["th", () => import("./th-SILBVHHQ.js")],
  ["tr", () => import("./tr-Q5DZ67AM.js")],
  ["uk", () => import("./uk-YVTTYXYV.js")],
  ["vi", () => import("./vi-J24HQDKR.js")],
  ["zh-cn", () => import("./zh-cn-LGZSO7HI.js")],
  ["zh-hk", () => import("./zh-hk-NU5VWZBN.js")],
  ["zh-tw", () => import("./zh-tw-3OVIGSTB.js")]
]);
esm_default.extend(customParseFormat_default);
esm_default.extend(localeData_default);
esm_default.extend(localizedFormat_default);
esm_default.extend(preParsePostFormat_default);
esm_default.extend(updateLocale_default);
var _le = class _le extends LitElement {
  // #endregion
  // #region Lifecycle
  constructor() {
    super(), this.userChangedValue = false, this._value = null, this.disabled = false, this.focusTrapDisabled = false, this.hourFormat = "user", this.messages = s(), this.open = false, this.overlayPositioning = "absolute", this.placement = "auto", this.readOnly = false, this.required = false, this.scale = "m", this.status = "idle", this.step = 60, this.validity = {
      valid: false,
      badInput: false,
      customError: false,
      patternMismatch: false,
      rangeOverflow: false,
      rangeUnderflow: false,
      stepMismatch: false,
      tooLong: false,
      tooShort: false,
      typeMismatch: false,
      valueMissing: false
    }, this.calciteInputTimePickerBeforeClose = createEvent({ cancelable: false }), this.calciteInputTimePickerBeforeOpen = createEvent({ cancelable: false }), this.calciteInputTimePickerChange = createEvent(), this.calciteInputTimePickerClose = createEvent({ cancelable: false }), this.calciteInputTimePickerOpen = createEvent({ cancelable: false }), this.setLocalizedInputValue = (e2) => {
      this.setInputValue(this.getLocalizedTimeString(e2));
    }, this.listen("blur", this.hostBlurHandler), this.listen("keydown", this.keyDownHandler);
  }
  /** The time value in ISO (24-hour) format. */
  get value() {
    return this._value;
  }
  set value(e2) {
    const t3 = this._value;
    e2 !== t3 && (this._value = e2, this.valueWatcher(e2));
  }
  // #endregion
  // #region Public Methods
  /**
   * Updates the position of the component.
   *
   * @param delayed If true, delay the repositioning.
   */
  async reposition(e2 = false) {
    var _a;
    (_a = this.popoverEl) == null ? void 0 : _a.reposition(e2);
  }
  /** Sets focus on the component. */
  async setFocus() {
    await m2(this), mt(this.el);
  }
  connectedCallback() {
    super.connectedCallback(), g(this.value) ? this.setValueDirectly(this.value) : this.value = void 0, v(this), D(this);
  }
  async load() {
    await this.loadLocaleData(), this.updateLocale();
  }
  willUpdate(e2) {
    e2.has("open") && (this.hasUpdated || this.open !== false) && this.openHandler(), e2.has("disabled") && (this.hasUpdated || this.disabled !== false) && (this.disabled || (this.open = false)), e2.has("hourFormat") && this.updateLocale(), e2.has("readOnly") && (this.hasUpdated || this.readOnly !== false) && (this.readOnly || (this.open = false)), e2.has("messages") && this.langWatcher(), e2.has("numberingSystem") && this.setLocalizedInputValue({ numberingSystem: e2.get("numberingSystem") }), e2.has("step") && (this.hasUpdated || this.step !== 60) && this.stepWatcher(this.step, e2.get("step"));
  }
  updated() {
    m(this);
  }
  loaded() {
    g(this.value) && this.setLocalizedInputValue();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), T(this), W(this);
  }
  // #endregion
  // #region Private Methods
  async langWatcher() {
    await this.loadLocaleData(), this.updateLocale();
  }
  openHandler() {
    this.disabled || this.readOnly || this.popoverEl && (this.popoverEl.open = this.open);
  }
  stepWatcher(e2, t3) {
    (t3 >= 60 && e2 > 0 && e2 < 60 || e2 >= 60 && t3 > 0 && t3 < 60) && this.setValueDirectly(this.value);
  }
  valueWatcher(e2) {
    this.userChangedValue || this.setValueDirectly(e2), this.userChangedValue = false;
  }
  hostBlurHandler() {
    const e2 = this.delocalizeTimeString(this.calciteInputEl.value);
    e2 ? e2 !== this.value && (this.setValue(e2), this.setLocalizedInputValue()) : this.setValue(""), this.deactivate();
  }
  calciteInternalInputFocusHandler(e2) {
    this.readOnly || e2.stopPropagation();
  }
  calciteInternalInputInputHandler(e2) {
    const { messages: { _lang: t3 }, numberingSystem: i } = this;
    if (i && i !== "latn") {
      const s3 = e2.target;
      q.numberFormatOptions = {
        locale: t3,
        numberingSystem: i,
        useGrouping: false
      };
      const l = q.delocalize(s3.value).split("").map((o2) => e.includes(o2) ? q.numberFormatter.format(Number(o2)) : o2).join("");
      this.setInputValue(l);
    }
  }
  timePickerChangeHandler(e2) {
    e2.stopPropagation();
    const i = e2.target.value, s3 = this.shouldIncludeSeconds();
    this.setValue(q2(i, s3)), this.setLocalizedInputValue({ isoTimeString: i });
  }
  updateLocale(e2 = this.messages._lang) {
    this.effectiveHourFormat = this.hourFormat === "user" ? b(this.messages._lang) : this.hourFormat, this.localeDefaultLTFormat = this.localeConfig.formats.LT, this.localeDefaultLTSFormat = this.localeConfig.formats.LTS, this.setLocalizedInputValue({ locale: e2 });
  }
  popoverBeforeOpenHandler(e2) {
    e2.stopPropagation(), this.calciteInputTimePickerBeforeOpen.emit();
  }
  popoverOpenHandler(e2) {
    e2.stopPropagation(), this.calciteInputTimePickerOpen.emit();
  }
  popoverBeforeCloseHandler(e2) {
    e2.stopPropagation(), this.calciteInputTimePickerBeforeClose.emit();
  }
  popoverCloseHandler(e2) {
    e2.stopPropagation(), this.calciteInputTimePickerClose.emit(), this.open = false;
  }
  syncHiddenFormInput(e2) {
    m4("time", this, e2);
  }
  delocalizeTimeString(e2) {
    esm_default.locale(this.getSupportedDayjsLocale(this.messages._lang.toLowerCase()));
    const t3 = this.delocalizeTimeStringToParts(e2);
    let i;
    if (this.shouldIncludeFractionalSeconds()) {
      const s3 = s2(this.step), l = this.delocalizeTimeStringToParts(e2, "S");
      if (s3 === 1)
        i = l.millisecond !== 0 ? this.getTimeStringFromParts(l) : this.getTimeStringFromParts(t3);
      else {
        const o2 = this.delocalizeTimeStringToParts(e2, "SS");
        if (s3 === 2)
          o2.millisecond !== 0 ? i = this.getTimeStringFromParts(o2) : l.millisecond !== 0 ? i = this.getTimeStringFromParts(l) : i = this.getTimeStringFromParts(t3);
        else if (s3 >= 3) {
          const n = this.delocalizeTimeStringToParts(e2, "SSS");
          n.millisecond !== 0 ? i = this.getTimeStringFromParts(n) : o2.millisecond !== 0 ? i = this.getTimeStringFromParts(o2) : l.millisecond !== 0 ? i = this.getTimeStringFromParts(l) : i = this.getTimeStringFromParts(t3);
        }
      }
    } else
      i = this.getTimeStringFromParts(t3);
    return i;
  }
  delocalizeTimeStringToParts(e2, t3) {
    const i = this.messages._lang;
    let s3 = e2;
    const l = Z(this.effectiveHourFormat, i) ? H(i) : b(i);
    if (W2.has(i) && l === "12") {
      const n = W2.get(i).am, a = W2.get(i).pm, c = E(i), m5 = c === c.toUpperCase() ? "AM" : "am", d = c === c.toUpperCase() ? "PM" : "pm";
      s3 = s3.includes(a) ? s3.replaceAll(a, d) : s3.replaceAll(n, m5);
    }
    this.setLocaleTimeFormat({
      fractionalSecondFormatToken: t3,
      hourFormat: l
    });
    const o2 = esm_default(s3, ["LTS", "LT"]);
    return o2.isValid() ? {
      hour: o2.get("hour"),
      minute: o2.get("minute"),
      second: o2.get("second"),
      millisecond: o2.get("millisecond")
    } : {
      hour: null,
      minute: null,
      second: null,
      millisecond: null
    };
  }
  getTimeStringFromParts(e2) {
    let t3 = "";
    if (!e2)
      return t3;
    if (e2.hour !== null && e2.minute !== null && (t3 = `${S2(e2.hour)}:${S2(e2.minute)}`, this.shouldIncludeSeconds() && e2.second !== null && (t3 += `:${S2(e2.second)}`, this.shouldIncludeFractionalSeconds() && e2.millisecond !== null))) {
      const i = (e2.millisecond * 1e-3).toFixed(s2(this.step));
      t3 += `.${i.toString().replace("0.", "")}`;
    }
    return t3;
  }
  keyDownHandler(e2) {
    const { defaultPrevented: t3, key: i } = e2;
    if (!t3)
      if (i === "Enter") {
        if ($(this) && (e2.preventDefault(), this.calciteInputEl.setFocus()), e2.composedPath().includes(this.calciteTimePickerEl))
          return;
        const s3 = this.delocalizeTimeString(this.calciteInputEl.value);
        g(s3) ? (this.setValue(s3), this.setLocalizedInputValue()) : this.setValue("");
      } else i === "ArrowDown" ? (this.open = true, e2.preventDefault()) : this.open && this.focusTrapDisabled && i === "Escape" && (this.open = false, e2.preventDefault());
  }
  getSupportedDayjsLocale(e2) {
    const t3 = e2.toLowerCase();
    return t3 === "no" ? "nb" : t3 === "pt-pt" ? "pt" : t3;
  }
  async loadLocaleData() {
    let e2 = O(this.messages._lang).toLowerCase();
    e2 = this.getSupportedDayjsLocale(e2);
    const { default: t3 } = await oe.get(e2)();
    this.localeConfig = t3, esm_default.locale(this.localeConfig, null, true), esm_default.updateLocale(e2, this.getExtendedLocaleConfig(e2));
  }
  getExtendedLocaleConfig(e2) {
    if (e2 === "ar")
      return {
        meridiem: (t3) => t3 > 12 ? "م" : "ص",
        formats: {
          LT: "h:mm a",
          LTS: "h:mm:ss a",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY h:mm a",
          LLLL: "dddd D MMMM YYYY h:mm a"
        }
      };
    if (e2 === "en-au")
      return {
        meridiem: (t3) => t3 > 12 ? "pm" : "am"
      };
    if (e2 === "en-ca")
      return {
        meridiem: (t3) => t3 > 12 ? "p.m." : "a.m."
      };
    if (e2 === "el")
      return {
        meridiem: (t3) => t3 > 12 ? "μ.μ." : "π.μ."
      };
    if (e2 === "es-mx")
      return {
        formats: {
          LT: "h:mm a",
          LTS: "h:mm:ss a",
          L: "DD/MM/YYYY",
          LL: "D [de] MMMM [de] YYYY",
          LLL: "D [de] MMMM [de] YYYY H:mm",
          LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        }
      };
    if (e2 === "hi")
      return {
        formats: {
          LT: "h:mm A",
          LTS: "h:mm:ss A",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY, h:mm A",
          LLLL: "dddd, D MMMM YYYY, h:mm A"
        },
        meridiem: (t3) => t3 > 12 ? "pm" : "am"
      };
    if (e2 === "ja")
      return {
        meridiem: (t3) => t3 > 12 ? "午後" : "午前"
      };
    if (e2 === "ko")
      return {
        meridiem: (t3) => t3 > 12 ? "오후" : "오전"
      };
    if (e2 === "no")
      return {
        meridiem: (t3) => t3 > 12 ? "p.m." : "a.m."
      };
    if (e2 === "ru")
      return {
        meridiem: (t3) => t3 > 12 ? "PM" : "AM"
      };
    if (e2 === "zh-cn")
      return {
        meridiem: (t3) => t3 > 12 ? "下午" : "上午"
      };
    if (e2 === "zh-tw")
      return {
        formats: {
          LT: "Ah:mm",
          LTS: "Ah:mm:ss"
        }
      };
    if (e2 === "zh-hk")
      return {
        formats: {
          LT: "Ah:mm",
          LTS: "Ah:mm:ss"
        },
        meridiem: (t3) => t3 > 12 ? "下午" : "上午"
      };
  }
  getLocalizedTimeString(e2) {
    const t3 = (e2 == null ? void 0 : e2.hourFormat) === "12" || this.effectiveHourFormat && this.effectiveHourFormat === "12", i = (e2 == null ? void 0 : e2.locale) ?? this.messages._lang, s3 = (e2 == null ? void 0 : e2.numberingSystem) ?? this.numberingSystem, l = (e2 == null ? void 0 : e2.isoTimeString) ?? this.value;
    return j({
      fractionalSecondDigits: s2(this.step),
      hour12: t3,
      includeSeconds: this.shouldIncludeSeconds(),
      locale: i,
      numberingSystem: s3,
      value: l
    }) ?? "";
  }
  onLabelClick() {
    this.setFocus();
  }
  shouldIncludeSeconds() {
    return this.step < 60;
  }
  shouldIncludeFractionalSeconds() {
    return s2(this.step) > 0;
  }
  setCalcitePopoverEl(e2) {
    this.popoverEl = e2, this.openHandler();
  }
  setInputEl(e2) {
    e2 && (this.calciteInputEl = e2);
  }
  setCalciteTimePickerEl(e2) {
    e2 && (this.calciteTimePickerEl = e2);
  }
  setLocaleTimeFormat({ fractionalSecondFormatToken: e2, hourFormat: t3 }) {
    const i = this.messages._lang, s3 = b(i), l = /h+|H+/g, o2 = /\s+|a+|A+|\s+/g;
    let n = this.localeConfig.formats.LT, a = this.localeConfig.formats.LTS;
    if (t3 === "12" && s3 === "24") {
      const m5 = E(i), d = L(i);
      n = n.replaceAll(l, "h"), n = n.replaceAll(o2, ""), n = d === 0 ? `${m5}${n}` : `${n}${m5}`, a = a.replaceAll(l, "h"), a = a.replaceAll(o2, ""), a = d === 0 ? `${m5}${a}` : `${a}${m5}`;
    } else t3 === "24" && s3 === "12" ? (n = n.replaceAll(l, "H"), n = n.replaceAll(o2, ""), a = a.replaceAll(l, "H"), a = a.replaceAll(o2, "")) : (n = this.localeDefaultLTFormat, a = this.localeDefaultLTSFormat);
    const c = a == null ? void 0 : a.match(/ss\.*(S+)/g);
    if (e2 && this.shouldIncludeFractionalSeconds()) {
      const m5 = `ss.${e2}`;
      a = c ? a.replace(c[0], m5) : a.replace("ss", m5);
    } else c && (a = a.replace(c[0], "ss"));
    this.localeConfig.formats.LT = n, this.localeConfig.formats.LTS = a, esm_default.updateLocale(this.getSupportedDayjsLocale(O(i)), this.localeConfig);
  }
  setInputValue(e2) {
    this.calciteInputEl && (this.calciteInputEl.value = e2);
  }
  /**
   * Sets the value and emits a change event.
   * This is used to update the value as a result of user interaction.
   *
   * @param value The new value
   */
  setValue(e2) {
    const t3 = this.value, i = V(e2) || "";
    if (i === t3)
      return;
    this.userChangedValue = true, this.value = i || "", this.calciteInputTimePickerChange.emit().defaultPrevented && (this.userChangedValue = false, this.value = t3, this.setLocalizedInputValue({ isoTimeString: t3 }));
  }
  /**
   * Sets the value directly without emitting a change event.
   * This is used to update the value on initial load and when props change that are not the result of user interaction.
   *
   * @param value The new value
   */
  setValueDirectly(e2) {
    const t3 = this.shouldIncludeSeconds();
    this.value = q2(e2, t3), this.setLocalizedInputValue();
  }
  onInputWrapperClick() {
    this.open = !this.open;
  }
  deactivate() {
    this.open = false;
  }
  // #endregion
  // #region Rendering
  render() {
    const { disabled: e2, messages: t3, readOnly: i } = this;
    return p({ disabled: this.disabled, children: html`<div class="input-wrapper" @click=${this.onInputWrapperClick}><calcite-input-text aria-errormessage=${y.validationMessage} aria-autocomplete=none aria-haspopup=dialog .ariaInvalid=${this.status === "invalid"} .disabled=${e2} icon=clock .label=${I(this)} lang=${this.messages._lang ?? nothing} @calciteInputTextInput=${this.calciteInternalInputInputHandler} @calciteInternalInputTextFocus=${this.calciteInternalInputFocusHandler} .readOnly=${i} role=combobox .scale=${this.scale} .status=${this.status} ${ref(this.setInputEl)}>${!this.readOnly && this.renderToggleIcon(this.open) || ""}</calcite-input-text></div><calcite-popover auto-close .focusTrapDisabled=${this.focusTrapDisabled} .focusTrapOptions=${{ initialFocus: false }} .label=${t3.chooseTime} lang=${this.messages._lang ?? nothing} @calcitePopoverBeforeClose=${this.popoverBeforeCloseHandler} @calcitePopoverBeforeOpen=${this.popoverBeforeOpenHandler} @calcitePopoverClose=${this.popoverCloseHandler} @calcitePopoverOpen=${this.popoverOpenHandler} .overlayPositioning=${this.overlayPositioning} .placement=${this.placement} .referenceElement=${this.calciteInputEl} trigger-disabled ${ref(this.setCalcitePopoverEl)}><calcite-time-picker .hourFormat=${this.effectiveHourFormat} lang=${this.messages._lang ?? nothing} .messageOverrides=${this.messageOverrides} .numberingSystem=${this.numberingSystem} @calciteTimePickerChange=${this.timePickerChangeHandler} .scale=${this.scale} .step=${this.step} tabindex=${(this.open ? void 0 : -1) ?? nothing} .value=${this.value} ${ref(this.setCalciteTimePickerEl)}></calcite-time-picker></calcite-popover>${B({ component: this })}${this.validationMessage && this.status === "invalid" ? m3({ icon: this.validationIcon, id: y.validationMessage, message: this.validationMessage, scale: this.scale, status: this.status }) : null}` });
  }
  renderToggleIcon(e2) {
    return html`<span class=${safeClassMap(ae.toggleIcon)} slot=action><calcite-icon .icon=${e2 ? "chevron-up" : "chevron-down"} .scale=${o(this.scale)}></calcite-icon></span>`;
  }
};
_le.properties = { calciteInputEl: 16, effectiveHourFormat: 16, disabled: 7, focusTrapDisabled: 7, form: 3, hourFormat: 3, max: 3, messageOverrides: 0, min: 3, name: 1, numberingSystem: 1, open: 7, overlayPositioning: 1, placement: 3, readOnly: 7, required: 7, scale: 3, status: 3, step: 9, validationIcon: [3, { converter: stringOrBoolean }], validationMessage: 1, validity: 0, value: 1 };
_le.shadowRootOptions = { mode: "open", delegatesFocus: true };
_le.styles = se;
var le = _le;
S("calcite-input-time-picker", le);
export {
  le as InputTimePicker
};
/*! Bundled license information:

@esri/calcite-components/dist/components/calcite-input-time-picker/customElement.js:
  (*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
  See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
  v3.1.0 *)
*/
//# sourceMappingURL=customElement-VNPBSYF7.js.map
