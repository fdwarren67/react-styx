{
  "version": 3,
  "sources": ["../../timezone-groups/dist/groupByOffset/index.mjs"],
  "sourcesContent": ["import { timeZones } from '../utils/time-zones.mjs';\nimport { extractRegion, global } from '../utils/region.mjs';\nimport '../chunks/index-p4VH55K1.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractRegion(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: continent !== global,\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => extractRegion(label) !== global);\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n"],
  "mappings": "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",
  "names": ["startDate", "groupDateRange"]
}
