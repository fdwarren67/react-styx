import {
  c as c3
} from "./chunk-T6KBTBSK.js";
import {
  t as t11
} from "./chunk-SCVGJHDO.js";
import {
  l as l6,
  t as t16,
  u as u10
} from "./chunk-FXA7IN4W.js";
import {
  o as o7,
  y as y2
} from "./chunk-B5RWARUO.js";
import {
  t as t15
} from "./chunk-WXM4FNHD.js";
import {
  n as n8
} from "./chunk-25NL5TAZ.js";
import {
  D as D3,
  E as E5,
  _ as _2,
  a as a6,
  e as e11,
  h as h5,
  n as n9,
  r as r6,
  r2 as r7,
  t as t14,
  y as y3
} from "./chunk-FQNFQXI3.js";
import "./chunk-MVZZVRSZ.js";
import "./chunk-SHJSYZ5S.js";
import {
  A as A3
} from "./chunk-JKNB3ZUJ.js";
import {
  a as a5,
  c as c2,
  h as h4,
  m as m4,
  u as u9
} from "./chunk-ZKRVW5CM.js";
import "./chunk-7BISKPXG.js";
import {
  F as F5,
  q as q2,
  s as s9,
  t as t9
} from "./chunk-IVUWXWSD.js";
import "./chunk-4YDWJUBU.js";
import {
  t as t12
} from "./chunk-7M6HCFVM.js";
import {
  e as e10,
  i as i9,
  m as m5,
  t2 as t10
} from "./chunk-DTPSE2SE.js";
import {
  e as e9,
  n as n7
} from "./chunk-IZJLQDI2.js";
import {
  n as n6
} from "./chunk-WWSYO2TL.js";
import {
  i as i8,
  s as s8,
  x as x3
} from "./chunk-GGSQ5AVK.js";
import {
  e as e7,
  e2 as e8
} from "./chunk-AWVDCINM.js";
import {
  i as i7
} from "./chunk-HRH4AVCZ.js";
import "./chunk-ODSRB4EZ.js";
import {
  y
} from "./chunk-QT7O73SQ.js";
import "./chunk-R4CRYRS5.js";
import {
  E as E3,
  o as o6
} from "./chunk-NJX7X3PO.js";
import {
  t as t8
} from "./chunk-QDSJY67F.js";
import "./chunk-WA26GNQ4.js";
import "./chunk-P5AGQYYC.js";
import "./chunk-223G2GN7.js";
import "./chunk-CXHZI2CJ.js";
import "./chunk-55SEMSMA.js";
import "./chunk-BUZ7I3MJ.js";
import "./chunk-J2QYVOHP.js";
import {
  L as L4
} from "./chunk-PQUUCIML.js";
import "./chunk-NBFYN6KG.js";
import {
  i as i6
} from "./chunk-23WGP47N.js";
import "./chunk-PXIP6WLU.js";
import "./chunk-V4U366R3.js";
import {
  F as F4
} from "./chunk-ASXBCL66.js";
import "./chunk-DEMYZR3T.js";
import {
  l as l5
} from "./chunk-Z2KLKHIE.js";
import {
  r as r5
} from "./chunk-V7SQVFRS.js";
import "./chunk-3YC3Z7OQ.js";
import "./chunk-355MBCYM.js";
import {
  t2 as t7
} from "./chunk-KFLWTVQX.js";
import {
  e as e3
} from "./chunk-BXTQHJJG.js";
import {
  d as d6,
  f as f6,
  p as p2
} from "./chunk-T5R43RTD.js";
import {
  e as e4,
  i as i3,
  n as n5,
  t as t4,
  t2 as t5,
  te
} from "./chunk-7NXOMMLC.js";
import {
  f as f5,
  g,
  m as m3
} from "./chunk-F6YRPEY7.js";
import "./chunk-CCPDXL7V.js";
import {
  f as f4,
  u as u7
} from "./chunk-2TACZL27.js";
import "./chunk-PKIZUJIH.js";
import "./chunk-LL7BB425.js";
import {
  o as o5
} from "./chunk-CUWQEJ5X.js";
import "./chunk-MVYDN2TM.js";
import "./chunk-B7S3HUFO.js";
import {
  t as t6
} from "./chunk-6VF5U3IZ.js";
import "./chunk-E7IFPXEX.js";
import "./chunk-OK5AUMBT.js";
import "./chunk-R2ZUOHHV.js";
import {
  t as t3
} from "./chunk-OBVDE24U.js";
import "./chunk-OBRCQKKM.js";
import {
  a as a2
} from "./chunk-W5QWJI4E.js";
import "./chunk-5RGDMZ2O.js";
import "./chunk-SNZZPKBU.js";
import "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import "./chunk-NINPG5JV.js";
import {
  _
} from "./chunk-32RP26YL.js";
import {
  e as e12
} from "./chunk-NIAMDTBM.js";
import "./chunk-I2RHXV3Q.js";
import "./chunk-QSDQ7XKD.js";
import "./chunk-HUXEKERJ.js";
import "./chunk-NPEU24W6.js";
import {
  A as A2,
  E as E4,
  c2 as c4,
  e as e6,
  o as o8,
  t as t13
} from "./chunk-TOU5KPOG.js";
import "./chunk-6D65DCMG.js";
import {
  e as e5
} from "./chunk-GTVVYAXM.js";
import "./chunk-AU4QUDF3.js";
import "./chunk-XOXXDYBM.js";
import "./chunk-2PJ3OYOC.js";
import "./chunk-5BSH2ZN2.js";
import {
  a2 as a4,
  p as p3,
  w as w3
} from "./chunk-HQ2GCCLQ.js";
import "./chunk-6ZLHM6GW.js";
import "./chunk-TYJV2BHR.js";
import {
  a as a3,
  c,
  i as i4,
  s as s7
} from "./chunk-I6H2R562.js";
import "./chunk-WMLTK6KE.js";
import {
  i as i5
} from "./chunk-SURICA27.js";
import "./chunk-PBHST2SF.js";
import {
  C as C2,
  Ci,
  E as E2,
  Ei,
  Fi,
  J,
  S,
  U as U3,
  Ui,
  W,
  X,
  Y,
  ai,
  ei,
  oi,
  ti,
  u as u5,
  ui,
  wi
} from "./chunk-PONPGREB.js";
import {
  B as B2,
  C,
  D,
  E,
  F as F2,
  G,
  I as I2,
  L as L2,
  N,
  O as O2,
  P as P4,
  R,
  T,
  U as U2
} from "./chunk-QNYMCEB7.js";
import {
  n as n3,
  t as t2
} from "./chunk-T7CHWWE2.js";
import {
  M,
  b as b2,
  f as f2,
  h,
  l as l4,
  m as m2
} from "./chunk-FWVSIQMR.js";
import {
  B,
  I,
  l as l3,
  o as o2
} from "./chunk-4ACM2XXN.js";
import {
  o as o3
} from "./chunk-ON7GWFUW.js";
import {
  h as h2
} from "./chunk-VPRLLNNO.js";
import {
  P as P3
} from "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import "./chunk-6W3XFTHW.js";
import "./chunk-ZPDG5M3T.js";
import "./chunk-YUQ6PSJ2.js";
import {
  r as r4
} from "./chunk-SB6LU3VH.js";
import {
  u as u8
} from "./chunk-TKEIF3N7.js";
import "./chunk-ZDLUQDDX.js";
import "./chunk-XAZEJYKE.js";
import {
  A,
  D as D2,
  F as F3,
  H,
  I as I3,
  K,
  L as L3,
  N as N2,
  O as O3,
  T as T2,
  U as U4,
  b as b3,
  d as d5,
  f as f3,
  h as h3,
  o as o4,
  p,
  q,
  u as u6,
  w as w2,
  x as x2,
  z
} from "./chunk-62KPTW4J.js";
import {
  n as n4
} from "./chunk-UCDQUN5K.js";
import {
  d as d4,
  i as i2,
  ne,
  s as s6
} from "./chunk-OQEC2EUK.js";
import "./chunk-MRPAGZVF.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-4JVIG75S.js";
import "./chunk-HZLSEOMW.js";
import "./chunk-L2AVI4MN.js";
import "./chunk-4JHPTLMD.js";
import "./chunk-35I4PBUK.js";
import {
  O,
  U
} from "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-T52X5K2I.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-C33DSFWF.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import {
  u as u4
} from "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import {
  n as n2
} from "./chunk-D3P3E2RE.js";
import {
  P,
  d as d3
} from "./chunk-UKY33OJN.js";
import {
  d as d2
} from "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import {
  i
} from "./chunk-BJEQ2APY.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import {
  e as e2,
  u as u3
} from "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-CAN2PXNV.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import {
  s as s5,
  x
} from "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import {
  r,
  s
} from "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2
} from "./chunk-BECTSF5P.js";
import {
  St
} from "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import {
  r as r2
} from "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import {
  F
} from "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  L,
  b,
  e,
  f2 as f,
  l as l2,
  m,
  o4 as o,
  r as r3,
  s as s4,
  t2 as t,
  u,
  u3 as u2,
  w
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import {
  s as s3
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  a,
  l2 as l,
  n2 as n,
  s as s2
} from "./chunk-6II7WQ2F.js";
import {
  d,
  has
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/symbols/cim/animationUtils.js
function l7(t23, e15, r10) {
  return { transform: g2(t23, e15, r10.transform), fromColor: b4(t23, e15, r10.fromColor), toColor: I4(t23, e15, r10.toColor), colorMix: T3(t23, e15, r10.colorMix), toOpacity: h6(t23, e15, r10.toOpacity), opacityMix: k(t23, e15, r10.opacityMix), hasAnimations: r10.hasAnimations || !!e15.animations && e15.animations.length > 0 };
}
function p4(t23) {
  return !t9.forceStaticPath && (t9.forceAnimatedPath || t23.hasAnimations);
}
function f7(e15, r10, o14) {
  if ("CIMCharacterMarker" === r10.type) return n.getLogger("animationUtils").error("#handleMarker()", "CIM character markers do not support animations"), o14;
  const n17 = K(e15, r10, "OffsetX"), i14 = K(e15, r10, "OffsetY");
  if ("CIMPictureMarker" === r10.type) return { ...o14, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: R2([n17, i14]), rotation: R2(0), scale: R2(K(e15, r10, "Size")), parent: o14.transform } };
  const s15 = r10.frame, c12 = s15.ymax - s15.ymin;
  return { ...o14, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: R2([n17, i14]), rotation: R2(0), scale: R2({ type: "Process", op: "Divide", left: K(e15, r10, "Size"), right: c12 }), parent: o14.transform } };
}
function u11(t23, e15) {
  let r10 = 0, o14 = 0;
  const n17 = "Absolute" !== t23.anchorPointUnits;
  return t23.anchorPoint && (r10 = -t23.anchorPoint.x, o14 = -t23.anchorPoint.y), { ...e15, transform: { type: "AnimatedTransform", relativeTranslation: n17, absoluteScale: false, translation: R2([r10, o14]), rotation: R2(0), scale: R2(1), parent: e15.transform } };
}
function y4(t23, e15) {
  return "Absolute" === t23.anchorPointUnits ? e15 : u11(t23, e15);
}
function C3(t23, e15) {
  return "Absolute" !== t23.anchorPointUnits ? e15 : u11(t23, e15);
}
function M2(t23, e15, r10) {
  return { ...t23, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: R2([e15, r10]), rotation: R2(0), scale: R2(1), parent: t23.transform } };
}
function d7(t23, e15) {
  const r10 = e15 ? 0.5 * -(e15.xmin + e15.xmax) : 0, o14 = e15 ? 0.5 * -(e15.ymin + e15.ymax) : 0;
  let n17 = 0, a14 = 0;
  if ("x" in t23 && "y" in t23) n17 = t23.x + r10, a14 = t23.y + o14;
  else {
    const e16 = m4(t23);
    if (e16) {
      n17 = (e16[0] + e16[2]) / 2 + r10, a14 = (e16[1] + e16[3]) / 2 + o14;
    }
  }
  return [n17, a14];
}
function S2(t23, e15) {
  switch (e15.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return K(t23, e15, "Rotation");
  }
  return 0;
}
function A4(t23, e15) {
  switch (e15.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return K(t23, e15, "RotateClockwise");
  }
  return 0;
}
function P5(t23, e15) {
  switch (e15.type) {
    case "CIMPointSymbol":
    case "CIMVectorMarker":
      return [1, 1, 1, 1];
    case "CIMSolidStroke":
    case "CIMSolidFill":
      return K(t23, e15, "Color");
    case "CIMPictureMarker":
    case "CIMPictureStroke":
    case "CIMPictureFill":
      return K(t23, e15, "TintColor");
  }
  return [1, 1, 1, 1];
}
function g2(t23, e15, r10) {
  return { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: O4(t23, e15), rotation: D4(t23, e15), scale: x4(t23, e15), parent: r10 };
}
function b4(t23, e15, r10) {
  return { type: "AnimatedColor", color: R2(P5(t23, e15)), opacity: R2(1), parent: r10 };
}
function I4(t23, e15, r10) {
  const { animations: o14 } = e15;
  let n17 = P5(t23, e15);
  const i14 = o14 == null ? void 0 : o14.filter((t24) => "CIMSymbolAnimationColor" === t24.type)[0];
  return i14 && (n17 = K(t23, i14, "ToColor")), { type: "AnimatedColor", color: R2(n17), opacity: R2(1), parent: r10 };
}
function T3(t23, e15, r10) {
  const { animations: o14 } = e15, n17 = o14 == null ? void 0 : o14.filter((t24) => "CIMSymbolAnimationColor" === t24.type)[0];
  return n17 ? { type: "AnimatedColor", color: R2([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: v(t23, n17 == null ? void 0 : n17.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : r10;
}
function h6(t23, e15, r10) {
  const { animations: o14 } = e15;
  let n17 = R2(1);
  const i14 = o14 == null ? void 0 : o14.filter((t24) => "CIMSymbolAnimationTransparency" === t24.type)[0];
  if (i14) {
    n17 = R2({ type: "Process", op: "Transparency", value: K(t23, i14, "ToTransparency") });
  }
  return { type: "AnimatedColor", color: R2([1, 1, 1, 1]), opacity: n17, parent: r10 };
}
function k(t23, e15, r10) {
  const { animations: o14 } = e15, n17 = o14 == null ? void 0 : o14.filter((t24) => "CIMSymbolAnimationTransparency" === t24.type)[0];
  return n17 ? { type: "AnimatedColor", color: R2([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: v(t23, n17 == null ? void 0 : n17.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : r10;
}
function v(t23, e15) {
  if (!e15) return { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t7.Local, repeatType: d4.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 };
  const i14 = K(t23, e15, "Duration");
  let c12;
  if (K(t23, e15, "RandomizeStartTime")) {
    c12 = { type: "Process", op: "Random", min: 0, max: i14, seed: K(t23, e15, "RandomizeStartSeed") };
  } else c12 = K(t23, e15, "StartTimeOffset");
  const l15 = K(t23, e15, "RepeatDelay"), p8 = K(t23, e15, "PlayAnimation"), f12 = K(t23, e15, "ReverseAnimation"), u18 = h3(e15.repeatType, n4.CIMAnimatedSymbolProperties.repeattype);
  return { duration: i14, startTimeOffset: c12, repeatDelay: l15, timeOriginSelector: u18 === d4.None ? t7.Local : t7.Global, repeatType: u18, easing: h3(e15.easing, n4.CIMAnimatedSymbolProperties.easing), playAnimation: p8, reverseAnimation: f12 };
}
function x4(t23, e15) {
  const { animations: r10 } = e15;
  if ("CIMPictureMarker" !== e15.type && "CIMVectorMarker" !== e15.type && "CIMPointSymbol" !== e15.type) return R2(1);
  let o14;
  o14 = "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type ? K(t23, e15, "Size") : H(e15) || 10;
  const n17 = r10 == null ? void 0 : r10.filter((t24) => "CIMSymbolAnimationScale" === t24.type)[0];
  if (!n17) {
    const e16 = r10 == null ? void 0 : r10.filter((t24) => "CIMSymbolAnimationSize" === t24.type)[0];
    if (!e16) return R2(1);
    return { from: 1, to: { type: "Process", op: "Divide", left: K(t23, e16, "ToSize"), right: o14 }, timing: v(t23, e16.animatedSymbolProperties) };
  }
  return { from: 1, to: K(t23, n17, "ScaleFactor"), timing: v(t23, n17.animatedSymbolProperties) };
}
function O4(t23, e15) {
  const { animations: r10 } = e15, o14 = r10 == null ? void 0 : r10.filter((t24) => "CIMSymbolAnimationOffset" === t24.type)[0];
  if (!o14) return R2([0, 0]);
  return { from: [0, 0], to: [K(t23, o14, "OffsetX"), K(t23, o14, "OffsetY")], timing: v(t23, o14.animatedSymbolProperties) };
}
function D4(t23, e15) {
  const { animations: r10 } = e15, o14 = A4(t23, e15), n17 = { type: "Process", op: "Divide", left: S2(t23, e15), right: { type: "Process", op: "Cond", condition: o14, ifTrue: -1, ifFalse: 1 } }, i14 = r10 == null ? void 0 : r10.filter((t24) => "CIMSymbolAnimationRotation" === t24.type)[0];
  if (!i14) return R2(n17);
  const s15 = { type: "Process", op: "Add", left: K(t23, i14, "ToRotation"), right: { type: "Process", op: "Divide", left: n17, right: -1 } };
  return { from: n17, to: { type: "Process", op: "Add", left: n17, right: { type: "Process", op: "Cond", condition: K(t23, i14, "RotateClockwise"), ifTrue: { type: "Process", op: "MatchWinding", sign: -1, angle: s15 }, ifFalse: { type: "Process", op: "MatchWinding", sign: 1, angle: s15 } } }, timing: v(t23, i14.animatedSymbolProperties) };
}
function R2(t23) {
  return { from: t23, to: t23, timing: { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t7.Local, repeatType: d4.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 } };
}
function L5(t23) {
  if (null == t23) return false;
  if ("object" != typeof t23) return false;
  if (t23.animations && Array.isArray(t23.animations) && t23.animations.length > 0) return true;
  for (const e15 in t23) if (L5(t23[e15])) return true;
  return false;
}

// node_modules/@arcgis/core/symbols/cim/fitVectorMarker.js
var a7 = 0.01;
function t17(t23, f12) {
  if (!t23.frame) return t23;
  const { markerGraphics: n17 } = t23;
  if (!n17 || 0 === n17.length) return t23;
  let o14 = 0, s15 = 0, i14 = 0, c12 = 0;
  for (const m7 of n17) {
    const { geometry: a14, symbol: t24 } = m7;
    if (!a14 || !t24 || !("symbolLayers" in t24)) continue;
    const { symbolLayers: n18 } = t24;
    if (n18) for (const m8 of n18) {
      const { effects: t25 } = m8, n19 = l5.applyEffects(t25, a14, f12), x7 = m4(n19);
      x7 && (o14 = Math.min(o14, x7[0]), s15 = Math.min(s15, x7[1]), i14 = Math.max(i14, x7[2]), c12 = Math.max(c12, x7[3]));
    }
  }
  const { xmin: x6, ymin: y5, xmax: p8, ymax: h13 } = t23.frame, l15 = (p8 - x6) / 2, M5 = (h13 - y5) / 2, u18 = (p8 + x6) / 2, b6 = (h13 + y5) / 2;
  if (l15 <= 0 || M5 <= 0) return t23;
  const g7 = (u18 - o14) / l15, j = (i14 - u18) / l15, E7 = (b6 - s15) / M5, F7 = (c12 - b6) / M5, H3 = Math.max(Math.max(g7, j), Math.max(E7, F7));
  return H3 <= 1 + a7 ? t23 : (t23 = a(t23)).frame ? (t23.frame.xmin = (t23.frame.xmin - u18) * H3 + u18, t23.frame.ymin = (t23.frame.ymin - b6) * H3 + b6, t23.frame.xmax = (t23.frame.xmax - u18) * H3 + u18, t23.frame.ymax = (t23.frame.ymax - b6) * H3 + b6, false !== t23.respectFrame && (t23.size *= H3), t23) : t23;
}

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var H2 = () => n.getLogger("esri.symbols.cim.cimAnalyzer");
function J2(e15) {
  const r10 = e15.markerPlacement;
  return r10 && r10.angleToLine ? i2.MAP : i2.SCREEN;
}
var B3 = class {
  constructor(e15) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], e15 && (this._resourceManager = e15);
  }
  analyzeSymbolReference(r10, t23, i14) {
    if (this._cimLayers = i14 ?? [], !r10) return this._cimLayers;
    if (this._reset(), r10.primitiveOverrides) {
      this._primitiveOverrides = r10.primitiveOverrides;
      for (const r11 of this._primitiveOverrides) {
        const t24 = r11.valueExpressionInfo;
        if (t24) this._setPoMap(r11.primitiveName, r11.propertyName, t24);
        else if (null != r11.value) {
          let t25 = r11.value;
          r11.propertyName.includes("Color") && (i6(t25) && (t25 = o4(t25)), t25 = f3(t25)), this._setPoMap(r11.primitiveName, r11.propertyName, t25);
        }
      }
    }
    return this._analyzeSymbol(r10.symbol, t23), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e15, r10) {
    switch (e15 == null ? void 0 : e15.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e15, r10);
    }
  }
  _analyzeMultiLayerSymbol(e15, r10) {
    const t23 = e15 == null ? void 0 : e15.symbolLayers;
    if (!t23) return;
    for (let l15 = 0; l15 < t23.length; l15++) {
      const e16 = t23[l15];
      "CIMVectorMarker" === e16.type && (t23[l15] = t17(e16, this._resourceManager.geometryEngine));
    }
    const i14 = e15.effects;
    let o14 = i2.SCREEN;
    const a14 = H(e15) ?? 0;
    "CIMPointSymbol" === e15.type && "Map" === e15.angleAlignment && (o14 = i2.MAP);
    let s15 = { transform: [0, 0, 0, 1], fromColor: [1, 1, 1, 1], toColor: [1, 1, 1, 1], colorMix: [0, 0, 0, 0], toOpacity: [1, 1, 1, 1], opacityMix: [0, 0, 0, 0], hasAnimations: L5(e15) };
    s15 = l7(this._poMap, e15, s15);
    const p8 = "CIMPolygonSymbol" === e15.type;
    let c12 = t23.length;
    for (; c12--; ) {
      const l15 = t23[c12];
      if (!l15 || false === l15.enable) continue;
      let n17;
      (i14 == null ? void 0 : i14.length) && (n17 = [...i14]);
      const m7 = l15.effects;
      (m7 == null ? void 0 : m7.length) && (i14 ? n17.push(...m7) : n17 = [...m7]);
      let y5 = null;
      if (n17) {
        y5 = [];
        for (const e16 of n17) {
          const r11 = y.findEffectOverrides(e16, this._primitiveOverrides);
          r11 && y5.push(r11);
        }
      }
      const d11 = [];
      switch (y.findApplicableOverrides(l15, this._primitiveOverrides, d11), l15.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(l15, y5);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(l15, y5);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(l15, y5);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(l15, y5);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(l15, y5, p8, a14);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(l15, y5, p8, a14);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(l15, y5, p8, a14);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e15.type && "CIMPolygonSymbol" !== e15.type || (o14 = J2(l15));
          const t24 = [], i15 = l15.primitiveName;
          i15 && t24.push(i15);
          const n18 = p8 && I3(l15.markerPlacement);
          this._analyzeMarker(l15, y5, null, t24, o14, a14, r10, [], s15, false, n18);
          break;
        }
        default:
          H2().error("Cannot analyze CIM layer", l15.type);
      }
    }
  }
  _analyzeSolidFill(e15, r10) {
    const { primitiveName: t23, type: i14 } = e15, o14 = f3(e15.color);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, color: this._getValueOrOverrideExpression(i14, t23, "Color", o14), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: r10, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false });
  }
  _analyzePictureFill(e15, r10) {
    const { primitiveName: t23, type: i14 } = e15, o14 = d5(e15), a14 = p(e15.height, n4.CIMPictureFill.height);
    let s15 = p(e15.scaleX, 1);
    if ("width" in e15 && "number" == typeof e15.width) {
      const r11 = e15.width;
      let t24 = 1;
      const i15 = this._resourceManager.getResource(e15.url);
      null != i15 && (t24 = i15.width / i15.height), s15 /= t24 * (a14 / r11);
    }
    const l15 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(t23, i14) };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: l15, colorLocked: !!e15.colorLocked, effects: r10, color: this._getValueOrOverrideExpression(i14, t23, "TintColor", o14), height: this._getValueOrOverrideExpression(i14, t23, "Height", a14), scaleX: this._getValueOrOverrideExpression(i14, t23, "ScaleX", s15), angle: this._getValueOrOverrideExpression(i14, t23, "Rotation", p(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i14, t23, "OffsetX", p(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i14, t23, "OffsetY", p(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeHatchFill(e15, r10) {
    var _a, _b, _c;
    const { primitiveName: t23, type: i14 } = e15, o14 = this._analyzeMaterialOverrides(t23, ["Rotation", "OffsetX", "OffsetY"]), a14 = U4(o14);
    let s15 = [255, 255, 255, 1], l15 = false;
    if ((_a = e15.lineSymbol) == null ? void 0 : _a.symbolLayers) for (const p8 of e15.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== p8.type) continue;
      const e16 = p8.primitiveName ?? t23;
      l15 || !e16 || p8.colorLocked || null == ((_b = this._poMap[e16]) == null ? void 0 : _b.Color) && null == ((_c = this._poMap[e16]) == null ? void 0 : _c.StrokeColor) || (s15 = f3(p8.color), s15 = this._maybeGetValueOrOverrideExpression(e16, "StrokeColor") ?? this._getValueOrOverrideExpression(i14, e16, "Color", s15), l15 = true);
      const r11 = this._maybeGetValueOrOverrideExpression(e16, "StrokeWidth");
      if (r11) {
        let t24 = null, o15 = null;
        "number" == typeof r11 ? t24 = r11 : o15 = r11.valueExpressionInfo;
        let s16 = a14.find((e17) => "strokeWidth" === e17.propertyName);
        s16 ? s16.propertyName = "width" : (s16 = { type: "CIMPrimitiveOverride", primitiveName: e16, propertyName: "width", valueExpressionInfo: o15, value: t24, defaultValue: D2(i14, "width") }, a14.push(s16));
      }
    }
    const n17 = { type: "sprite-rasterization-param", resource: e15, overrides: a14 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: n17, colorLocked: !!e15.colorLocked, effects: r10, color: s15, height: this._getValueOrOverrideExpression(i14, t23, "Separation", p(e15.separation, n4.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i14, t23, "Rotation", p(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i14, t23, "OffsetX", p(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i14, t23, "OffsetY", p(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !l15 });
  }
  _analyzeGradientFill(e15, r10) {
    const { angle: t23, gradientMethod: i14, gradientSize: o14, gradientSizeUnits: a14, gradientType: s15, interval: l15, primitiveName: n17, type: p8 } = e15, c12 = n4.CIMGradientFill, m7 = e15.colorRamp;
    this._cimLayers.push({ type: "gradientFill", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(n17, p8) }, colorLocked: false, effects: r10, color: [255, 255, 255, 1], gradientMethod: this._getValueOrOverrideExpression(p8, n17, "GradientMethod", i14 ?? "Linear"), angle: this._getValueOrOverrideExpression(p8, n17, "Angle", p(t23, c12.angle)), gradientType: this._getValueOrOverrideExpression(p8, n17, "GradientType", s15 ?? c12.gradientType), interval: this._getValueOrOverrideExpression(p8, n17, "Interval", p(l15, "CIMFixedColorRamp" === m7.type ? m7.colors.length : c12.interval)), gradientSize: this._getValueOrOverrideExpression(p8, n17, "GradientSize", p(o14, c12.gradientSize)), gradientSizeUnits: "Absolute" === a14 ? ne.Absolute : "Relative" === a14 ? ne.Relative : c12.gradientSizeUnits });
  }
  _analyzeSolidStroke(e15, r10, t23, i14) {
    const { primitiveName: o14, type: a14 } = e15, s15 = f3(e15.color), l15 = p(e15.width, n4.CIMSolidStroke.width), n17 = b3(e15.capStyle, n4.CIMSolidStroke.capstyle), p8 = b3(e15.joinStyle, n4.CIMSolidStroke.joinstyle), c12 = e15.miterLimit;
    let m7, y5, d11, h13, f12 = [];
    if (this._analyzePrimitiveOverrides(o14, r10, null, null) && (f12 = this._getPrimitiveMaterialOverrides(o14, a14)), r10 && Array.isArray(r10) && r10.length > 0) {
      const e16 = r10[r10.length - 1].effect;
      e16 && "CIMGeometricEffectDashes" === e16.type && "NoConstraint" === e16.lineDashEnding && (m7 = e16.dashTemplate, y5 = e16.scaleDash, d11 = e16.offsetAlongLine, h13 = e16.primitiveName, (r10 = [...r10]).pop());
    }
    null != h13 && f12.push(...this._getPrimitiveMaterialOverrides(h13, a14).filter((e16) => "dashTemplate" === e16.propertyName));
    const u18 = void 0 !== m7 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: m7, primitiveName: h13 }, overrides: f12 } : null;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: u18, isOutline: t23, colorLocked: !!e15.colorLocked, effects: r10, color: this._getValueOrOverrideExpression(a14, o14, "Color", s15), width: this._getValueOrOverrideExpression(a14, o14, "Width", l15), cap: this._getValueOrOverrideExpression(a14, o14, "CapStyle", n17), join: this._getValueOrOverrideExpression(a14, o14, "JoinStyle", p8), miterLimit: c12 && this._getValueOrOverrideExpression(a14, o14, "MiterLimit", c12), referenceWidth: i14, zOrder: K2(e15.name), dashTemplate: this._maybeGetValueOrOverrideExpression(h13, "DashTemplate") ?? m7, offsetAlongLine: this._getValueOrOverrideExpression(a14, h13, "OffsetAlongLine", d11 ?? 0), scaleDash: y5, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e15, r10, t23, i14) {
    const { primitiveName: o14, type: a14 } = e15, s15 = d5(e15), l15 = p(e15.width, n4.CIMPictureStroke.width), n17 = b3(e15.capStyle, n4.CIMPictureStroke.capstyle), p8 = b3(e15.joinStyle, n4.CIMPictureStroke.joinstyle), c12 = e15.miterLimit, m7 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(o14, a14) };
    this._cimLayers.push({ type: "line", spriteRasterizationParam: m7, isOutline: t23, colorLocked: !!e15.colorLocked, effects: r10, color: this._getValueOrOverrideExpression(a14, o14, "TintColor", s15), width: this._getValueOrOverrideExpression(a14, o14, "Width", l15), cap: this._getValueOrOverrideExpression(a14, o14, "CapStyle", n17), join: this._getValueOrOverrideExpression(a14, o14, "JoinStyle", p8), miterLimit: c12 && this._getValueOrOverrideExpression(a14, o14, "MiterLimit", c12), referenceWidth: i14, zOrder: K2(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e15, r10, t23, i14) {
    const { gradientMethod: o14, gradientSize: a14, gradientSizeUnits: s15, gradientType: l15, interval: n17, primitiveName: p8, type: c12 } = e15, m7 = n4.CIMGradientStroke, y5 = p(e15.width, m7.width), d11 = b3(e15.capStyle, m7.capstyle), h13 = b3(e15.joinStyle, m7.joinstyle), f12 = e15.miterLimit, u18 = e15.colorRamp;
    this._cimLayers.push({ type: "gradientStroke", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(p8, c12) }, colorLocked: !!e15.colorLocked, effects: r10, color: [255, 255, 255, 1], width: this._getValueOrOverrideExpression(c12, p8, "Width", y5), cap: this._getValueOrOverrideExpression(c12, p8, "CapStyle", d11), join: this._getValueOrOverrideExpression(c12, p8, "JoinStyle", h13), miterLimit: f12 && this._getValueOrOverrideExpression(c12, p8, "MiterLimit", f12), referenceWidth: i14, isOutline: t23, gradientMethod: this._getValueOrOverrideExpression(c12, p8, "GradientMethod", o14 ?? m7.gradientMethod), gradientType: this._getValueOrOverrideExpression(c12, p8, "GradientType", l15 ?? m7.gradientType), interval: this._getValueOrOverrideExpression(c12, p8, "Interval", p(n17, "CIMFixedColorRamp" === u18.type ? u18.colors.length : m7.interval)), gradientSize: this._getValueOrOverrideExpression(c12, p8, "GradientSize", p(a14, m7.gradientSize)), gradientSizeUnits: "Absolute" === s15 ? ne.Absolute : "Relative" === s15 ? ne.Relative : m7.gradientSizeUnits });
  }
  _analyzeMarker(e15, r10, t23, i14, o14, a14, s15, l15, y5, d11 = false, h13 = false) {
    if (d11 || (d11 = !!e15.colorLocked), this._analyzeMarkerInsidePolygon(e15, r10, d11)) return;
    const f12 = p(e15.size, n4.CIMVectorMarker.size), u18 = p(e15.rotation), O8 = p(e15.offsetX), g7 = p(e15.offsetY), { primitiveName: _7, type: M5 } = e15, S3 = this._getValueOrOverrideExpression(M5, _7, "Size", f12), k3 = this._getValueOrOverrideExpression(M5, _7, "Rotation", u18), b6 = this._getValueOrOverrideExpression(M5, _7, "OffsetX", O8), C4 = this._getValueOrOverrideExpression(M5, _7, "OffsetY", g7);
    let P6 = y5;
    switch (P6 = l7(this._poMap, e15, P6), P6 = C3(e15, P6), P6 = f7(this._poMap, e15, P6), P6 = y4(e15, P6), e15.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e15, r10, t23, i14, o14, a14, S3, k3, b6, C4, l15, P6, d11, h13);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e15, r10, t23, i14, o14, a14, S3, k3, b6, C4, l15, P6, s15, d11, h13);
    }
  }
  _analyzeMarkerInsidePolygon(e15, r10, t23) {
    const { markerPlacement: i14, type: o14 } = e15;
    if (!i14 || "CIMMarkerPlacementInsidePolygon" !== i14.type) return false;
    if ("CIMVectorMarker" === o14 || "CIMPictureMarker" === o14) {
      const t24 = e15.primitiveName;
      if (t24 && this._analyzePrimitiveOverrides([t24], r10, null, null)) return false;
      const a14 = i14.primitiveName;
      if (a14 && this._analyzePrimitiveOverrides([a14], r10, null, null)) return false;
      if ("CIMVectorMarker" === o14) {
        const { markerGraphics: r11 } = e15;
        if (r11) for (const e16 of r11) {
          const { symbol: r12 } = e16;
          if ("CIMPolygonSymbol" === (r12 == null ? void 0 : r12.type) && r12.symbolLayers) {
            const { symbolLayers: e17 } = r12;
            for (const r13 of e17) if ("CIMSolidStroke" === r13.type) return false;
          }
        }
      } else {
        const { animatedSymbolProperties: r11 } = e15;
        if (r11) return false;
      }
    }
    const s15 = Math.abs(i14.stepX), l15 = Math.abs(i14.stepY);
    if (0 === s15 || 0 === l15) return true;
    let n17, p8;
    if ("Random" === i14.gridType) {
      const e16 = e2(Fi), r11 = Math.max(Math.floor(e16 / s15), 1);
      n17 = l15 * Math.max(Math.floor(e16 / l15), 1);
      p8 = r11 * s15 / n17;
    } else i14.shiftOddRows ? (n17 = 2 * l15, p8 = s15 / l15 * 0.5) : (n17 = l15, p8 = s15 / l15);
    const c12 = d5(e15), m7 = "CIMCharacterMarker" === e15.type ? null : { type: "sprite-rasterization-param", resource: e15, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: m7, colorLocked: t23, effects: r10, color: c12, height: n17, scaleX: p8, angle: i14.gridAngle, offsetX: p(i14.offsetX), offsetY: p(i14.offsetY), applyRandomOffset: "Random" === i14.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e15.type, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e15, r10, i14, o14, a14, l15, n17, p8, c12, m7, y5, d11, h13, f12) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { animatedSymbolProperties: u18, primitiveName: v3, type: O8 } = e15;
    let g7 = p(e15.scaleX, 1);
    const _7 = d5(e15);
    i14 || (i14 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    const M5 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(u18), S3 = e15.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e15 && "number" == typeof e15.width) {
      const r11 = e15.width;
      let t23 = 1;
      const i15 = this._resourceManager.getResource(e15.url);
      null != i15 && (t23 = i15.width / i15.height);
      g7 /= t23 * (p(e15.size) / r11);
    }
    const k3 = [...o14];
    let b6;
    e15.primitiveName && k3.push(e15.primitiveName), u18 || M5 ? b6 = { type: "animated", url: e15.url, urlHash: "H" + l(e15.url), playAnimation: (_a = e15.animatedSymbolProperties) == null ? void 0 : _a.playAnimation, reverseAnimation: (_b = e15.animatedSymbolProperties) == null ? void 0 : _b.reverseAnimation, randomizeStartTime: (_c = e15.animatedSymbolProperties) == null ? void 0 : _c.randomizeStartTime, randomizeStartSeed: (_d = e15.animatedSymbolProperties) == null ? void 0 : _d.randomizeStartSeed, startTimeOffset: (_e = e15.animatedSymbolProperties) == null ? void 0 : _e.startTimeOffset, duration: (_f = e15.animatedSymbolProperties) == null ? void 0 : _f.duration, repeatType: (_g = e15.animatedSymbolProperties) == null ? void 0 : _g.repeatType, repeatDelay: (_h = e15.animatedSymbolProperties) == null ? void 0 : _h.repeatDelay } : (b6 = a(e15), b6.markerPlacement = null);
    const C4 = { type: "sprite-rasterization-param", resource: b6, overrides: this._getMaterialOverrides(k3, O8) };
    M5 && C4.overrides.push(...M5.overrides);
    const P6 = n17;
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: C4, colorLocked: h13, effects: r10, scaleSymbolsProportionally: false, alignment: a14, size: n17, scaleX: this._getValueOrOverrideExpression(O8, v3, "ScaleX", g7), rotation: p8, offsetX: c12, offsetY: m7, transform: { type: "cim-marker-transform-param", params: y5 }, color: this._getValueOrOverrideExpression(O8, v3, "TintColor", _7), anchorPoint: { x: S3.x, y: S3.y }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l15, sizeRatio: 1, isOutline: f12, markerPlacement: i14, animationParams: te2(d11), baseSize: P6 });
  }
  _analyzeVectorMarker(e15, r10, t23, i14, o14, a14, s15, l15, p8, c12, m7, f12, u18, v3, O8) {
    const g7 = e15.markerGraphics;
    if (!g7) return;
    const _7 = e15.frame;
    let M5 = 0;
    M5 = _7 ? _7.ymax - _7.ymin : a14;
    const S3 = !!e15.scaleSymbolsProportionally;
    if (M5) {
      const r11 = { offsetX: p8, offsetY: c12, rotation: l15, size: s15, frameHeight: M5, rotateClockWise: !!e15.rotateClockwise, absoluteAnchorPoint: false, scaleSymbolsProportionally: S3 };
      m7 = [...m7, r11];
    }
    t23 || (t23 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    for (const k3 of g7) if (k3) {
      const s16 = k3.symbol;
      if (!s16) continue;
      const l16 = k3.primitiveName;
      l16 && i14.push(l16);
      let p9, c13 = f12;
      if (("CIMPointSymbol" === s16.type || "CIMTextSymbol" === s16.type) && _7) {
        let r11 = 0, t24 = 0;
        const i15 = k3.geometry;
        "x" in i15 && "y" in i15 && (r11 += i15.x - 0.5 * (_7.xmin + _7.xmax), t24 += i15.y - 0.5 * (_7.ymin + _7.ymax));
        const o15 = e15.anchorPoint;
        let a15 = false;
        o15 && ("Absolute" === e15.anchorPointUnits ? (r11 -= o15.x, t24 -= o15.y, a15 = true) : _7 && (r11 -= (_7.xmax - _7.xmin) * o15.x, t24 -= (_7.ymax - _7.ymin) * o15.y));
        const s17 = { offsetX: r11, offsetY: t24, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false, absoluteAnchorPoint: a15, scaleSymbolsProportionally: S3 };
        p9 = [...m7, s17];
      }
      const g8 = k3.geometry, [b6, C4] = d7(g8, _7);
      switch (0 === b6 && 0 === C4 || (c13 = M2(c13, b6, C4)), "CIMPointSymbol" === s16.type && (c13 = l7(this._poMap, s16, c13)), s16.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          u18 || $(s16) ? (c13 = { ...c13, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: R2([0, 0]), rotation: R2(0), scale: R2(M5), parent: f12.transform } }, this._analyzeMultiLayerGraphicNonSDF(e15, r10, t23, k3, i14, o14, a14, p9 ?? m7, c13, M5, v3, O8)) : this._analyzeMultiLayerGraphic(e15, r10, t23, k3, i14, o14, a14, p9 ?? m7, c13, M5, v3, O8);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(r10, t23, k3, i14, o14, a14, p9 ?? m7, v3);
      }
      l16 && i14.pop();
    }
  }
  _analyzeMultiLayerGraphic(e15, r10, t23, i14, o14, a14, s15, l15, n17, p8, c12, m7) {
    const y5 = i14.symbol.symbolLayers;
    y5 && (!Z(y5) || p4(n17) ? ee(y5) ? this._analyzeMultiLayerGraphicNonSDF(e15, r10, t23, i14, o14, a14, s15, l15, n17, p8, !!c12, m7) : this._analyzeMarkerGraphicSymbolLayers(e15, r10, t23, i14, o14, a14, s15, l15, n17, p8, c12, m7) : this._analyzeCompositeMarkerGraphic(e15, r10, t23, i14, y5, a14, s15, l15, p8, c12, m7));
  }
  _analyzeMarkerGraphicSymbolLayers(e15, r10, t23, i14, o14, a14, s15, l15, p8, c12, m7, y5) {
    const d11 = i14.symbol, h13 = d11.symbolLayers;
    if (!h13) return;
    const f12 = this._resourceManager.geometryEngine, u18 = l5.applyEffects(d11.effects, i14.geometry, f12);
    if (!u18) return;
    let O8 = h13.length;
    for (; O8--; ) {
      const d12 = h13[O8];
      if (!d12 || false === d12.enable) continue;
      const g7 = d12.primitiveName;
      switch (g7 && o14.push(g7), d12.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o15 = l5.applyEffects(d12.effects, u18, f12), h14 = m4(o15);
          if (!h14) continue;
          const O9 = "Relative" !== e15.anchorPointUnits, _7 = x2(d12) ?? 0, { frameSizeRatio: M5, anchorX: C4, anchorY: z2, widthRatio: x6, sdfPaddingRatio: E7 } = h4(h14, e15.frame, e15.size, e15.anchorPoint, O9, _7, e15.scaleSymbolsProportionally), L7 = "CIMSolidFill" === d12.type, V = { type: "sdf", geom: o15, sdfPaddingRatio: E7, asFill: L7 }, { path: N4 } = d12, G3 = L7 ? f3(T2(d12)) : null == N4 ? f3(A(d12)) : [0, 0, 0, 0], F7 = L7 ? [0, 0, 0, 0] : f3(A(d12));
          if (!L7 && !_7) break;
          const T4 = i14.primitiveName;
          let X2 = null;
          L7 && !d12.colorLocked && (X2 = this._maybeGetValueOrOverrideExpression(T4, "FillColor"));
          let Y2 = null;
          L7 || d12.colorLocked || (Y2 = this._maybeGetValueOrOverrideExpression(T4, "StrokeColor"));
          const j = X2 ?? this._getValueOrOverrideExpression(d12.type, g7, "Color", G3), U6 = Y2 ?? this._getValueOrOverrideExpression(d12.type, g7, "Color", F7), D5 = this._maybeGetValueOrOverrideExpression(T4, "StrokeWidth") ?? this._getValueOrOverrideExpression(d12.type, g7, "Width", _7), H3 = N4 ? { type: "sprite-rasterization-param", resource: { type: "path", path: N4, asFill: L7 }, overrides: [] } : { type: "sprite-rasterization-param", resource: V, overrides: [] }, J3 = l7(this._poMap, d12, p8), B5 = p(e15.size, n4.CIMVectorMarker.size), q5 = this._getValueOrOverrideExpression(e15.type, e15.primitiveName, "Size", B5);
          this._cimLayers.push({ type: "marker", spriteRasterizationParam: H3, colorLocked: !!d12.colorLocked || !!m7, effects: r10, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a14, anchorPoint: { x: C4, y: z2 }, isAbsoluteAnchorPoint: O9, size: c12, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l15 }, frameHeight: c12, widthRatio: x6, rotateClockwise: false, referenceSize: s15, sizeRatio: M5, color: j, outlineColor: U6, outlineWidth: D5, isOutline: y5, markerPlacement: t23, animationParams: te2(J3), isStroke: "CIMSolidFill" !== d12.type, baseSize: q5, ...c2(o15, E7) });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          if (d12.markerPlacement) {
            H2().error("Error analyzing CIM, got unexpected marker placement");
            break;
          }
          this._analyzeMarker(d12, r10, t23, o14, a14, s15, false, l15, p8, m7, y5);
      }
      g7 && o14.pop();
    }
  }
  _analyzeTextGraphic(e15, t23, i14, o14, a14, s15, l15, n17) {
    var _a, _b, _c;
    const p8 = [];
    y.findApplicableOverrides(i14, this._primitiveOverrides, p8);
    const c12 = i14.geometry;
    if (!("x" in c12) || !("y" in c12)) return;
    const m7 = i14.symbol, y5 = L3(m7), d11 = w2(m7.fontStyleName), h13 = u7(m7.fontFamilyName);
    m7.font = { family: h13, decoration: y5, ...d11 };
    const f12 = p(m7.height, n4.CIMTextSymbol.height), u18 = p(m7.angle), O8 = p(m7.offsetX), g7 = p(m7.offsetY), { haloSymbol: _7 } = m7, S3 = p(m7.haloSize, 0);
    let k3 = [0, 0, 0, 0];
    if ((_a = _7 == null ? void 0 : _7.symbolLayers) == null ? void 0 : _a.length) {
      const e16 = _7.symbolLayers;
      for (const r10 of e16) if (r10.color) {
        k3 = this._getValueOrOverrideExpression(((_b = m7 == null ? void 0 : m7.haloSymbol) == null ? void 0 : _b.type) ?? "CIMPolygonSymbol", r10.primitiveName, "Color", f3(r10.color));
        break;
      }
    }
    const b6 = i14.primitiveName;
    let C4 = [0, 0, 0, 1], z2 = [0, 0, 0, 0], x6 = 0, E7 = false;
    if ((_c = m7.symbol) == null ? void 0 : _c.symbolLayers) for (const r10 of m7.symbol.symbolLayers) {
      const e16 = r10.primitiveName;
      if ("CIMSolidStroke" === r10.type) z2 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Color", f3(r10.color)), x6 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Width", x2(r10) ?? 0);
      else if ("CIMSolidFill" === r10.type) {
        const t24 = f3(r10.color);
        E7 = E7 ?? !!r10.colorLocked, C4 = this._getValueOrOverrideExpression("CIMSolidFill", e16 ?? b6, "Color", t24);
      }
    }
    let L7 = null, V = null, N4 = null, A7 = null, w5 = null;
    b6 && (L7 = this._maybeGetValueOrOverrideExpression(b6, "TextSize"), V = this._maybeGetValueOrOverrideExpression(b6, "TextAngle"), N4 = this._maybeGetValueOrOverrideExpression(b6, "TextOffsetX"), A7 = this._maybeGetValueOrOverrideExpression(b6, "TextOffsetY"), E7 || (w5 = this._maybeGetValueOrOverrideExpression(b6, "FillColor")));
    const Y2 = w5 ?? C4;
    let j = null, W2 = null, U6 = 0;
    if (m7.callout && "CIMBackgroundCallout" === m7.callout.type) {
      const e16 = m7.callout;
      if (e16.backgroundSymbol) {
        const r10 = e16.backgroundSymbol.symbolLayers;
        if (r10) for (const e17 of r10) "CIMSolidFill" === e17.type ? j = f3(e17.color) : "CIMSolidStroke" === e17.type && (W2 = f3(e17.color), U6 = p(e17.width, n4.CIMSolidStroke.width));
      }
    }
    const D5 = this._getValueOrOverrideExpression(m7.type, i14.primitiveName, "TextString", i14.textString ?? "");
    if (null == D5) return;
    const { fontStyleName: H3 } = m7, J3 = h13 + (H3 ? "-" + H3.toLowerCase() : "-regular"), B5 = this._getMaterialOverrides(o14, m7.type);
    B5.push(...this._getPrimitiveMaterialOverrides(i14.primitiveName, m7.type));
    const q5 = { type: "text-rasterization-param", resource: { type: "text", textString: i14.textString ?? "", font: m7.font, symbol: m7, primitiveName: i14.primitiveName }, overrides: B5 };
    this._cimLayers.push({ type: "text", lineWidth: m7.lineWidth, textRasterizationParam: q5, colorLocked: !!n17 || !!E7, effects: e15, alignment: a14, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: J3, decoration: y5, haloSize: S3, haloColor: k3, weight: d11.weight, style: d11.style, size: L7 ?? f12, angle: V ?? u18, offsetX: N4 ?? O8, offsetY: A7 ?? g7, transform: { type: "cim-marker-transform-param", params: l15 }, horizontalAlignment: N2(m7.horizontalAlignment), verticalAlignment: F3(m7.verticalAlignment), text: D5, color: Y2, outlineColor: z2, outlineSize: x6, backgroundColor: j, borderLineColor: W2, borderLineWidth: U6, referenceSize: s15, sizeRatio: 1, markerPlacement: t23 });
  }
  _analyzeMultiLayerGraphicNonSDF(e15, r10, t23, i14, a14, s15, l15, n17, p8, c12, m7, y5) {
    const d11 = q3(e15, i14), h13 = e15.primitiveName, f12 = this._analyzeMaterialOverrides(h13, ["Rotation", "OffsetX", "OffsetY"]), O8 = U4(f12), [g7, _7, M5] = te.getTextureAnchor(d11, this._resourceManager, oi), S3 = this._getMaterialOverrides(a14, e15.type);
    S3.push(...O8);
    const k3 = { type: "sprite-rasterization-param", resource: { ...d11, avoidSDFRasterization: true }, overrides: S3 }, b6 = p(e15.size, n4.CIMVectorMarker.size), C4 = this._getValueOrOverrideExpression(e15.type, h13, "Size", b6);
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: k3, colorLocked: m7, effects: r10, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: s15, anchorPoint: { x: g7, y: _7 }, isAbsoluteAnchorPoint: false, size: c12, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: n17 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: c12, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l15, sizeRatio: M5 / u3(e15.size), isOutline: y5, markerPlacement: t23, animationParams: te2(p8), baseSize: C4 });
  }
  _createMarkerPlacementOverrideExpression(e15) {
    if (!e15) return null;
    const r10 = [];
    return y.findApplicableOverrides(e15, this._primitiveOverrides, r10), { type: "cim-marker-placement-param", placement: e15, overrides: re(r10) };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e15) {
    if (!e15) return null;
    const r10 = [];
    return y.findApplicableOverrides(e15, this._primitiveOverrides, r10), { type: "cim-gif-animation-params", animation: e15, overrides: re(r10) };
  }
  _analyzeCompositeMarkerGraphic(e15, r10, t23, i14, o14, a14, s15, l15, n17, p8, c12) {
    const m7 = i14.geometry, y5 = o14[0], d11 = o14[1], h13 = m4(m7);
    if (!h13) return;
    const f12 = "Relative" !== e15.anchorPointUnits, u18 = p(y5.width, n4.CIMSolidStroke.width), { frameSizeRatio: O8, anchorX: g7, anchorY: _7, widthRatio: M5, sdfPaddingRatio: b6 } = h4(h13, e15.frame, e15.size, e15.anchorPoint, f12, u18, e15.scaleSymbolsProportionally), { path: C4 } = d11, z2 = d11.primitiveName, x6 = y5.primitiveName, E7 = i14.primitiveName;
    let L7 = null;
    d11.colorLocked || p8 || (L7 = this._maybeGetValueOrOverrideExpression(E7, "FillColor"));
    const V = L7 ?? this._getValueOrOverrideExpression(d11.type, z2, "Color", f3(d11.color));
    let N4 = null;
    y5.colorLocked || p8 || (N4 = this._maybeGetValueOrOverrideExpression(E7, "StrokeColor"));
    const R3 = N4 ?? this._getValueOrOverrideExpression(y5.type, x6, "Color", f3(y5.color)), A7 = this._maybeGetValueOrOverrideExpression(E7, "StrokeWidth") ?? this._getValueOrOverrideExpression(y5.type, x6, "Width", u18), w5 = { type: "sprite-rasterization-param", resource: C4 ? { type: "path", path: C4, asFill: true } : { type: "sdf", geom: m7, sdfPaddingRatio: b6, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: w5, colorLocked: p8, effects: r10, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a14, anchorPoint: { x: g7, y: _7 }, isAbsoluteAnchorPoint: f12, size: n17, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l15 }, frameHeight: n17, widthRatio: M5, rotateClockwise: false, referenceSize: s15, sizeRatio: O8, color: V, outlineColor: R3, outlineWidth: A7, isOutline: c12, markerPlacement: t23 });
  }
  _setPoMap(e15, r10, t23) {
    let i14;
    this._poMap[e15] ? i14 = this._poMap[e15] : (i14 = {}, this._poMap[e15] = i14), i14[r10] = t23;
  }
  _maybeGetValueOrOverrideExpression(e15, r10, t23) {
    return this._getValueOrOverrideExpression("", e15, r10, t23, false);
  }
  _getValueOrOverrideExpression(e15, r10, t23, i14, o14 = true) {
    if (o14 && !O3(i14) && (i14 = D2(e15, t23.toLowerCase())), null == r10) return i14;
    const a14 = this._poMap[r10];
    if (null == a14) return i14;
    const s15 = a14[t23];
    return "string" == typeof s15 || "number" == typeof s15 || Array.isArray(s15) ? s15 : s15 ? { valueExpressionInfo: s15, defaultValue: i14 } : i14;
  }
  _analyzePrimitiveOverrides(e15, r10, t23, i14) {
    if (null == e15) return false;
    "string" == typeof e15 && (e15 = [e15]);
    for (const o14 of this._primitiveOverrides) if (e15.includes(o14.primitiveName) && o14.valueExpressionInfo) return true;
    if (null != r10) {
      for (const o14 of r10) if ((o14 == null ? void 0 : o14.overrides.length) > 0) return true;
    }
    if (null != t23) {
      for (const o14 of t23) if ((o14 == null ? void 0 : o14.overrides.length) > 0) return true;
    }
    if (null != i14) {
      for (const o14 of i14) if ((o14 == null ? void 0 : o14.overrides.length) > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e15, r10) {
    if (!e15) return [];
    const t23 = [];
    for (const i14 of e15) t23.push(...this._getPrimitiveMaterialOverrides(i14, r10));
    return t23;
  }
  _getPrimitiveMaterialOverrides(e15, r10) {
    if (!e15) return [];
    const t23 = U4(this._primitiveOverrides.filter((r11) => r11.primitiveName === e15));
    return t23.forEach((e16) => e16.defaultValue = D2(r10, e16.propertyName.toLowerCase())), t23;
  }
  _analyzeMaterialOverrides(e15, r10) {
    return this._primitiveOverrides.filter((t23) => t23.primitiveName !== e15 || !r10.includes(t23.propertyName));
  }
};
function q3(e15, r10) {
  return { type: e15.type, enable: true, name: e15.name, colorLocked: e15.colorLocked, primitiveName: e15.primitiveName, anchorPoint: e15.anchorPoint, anchorPointUnits: e15.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e15.rotateClockwise, rotation: 0, size: e15.size, billboardMode3D: e15.billboardMode3D, depth3D: e15.depth3D, frame: e15.frame, markerGraphics: [r10], scaleSymbolsProportionally: e15.scaleSymbolsProportionally, respectFrame: e15.respectFrame, clippingPath: e15.clippingPath };
}
function K2(e15) {
  if (e15 && 0 === e15.indexOf("Level_")) {
    const r10 = parseInt(e15.slice(6), 10);
    if (!isNaN(r10)) return r10;
  }
  return 0;
}
var Z = (e15) => e15 && 2 === e15.length && e15[0].enable && e15[1].enable && "CIMSolidStroke" === e15[0].type && "CIMSolidFill" === e15[1].type && null == e15[0].path && null == e15[1].path && !e15[0].effects && !e15[1].effects && !e15[0].animations && !e15[1].animations;
function $(e15) {
  const r10 = e15.symbolLayers;
  if (!r10) return false;
  const t23 = r10.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectDashes" === e17.type && null != e17.dashTemplate);
  }), i14 = r10.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectAddControlPoints" === e17.type);
  });
  return !!t23 || !!i14;
}
function ee(e15) {
  return e15.some((e16) => "CIMSolidFill" !== e16.type && "CIMSolidStroke" !== e16.type && ("CIMVectorMarker" !== e16.type && "CIMPictureMarker" !== e16.type || null != e16.markerPlacement));
}
function re(e15) {
  return a(e15).map((e16) => ({ ...e16, propertyName: z(e16.propertyName) }));
}
function te2(e15) {
  return p4(e15) ? { type: "animation-params", params: e15 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/ManagedCanvas.js
var c5 = class {
  constructor(r10) {
    this.events = new i(), this._hasMajorPerformanceCaveat = false, this._lastRenderFrameCounter = 0, this._canvas = document.createElement("canvas"), this._canvas.setAttribute("style", "width: 100%; height:100%; display:block; willChange:transform");
    const s15 = { failIfMajorPerformanceCaveat: true, alpha: true, antialias: false, depth: true, stencil: true, powerPreference: "high-performance" };
    r10.appendChild(this._canvas);
    let i14 = this._canvas.getContext("webgl2", s15);
    i14 || (i14 = this._canvas.getContext("webgl2", { ...s15, failIfMajorPerformanceCaveat: false }), this._hasMajorPerformanceCaveat = true), this._gl = i14, this._handles = t([o(this._canvas, "webglcontextlost", (e15) => this.events.emit("webgl-context-lost", e15))]);
  }
  destroy() {
    var _a;
    (_a = this._canvas.parentNode) == null ? void 0 : _a.removeChild(this._canvas), this._canvas = null, this._handles.remove(), this._gl = null;
  }
  get gl() {
    return this._gl;
  }
  render(e15, t23) {
    if (this._hasMajorPerformanceCaveat || has("esri-force-performance-mode")) {
      if (++this._lastRenderFrameCounter >= has("esri-performance-mode-frames-between-render") && (t23(), this._lastRenderViewState = e15.state.clone(), this._lastRenderFrameCounter = 0), this._lastRenderViewState) {
        const [t24, a14, r10, s15, i14, o14] = this._computeViewTransform(this._lastRenderViewState, e15.state);
        this._canvas.style.transform = `matrix(${t24}, ${a14}, ${r10}, ${s15}, ${i14}, ${o14})`;
      }
    } else t23();
  }
  resize(e15) {
    const t23 = this._canvas, a14 = t23.style, { state: { size: r10 }, pixelRatio: s15 } = e15, i14 = r10[0], o14 = r10[1], n17 = Math.round(i14 * s15), h13 = Math.round(o14 * s15);
    t23.width === n17 && t23.height === h13 || (t23.width = n17, t23.height = h13), a14.width = i14 + "px", a14.height = o14 + "px";
  }
  _computeViewTransform(e15, t23) {
    const [a14, c12] = e15.center, [l15, m7] = t23.center, [d11, f12] = e15.toScreen([0, 0], l15, m7), [_7, p8] = e15.toScreen([0, 0], a14, c12), v3 = _7 - d11, g7 = p8 - f12, w5 = e15.scale / t23.scale, u18 = t23.rotation - e15.rotation, C4 = e5();
    return a3(C4), c(C4, C4, [w5, w5]), s7(C4, C4, s(u18)), i4(C4, C4, [v3, g7]), C4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e13 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o9(e15) {
  let o14 = e13;
  return e15.split("/").forEach((r10) => {
    o14 && (o14 = o14[r10]);
  }), o14;
}
var t18 = new e7(o9);
function n10(r10) {
  return t18.resolveIncludes(r10);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t19 = (e15) => n6({ PATTERN: e15.pattern });
var a8 = { shaders: (r10) => ({ vertexShader: t19(r10) + n10("background/background.vert"), fragmentShader: t19(r10) + n10("background/background.frag") }) };
var d8 = { shaders: (r10) => ({ vertexShader: n10("circle/circle.vert"), fragmentShader: n10("circle/circle.frag") }) };
var n11 = (e15) => n6({ PATTERN: e15.pattern });
var i10 = { shaders: (r10) => ({ vertexShader: n11(r10) + n10("fill/fill.vert"), fragmentShader: n11(r10) + n10("fill/fill.frag") }) };
var l8 = { shaders: (r10) => ({ vertexShader: n10("outline/outline.vert"), fragmentShader: n10("outline/outline.frag") }) };
var s10 = (e15) => n6({ SDF: e15.sdf });
var f8 = { shaders: (r10) => ({ vertexShader: s10(r10) + n10("icon/icon.vert"), fragmentShader: s10(r10) + n10("icon/icon.frag") }) };
var h7 = (e15) => n6({ PATTERN: e15.pattern, SDF: e15.sdf });
var o10 = { shaders: (r10) => ({ vertexShader: h7(r10) + n10("line/line.vert"), fragmentShader: h7(r10) + n10("line/line.frag") }) };
var g3 = { shaders: (r10) => ({ vertexShader: n10("text/text.vert"), fragmentShader: n10("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var p5 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e15) => e15.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e15, r10, t23) {
    const a14 = r10.key << 3 | this._getMaterialOptionsValue(r10.type, t23);
    if (this._programByKey.has(a14)) return this._programByKey.get(a14);
    const s15 = this._getProgramTemplate(r10.type), { shaders: n17 } = s15, { vertexShader: c12, fragmentShader: o14 } = n17(t23), p8 = r10.getShaderHeader(), u18 = r10.getShaderMain(), i14 = c12.replace("#pragma header", p8).replace("#pragma main", u18), g7 = e15.programCache.acquire(i14, o14, r10.getAttributeLocations());
    return this._programByKey.set(a14, g7), g7;
  }
  _getMaterialOptionsValue(r10, t23) {
    switch (r10) {
      case L4.BACKGROUND:
        return (t23.pattern ? 1 : 0) << 1;
      case L4.FILL:
        return (t23.pattern ? 1 : 0) << 1;
      case L4.OUTLINE:
        return 0;
      case L4.LINE: {
        const e15 = t23;
        return (e15.sdf ? 1 : 0) << 2 | (e15.pattern ? 1 : 0) << 1;
      }
      case L4.ICON:
        return (t23.sdf ? 1 : 0) << 1;
      case L4.CIRCLE:
      case L4.TEXT:
      default:
        return 0;
    }
  }
  _getProgramTemplate(p8) {
    switch (p8) {
      case L4.BACKGROUND:
        return a8;
      case L4.CIRCLE:
        return d8;
      case L4.FILL:
        return i10;
      case L4.ICON:
        return f8;
      case L4.LINE:
        return o10;
      case L4.OUTLINE:
        return l8;
      case L4.TEXT:
        return g3;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _3 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r3(this._program), this._vertexArrayObject = r3(this._vertexArrayObject);
  }
  render(r10, t23, e15, i14) {
    r10 && (this._initialized || this._initialize(r10), r10.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), r10.bindVAO(this._vertexArrayObject), r10.useProgram(this._program), t23.setSamplingMode(e15), r10.bindTexture(t23, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i14), r10.drawArrays(E.TRIANGLE_STRIP, 0, 4), r10.bindTexture(null, 0), r10.bindVAO());
  }
  _initialize(r10) {
    if (this._initialized) return true;
    const s15 = e8(r10, e11);
    if (!s15) return false;
    const a14 = new Int8Array(16);
    a14[0] = -1, a14[1] = -1, a14[2] = 0, a14[3] = 0, a14[4] = 1, a14[5] = -1, a14[6] = 1, a14[7] = 0, a14[8] = -1, a14[9] = 1, a14[10] = 0, a14[11] = 1, a14[12] = 1, a14[13] = 1, a14[14] = 1, a14[15] = 1;
    const _7 = e11.attributes, p8 = new o6(r10, _7, t10, /* @__PURE__ */ new Map([["geometry", E3.createVertex(r10, F2.STATIC_DRAW, a14)]]));
    return this._program = s15, this._vertexArrayObject = p8, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e14 = class {
  constructor(r10) {
    this._rctx = r10, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r10) => r10.dispose()), this._programByKey.clear();
  }
  getProgram(e15, t23 = []) {
    const a14 = e15.vsPath + "." + e15.fsPath + JSON.stringify(t23);
    if (this._programByKey.has(a14)) return this._programByKey.get(a14);
    const s15 = { ...t23.map((r10) => "string" == typeof r10 ? { name: r10, value: true } : r10).reduce((r10, e16) => ({ ...r10, [e16.name]: e16.value }), {}) }, { vsPath: o14, fsPath: h13, attributes: i14 } = e15, g7 = o7(o14, h13, i14, s15), m7 = this._rctx.programCache.acquire(g7.shaders.vertexShader, g7.shaders.fragmentShader, g7.attributes);
    if (!m7) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a14, m7), m7;
  }
};

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var f9 = 512;
var d9 = class {
  constructor(e15) {
    this._resourceManager = e15, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e15) {
    switch (e15.type) {
      case "dash": {
        const r10 = q(e15.dashTemplate), [a14, n17, s15] = m3(r10);
        return { size: [n17, s15], image: new Uint32Array(a14.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t23, a14, n17, s15] = f5(this._canvas, e15, ai);
        return { size: [a14, n17], image: new Uint32Array(t23.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: s15 };
      }
      case "sdf":
        return u12(e15);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        return this._rasterizeCIMJSONResource(e15);
    }
  }
  _rasterizeCIMJSONResource(r10) {
    var _a;
    switch (r10.type) {
      case "CIMGradientFill":
      case "CIMGradientStroke": {
        const [e15, t23, n17] = g(this._canvas, r10);
        return { size: [t23, n17], image: new Uint32Array(e15.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, samplingMode: "Discrete" === r10.gradientType || "CIMFixedColorRamp" === r10.colorRamp.type ? "Nearest" : "Linear" };
      }
      case "CIMHatchFill": {
        const t23 = te.fromCIMHatchFill(r10, ai);
        return this._rasterizeCIMVectorMarker(t23);
      }
      case "CIMPictureMarker": {
        const t23 = te.fromCIMInsidePolygon(r10);
        return this._rasterizeCIMVectorMarker(t23);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === ((_a = r10.markerPlacement) == null ? void 0 : _a.type)) {
          const t24 = te.fromCIMInsidePolygon(r10);
          return this._rasterizeCIMVectorMarker(t24);
        }
        const t23 = a5(r10);
        return t23 && !r10.avoidSDFRasterization ? u12(t23) : this._rasterizeCIMVectorMarker(r10, false, oi);
      }
    }
  }
  _rasterizeCIMVectorMarker(r10, t23 = true, a14) {
    const s15 = t23 ? t4.fromExtent(r10.frame) : null, [i14, o14, c12, l15, h13] = te.rasterize(this._canvas, r10, s15, this._resourceManager, true, a14);
    return i14 ? { size: [o14, c12], image: new Uint32Array(i14.buffer), sdf: false, simplePattern: false, anchorX: l15, anchorY: h13 } : null;
  }
  rasterizeImageResource(e15, r10, t23, a14) {
    this._canvas.width = e15, this._canvas.height = r10;
    const n17 = this._canvas.getContext("2d", { willReadFrequently: true });
    t23 instanceof ImageData ? n17.putImageData(t23, 0, 0) : (t23.setAttribute("width", `${e15}px`), t23.setAttribute("height", `${r10}px`), n17.drawImage(t23, 0, 0, e15, r10));
    const s15 = n17.getImageData(0, 0, e15, r10), i14 = new Uint8Array(s15.data);
    if (a14) {
      for (const c12 of a14) if (c12 && c12.oldColor && 4 === c12.oldColor.length && c12.newColor && 4 === c12.newColor.length) {
        const [e16, r11, t24, a15] = c12.oldColor, [n18, s16, o15, l16] = c12.newColor;
        if (e16 === n18 && r11 === s16 && t24 === o15 && a15 === l16) continue;
        for (let c13 = 0; c13 < i14.length; c13 += 4) e16 === i14[c13] && r11 === i14[c13 + 1] && t24 === i14[c13 + 2] && a15 === i14[c13 + 3] && (i14[c13] = n18, i14[c13 + 1] = s16, i14[c13 + 2] = o15, i14[c13 + 3] = l16);
      }
    }
    let o14;
    for (let c12 = 0; c12 < i14.length; c12 += 4) o14 = i14[c12 + 3] / 255, i14[c12] = i14[c12] * o14, i14[c12 + 1] = i14[c12 + 1] * o14, i14[c12 + 2] = i14[c12 + 2] * o14;
    let l15 = i14, h13 = e15, d11 = r10;
    const u18 = f9;
    if (h13 >= u18 || d11 >= u18) {
      const t24 = h13 / d11;
      t24 > 1 ? (h13 = u18, d11 = Math.round(u18 / t24)) : (d11 = u18, h13 = Math.round(u18 * t24)), l15 = new Uint8Array(4 * h13 * d11);
      const a15 = new Uint8ClampedArray(l15.buffer);
      u6(i14, e15, r10, a15, h13, d11, false);
    }
    return { size: [h13, d11], image: new Uint32Array(l15.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function u12(e15) {
  if (!e15) return null;
  const { data: r10, width: t23, height: a14, sdfPaddingRatio: n17, sdfDecodeCoeff: s15 } = u9(e15);
  return r10 ? { size: [t23, a14], image: new Uint32Array(r10.buffer), sdf: true, simplePattern: true, sdfPaddingRatio: n17, sdfDecodeCoeff: s15, anchorX: 0, anchorY: 0 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t20 = class {
  constructor(t23, e15) {
    this._width = 0, this._height = 0, this._free = [], this._width = t23, this._height = e15, this._free.push(new t6(0, 0, t23, e15));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t23, e15) {
    if (t23 > this._width || e15 > this._height) return new t6();
    let i14 = null, s15 = -1;
    for (let h13 = 0; h13 < this._free.length; ++h13) {
      const r10 = this._free[h13];
      t23 <= r10.width && e15 <= r10.height && (null === i14 || r10.y <= i14.y && r10.x <= i14.x) && (i14 = r10, s15 = h13);
    }
    return null === i14 ? new t6() : (this._free.splice(s15, 1), i14.width < i14.height ? (i14.width > t23 && this._free.push(new t6(i14.x + t23, i14.y, i14.width - t23, e15)), i14.height > e15 && this._free.push(new t6(i14.x, i14.y + e15, i14.width, i14.height - e15))) : (i14.width > t23 && this._free.push(new t6(i14.x + t23, i14.y, i14.width - t23, i14.height)), i14.height > e15 && this._free.push(new t6(i14.x, i14.y + e15, t23, i14.height - e15))), new t6(i14.x, i14.y, t23, e15));
  }
  release(h13) {
    for (let t23 = 0; t23 < this._free.length; ++t23) {
      const e15 = this._free[t23];
      if (e15.y === h13.y && e15.height === h13.height && e15.x + e15.width === h13.x) e15.width += h13.width;
      else if (e15.x === h13.x && e15.width === h13.width && e15.y + e15.height === h13.y) e15.height += h13.height;
      else if (h13.y === e15.y && h13.height === e15.height && h13.x + h13.width === e15.x) e15.x = h13.x, e15.width += h13.width;
      else {
        if (h13.x !== e15.x || h13.width !== e15.width || h13.y + h13.height !== e15.y) continue;
        e15.y = h13.y, e15.height += h13.height;
      }
      this._free.splice(t23, 1), this.release(h13);
    }
    this._free.push(h13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n12 = 256;
var o11 = (t23) => Math.floor(t23 / 256);
function c6(t23) {
  const e15 = /* @__PURE__ */ new Set();
  for (const i14 of t23) e15.add(o11(i14));
  return e15;
}
function l9(e15, i14, h13) {
  return e15.has(i14) || e15.set(i14, h13().then(() => {
    e15.delete(i14);
  }).catch((h14) => {
    e15.delete(i14), f(h14);
  })), e15.get(i14);
}
var g4 = (t23) => ({ rect: new t6(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t23, sdf: true });
var p6 = class {
  constructor(t23, e15, h13) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t23, this.height = e15, this._glyphSource = h13, this._binPack = new t20(t23 - 4, e15 - 4), this._glyphData.push(new Uint8Array(t23 * e15)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t23 of this._textures) t23 && t23.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t23 = [117, 149, 181, 207, 207, 181, 149, 117], e15 = [], i14 = [];
    for (let r10 = 0; r10 < t23.length; r10++) {
      const h14 = t23[r10];
      for (let t24 = 0; t24 < 11; t24++) {
        const s16 = r10 >= 3 && r10 < 5 && t24 >= 3 && t24 < 8 ? 255 : 0;
        e15.push(h14), i14.push(s16);
      }
    }
    const h13 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e15) }, s15 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i14) };
    this._recordGlyph(h13), this._recordGlyph(s15);
  }
  getTexture(t23, e15) {
    if (!this._textures[e15]) {
      const i14 = new p3();
      i14.pixelFormat = G.ALPHA, i14.wrapMode = D.CLAMP_TO_EDGE, i14.width = this.width, i14.height = this.height, this._textures[e15] = new w3(t23, i14, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e15] && (this._textures[e15].setData(this._glyphData[e15]), this._dirties[e15] = false), this._textures[e15];
  }
  async getGlyphItems(t23, e15, i14) {
    const h13 = this._getGlyphCache(t23);
    return await this._fetchRanges(t23, e15, i14), e15.map((e16) => this._getMosaicItem(h13, t23, e16));
  }
  bind(t23, e15, i14, h13) {
    const s15 = this.getTexture(t23, i14);
    s15.setSamplingMode(e15), t23.bindTexture(s15, h13);
  }
  preloadASCIIGlyphCache(t23) {
    const e15 = this._preloadCache[t23];
    if (null != e15) return e15;
    const i14 = this._glyphSource.preloadASCIIRange(t23).then(() => {
      const e16 = this._getGlyphCache(t23);
      for (let i15 = 0; i15 < 256; i15++) this._getMosaicItem(e16, t23, i15);
    });
    return this._preloadCache[t23] = i14, i14;
  }
  _getGlyphCache(t23) {
    return this._glyphCache[t23] || (this._glyphCache[t23] = {}), this._glyphCache[t23];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t23, e15, i14) {
    const h13 = c6(e15), s15 = [];
    h13.forEach((e16) => {
      s15.push(this._fetchRange(t23, e16, i14));
    }), await Promise.all(s15);
  }
  async _fetchRange(t23, e15, i14) {
    if (e15 > n12) return;
    const h13 = t23 + e15;
    return l9(this._rangePromises, h13, () => this._glyphSource.getRange(t23, e15, i14));
  }
  _getMosaicItem(t23, e15, i14) {
    if (!t23[i14]) {
      const h13 = this._glyphSource.getGlyph(e15, i14);
      if (!(h13 == null ? void 0 : h13.metrics)) return g4(i14);
      const s15 = this._recordGlyph(h13), r10 = this._currentPage, a14 = h13.metrics;
      t23[i14] = { rect: s15, page: r10, metrics: a14, code: i14, sdf: true }, this._invalidate();
    }
    return t23[i14];
  }
  _recordGlyph(t23) {
    const h13 = t23.metrics;
    let s15;
    if (0 === h13.width) s15 = new t6(0, 0, 0, 0);
    else {
      const e15 = 3, r10 = h13.width + 2 * e15, a14 = h13.height + 2 * e15;
      s15 = this._binPack.allocate(r10, a14), s15.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t20(this.width - 4, this.height - 4), s15 = this._binPack.allocate(r10, a14));
      const n17 = this._glyphData[this._currentPage], o14 = t23.bitmap;
      let c12, l15;
      if (o14) for (let t24 = 0; t24 < a14; t24++) {
        c12 = r10 * t24, l15 = this.width * (s15.y + t24) + s15.x;
        for (let t25 = 0; t25 < r10; t25++) n17[l15 + t25] = o14[c12 + t25];
      }
      has("esri-glyph-debug") && this._showDebugPage(n17);
    }
    return s15;
  }
  _showDebugPage(t23) {
    const e15 = document.createElement("canvas"), i14 = e15.getContext("2d"), h13 = new ImageData(this.width, this.height), s15 = h13.data;
    e15.width = this.width, e15.height = this.height, e15.style.border = "1px solid black";
    for (let r10 = 0; r10 < t23.length; ++r10) s15[4 * r10] = t23[r10], s15[4 * r10 + 1] = 0, s15[4 * r10 + 2] = 0, s15[4 * r10 + 3] = 255;
    i14.putImageData(h13, 0, 0), document.body.appendChild(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a9 = class {
  constructor(e15) {
    for (this._metrics = [], this._bitmaps = []; e15.next(); ) switch (e15.tag()) {
      case 1: {
        const t23 = e15.getMessage();
        for (; t23.next(); ) switch (t23.tag()) {
          case 3: {
            const e16 = t23.getMessage();
            let a14, s15, r10, n17, i14, c12, g7;
            for (; e16.next(); ) switch (e16.tag()) {
              case 1:
                a14 = e16.getUInt32();
                break;
              case 2:
                s15 = e16.getBytes();
                break;
              case 3:
                r10 = e16.getUInt32();
                break;
              case 4:
                n17 = e16.getUInt32();
                break;
              case 5:
                i14 = e16.getSInt32();
                break;
              case 6:
                c12 = e16.getSInt32();
                break;
              case 7:
                g7 = e16.getUInt32();
                break;
              default:
                e16.skip();
            }
            e16.release(), a14 && (this._metrics[a14] = { width: r10, height: n17, left: i14, top: c12, advance: g7 }, this._bitmaps[a14] = s15);
            break;
          }
          default:
            t23.skip();
        }
        t23.release();
        break;
      }
      default:
        e15.skip();
    }
  }
  getMetrics(e15) {
    return this._metrics[e15];
  }
  getBitmap(e15) {
    return this._bitmaps[e15];
  }
};
var s11 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e15) {
    return this._ranges[e15];
  }
  addRange(e15, t23) {
    this._ranges[e15] = t23;
  }
};
var r8 = class {
  constructor(e15) {
    this._glyphInfo = {}, this._baseURL = e15;
  }
  getRange(s15, r10, n17) {
    const i14 = this._getFontStack(s15);
    if (i14.getRange(r10)) return Promise.resolve();
    const c12 = 256 * r10, g7 = c12 + 255, o14 = this._baseURL.replace("{fontstack}", s15).replace("{range}", c12 + "-" + g7);
    return P2(o14, { responseType: "array-buffer", ...n17 }).then((e15) => {
      i14.addRange(r10, new a9(new a2(new Uint8Array(e15.data), new DataView(e15.data))));
    });
  }
  async preloadASCIIRange(s15) {
    const r10 = this._getFontStack(s15), n17 = 0, i14 = 255, c12 = this._baseURL.replace("{fontstack}", s15).replace("{range}", n17 + "-" + i14), g7 = await P2(c12, { responseType: "array-buffer" }), o14 = new a9(new a2(new Uint8Array(g7.data), new DataView(g7.data)));
    for (let e15 = n17; e15 <= i14; e15++) r10.getRange(e15) || r10.addRange(e15, o14);
  }
  getGlyph(e15, t23) {
    const a14 = this._getFontStack(e15);
    if (!a14) return;
    const s15 = Math.floor(t23 / 256), r10 = a14.getRange(s15);
    return r10 ? { metrics: r10.getMetrics(t23), bitmap: r10.getBitmap(t23) } : void 0;
  }
  _getFontStack(e15) {
    let t23 = this._glyphInfo[e15];
    return t23 || (t23 = this._glyphInfo[e15] = new s11()), t23;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var o12 = 1e20;
var a10 = class {
  constructor(t23, e15 = 2) {
    this._textureSize = t23, this._rasterizationScale = e15, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: s15 } = this, i14 = document.createElement("canvas");
    i14.width = i14.height = s15, this._context = i14.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(s15 * s15), this._gridInner = new Float64Array(s15 * s15), this._f = new Float64Array(s15), this._d = new Float64Array(s15), this._z = new Float64Array(s15 + 1), this._v = new Int16Array(s15);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg = n5(this._svg);
  }
  draw(i14, r10, n17) {
    const { _canvasSize: a14, _textureSize: h13, _rasterizationScale: _7 } = this, l15 = h13 / 4;
    this._initSVG();
    const c12 = this.createSVGString(i14, r10);
    return new Promise((i15, r11) => {
      const d11 = new Image();
      d11.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(c12), d11.onload = () => {
        d11.onload = null, this._context.clearRect(0, 0, a14, a14), this._context.drawImage(d11, 0, 0, a14, a14);
        const e15 = this._context.getImageData(0, 0, a14, a14), s15 = new Uint8Array(h13 * h13 * 4);
        for (let t23 = 0; t23 < a14 * a14; t23++) {
          const s16 = e15.data[4 * t23 + 3] / 255;
          this._gridOuter[t23] = 1 === s16 ? 0 : 0 === s16 ? o12 : Math.max(0, 0.5 - s16) ** 2, this._gridInner[t23] = 1 === s16 ? o12 : 0 === s16 ? 0 : Math.max(0, s16 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, a14, a14), this._edt(this._gridInner, a14, a14);
        for (let i16 = 0; i16 < h13 * h13; i16++) {
          let e16 = 0;
          for (let t23 = 0; t23 < _7; t23++) {
            const s16 = Math.floor(i16 / h13) * _7 + t23;
            for (let t24 = 0; t24 < _7; t24++) {
              const r12 = s16 * a14 + (i16 % h13 * _7 + t24);
              e16 += this._gridOuter[r12] - this._gridInner[r12];
            }
          }
          e16 /= _7 * _7, e16 /= _7;
          o5(0.5 - e16 / (2 * l15), s15, 4 * i16);
        }
        i15(s15);
      };
      const g7 = n17 == null ? void 0 : n17.signal;
      g7 && m(g7, () => r11(u2()));
    });
  }
  _initSVG() {
    return this._svg || (this._svg = e4()), this._svg;
  }
  createSVGString(t23, e15) {
    const s15 = this._initSVG(), i14 = t5("path");
    i14.setAttribute("d", t23), s15.appendChild(i14);
    const r10 = i14.getBBox(), o14 = r10.width / r10.height, a14 = this._canvasSize / 2;
    let h13, _7, l15;
    if (o14 > 1) {
      h13 = a14 / r10.width;
      const t24 = a14 * (1 / o14);
      _7 = this._canvasSize / 4, l15 = a14 - t24 / 2;
    } else {
      h13 = a14 / r10.height;
      _7 = a14 - a14 * o14 / 2, l15 = this._canvasSize / 4;
    }
    const c12 = -r10.x * h13 + _7, d11 = -r10.y * h13 + l15;
    i14.setAttribute("style", `transform: matrix(${h13}, 0, 0, ${h13}, ${c12}, ${d11})`), i14.setAttribute("stroke-width", "" + 0.5 / h13);
    const g7 = `<svg style="fill:${e15 ? "red" : "none"}; stroke:${e15 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${s15.innerHTML}</svg>`;
    return s15.removeChild(i14), g7;
  }
  _edt(t23, e15, s15) {
    const i14 = this._f, r10 = this._d, n17 = this._v, o14 = this._z;
    for (let a14 = 0; a14 < e15; a14++) {
      for (let r11 = 0; r11 < s15; r11++) i14[r11] = t23[r11 * e15 + a14];
      this._edt1d(i14, r10, n17, o14, s15);
      for (let i15 = 0; i15 < s15; i15++) t23[i15 * e15 + a14] = r10[i15];
    }
    for (let a14 = 0; a14 < s15; a14++) {
      for (let s16 = 0; s16 < e15; s16++) i14[s16] = t23[a14 * e15 + s16];
      this._edt1d(i14, r10, n17, o14, e15);
      for (let s16 = 0; s16 < e15; s16++) t23[a14 * e15 + s16] = Math.sqrt(r10[s16]);
    }
  }
  _edt1d(t23, e15, s15, i14, r10) {
    s15[0] = 0, i14[0] = -1e20, i14[1] = 1e20;
    for (let n17 = 1, o14 = 0; n17 < r10; n17++) {
      let e16 = (t23[n17] + n17 * n17 - (t23[s15[o14]] + s15[o14] * s15[o14])) / (2 * n17 - 2 * s15[o14]);
      for (; e16 <= i14[o14]; ) o14--, e16 = (t23[n17] + n17 * n17 - (t23[s15[o14]] + s15[o14] * s15[o14])) / (2 * n17 - 2 * s15[o14]);
      o14++, s15[o14] = n17, i14[o14] = e16, i14[o14 + 1] = 1e20;
    }
    for (let n17 = 0, o14 = 0; n17 < r10; n17++) {
      for (; i14[o14 + 1] < n17; ) o14++;
      e15[n17] = (n17 - s15[o14]) * (n17 - s15[o14]) + t23[s15[o14]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c7(t23) {
  return t23 && "static" === t23.type;
}
var n13 = class _n {
  constructor(t23, e15, i14 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t23, this._pageHeight = e15, i14 > 0 && (this._maxItemSize = i14), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t20(this._pageWidth, this._pageHeight);
    const s15 = Math.floor(this._pageWidth), r10 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s15 * r10) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t23) {
    return t23 >= this._mosaicPages.length ? -1 : this._mosaicPages[t23].size[0];
  }
  getHeight(t23) {
    return t23 >= this._mosaicPages.length ? -1 : this._mosaicPages[t23].size[1];
  }
  getPageTexture(t23) {
    return t23 < this._mosaicPages.length ? this._mosaicPages[t23].texture : null;
  }
  has(t23) {
    return this._mosaicRects.has(t23);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t23) {
    return this._mosaicRects.get(t23);
  }
  addSpriteItem(t23, i14, a14, r10, o14, h13, n17 = 1, g7 = "Linear", p8 = 0.5, m7 = 1) {
    if (this._mosaicRects.has(t23)) return this._mosaicRects.get(t23);
    let d11, u18, l15;
    if (c7(a14)) [d11, u18, l15] = this._allocateImage(i14[0], i14[1]);
    else {
      d11 = new t6(0, 0, i14[0], i14[1]), u18 = this._mosaicPages.length;
      const t24 = void 0;
      this._mosaicPages.push({ mosaicsData: a14, size: [i14[0] + 2 * ti, i14[1] + 2 * ti], dirty: true, texture: t24 });
    }
    if (d11.width <= 0 || d11.height <= 0) return null;
    const _7 = { type: "sprite", rect: d11, width: i14[0], height: i14[1], sdf: o14, simplePattern: h13, rasterizationScale: n17, samplingMode: g7, sdfPaddingRatio: p8, sdfDecodeCoeff: m7, page: u18 };
    return this._mosaicRects.set(t23, _7), c7(a14) && (has("esri-mosaic-debug") && this._showDebugSprite(i14, a14.data), this._copy({ rect: d11, spriteSize: i14, spriteData: a14.data, page: u18, pageSize: l15, repeat: r10, sdf: o14 })), _7;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t23 = this._spriteCopyQueue.pop();
    t23 && this._copy(t23);
  }
  getMosaicItemPosition(t23) {
    const i14 = this.getSpriteItem(t23), s15 = i14 == null ? void 0 : i14.rect;
    if (!s15) return null;
    s15.width = i14.width, s15.height = i14.height;
    const a14 = i14.width, r10 = i14.height, o14 = ti, h13 = this._mosaicPages[i14.page].size;
    return { size: [i14.width, i14.height], tl: [(s15.x + o14) / h13[0], (s15.y + o14) / h13[1]], br: [(s15.x + o14 + a14) / h13[0], (s15.y + o14 + r10) / h13[1]], page: i14.page };
  }
  bind(t23, e15, i14 = 0, s15 = 0) {
    const a14 = this._mosaicPages[i14], r10 = a14.mosaicsData;
    let o14 = a14.texture;
    if (o14 || (o14 = p7(t23, a14.size), a14.texture = o14), o14.setSamplingMode(e15), c7(r10)) t23.bindTexture(o14, s15), a14.dirty && (o14.setData(new Uint8Array(r10.data.buffer)), o14.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i14));
    else {
      r10.data.loadFrame(o14), t23.bindTexture(o14, s15), o14.generateMipmap();
    }
    a14.dirty = false;
  }
  getTexture(t23, e15 = 0) {
    const i14 = this._mosaicPages[e15], s15 = i14.mosaicsData;
    let a14 = i14.texture;
    if (a14 || (a14 = p7(t23, i14.size), i14.texture = a14), c7(s15)) i14.dirty && (a14.setData(new Uint8Array(s15.data.buffer)), a14.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e15));
    else {
      s15.data.loadFrame(a14), a14.generateMipmap();
    }
    return i14.dirty = false, a14;
  }
  dispose() {
    this._binPack = null;
    for (const t23 of this._mosaicPages) {
      const e15 = t23.texture;
      e15 && e15.dispose();
      const i14 = t23.mosaicsData;
      if (!c7(i14)) {
        i14.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t23, e15, i14, s15, a14, r10, o14, h13, c12, n17, g7) {
    let p8 = s15 * e15 + i14, m7 = h13 * r10 + o14;
    if (g7) {
      m7 -= r10;
      for (let o15 = -1; o15 <= n17; o15++, p8 = ((o15 + n17) % n17 + s15) * e15 + i14, m7 += r10) for (let e16 = -1; e16 <= c12; e16++) a14[m7 + e16] = t23[p8 + (e16 + c12) % c12];
    } else for (let d11 = 0; d11 < n17; d11++) {
      for (let e16 = 0; e16 < c12; e16++) a14[m7 + e16] = t23[p8 + e16];
      p8 += e15, m7 += r10;
    }
  }
  _copy(i14) {
    if (i14.page >= this._mosaicPages.length) return;
    const s15 = this._mosaicPages[i14.page], a14 = s15.mosaicsData;
    if (!c7(s15.mosaicsData)) throw new s3("mapview-invalid-resource", "unsuitable data type!");
    const r10 = i14.spriteData, o14 = a14.data;
    _n._copyBits(r10, i14.spriteSize[0], 0, 0, o14, i14.pageSize[0], i14.rect.x + ti, i14.rect.y + ti, i14.spriteSize[0], i14.spriteSize[1], i14.repeat), s15.dirty = true;
  }
  _allocateImage(t23, r10) {
    t23 += 2 * ti, r10 += 2 * ti;
    const o14 = Math.max(t23, r10);
    if (this._maxItemSize && this._maxItemSize < o14) {
      const e15 = 2 ** Math.ceil(e10(t23)), a14 = 2 ** Math.ceil(e10(r10)), o15 = new t6(0, 0, t23, r10);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e15 * a14) }, size: [e15, a14], dirty: true, texture: void 0 }), [o15, this._mosaicPages.length - 1, [e15, a14]];
    }
    const h13 = this._binPack.allocate(t23, r10);
    if (h13.width <= 0) {
      const e15 = this._mosaicPages[this._currentPage];
      return !e15.dirty && c7(e15.mosaicsData) && (e15.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t20(this._pageWidth, this._pageHeight), this._allocateImage(t23, r10);
    }
    return [h13, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t23, e15], i14) {
    const s15 = document.createElement("canvas");
    s15.width = t23, s15.height = e15, s15.setAttribute("style", `position: absolute; top: ${4 + 204 * g5++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a14 = s15.getContext("2d"), r10 = new ImageData(t23, e15);
    r10.data.set(new Uint8Array(i14.buffer)), a14.putImageData(r10, 0, 0), document.body.appendChild(s15);
  }
  _showDebugPage(t23) {
    const e15 = this._mosaicPages[t23], { size: [i14, s15], mosaicsData: a14 } = e15;
    if (!c7(a14)) return;
    const r10 = `mosaicDebugPage${t23}`, o14 = document.getElementById(r10) ?? document.createElement("canvas");
    o14.id = r10, o14.width = i14, o14.height = s15, o14.setAttribute("style", `position: absolute; top: ${4 + 204 * t23}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h13 = o14.getContext("2d"), n17 = new ImageData(i14, s15);
    n17.data.set(new Uint8Array(a14.data.buffer)), h13.putImageData(n17, 0, 0), document.body.appendChild(o14);
  }
};
var g5 = 0;
function p7(t23, e15) {
  const i14 = new p3();
  return i14.width = e15[0], i14.height = e15[1], i14.wrapMode = D.CLAMP_TO_EDGE, new w3(t23, i14, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a11 = class {
  constructor(t23, a14, h13, e15) {
    this._animation = t23, this._frameData = null;
    const n17 = (t24) => {
      this._frameData = t24, a14.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = c3(this._animation, h13, e15, n17);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i14) {
    const a14 = this._frameData;
    if (null == a14) return;
    const h13 = "width" in a14 ? a14.width : a14.codedWidth, e15 = "height" in a14 ? a14.height : a14.codedHeight;
    i14.updateData(0, ti, ti, h13, e15, a14), this._frameData = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/store/AnimationStore.js
var h8 = class {
  constructor() {
    this._entries = new l10(), this._nodes = /* @__PURE__ */ new Map(), this._book = new a12();
  }
  add(t23) {
    let e15 = this._entries.get(t23);
    if (!e15) {
      const s15 = this._book.add(t23), r10 = new Object();
      e15 = { location: s15, references: 0, handle: r10 };
      const o14 = this._entries.set(t23, e15);
      this._nodes.set(r10, o14);
    }
    return e15.references++, e15;
  }
  remove(t23) {
    const e15 = this._nodes.get(t23.handle);
    e15 && e15.payload && (e15.payload.references--, 0 === e15.payload.references && (this._book.remove(e15.payload.location), this._entries.delete(e15), this._nodes.delete(t23.handle)));
  }
  getTexture(t23, e15) {
    return this._book.getTexture(t23, e15);
  }
  destroy() {
    this._book.destroy();
  }
};
var u13 = class _u {
  constructor(t23, e15) {
    this.parent = t23, this.key = e15, this.payload = null, this._children = /* @__PURE__ */ new Map();
  }
  get(t23) {
    return this._children.get(t23);
  }
  ensure(t23) {
    let e15 = this._children.get(t23);
    return e15 || (e15 = new _u(this, t23), this._children.set(t23, e15)), e15;
  }
  delete(t23) {
    this._children.delete(t23);
  }
};
var l10 = class {
  constructor() {
    this._root = new u13(null, NaN);
  }
  set(t23, e15) {
    let s15 = this._root;
    for (const r10 of t23) for (const t24 of r10) s15 = s15.ensure(t24);
    return s15.payload = e15, s15;
  }
  delete(t23) {
    var _a;
    (_a = t23.parent) == null ? void 0 : _a.delete(t23.key);
  }
  get(t23) {
    let e15 = this._root;
    for (const s15 of t23) for (const t24 of s15) {
      const s16 = e15.get(t24);
      if (!s16) return;
      e15 = s16;
    }
    return e15.payload || void 0;
  }
};
var a12 = class {
  constructor() {
    this._pages = [];
  }
  add(t23) {
    0 === this._pages.length && this._pages.push(new _4());
    let e15 = this._pages.length - 1, s15 = this._pages[e15].add(t23);
    if (s15 || (this._pages.push(new _4()), e15 = this._pages.length - 1, s15 = this._pages[e15].add(t23)), !s15) throw new Error("Data allocation failed.");
    return { ...s15, page: e15 };
  }
  remove(t23) {
    this._pages[t23.page].remove(t23);
  }
  getTexture(t23, e15) {
    return this._pages[e15].getTexture(t23);
  }
  destroy() {
  }
};
var _4 = class {
  constructor() {
    this._cursor = { row: 0, column: 0 }, this._columns = 1024, this._rows = 1024, this._data = new Float32Array(this._columns * this._rows * 4), this._texture = null, this._textureCursor = { row: 0, column: 0 };
  }
  add(t23) {
    if (t23.length > this._columns) throw new Error(`The maximum allocation size is ${this._columns} texels.`);
    const e15 = { ...this._cursor };
    if (e15.column += t23.length, e15.column >= this._columns && (e15.column = t23.length, e15.row++), e15.row >= this._rows) return null;
    this._cursor = e15;
    const s15 = { ...this._cursor };
    s15.column -= t23.length;
    let r10 = 4 * (s15.row * this._columns + s15.column);
    for (let o14 = 0; o14 < t23.length; o14++) this._data[r10++] = t23[o14][0], this._data[r10++] = t23[o14][1], this._data[r10++] = t23[o14][2], this._data[r10++] = t23[o14][3];
    return s15;
  }
  remove(t23) {
  }
  getTexture(h13) {
    if (!this._texture) {
      const u19 = new p3(this._columns, this._rows);
      u19.pixelFormat = G.RGBA, u19.dataType = U2.FLOAT, u19.wrapMode = D.CLAMP_TO_EDGE, u19.samplingMode = L2.NEAREST, u19.hasMipmap = false;
      const l16 = new a4(h13, u19);
      this._texture = new w3(h13, l16);
    }
    if (this._cursor.row === this._textureCursor.row && this._cursor.column === this._textureCursor.column) return this._texture;
    const u18 = this._textureCursor.row, l15 = this._cursor.row - u18 + 1;
    return this._texture.updateData(0, 0, u18, this._columns, l15, this._data, u18), this._textureCursor.row = this._cursor.row, this._textureCursor.column = this._cursor.column, this._texture;
  }
  destroy() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var $2 = "arial-unicode-ms-regular";
var v2 = () => n.getLogger("esri.views.MapView");
var k2 = (e15, t23, i14) => v2().error(new s3(e15, t23, i14));
var A5 = (e15, t23 = "") => v2().warnOnce(e15, t23);
var F6 = class _F {
  static fromMosaic(e15, t23) {
    return new _F(e15, t23.page, t23.sdf, t23.samplingMode);
  }
  constructor(e15, t23, i14, s15) {
    this.mosaicType = e15, this.page = t23, this.sdf = i14, this.samplingMode = s15;
  }
};
var G2 = class {
  constructor(i14) {
    this._requestRender = i14, this._resourceManager = new i7(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new a10(ei), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e15, i15) => {
      s4(i15);
      try {
        return await P2(e15, { responseType: "image", signal: i15 });
      } catch (r10) {
        if (!b(r10)) throw new s3("mapview-invalid-resource", `Could not fetch requested resource at ${e15}`, r10);
        throw r10;
      }
    } }), this.animationStore = new h8(), this._spriteMosaic = new n13(2048, 2048, 500), this._glyphSource = new r8(`${s2.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p6(1024, 1024, this._glyphSource), this._rasterizer = new d9(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy(), this.animationStore.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e15, t23) {
    if (null == e15) return k2("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("animation-info" === e15.type) {
      const { resource: t24 } = e15, i15 = this.animationStore.add(t24), { location: s16 } = i15;
      return { rect: new t6(s16.column, s16.row, t24.length, 1), page: s16.page, type: "sprite", width: t24.length, height: 1, rasterizationScale: 1, sdfPaddingRatio: 0.5, samplingMode: "Linear", sdfDecodeCoeff: 1, simplePattern: false };
    }
    if ("cim-rasterization-info" !== e15.type) return k2("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i14 } = e15;
    if ("text" === i14.type) {
      const e16 = await this._rasterizeText(i14, t23);
      for (const t24 of e16.glyphs) this._setTextureBinding(A2.GLYPH, t24);
      return e16;
    }
    const s15 = await this._rasterizeSprite(i14, t23);
    return s15 && this._setTextureBinding(A2.SPRITE, s15), s15;
  }
  getMosaicInfo(e15, t23, i14 = false) {
    const s15 = this._getTextureBindingInfo(e15, t23, i14);
    return s15 ? { size: s15.size, texture: { texture: s15.texture, unit: "sprite" === s15.type ? U3 : u5 } } : (k2("mapview-invalid-resource", `Unable to find resource for ${t23}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e15, t23, i14) {
    const s15 = this._bindingInfos[t23 - 1], r10 = s15.page, a14 = "Nearest" === s15.samplingMode ? L2.NEAREST : i14 ? L2.LINEAR_MIPMAP_LINEAR : L2.LINEAR;
    switch (s15.mosaicType) {
      case A2.SPRITE: {
        const t24 = [this.sprites.getWidth(r10), this.sprites.getHeight(r10)], i15 = this._spriteMosaic.getTexture(e15, r10);
        return i15.setSamplingMode(a14), { type: "sprite", texture: i15, size: t24 };
      }
      case A2.GLYPH: {
        const t24 = [this.glyphs.width, this.glyphs.height], i15 = this._glyphMosaic.getTexture(e15, r10);
        return this._glyphMosaic.bind(e15, a14, r10, u5), i15.setSamplingMode(a14), { type: "glyph", texture: i15, size: t24 };
      }
      default:
        return k2("mapview-texture-manager", `Cannot handle unknown type ${s15.mosaicType}`), null;
    }
  }
  _hashMosaic(e15, t23) {
    return 1 | e15 << 1 | (t23.sdf ? 1 : 0) << 2 | ("Nearest" === t23.samplingMode ? 1 : 0) << 3 | t23.page << 4;
  }
  _setTextureBinding(e15, t23) {
    const i14 = this._hashMosaic(e15, t23);
    if (!this._hashToBindingIndex.has(i14)) {
      const s15 = F6.fromMosaic(e15, t23), r10 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i14, r10), this._bindingInfos.push(s15);
    }
    t23.textureBinding = this._hashToBindingIndex.get(i14);
  }
  async _rasterizeText(e15, t23) {
    const { font: s15, textString: a14 } = e15, n17 = f4(s15), o14 = this._invalidFontsMap.has(n17), [c12, h13] = i3(a14), l15 = d6(c12);
    try {
      const e16 = o14 ? $2 : n17;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e16);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e16, l15, t23), isRightToLeft: h13 };
    } catch (u18) {
      A5(`Font ${n17} is not available on the web, using "Arial Unicode MS Regular"`), this._invalidFontsMap.set(n17, true);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems($2, l15, t23), isRightToLeft: h13 };
    }
  }
  _hashSpriteResource(e15) {
    switch (e15.type) {
      case "path":
        return `path:${e15.path}.${e15.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e15.type}:${e15.url}:${e15.size}:${p2(e15.markerPlacement)}`;
      case "CIMPictureFill":
        return `${e15.type}:${e15.url}:${e15.height}`;
      case "CIMPictureStroke":
        return `${e15.type}:${e15.url}:${e15.width}`;
      case "dash":
        return `dash:${e15.capStyle}.${q(e15.dashTemplate).join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e15.geom)}.${e15.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e15.style}`;
      case "animated":
        return JSON.stringify(r5(e15));
      case "CIMGradientFill":
      case "CIMGradientStroke":
        return `gradient:${JSON.stringify(e15.colorRamp)}.${e15.gradientType}.${e15.interval}`;
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e15);
    }
  }
  async _rasterizeSprite(e15, t23) {
    var _a;
    if (!e15) return null;
    const i14 = l(this._hashSpriteResource(e15));
    if (this._spriteMosaic.has(i14)) return this._spriteMosaic.getSpriteItem(i14);
    if ("url" in e15 && e15.url || "CIMPictureFill" === e15.type || "CIMPictureStroke" === e15.type || "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type) {
      const t24 = [];
      te.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e15] }, this._resourceManager, t24), t24.length > 0 && await Promise.all(t24);
    }
    switch (e15.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === ((_a = e15.markerPlacement) == null ? void 0 : _a.type) ? this._rasterizeJSONResource(i14, e15) : this._handleAsyncResource(i14, e15, t23);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i14, e15, t23);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "dash":
      case "fill-style":
      case "sdf":
        return this._rasterizeJSONResource(i14, e15);
    }
  }
  _rasterizeJSONResource(e15, t23) {
    const i14 = this._rasterizer.rasterizeJSONResource(t23);
    if (i14) {
      const { size: s15, image: r10, sdf: a14, simplePattern: n17, rasterizationScale: o14, samplingMode: c12, sdfPaddingRatio: h13, sdfDecodeCoeff: l15 } = i14;
      return this._addItemToMosaic(e15, s15, { type: "static", data: r10 }, N3(t23), a14, n17, o14, c12, h13, l15);
    }
    return null;
  }
  async _handleAsyncResource(e15, t23, i14) {
    if (this._ongoingRasterizations.has(e15)) return this._ongoingRasterizations.get(e15);
    let s15;
    return s15 = "path" === t23.type ? this._handleSVG(t23, e15, i14) : this._handleImage(t23, e15, i14), this._ongoingRasterizations.set(e15, s15), s15.finally(() => this._ongoingRasterizations.delete(e15)), s15;
  }
  async _handleSVG(e15, t23, i14) {
    const s15 = [ei, ei], { asFill: r10 } = e15, a14 = await this._sdfConverter.draw(e15.path, r10, i14);
    return this._addItemToMosaic(t23, s15, { type: "static", data: new Uint32Array(a14.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e15, t23, i14) {
    const s15 = e15.url, r10 = this.resourceManager.getResource(s15);
    if (null == r10) return null;
    const { width: a14, height: n17 } = r10;
    if (r10 instanceof HTMLImageElement) {
      if ("animated" === e15.type) return k2("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i15 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: s16, sdf: o15, image: c13 } = this._rasterizer.rasterizeImageResource(a14, n17, r10, i15);
      return this._addItemToMosaic(t23, s16, { type: "static", data: c13 }, N3(e15), o15, false);
    }
    let o14, c12, h13;
    "animated" === e15.type ? (o14 = false, c12 = { type: "CIMAnimatedSymbolProperties", playAnimation: e15.playAnimation, reverseAnimation: e15.reverseAnimation, randomizeStartTime: e15.randomizeStartTime, randomizeStartSeed: e15.randomizeStartSeed, startTimeOffset: e15.startTimeOffset, duration: e15.duration, repeatType: e15.repeatType, repeatDelay: e15.repeatDelay }, h13 = e15.startGroup || 0) : (o14 = N3(e15), c12 = { type: "CIMAnimatedSymbolProperties" }, h13 = 0);
    const l15 = new a11(r10, this._requestRender, c12, h13);
    return this._addItemToMosaic(t23, [l15.width, l15.height], { type: "animated", data: l15 }, o14, false, false);
  }
  async _handleImage(e15, t23, i14) {
    const r10 = e15.url;
    if (L6(r10) || U5(r10)) return this._handleGIFOrPNG(e15, t23, i14);
    if ("animated" === e15.type) return k2("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let s15;
      const a14 = this.resourceManager.getResource(r10);
      if (null != a14 && a14 instanceof HTMLImageElement) s15 = a14;
      else {
        const { data: e16 } = await this._imageRequestQueue.push(r10, { ...i14 });
        s15 = e16;
      }
      if (f6(r10)) {
        if ("width" in e15 && "height" in e15) s15.width = u3(e15.width), s15.height = u3(e15.height);
        else if ("cim" in e15) {
          const t24 = e15;
          s15.width = u3(t24.width ?? t24.scaleX * t24.size), s15.height = u3(t24.size);
        }
      }
      if (!s15.width || !s15.height) return null;
      const n17 = s15.width, o14 = s15.height, c12 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: l15, sdf: u18, image: p8 } = this._rasterizer.rasterizeImageResource(n17, o14, s15, c12);
      return this._addItemToMosaic(t23, l15, { type: "static", data: p8 }, N3(e15), u18, false);
    } catch (k3) {
      if (!b(k3)) throw new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r10}. ${k3.message}`);
      throw k3;
    }
  }
  _addItemToMosaic(e15, t23, i14, s15, r10, a14, n17, o14, c12, h13) {
    return this._spriteMosaic.addSpriteItem(e15, t23, i14, s15, r10, a14, n17, o14, c12, h13);
  }
};
function N3(e15) {
  switch (e15.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return E6(e15);
    default:
      return true;
  }
}
var B4 = (e15) => null != e15 && e15.startsWith("data:image/gif");
var L6 = (e15) => e15 && (e15.includes(".gif") || B4(e15));
var O5 = (e15) => null != e15 && e15.startsWith("data:image/png");
var U5 = (e15) => e15 && (e15.includes(".png") || O5(e15));
var E6 = (e15) => e15 && "markerPlacement" in e15 && e15.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e15.markerPlacement.type;

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var u14 = class {
  constructor(e15) {
    this._queue = [], this._refreshable = e15;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(o14, u18) {
    const n17 = L(), h13 = o14, i14 = Ui, a14 = Math.ceil(h13.height / i14);
    s4(u18);
    for (let e15 = 0; e15 < a14; e15++) {
      const t23 = e15 * i14, s15 = e15 === a14 - 1, r10 = s15 ? h13.height - i14 * e15 : i14;
      this._queue.push({ type: "chunk", request: o14, resolver: n17, chunk: e15, chunkOffset: t23, destHeight: r10, chunkIsLast: s15, options: u18 });
    }
    return w(u18, (e15) => n17.reject(e15)), n17.promise;
  }
  upload() {
    const e15 = performance.now();
    let t23 = 0;
    for (; this._queue.length; ) {
      const s15 = this._queue.shift();
      if (s15) {
        if (null != s15.options.signal && s15.options.signal.aborted) continue;
        switch (s15.type) {
          case "chunk":
            this._uploadChunk(s15);
            break;
          case "no-chunk":
            this._uploadNoChunk(s15);
        }
        ++t23;
        const r10 = performance.now() - e15;
        if (r10 + r10 / t23 >= ui) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e15) {
    const { request: t23, resolver: s15, chunkOffset: o14, chunkIsLast: r10, destHeight: u18 } = e15, { data: n17, texture: h13, width: i14 } = t23;
    null != n17 && (h13.updateData(0, 0, o14, i14, u18, n17, o14), r10 && s15.resolve());
  }
  _uploadNoChunk(e15) {
    const { request: t23, resolver: s15 } = e15, { data: o14, texture: r10 } = t23;
    r10.setData(o14), s15.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var g6 = t2(-0.5, -0.5);
var b5 = class {
  constructor() {
    this._centerNdc = n2(), this._pxToNdc = n2(), this._worldDimensionsPx = n2(), this._mat3 = e6(), this._initialized = false;
  }
  dispose() {
    this._program = r3(this._program), this._quad = r3(this._quad);
  }
  render(t23, i14, e15) {
    const { context: r10 } = t23, s15 = this._updateGeometry(t23, e15);
    if (null != i14) {
      const { r: t24, g: e16, b: s16, a: o14 } = i14;
      r10.setClearColor(o14 * t24 / 255, o14 * e16 / 255, o14 * s16 / 255, o14);
    } else r10.setClearColor(0, 0, 0, 0);
    if (r10.setStencilFunction(O2.ALWAYS, 0, 255), r10.setStencilWriteMask(255), !s15) return r10.setClearStencil(Ci), void r10.clear(r10.gl.STENCIL_BUFFER_BIT | r10.gl.COLOR_BUFFER_BIT);
    r10.setClearStencil(Ei), r10.clear(r10.gl.STENCIL_BUFFER_BIT | r10.gl.COLOR_BUFFER_BIT), this._initialized || this._initialize(r10), r10.setDepthWriteEnabled(false), r10.setDepthTestEnabled(false), r10.setColorMask(false, false, false, false), r10.setBlendingEnabled(false), r10.setStencilOp(I2.KEEP, I2.KEEP, I2.REPLACE), r10.setStencilFunction(O2.ALWAYS, Ci, 255), r10.setStencilTestEnabled(true), r10.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.bind(), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t23) {
    if (this._initialized) return;
    const i14 = e8(t23, r6);
    i14 && (this._program = i14, this._quad = new n8(t23, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t23, a14) {
    const { state: n17, pixelRatio: m7 } = t23, { size: c12, rotation: h13 } = n17, d11 = Math.round(c12[0] * m7), _7 = Math.round(c12[1] * m7);
    if (!n17.spatialReference.isWrappable) return false;
    const p8 = u4(h13), f12 = Math.abs(Math.cos(p8)), u18 = Math.abs(Math.sin(p8)), b6 = Math.round(d11 * f12 + _7 * u18), x6 = Math.round(m7 * n17.worldScreenWidth);
    if (b6 <= x6) return false;
    const E7 = d11 * u18 + _7 * f12, S3 = (a14.left - a14.right) * m7 / d11, j = (a14.bottom - a14.top) * m7 / _7;
    o3(this._worldDimensionsPx, x6, E7, 1), o3(this._pxToNdc, 2 / d11, -2 / _7, 1), o3(this._centerNdc, S3, j, 1);
    const C4 = this._mat3;
    return l4(C4, this._centerNdc), f2(C4, C4, this._pxToNdc), 0 !== h13 && h(C4, C4, p8), f2(C4, C4, this._worldDimensionsPx), M(C4, C4, g6), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/blend/BlendTechnique.js
var f10 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Blend, this._backBufferTexture = null, this.shaders = { blend: new D3(), opacity: new h5() };
  }
  shutdown() {
    super.shutdown(), null !== this._backBufferTexture && (this._backBufferTexture.dispose(), this._backBufferTexture = null);
  }
  render(t23, r10) {
    const { context: s15, state: i14, pixelRatio: o14, inFadeTransition: n17, painter: a14 } = t23, { size: c12 } = i14, f12 = s15.getBoundFramebufferObject();
    let h13, l15;
    null != f12 ? (h13 = f12.width, l15 = f12.height) : (h13 = Math.round(o14 * c12[0]), l15 = Math.round(o14 * c12[1]));
    const { blendMode: d11 } = r10;
    if ("normal" === d11) {
      const t24 = { shader: this.shaders.opacity, uniforms: { config: { layerTexture: { texture: r10.colorTexture, unit: 0 }, opacity: r10.config.opacity } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      return a14.setPipelineState(t11), void a14.submitDrawMesh(s15, t24, a14.quadMesh);
    }
    const p8 = this._createOrResizeTexture(t23, h13, l15);
    f12.copyToTexture(0, 0, h13, l15, 0, 0, p8);
    const x6 = { color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO } }, depth: false, stencil: false };
    a14.setPipelineState(x6);
    const b6 = { backbufferTexture: { texture: p8, unit: 0 }, layerTexture: { texture: r10.colorTexture, unit: 1 }, inFadeOpacity: n17 ? 1 : 0, ...r10.config }, T4 = { shader: this.shaders.blend, uniforms: { config: b6 }, defines: { blendMode: d11 }, optionalAttributes: null, useComputeBuffer: false };
    a14.submitDrawMesh(s15, T4, a14.quadMesh);
  }
  _createOrResizeTexture(e15, t23, r10) {
    var _a, _b;
    const { context: s15 } = e15;
    if (null !== this._backBufferTexture && ((_a = this._backBufferTexture.descriptor) == null ? void 0 : _a.width) === t23 && ((_b = this._backBufferTexture.descriptor) == null ? void 0 : _b.height) === r10) return this._backBufferTexture;
    if (null === this._backBufferTexture) {
      const e16 = new p3();
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = t23, e16.height = r10, this._backBufferTexture = new w3(s15, e16);
    } else this._backBufferTexture.resize(t23, r10);
    return this._backBufferTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var n14 = class {
  constructor() {
    this._blendTechnique = new f10();
  }
  dispose(e15) {
    var _a;
    (_a = this._blendTechnique) == null ? void 0 : _a.shutdown();
  }
  draw(e15, n17, d11, i14, o14) {
    this._blendTechnique.render(e15, { colorTexture: n17, config: { opacity: o14, samplingMode: d11 }, blendMode: i14 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t21 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t23, r10) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var s12 = class extends t21 {
  constructor(e15) {
    super(), this.name = this.constructor.name, this.defines = [e15];
  }
  dispose() {
  }
  bind({ context: e15, painter: t23 }) {
    this._prev = e15.getBoundFramebufferObject();
    const s15 = t23.getFbos().effect0;
    e15.bindFramebuffer(s15), e15.setColorMask(true, true, true, true), e15.setClearColor(0, 0, 0, 0), e15.clear(e15.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e15, s15) {
    const { context: r10, painter: o14 } = e15, n17 = o14.getPostProcessingEffects(s15), c12 = r10.getBoundFramebufferObject();
    for (const { postProcessingEffect: t23, effect: f12 } of n17) t23.draw(e15, c12, f12);
    r10.bindFramebuffer(this._prev), r10.setStencilTestEnabled(false), o14.blitTexture(r10, c12.colorTexture, L2.NEAREST), r10.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c8 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e15, i14) {
    e15.bindTexture(i14, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t13), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  finalBlur(e15, s15) {
    e15.bindTexture(s15, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", c4), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  renderHighlight(e15, s15, i14) {
    e15.bindTexture(s15, C2), e15.useProgram(this._resources.highlightProgram), i14.applyHighlightOptions(e15, this._resources.highlightProgram), e15.bindVAO(this._resources.quadVAO), e15.setBlendingEnabled(true), e15.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  _initialize(s15, i14, h13) {
    this._width = i14, this._height = h13;
    const m7 = E3.createVertex(s15, F2.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c12 = new o6(s15, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), /* @__PURE__ */ new Map([["geometry", [new t3("a_position", 2, C.BYTE, 0, 4), new t3("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)]]]), /* @__PURE__ */ new Map([["geometry", m7]])), f12 = e8(s15, t14), b6 = e8(s15, r7);
    s15.useProgram(f12), f12.setUniform1i("u_texture", C2), f12.setUniform1i("u_shade", E2), f12.setUniform1f("u_sigma", o8), s15.useProgram(b6), b6.setUniform1i("u_texture", C2), b6.setUniform1f("u_sigma", o8), this._resources = { quadGeometry: m7, quadVAO: c12, highlightProgram: f12, blurProgram: b6 };
  }
  setup(r10, e15, s15) {
    this._resources ? (this._width = e15, this._height = s15) : this._initialize(r10, e15, s15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i11(i14, h13, u18) {
  const l15 = new p3(h13, u18);
  return l15.wrapMode = D.CLAMP_TO_EDGE, new x3(i14, l15, new i8(B2.STENCIL_INDEX8, h13, u18));
}
var h9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r10, e15, s15) {
    this._width = e15, this._height = s15;
    const t23 = i11(r10, e15, s15), o14 = i11(r10, e15, s15);
    this._resources = { sharedBlur1Fbo: t23, sharedBlur2Fbo: o14 };
  }
  setup(r10, e15, s15) {
    !this._resources || this._width === e15 && this._height === s15 || this.dispose(), this._resources || this._initialize(r10, e15, s15);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var h10 = 4;
var d10 = 4 / h10;
var l11 = class extends t21 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c8(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h9(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _3();
  }
  dispose() {
    var _a, _b;
    (_a = this._hlSurfaces) == null ? void 0 : _a.dispose(), (_b = this._hlRenderer) == null ? void 0 : _b.dispose(), this._boundFBO = null;
  }
  bind(e15) {
    const { context: t23, painter: s15 } = e15, { width: r10, height: i14 } = t23.getViewport(), h13 = s15.getFbos().effect0;
    this.setup(e15, r10, i14), t23.bindFramebuffer(h13), t23.setColorMask(true, true, true, true), t23.setClearColor(0, 0, 0, 0), t23.clear(t23.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({ context: e15 }, t23, s15) {
    this._width = t23, this._height = s15;
    const r10 = t23 % h10, i14 = s15 % h10;
    t23 += r10 < h10 / 2 ? -r10 : h10 - r10, s15 += i14 < h10 / 2 ? -i14 : h10 - i14, this._adjustedWidth = t23, this._adjustedHeight = s15, this._boundFBO = e15.getBoundFramebufferObject();
    const l15 = Math.round(t23 * d10), o14 = Math.round(s15 * d10);
    this._hlRenderer.setup(e15, l15, o14), this._hlSurfaces.setup(e15, l15, o14);
  }
  draw(e15) {
    const { context: t23, passOptions: s15 } = e15, r10 = s15.activeGradient, h13 = t23.getBoundFramebufferObject();
    t23.setViewport(0, 0, this._adjustedWidth * d10, this._adjustedHeight * d10), t23.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t23.setStencilTestEnabled(false), t23.setClearColor(0, 0, 0, 0), t23.clear(t23.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(t23, h13.colorTexture, L2.NEAREST, 1), t23.setStencilTestEnabled(false), t23.setBlendingEnabled(false), t23.setColorMask(false, false, false, true), t23.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t23.setClearColor(0, 0, 0, 0), t23.clear(t23.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(t23, this._hlSurfaces.sharedBlur1Tex), t23.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t23.setClearColor(0, 0, 0, 0), t23.clear(t23.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(t23, this._hlSurfaces.sharedBlur2Tex), t23.bindFramebuffer(this._boundFBO), t23.setBlendingEnabled(true), t23.setColorMask(true, true, true, true), t23.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t23, this._hlSurfaces.sharedBlur1Tex, r10), this._boundFBO = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var c9 = class extends t21 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: t23 }, r10) {
    if (!r10.length) return null;
    const n17 = r10.shift(), l15 = n17.x, c12 = n17.y;
    this._outstanding = n17;
    const a14 = has("esri-mobile");
    return { type: "hittest", distance: (a14 ? S : W) * t23, smallSymbolDistance: (a14 ? S : X) * t23, smallSymbolSizeThreshold: Y, position: [l15, c12] };
  }
  bind(e15) {
    const { context: s15, attributeView: i14 } = e15;
    if (!i14.size) return;
    const o14 = i14.getBlock(J.GPGPU);
    if (null == o14) return;
    const r10 = o14.getFBO(s15);
    s15.setViewport(0, 0, i14.size, i14.size), s15.bindFramebuffer(r10), s15.setColorMask(true, true, true, true), s15.setClearColor(0, 0, 0, 0), s15.clear(s15.gl.COLOR_BUFFER_BIT | s15.gl.DEPTH_BUFFER_BIT);
  }
  unbind() {
  }
  draw(t23) {
    if (null == this._outstanding) return;
    const e15 = this._outstanding;
    this._outstanding = null, this._resolve(t23, e15.resolvers);
  }
  async _resolve(e15, s15) {
    const { context: i14, attributeView: o14 } = e15, r10 = o14.getBlock(J.GPGPU);
    if (null == r10) return void s15.forEach((t23) => t23.resolve([]));
    const c12 = r10.getFBO(i14), a14 = new Uint8Array(c12.width * c12.height * 4);
    try {
      await c12.readPixelsAsync(0, 0, c12.width, c12.height, G.RGBA, U2.UNSIGNED_BYTE, a14);
    } catch (u18) {
      return void s15.forEach((t23) => t23.resolve([]));
    }
    const h13 = [];
    for (let t23 = 0; t23 < a14.length; t23 += 4) {
      const e16 = t23 / 4;
      a14[t23] && h13.push(e16);
    }
    s15.forEach((t23) => t23.resolve(h13));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a13 = 5;
var u15 = [1, 0];
var l12 = [0, 1];
var m6 = [1, 0.8, 0.6, 0.4, 0.2];
var _5 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h11 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a13), this._nMips = a13, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad = r3(this._quad), this._intensityFBO = r3(this._intensityFBO), this._compositeFBO = r3(this._compositeFBO), this._mipsFBOs) {
      for (let t23 = 0; t23 < this._nMips; t23++) this._mipsFBOs[t23] && (this._mipsFBOs[t23].horizontal.dispose(), this._mipsFBOs[t23].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t23, i14, r10) {
    const { width: o14, height: n17 } = i14, { context: h13, painter: p8 } = t23, { materialManager: c12 } = p8, d11 = h13.gl, f12 = this._programDesc, { strength: b6, radius: F7, threshold: O8 } = r10;
    this._quad || (this._quad = new n8(h13, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t23, o14, n17), h13.setStencilTestEnabled(false), h13.setBlendingEnabled(true), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilWriteMask(0);
    const B5 = this._quad;
    B5.bind(), h13.bindFramebuffer(this._intensityFBO);
    const g7 = c12.getProgram(f12.luminosityHighPass);
    h13.useProgram(g7), h13.bindTexture(i14.colorTexture, 0), g7.setUniform1i("u_texture", 0), g7.setUniform3fv("u_defaultColor", [0, 0, 0]), g7.setUniform1f("u_defaultOpacity", 0), g7.setUniform1f("u_luminosityThreshold", O8), g7.setUniform1f("u_smoothWidth", 0.01);
    const T4 = [Math.round(o14 / 2), Math.round(n17 / 2)];
    h13.setViewport(0, 0, T4[0], T4[1]), h13.setClearColor(0, 0, 0, 0), h13.clear(d11.COLOR_BUFFER_BIT), B5.draw(), h13.setBlendingEnabled(false);
    let x6 = this._intensityFBO.colorTexture;
    for (let e15 = 0; e15 < this._nMips; e15++) {
      const t24 = c12.getProgram(f12.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[e15] }]);
      h13.useProgram(t24), h13.bindTexture(x6, e15 + 1), t24.setUniform1i("u_colorTexture", e15 + 1), t24.setUniform2fv("u_texSize", T4), t24.setUniform2fv("u_direction", u15), h13.setViewport(0, 0, T4[0], T4[1]);
      const s15 = this._mipsFBOs[e15];
      h13.bindFramebuffer(s15.horizontal), B5.draw(), x6 = s15.horizontal.colorTexture, h13.bindFramebuffer(s15.vertical), h13.bindTexture(x6, e15 + 1), t24.setUniform2fv("u_direction", l12), B5.draw(), x6 = s15.vertical.colorTexture, T4[0] = Math.round(T4[0] / 2), T4[1] = Math.round(T4[1] / 2);
    }
    h13.setViewport(0, 0, o14, n17);
    const w5 = c12.getProgram(f12.composite, [{ name: "nummips", value: a13 }]);
    h13.bindFramebuffer(this._compositeFBO), h13.useProgram(w5), w5.setUniform1f("u_bloomStrength", b6), w5.setUniform1f("u_bloomRadius", F7), w5.setUniform1fv("u_bloomFactors", m6), w5.setUniform3fv("u_bloomTintColors", _5), h13.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w5.setUniform1i("u_blurTexture1", 1), h13.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w5.setUniform1i("u_blurTexture2", 2), h13.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w5.setUniform1i("u_blurTexture3", 3), h13.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w5.setUniform1i("u_blurTexture4", 4), h13.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w5.setUniform1i("u_blurTexture5", 5), B5.draw(), h13.bindFramebuffer(i14), h13.setBlendingEnabled(true);
    const M5 = c12.getProgram(f12.blit);
    h13.useProgram(M5), h13.bindTexture(this._compositeFBO.colorTexture, 6), M5.setUniform1i("u_texture", 6), h13.setBlendFunction(R.ONE, R.ONE), B5.draw(), B5.unbind(), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t23, e15, s15) {
    const { context: a14 } = t23;
    if (this._compositeFBO && this._size[0] === e15 && this._size[1] === s15) return;
    this._size[0] = e15, this._size[1] = s15;
    const u18 = [Math.round(e15 / 2), Math.round(s15 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(e15, s15);
    else {
      const t24 = new p3(e15, s15);
      t24.internalFormat = G.RGBA, t24.wrapMode = D.CLAMP_TO_EDGE, this._compositeFBO = new x3(a14, t24);
    }
    if (this._intensityFBO) this._intensityFBO.resize(u18[0], u18[1]);
    else {
      const t24 = new p3(u18[0], u18[1]);
      t24.internalFormat = G.RGBA, t24.wrapMode = D.CLAMP_TO_EDGE, this._intensityFBO = new x3(a14, t24);
    }
    for (let l15 = 0; l15 < this._nMips; l15++) {
      if (this._mipsFBOs[l15]) this._mipsFBOs[l15].horizontal.resize(u18[0], u18[1]), this._mipsFBOs[l15].vertical.resize(u18[0], u18[1]);
      else {
        const t24 = new p3(u18[0], u18[1]);
        t24.internalFormat = G.RGBA, t24.wrapMode = D.CLAMP_TO_EDGE, this._mipsFBOs[l15] = { horizontal: new x3(a14, t24), vertical: new x3(a14, t24) };
      }
      u18[0] = Math.round(u18[0] / 2), u18[1] = Math.round(u18[1] / 2);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n15 = [1, 0];
var o13 = [0, 1];
var u16 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t23, s15, r10) {
    const { context: i14 } = t23, { type: a14, radius: n17 } = r10;
    if (0 === n17) return;
    this._createOrResizeResources(t23), this._quad || (this._quad = new n8(i14, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o14 = this._quad;
    o14.bind(), "blur" === a14 ? this._gaussianBlur(t23, s15, n17) : this._radialBlur(t23, s15), o14.unbind();
  }
  _gaussianBlur(e15, s15, r10) {
    const { context: i14, state: a14, painter: u18, pixelRatio: l15 } = e15, { size: d11 } = a14, { materialManager: b6 } = u18, c12 = this._programDesc, _7 = this._quad, p8 = [Math.round(l15 * d11[0]), Math.round(l15 * d11[1])], h13 = this._blurFBO, m7 = b6.getProgram(c12.gaussianBlur, [{ name: "radius", value: Math.ceil(r10) }]);
    i14.useProgram(m7), i14.setBlendingEnabled(false), i14.bindFramebuffer(h13), i14.bindTexture(s15.colorTexture, 4), m7.setUniform1i("u_colorTexture", 4), m7.setUniform2fv("u_texSize", p8), m7.setUniform2fv("u_direction", n15), m7.setUniform1f("u_sigma", r10), _7.draw(), i14.bindFramebuffer(s15), i14.setStencilWriteMask(0), i14.setStencilTestEnabled(false), i14.setDepthWriteEnabled(false), i14.setDepthTestEnabled(false), i14.bindTexture(h13 == null ? void 0 : h13.colorTexture, 5), m7.setUniform1i("u_colorTexture", 5), m7.setUniform2fv("u_direction", o13), _7.draw(), i14.setBlendingEnabled(true), i14.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), i14.setStencilTestEnabled(true);
  }
  _radialBlur(e15, s15) {
    const { context: r10, painter: i14 } = e15, { materialManager: a14 } = i14, n17 = this._programDesc, o14 = this._quad, u18 = this._blurFBO;
    r10.bindFramebuffer(u18);
    const l15 = a14.getProgram(n17.radialBlur);
    r10.useProgram(l15), r10.setBlendingEnabled(false), r10.bindTexture(s15.colorTexture, 4), l15.setUniform1i("u_colorTexture", 4), o14.draw(), r10.bindFramebuffer(s15), r10.setStencilWriteMask(0), r10.setStencilTestEnabled(false), r10.setDepthWriteEnabled(false), r10.setDepthTestEnabled(false), r10.setBlendingEnabled(true);
    const d11 = a14.getProgram(n17.blit);
    r10.useProgram(d11), r10.bindTexture(u18 == null ? void 0 : u18.colorTexture, 5), d11.setUniform1i("u_texture", 5), r10.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), o14.draw();
  }
  _createOrResizeResources(e15) {
    const { context: t23, state: n17, pixelRatio: o14 } = e15, { size: u18 } = n17, l15 = Math.round(o14 * u18[0]), d11 = Math.round(o14 * u18[1]);
    if (!this._blurFBO || this._size[0] !== l15 || this._size[1] !== d11) if (this._size[0] = l15, this._size[1] = d11, this._blurFBO) this._blurFBO.resize(l15, d11);
    else {
      const e16 = new p3(l15, d11);
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._blurFBO = new x3(t23, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n16 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture);
  }
  draw(e15, t23, s15) {
    const { width: i14, height: o14 } = t23;
    this._createOrResizeResources(e15, i14, o14);
    const { context: a14, painter: n17 } = e15, { materialManager: c12 } = n17, l15 = this._programDesc, u18 = this._quad, _7 = s15.colorMatrix;
    u18.bind();
    const h13 = this._layerFBOTexture;
    a14.bindFramebuffer(t23), t23.copyToTexture(0, 0, i14, o14, 0, 0, h13), a14.setBlendingEnabled(false), a14.setStencilTestEnabled(false);
    const m7 = c12.getProgram(l15);
    a14.useProgram(m7), a14.bindTexture(h13, 2), m7.setUniformMatrix4fv("u_coefficients", _7), m7.setUniform1i("u_colorTexture", 2), u18.draw(), a14.setBlendingEnabled(true), a14.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), a14.setStencilTestEnabled(true), u18.unbind();
  }
  _createOrResizeResources(e15, r10, n17) {
    const { context: c12 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== r10 || this._size[1] !== n17) {
      if (this._size[0] = r10, this._size[1] = n17, this._layerFBOTexture) this._layerFBOTexture.resize(r10, n17);
      else {
        const e16 = new p3();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = r10, e16.height = n17, this._layerFBOTexture = new w3(c12, e16);
      }
      this._quad || (this._quad = new n8(c12, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u17 = [1, 0];
var h12 = [0, 1];
var _6 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture), this._horizontalBlurFBO = r3(this._horizontalBlurFBO), this._verticalBlurFBO = r3(this._verticalBlurFBO);
  }
  draw(e15, i14, o14) {
    const { context: a14, state: n17, painter: l15 } = e15, { materialManager: _7 } = l15, c12 = this._programDesc, p8 = i14.width, m7 = i14.height, f12 = [Math.round(p8), Math.round(m7)], { blurRadius: B5, offsetX: d11, offsetY: b6, color: O8 } = o14, F7 = [u3(d11), u3(b6)];
    this._createOrResizeResources(e15, p8, m7, f12);
    const w5 = this._horizontalBlurFBO, T4 = this._verticalBlurFBO;
    a14.setStencilWriteMask(0), a14.setStencilTestEnabled(false), a14.setDepthWriteEnabled(false), a14.setDepthTestEnabled(false);
    const x6 = this._layerFBOTexture;
    i14.copyToTexture(0, 0, p8, m7, 0, 0, x6), this._quad || (this._quad = new n8(a14, [-1, -1, 1, -1, -1, 1, 1, 1])), a14.setViewport(0, 0, f12[0], f12[1]);
    const g7 = this._quad;
    g7.bind(), a14.setBlendingEnabled(false);
    const z2 = _7.getProgram(c12.blur, [{ name: "radius", value: Math.ceil(B5) }]);
    a14.useProgram(z2), a14.bindFramebuffer(w5), a14.bindTexture(i14.colorTexture, 4), z2.setUniform1i("u_colorTexture", 4), z2.setUniform2fv("u_texSize", f12), z2.setUniform2fv("u_direction", u17), z2.setUniform1f("u_sigma", B5), g7.draw(), a14.bindFramebuffer(T4), a14.bindTexture(w5 == null ? void 0 : w5.colorTexture, 5), z2.setUniform1i("u_colorTexture", 5), z2.setUniform2fv("u_direction", h12), g7.draw(), a14.bindFramebuffer(i14), a14.setViewport(0, 0, p8, m7);
    const M5 = _7.getProgram(c12.composite);
    a14.useProgram(M5), a14.bindTexture(T4 == null ? void 0 : T4.colorTexture, 2), M5.setUniform1i("u_blurTexture", 2), a14.bindTexture(x6, 3), M5.setUniform1i("u_layerFBOTexture", 3), M5.setUniform4fv("u_shadowColor", [O8[3] * (O8[0] / 255), O8[3] * (O8[1] / 255), O8[3] * (O8[2] / 255), O8[3]]), M5.setUniformMatrix3fv("u_displayViewMat3", n17.displayMat3), M5.setUniform2fv("u_shadowOffset", F7), g7.draw(), a14.setBlendingEnabled(true), a14.setStencilTestEnabled(true), a14.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), g7.unbind();
  }
  _createOrResizeResources(e15, t23, r10, s15) {
    const { context: u18 } = e15;
    if (!this._horizontalBlurFBO || this._size[0] !== t23 || this._size[1] !== r10) {
      if (this._size[0] = t23, this._size[1] = r10, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s15[0], s15[1]);
      else {
        const e16 = new p3(s15[0], s15[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._horizontalBlurFBO = new x3(u18, e16);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s15[0], s15[1]);
      else {
        const e16 = new p3(s15[0], s15[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._verticalBlurFBO = new x3(u18, e16);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t23, r10);
      else {
        const e16 = new p3();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = t23, e16.height = r10, this._layerFBOTexture = new w3(u18, e16);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l13 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture);
  }
  draw(e15, r10, s15) {
    const { width: i14, height: o14 } = r10;
    this._createOrResizeResources(e15, i14, o14);
    const { context: l15, painter: a14 } = e15, { amount: n17 } = s15, h13 = l15.gl, u18 = this._layerFBOTexture;
    l15.bindFramebuffer(r10), r10.copyToTexture(0, 0, i14, o14, 0, 0, u18), l15.setBlendingEnabled(true), l15.setStencilTestEnabled(false), l15.setDepthTestEnabled(false), l15.setClearColor(0, 0, 0, 0), l15.clear(h13.COLOR_BUFFER_BIT), a14.blitTexture(l15, u18, L2.NEAREST, n17);
  }
  _createOrResizeResources(e15, l15, a14) {
    const { context: n17 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== l15 || this._size[1] !== a14) if (this._size[0] = l15, this._size[1] = a14, this._layerFBOTexture) this._layerFBOTexture.resize(l15, a14);
    else {
      const e16 = new p3();
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.samplingMode = L2.NEAREST, e16.width = l15, e16.height = a14, this._layerFBOTexture = new w3(n17, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c10(o14) {
  switch (o14) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o14;
    default:
      return "colorize";
  }
}
var f11 = { colorize: () => new n16(), blur: () => new u16(), bloom: () => new h11(), opacity: () => new l13(), "drop-shadow": () => new _6() };
var i12 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o14) => o14.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o14) {
    if (!o14 || 0 === o14.length) return [];
    const e15 = [];
    for (const t23 of o14) {
      const o15 = c10(t23.type);
      let s15 = this._effectMap.get(o15);
      s15 || (s15 = f11[o15](), this._effectMap.set(o15, s15)), e15.push({ postProcessingEffect: s15, effect: t23 });
    }
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t22 = class {
  constructor(e15, t23) {
    this.brushes = e15, this.name = t23.name, this.drawPhase = t23.drawPhase || E4.MAP, this._targetFn = t23.target, this.effects = t23.effects || [], this.enableDefaultDraw = t23.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t23.forceDrawByDisplayOrder;
  }
  render(e15) {
    var _a;
    const { context: r10, profiler: t23 } = e15, s15 = this._targetFn(), a14 = this.drawPhase & e15.drawPhase;
    if (t23.recordPassStart(this.name), a14) {
      this.enableDefaultDraw() && this._doRender(e15, s15), t23.recordPassEnd();
      for (const t24 of this.effects) {
        if (!t24.enable()) continue;
        const a15 = t24.apply, n17 = (_a = t24.args) == null ? void 0 : _a.call(t24), i14 = r10.getViewport(), o14 = r10.getBoundFramebufferObject(), d11 = e15.passOptions;
        this._bindEffect(e15, a15, n17), this._doRender(e15, s15, a15.defines), this._drawAndUnbindEffect(e15, a15, i14, o14, d11, n17);
      }
    }
  }
  _doRender(e15, r10, t23) {
    if (null == r10) return;
    const { profiler: s15, context: a14 } = e15;
    for (const n17 of this.brushes) {
      if (s15.recordBrushStart(n17.name), null != n17.brushEffect) {
        const s16 = a14.getViewport(), i14 = a14.getBoundFramebufferObject(), o14 = e15.passOptions;
        this._bindEffect(e15, n17.brushEffect), this._drawWithBrush(n17, e15, r10, t23), this._drawAndUnbindEffect(e15, n17.brushEffect, s16, i14, o14);
      } else this._drawWithBrush(n17, e15, r10, t23);
      s15.recordBrushEnd();
    }
  }
  _drawWithBrush(r10, t23, s15, a14) {
    d(s15) ? (r10.prepareState(t23, a14), r10.drawMany(t23, s15, a14)) : s15.visible && (r10.prepareState(t23, a14), r10.draw(t23, s15, a14));
  }
  _bindEffect(e15, r10, t23) {
    const { profiler: s15 } = e15;
    s15.recordPassStart(this.name + "." + r10.name), r10.bind(e15, t23);
    const a14 = r10.createOptions(e15, t23);
    e15.passOptions = a14;
  }
  _drawAndUnbindEffect(e15, r10, t23, s15, a14, n17) {
    const { profiler: i14, context: o14 } = e15;
    e15.passOptions = a14, i14.recordBrushStart(r10.name), r10.draw(e15, n17), r10.unbind(e15, n17), o14.bindFramebuffer(s15);
    const { x: d11, y: f12, width: h13, height: c12 } = t23;
    o14.setViewport(d11, f12, h13, c12), i14.recordBrushEnd(), i14.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r9 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r10 of this._programCache.values()) r10.destroy();
    this._programCache.clear();
  }
  getProgram(r10, e15, t23, a14, o14) {
    const s15 = r10.getShaderKey(e15, t23, a14, o14);
    let c12 = this._programCache.get(s15);
    return c12 || (c12 = r10.getProgram(e15, t23, a14, o14), this._programCache.set(s15, c12)), c12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var O6 = class {
  constructor(e15, t23) {
    this.context = e15, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _3(), this._worldExtentRenderer = new b5(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p5(), this._blendEffect = new n14(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new l11(), hittest: new c9(), insideEffect: new s12("inside"), outsideEffect: new s12("outside") }, this._programCache = new r9(), this._shaderState = { shader: null, uniforms: null, defines: null, optionalAttributes: null, useComputeBuffer: false }, this.materialManager = new e14(e15), this.textureManager = new G2(t23), this.textureUploadManager = new u14(t23), this._effectsManager = new i12(), this._quadMesh = s9.fromVertexStream(e15, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r3(this._blitRenderer), this._worldExtentRenderer = r3(this._worldExtentRenderer), this._quadMesh = u(this._quadMesh), this._brushCache && (this._brushCache.forEach((e15) => e15.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e15;
      for (e15 in this._fbos) this._fbos[e15] && this._fbos[e15].dispose();
    }
    for (const e15 of this._fboPool) e15.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e15;
      for (e15 in this.effects) this.effects[e15] && this.effects[e15].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r3(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r9();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  get quadMesh() {
    return this._quadMesh;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e15, t23) {
    let s15;
    if (this._fboPool.length > 0) s15 = this._fboPool.pop();
    else {
      const r10 = new p3(e15, t23);
      r10.samplingMode = L2.NEAREST, r10.wrapMode = D.CLAMP_TO_EDGE, s15 = new x3(this.context, r10, this._stencilBuf);
    }
    return s15.width === e15 && s15.height === t23 || s15.resize(e15, t23), s15;
  }
  releaseFbo(e15) {
    this._fboPool.push(e15);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e15, t23, s15) {
    const { context: r10 } = e15;
    this._worldExtentRenderer.render(e15, t23, s15);
    const { width: i14, height: n17 } = r10.getViewport();
    if (this.updateFBOs(i14, n17), this._prevFBO = r10.getBoundFramebufferObject(), r10.bindFramebuffer(this.getFbos().output), r10.setColorMask(true, true, true, true), null != t23) {
      const { r: e16, g: s16, b: i15, a: n18 } = t23;
      r10.setClearColor(n18 * e16 / 255, n18 * s16 / 255, n18 * i15 / 255, n18);
    } else r10.setClearColor(0, 0, 0, 0);
    r10.setDepthWriteEnabled(true), r10.setClearDepth(1), r10.clear(r10.gl.COLOR_BUFFER_BIT | r10.gl.DEPTH_BUFFER_BIT), r10.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e15) {
    const { context: t23 } = e15;
    t23.bindFramebuffer(this._prevFBO), t23.setStencilFunction(O2.EQUAL, Ci, 255), t23.setStencilTestEnabled(true), t23.setDepthTestEnabled(false), this.blitTexture(t23, this.getFbos().output.colorTexture, L2.NEAREST);
  }
  beforeRenderLayer(e15, t23, s15) {
    const { context: r10, blendMode: i14, effects: n17, drawPhase: a14, requireFBO: o14 } = e15;
    if (o14 || A6(a14, i14, n17, s15)) {
      const e16 = r10.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e16);
      const { width: t24, height: s16 } = r10.getViewport(), i15 = this.acquireFbo(t24, s16);
      r10.bindFramebuffer(i15), r10.setColorMask(true, true, true, true), r10.setClearColor(0, 0, 0, 0), r10.setDepthWriteEnabled(true), r10.setClearDepth(1), r10.clear(r10.gl.COLOR_BUFFER_BIT | r10.gl.DEPTH_BUFFER_BIT), r10.setDepthWriteEnabled(false);
    }
    r10.setDepthWriteEnabled(false), r10.setDepthTestEnabled(false), r10.setStencilTestEnabled(true), r10.setClearStencil(t23), r10.setStencilWriteMask(255), r10.clear(r10.gl.STENCIL_BUFFER_BIT);
  }
  afterRenderLayer(e15, t23) {
    const { context: s15, blendMode: r10, effects: i14, requireFBO: n17, drawPhase: o14 } = e15;
    if (n17 || A6(o14, r10, i14, t23)) {
      const n18 = s15.getBoundFramebufferObject();
      null != i14 && i14.length > 0 && o14 === E4.MAP && (s15.setColorMask(true, true, true, true), this._applyEffects(e15, i14, n18)), s15.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s15.setStencilTestEnabled(false), s15.setStencilWriteMask(0), s15.setBlendingEnabled(true), s15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), s15.setColorMask(true, true, true, true);
      const l15 = null == r10 || o14 === E4.HIGHLIGHT || o14 === E4.LABEL ? "normal" : r10;
      this._blendEffect.draw(e15, n18.colorTexture, L2.NEAREST, l15, t23), this.releaseFbo(n18);
    }
  }
  renderObject(e15, t23, r10, i14) {
    const n17 = m5[r10];
    if (!n17) return;
    let a14 = this._brushCache.get(n17);
    void 0 === a14 && (a14 = new n17(), this._brushCache.set(n17, a14)), a14.prepareState(e15), a14.draw(e15, t23, i14);
  }
  renderObjects(e15, t23, r10, i14) {
    const n17 = m5[r10];
    if (!n17) return;
    let a14 = this._brushCache.get(n17);
    void 0 === a14 && (a14 = new n17(), this._brushCache.set(n17, a14)), a14.drawMany(e15, t23, i14);
  }
  registerRenderPass(e15) {
    const t23 = e15.brushes.map((e16) => (this._brushCache.has(e16) || this._brushCache.set(e16, new e16()), this._brushCache.get(e16)));
    return new t22(t23, e15);
  }
  blitTexture(e15, t23, s15, r10 = 1) {
    e15.setBlendingEnabled(true), e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e15.setColorMask(true, true, true, true), this._blitRenderer.render(e15, t23, s15, r10), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e15) {
    return this._effectsManager.getPostProcessingEffects(e15);
  }
  updateFBOs(e15, t23) {
    if (e15 !== this._lastWidth || t23 !== this._lastHeight) {
      if (this._lastWidth = e15, this._lastHeight = t23, this._fbos) {
        let s16;
        for (s16 in this._fbos) this._fbos[s16].resize(e15, t23);
        return;
      }
      const s15 = new p3(e15, t23);
      s15.samplingMode = L2.NEAREST, s15.wrapMode = D.CLAMP_TO_EDGE;
      const r10 = new i8(B2.DEPTH_STENCIL, e15, t23);
      this._stencilBuf = new s8(this.context, r10), this._fbos = { output: new x3(this.context, s15, this._stencilBuf), effect0: new x3(this.context, s15, this._stencilBuf) };
    }
  }
  _applyEffects(e15, t23, s15) {
    const { context: r10 } = e15, i14 = this._effectsManager.getPostProcessingEffects(t23);
    for (const { postProcessingEffect: n17, effect: a14 } of i14) r10.bindFramebuffer(s15), n17.draw(e15, s15, a14);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e15) {
    this._shaderState.shader = e15.shader, this._shaderState.uniforms = e15.uniforms, this._shaderState.defines = e15.defines, this._shaderState.optionalAttributes = e15.optionalAttributes, this._shaderState.useComputeBuffer = e15.useComputeBuffer ?? false;
  }
  setPipelineState(e15) {
    e15 !== this._currentPipelineState && (this._currentPipelineState = e15, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e15, t23) {
    const { shader: s15, uniforms: r10, defines: i14, optionalAttributes: n17 } = this._shaderState, a14 = e15.context, o14 = t23.getAttributePrecisionPackFactors(), l15 = this._programCache.getProgram(s15, o14, r10, i14 ?? {}, n17 ?? {});
    return l15.setUniforms(r10), l15.bind(a14), this.updatePipelineState(a14), this.setStencilRef(a14, t23), t23.draw(e15, s15.locationInfo), l15.cleanupTemporaryTextures(), { vertexShader: l15.vertexShader, fragmentShader: l15.fragmentShader };
  }
  submitDrawMesh(e15, t23, s15, r10) {
    this.submitDrawMeshUntyped(e15, t23, s15, r10);
  }
  submitDrawMeshUntyped(e15, t23, s15, r10) {
    this.setShader(t23);
    const { shader: i14, uniforms: n17, defines: a14, optionalAttributes: o14 } = this._shaderState, l15 = this._programCache.getProgram(i14, {}, n17, a14 ?? {}, o14 ?? {});
    if (l15.setUniforms(n17), l15.bind(e15), this.updatePipelineState(e15), r10) for (const h13 of r10) s15.bind(e15, t23.shader.locationInfo, h13), s15.draw(e15);
    else for (let h13 = 0; h13 < s15.parts.length; h13++) s15.bind(e15, t23.shader.locationInfo, h13), s15.draw(e15);
    s15.unbind(e15), l15.cleanupTemporaryTextures();
  }
  updatePipelineState(e15) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e15));
  }
  _updatePipelineState(e15) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t23, depth: s15, stencil: r10 } = this._currentPipelineState;
    if (t23) {
      const { blendMode: s16, write: r11 } = t23;
      switch (e15.setColorMask(...r11), e15.setBlendingEnabled(true), e15.setBlendEquation(T.ADD), s16) {
        case "composite":
          e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e15.setBlendFunctionSeparate(R.ONE, R.ONE, R.ONE, R.ONE);
          break;
        case "custom": {
          const { blendParameters: s17 } = t23, { dstAlpha: r12, dstRGB: i14, srcAlpha: n17, srcRGB: a14 } = s17;
          e15.setBlendFunctionSeparate(a14, i14, n17, r12);
          break;
        }
        case "delete":
          e15.setBlendEquation(T.REVERSE_SUBTRACT), e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
      }
    } else e15.setColorMask(false, false, false, false);
    if (s15) {
      const { test: t24, write: r11 } = s15;
      r11 ? (e15.setDepthWriteEnabled(true), e15.setDepthRange(r11.zNear, r11.zFar)) : e15.setDepthWriteEnabled(false), t24 ? (e15.setDepthTestEnabled(true), e15.setDepthFunction(t24)) : e15.setDepthTestEnabled(false);
    } else e15.setDepthTestEnabled(false), e15.setDepthWriteEnabled(false);
    if (r10) {
      const { test: t24, write: s16 } = r10;
      if (t24) {
        const { compare: s17, mask: r11, op: i14, ref: n17 } = t24;
        e15.setStencilTestEnabled(true), "function" != typeof n17 && e15.setStencilFunctionSeparate(N.FRONT_AND_BACK, s17, n17, r11), e15.setStencilOpSeparate(N.FRONT_AND_BACK, i14.fail, i14.zFail, i14.zPass);
      } else e15.setStencilTestEnabled(false);
      if (s16) {
        const { mask: t25 } = s16;
        e15.setStencilWriteMask(t25);
      } else e15.setStencilWriteMask(0);
    } else e15.setStencilTestEnabled(false), e15.setStencilWriteMask(0);
  }
  setStencilRef(e15, t23) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s15 } = this._currentPipelineState;
    if (s15) {
      const { test: r10 } = s15;
      if (r10) {
        const { compare: s16, mask: i14, ref: n17 } = r10;
        if ("function" == typeof n17) {
          const r11 = t23.getStencilReference();
          if (null === r11) throw new Error("InternalError: Stencil reference expected for target but not defined");
          e15.setStencilFunctionSeparate(N.FRONT_AND_BACK, s16, r11, i14);
        }
      }
    }
  }
};
function A6(e15, t23, s15, r10) {
  return e15 !== E4.LABEL_ALPHA && e15 !== E4.LABEL && e15 !== E4.HIGHLIGHT && (1 !== r10 || null != t23 && "normal" !== t23 || null != s15 && s15.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileReshuffleManager.js
var s13 = class {
  constructor() {
    this._candidateTiles = [];
  }
  schedule(s15) {
    this._candidateTiles.includes(s15) || this._candidateTiles.push(s15);
  }
  reshuffle(s15) {
    const e15 = [];
    for (const i14 of this._candidateTiles) s15 > 0 ? (i14.reshuffle(), s15--) : e15.push(i14);
    this._candidateTiles = e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var M3 = 2e3;
var O7 = class extends n7 {
  constructor(t23, i14) {
    super(), this.meshWriterRegistry = new F4(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r4(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s13(), this._canvas = new c5(t23), this.context = new y2(this._canvas.gl, i14.contextOptions ?? {}), this.painter = new O6(this.context, this), this._cimAnalyzer = new B3(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t23.appendChild(this._debugOutput));
    const a14 = () => this.highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i14.timeline || new e12(), renderingOptions: i14.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new n9(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return a14();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i14.backgroundColor }, this._taskHandle = F({ render: (e15) => this.renderFrame(e15) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._canvas.events.on("webgl-context-lost", (t24) => this.emit("webgl-error", { error: new s3("webgl-context-lost", t24.statusMessage) })), this._bufferPool = new i9(), q2();
  }
  destroy() {
    var _a, _b;
    F5(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._canvas.destroy(), (_b = (_a = this._debugOutput) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e15) {
    this._renderParameters.backgroundColor = e15, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e15) {
    this._renderingOptions = e15, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e15) {
    this._state = e15, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e15) {
    this._stationary !== e15 && (this._stationary = e15, this.requestRender());
  }
  trashDisplayObject(e15) {
    this._trash.add(e15), this.requestRender();
  }
  untrashDisplayObject(e15) {
    return this._trash.delete(e15);
  }
  requestRender() {
    this._renderRemainingTime = M3, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e15) {
    const t23 = this._lastFrameRenderTime ? e15.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t23, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e15.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e15.time, this._renderParameters.deltaTime = e15.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  renderChildren(e15) {
    for (const t23 of this.children) t23.beforeRender(e15);
    this._reshuffleManager.reshuffle(wi), this._canvas.render(e15, () => this._renderChildren(this.children, e15));
    for (const t23 of this.children) t23.afterRender(e15);
  }
  _renderChildren(e15, t23) {
    const r10 = this.context;
    this.painter.textureUploadManager.upload(), r10.resetInfo(), t23.profiler.recordStart("drawLayers"), t23.dataUploadCounter = 0, this.painter.beforeRenderPhases(t23, t23.backgroundColor, this.state.padding), t23.drawPhase = E4.MAP;
    for (const s15 of e15) s15.processRender(t23);
    if (this.children.some((e16) => e16.hasHighlight)) {
      t23.drawPhase = E4.HIGHLIGHT;
      for (const r11 of e15) r11.processRender(t23);
    }
    if (this.children.some((e16) => e16.hasLabels)) {
      t23.drawPhase = E4.LABEL;
      for (const r11 of e15) r11.processRender(t23);
    }
    if (has("esri-tiles-debug")) {
      t23.drawPhase = E4.DEBUG;
      for (const r11 of e15) r11.processRender(t23);
    }
    this.painter.afterRenderPhases(t23), t23.profiler.recordEnd("drawLayers"), r10.logInfo();
  }
  doRender(e15) {
    const t23 = this.context, { state: r10, pixelRatio: s15 } = e15;
    this._canvas.resize(e15), t23.setViewport(0, 0, s15 * r10.size[0], s15 * r10.size[1]), t23.setDepthWriteEnabled(true), t23.setStencilWriteMask(255), this.renderChildren(e15);
  }
  async takeScreenshot(e15, t23, r10, s15) {
    const i14 = Math.round(this.state.size[0] * e15.resolutionScale), n17 = Math.round(this.state.size[1] * e15.resolutionScale), a14 = e15.resolutionScale, o14 = this.context, h13 = this._state.clone();
    if (null != s15) {
      const e16 = h13.viewpoint;
      h13.viewpoint.rotation = s15, h13.viewpoint = e16;
    }
    const d11 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h13, pixelRatio: a14, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r10 }, l15 = new p3(i14, n17);
    l15.wrapMode = D.CLAMP_TO_EDGE, l15.internalFormat = P4.RGBA8, l15.isImmutable = true;
    const m7 = new x3(o14, l15, new i8(B2.DEPTH_STENCIL, i14, n17)), c12 = o14.getBoundFramebufferObject(), u18 = o14.getViewport();
    o14.bindFramebuffer(m7), o14.setViewport(0, 0, i14, n17), this._renderChildren(t23 ?? this.children, d11);
    const p8 = this._readbackScreenshot(m7, { ...e15.cropArea, y: n17 - (e15.cropArea.y + e15.cropArea.height) });
    o14.bindFramebuffer(c12), o14.setViewport(u18.x, u18.y, u18.width, u18.height), this.requestRender();
    const f12 = await p8;
    let g7;
    return 1 === e15.outputScale ? g7 = f12 : (g7 = new ImageData(Math.round(f12.width * e15.outputScale), Math.round(f12.height * e15.outputScale)), (await import("./screenshotUtils-TKFGWP7P.js")).resampleHermite(f12, g7, true)), m7.dispose(), g7;
  }
  async _readbackScreenshot(e15, t23) {
    const r10 = (await import("./screenshotUtils-TKFGWP7P.js")).createEmptyImageData(t23.width, t23.height, document.createElement("canvas"));
    return await e15.readPixelsAsync(t23.x, t23.y, t23.width, t23.height, G.RGBA, U2.UNSIGNED_BYTE, new Uint8Array(r10.data.buffer)), r10;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e15 = Array.from(this._trash);
      this._trash.clear();
      for (const t23 of e15) t23.processDetach();
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/magnifier/MagnifierTechnique.js
var l14 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Magnifier, this._resourcePixelRatio = 1, this._position = [0, 0, 0, 0], this.shaders = { magnifier: new E5() };
  }
  updateResources(t23, i14, r10, s15) {
    t23.pixelRatio !== this._resourcePixelRatio && this._destroyResources(), this._readbackTexture || this._initializeResources(t23, i14, r10, s15);
    const { context: o14, pixelRatio: a14 } = t23, { factor: n17, offset: u18, position: h13 } = s15, { size: p8 } = t23.state, c12 = s15.size * a14, l15 = 1 / n17, m7 = Math.ceil(l15 * c12);
    this._readbackTexture.resize(m7, m7);
    const x6 = a14 * p8[0], d11 = a14 * p8[1], _7 = 0.5 * m7, T4 = 0.5 * m7, f12 = r(a14 * h13.x, _7, x6 - _7 - 1), g7 = r(d11 - a14 * h13.y, T4, d11 - T4 - 1), R3 = f12 - _7, w5 = g7 - T4, b6 = this._readbackTexture;
    o14.bindTexture(b6, 0), o14.gl.copyTexImage2D(b6.descriptor.target, 0, b6.descriptor.pixelFormat, R3, w5, m7, m7, 0);
    const y5 = (f12 + u18.x * a14) / x6 * 2 - 1, M5 = (g7 - u18.y * a14) / d11 * 2 - 1, k3 = c12 / x6 * 2, j = c12 / d11 * 2;
    this._position[0] = y5, this._position[1] = M5, this._position[2] = k3, this._position[3] = j;
  }
  render(e15, t23) {
    const { context: i14, painter: s15 } = e15;
    s15.setPipelineState(t11);
    const o14 = { readbackTexture: { texture: this._readbackTexture, unit: 0 }, maskTexture: { texture: this._maskTexture, unit: 7 }, overlayTexture: { texture: this._overlayTexture, unit: 6 }, drawPos: this._position, ...t23 };
    s15.submitDrawMesh(i14, { shader: this.shaders.magnifier, uniforms: { config: o14 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, s15.quadMesh);
  }
  shutdown() {
    this._destroyResources();
  }
  _initializeResources(e15, t23, r10, s15) {
    const o14 = e15.context;
    this._resourcePixelRatio = e15.pixelRatio;
    const a14 = Math.ceil(s15.size * e15.pixelRatio);
    r10.width = a14, r10.height = a14;
    const l15 = new p3();
    l15.internalFormat = G.RGBA, l15.wrapMode = D.CLAMP_TO_EDGE, l15.samplingMode = L2.NEAREST, l15.flipped = true, l15.preMultiplyAlpha = !St(r10.src) || !e15.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new w3(o14, l15, r10), t23.width = a14, t23.height = a14, l15.pixelFormat = l15.internalFormat = G.ALPHA, this._maskTexture = new w3(o14, l15, t23);
    const m7 = 1 / s15.factor;
    l15.pixelFormat = l15.internalFormat = G.RGBA, l15.width = l15.height = Math.ceil(m7 * a14), l15.samplingMode = L2.LINEAR, l15.flipped = false, this._readbackTexture = new w3(o14, l15);
  }
  _destroyResources() {
    r3(this._maskTexture), r3(this._overlayTexture), r3(this._readbackTexture);
  }
};

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s14(s15) {
  const r10 = import("./mask-svg-LHKPOGJL.js"), i14 = import("./overlay-svg-VHNZXGBA.js"), o14 = t8((await r10).default, { signal: s15 }), e15 = t8((await i14).default, { signal: s15 }), m7 = { mask: await o14, overlay: await e15 };
  return s4(s15), m7;
}

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var c11 = class extends e9 {
  constructor() {
    super(), this._handles = new r2(), this._magnifierTechnique = new l14(), this.updatingHandles = new h2(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._magnifierTechnique.shutdown(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e15) {
    this._backgroundColor = e15, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e15) {
    this._magnifier = e15, this._handles.removeAll(), this._handles.add([d3(() => e15.version, () => {
      this.visible = e15.visible && null != e15.position && e15.size > 0, this.requestRender();
    }, P), d3(() => [e15.maskUrl, e15.overlayUrl], () => this._reloadResources()), d3(() => e15.size, () => {
      this._magnifierTechnique.shutdown(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (!this._resourcesTask) return void this._reloadResources();
    if (e15.drawPhase !== E4.MAP || !this._canRender()) return;
    const s15 = this._magnifier;
    if (null == s15.position) return;
    this._magnifierTechnique.updateResources(e15, this._mask, this._overlay, s15);
    const r10 = this.backgroundColor, i14 = r10 ? [r10.a * r10.r / 255, r10.a * r10.g / 255, r10.a * r10.b / 255, r10.a] : [1, 1, 1, 1];
    this._magnifierTechnique.render(e15, { background: i14, maskEnabled: s15.maskEnabled ? 1 : 0, overlayEnabled: s15.overlayEnabled ? 1 : 0 });
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const r10 = null != this._magnifier ? this._magnifier.maskUrl : null, i14 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d2(async (s15) => {
      const n17 = null == r10 || null == i14 ? s14(s15) : null, t23 = null != r10 ? P2(r10, { responseType: "image", signal: s15 }).then((e15) => e15.data) : n17.then((e15) => e15.mask), a14 = null != i14 ? P2(i14, { responseType: "image", signal: s15 }).then((e15) => e15.data) : n17.then((e15) => e15.overlay), [o14, l15] = await Promise.all([t23, a14]);
      this._mask = o14, this._overlay = l15, this._magnifierTechnique.shutdown(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/grid/GridTechnique.js
var i13 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Grid, this.shaders = { grid: new _2() };
  }
  render(s15, r10) {
    const { context: t23, painter: i14 } = s15;
    i14.setPipelineState(t11), i14.submitDrawMesh(t23, { shader: this.shaders.grid, uniforms: r10, defines: null, optionalAttributes: null, useComputeBuffer: false }, i14.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/grid/GridView2D.js
var x5 = n3();
var w4 = class extends e9 {
  constructor() {
    super(), this._handles = new r2(), this._projectedCenter = null, this._metersPerSRUnit = null, this._technique = new i13(), this._grid = null, this.visible = true;
  }
  destroy() {
    this._handles = u(this._handles), this._technique.shutdown();
  }
  get grid() {
    return this._grid;
  }
  set grid(e15) {
    this._grid = e15, this._handles.removeAll(), this._handles.add([d3(() => e15 == null ? void 0 : e15.center, () => {
      this._projectedCenter = null;
    }, P), d3(() => [e15 == null ? void 0 : e15.center, e15 == null ? void 0 : e15.dynamicScaling, e15 == null ? void 0 : e15.majorLineColor, e15 == null ? void 0 : e15.majorLineInterval, e15 == null ? void 0 : e15.minorLineColor, e15 == null ? void 0 : e15.rotateWithMap, e15 == null ? void 0 : e15.rotation, e15 == null ? void 0 : e15.spacing, e15 == null ? void 0 : e15.units], () => this.requestRender(), P)]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (e15.drawPhase !== E4.MAP || null == this.grid || !this.visible) return;
    const { spacing: t23, units: r10, majorLineInterval: i14, dynamicScaling: s15, majorLineColor: o14, minorLineColor: a14 } = this.grid;
    if (0 === t23) return;
    if (this._updateDerivedValues(e15), null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const { scale: l15, spatialReference: m7 } = e15.state, c12 = x(t23, r10, "meters"), h13 = this._metersPerSRUnit * u8(l15, m7), p8 = c12 / h13;
    if (!s15 && p8 < t16) return;
    const d11 = c12 * l6(i14, p8, s15);
    this._updateTransform(e15, h13, d11), this._technique.render(e15, { transform: { dvs: this.transforms.displayViewScreenMat3 }, config: { pxPerCell: d11 / h13, minorLineColor: q4(a14), majorLineColor: q4(o14), majorLineInterval: i14, halfWidth: 0.25, aaWidth: 0.5 } });
  }
  _updateDerivedValues(e15) {
    if (!this.grid) return;
    const { center: t23 } = this.grid, { spatialReference: r10 } = e15.state;
    this._projectedCenter && s5(this._projectedCenter.spatialReference, r10) || (this._metersPerSRUnit = null, s5(t23.spatialReference, r10) ? this._projectedCenter = t23 : U(t23.spatialReference, r10) ? this._projectedCenter = O(t23, r10) : this.requestRender()), null == this._metersPerSRUnit && null != this._projectedCenter && (this._metersPerSRUnit = u10(this._projectedCenter));
  }
  _updateTransform(e15, r10, i14) {
    const { grid: s15 } = this, { center: n17, rotation: c12, size: j, spatialReference: _7 } = e15.state;
    if (null == s15 || null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const g7 = r10 * (j[0] / 2), R3 = r10 * (j[1] / 2), v3 = this._metersPerSRUnit / i14, U6 = this._projectedCenter, y5 = s(s15.rotation), S3 = s(c12), b6 = this.transforms.displayViewScreenMat3;
    m2(b6, -y5);
    const L7 = _7.isWrappable ? P3(U6.x, n17[0], _7) : U6.x, P6 = o2(x5, L7, U6.y), w5 = B(x5, n17, P6);
    l3(w5, w5, v3), s15.rotateWithMap || I(w5, w5, i5, -S3), I(w5, w5, i5, -y5), l3(w5, w5, 1 / s15.majorLineInterval), M4(w5, w5), l3(w5, w5, s15.majorLineInterval), I(w5, w5, i5, y5), M(b6, b6, w5), s15.rotateWithMap && h(b6, b6, S3);
    const q5 = o2(x5, g7 / i14, R3 / i14);
    b2(b6, b6, q5);
  }
};
function M4(e15, t23) {
  return e15[0] = t23[0] - Math.trunc(t23[0]), e15[1] = t23[1] - Math.trunc(t23[1]), e15;
}
function q4(e15) {
  const [t23, r10, i14, s15] = e15.toArray().map((e16) => e16 / 255);
  return [t23 * s15, r10 * s15, i14 * s15, s15];
}
export {
  t15 as GraphicContainer,
  A3 as GraphicsView2D,
  w4 as GridView2D,
  a6 as LabelManager,
  c11 as MagnifierView2D,
  y3 as MapViewNavigation,
  O7 as Stage
};
//# sourceMappingURL=mapViewDeps-KT3BZ35R.js.map
