import {
  f
} from "./chunk-W7QCICS6.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/arcade/geometry/operatorsWorker.js
function t(e, t2) {
  let r2;
  return { loaded: false, load: () => r2 ?? (r2 = t2().then((t3) => {
    o[e] = { loaded: true, execute: t3 };
  })) };
}
function r(e) {
  return null == e ? null : e.toJSON();
}
var o = { disjoint: t("disjoint", () => import("./disjointOperator-V2DOOPCJ.js").then((e) => e.execute)), intersects: t("intersects", () => import("./intersectsOperator-I2OKPQCT.js").then((e) => e.execute)), touches: t("touches", () => import("./touchesOperator-GXVINHYI.js").then((e) => e.execute)), crosses: t("crosses", () => import("./crossesOperator-MEKOQ2G6.js").then((e) => e.execute)), within: t("within", () => import("./withinOperator-MD7KIUNN.js").then((e) => e.execute)), contains: t("contains", () => import("./containsOperator-5QQYHZDY.js").then((e) => e.execute)), overlaps: t("overlaps", () => import("./overlapsOperator-PLZWUQKI.js").then((e) => e.execute)), equals: t("equals", async () => {
  const t2 = await import("./equalsOperator-FHX7LMRS.js");
  return (r2, o2) => t2.execute(f(r2), f(o2));
}), relate: t("relate", async () => {
  const t2 = await import("./relateOperator-QJWONEO7.js");
  return (r2, o2, n2) => t2.execute(f(r2), f(o2), n2);
}), intersection: t("intersection", () => import("./intersectionOperator-P53V23DW.js").then((e) => e.execute)), union: t("union", () => import("./unionOperator-DHCSXFNM.js").then((e) => e.executeMany)), difference: t("difference", async () => {
  const t2 = await import("./differenceOperator-CXU7SN7C.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), symmetricDifference: t("symmetricDifference", async () => {
  const t2 = await import("./symmetricDifferenceOperator-LZY5JMJ5.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), clip: t("clip", async () => {
  const t2 = await import("./clipOperator-DAOEEY7M.js");
  return (o2, n2) => r(t2.execute(f(o2), f(n2)));
}), cut: t("cut", async () => {
  const t2 = await import("./cutOperator-7QGZ4TCJ.js");
  return (o2, n2) => t2.execute(f(o2), f(n2)).map((e) => r(e));
}), area: t("area", async () => {
  const t2 = await import("./areaOperator-VBP53XM3.js"), { convertFromSpatialReferenceUnit: r2, toAreaUnit: o2 } = await import("./unitConversion-6BOQ5QID.js");
  return (n2, a) => {
    const s = t2.execute(f(n2));
    return r2(n2.spatialReference, o2(a), s);
  };
}), geodeticArea: t("geodeticArea", async () => {
  const t2 = await import("./geodeticAreaOperator-L4IXQFZQ.js"), { convert: r2, squareMeters: o2, toAreaUnit: n2 } = await import("./unitConversion-6BOQ5QID.js");
  return await t2.load(), (a, s) => {
    const i = t2.execute(f(a));
    return r2(o2, n2(s), i);
  };
}), length: t("length", async () => {
  const e = await import("./lengthOperator-7X27FF2U.js"), { convertFromSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-6BOQ5QID.js");
  return (o2, n2) => {
    const a = e.execute(o2);
    return t2(o2.spatialReference, r2(n2), a);
  };
}), geodeticLength: t("geodeticLength", async () => {
  const t2 = await import("./geodeticLengthOperator-FIKP27Y4.js"), { convert: r2, meters: o2, toLengthUnit: n2 } = await import("./unitConversion-6BOQ5QID.js");
  return await t2.load(), (a, s) => {
    const i = t2.execute(f(a));
    return r2(o2, n2(s), i);
  };
}), distance: t("distance", async () => {
  const t2 = await import("./distanceOperator-2PC6DJPJ.js"), { convertFromSpatialReferenceUnit: r2, toLengthUnit: o2 } = await import("./unitConversion-6BOQ5QID.js");
  return (n2, a, s) => {
    const i = t2.execute(f(n2), f(a));
    return r2(n2.spatialReference, o2(s), i);
  };
}), densify: t("densify", async () => {
  const t2 = await import("./densifyOperator-UFNSWZUO.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-6BOQ5QID.js");
  return (a, s, i) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s)));
}), geodeticDensify: t("geodeticDensify", async () => {
  const t2 = await import("./geodeticDensifyOperator-CF7C5V3P.js"), { convert: o2, meters: n2, toLengthUnit: a } = await import("./unitConversion-6BOQ5QID.js");
  return await t2.load(), (s, i, c) => (i = o2(a(c), n2, i), r(t2.execute(f(s), i)));
}), generalize: t("generalize", async () => {
  const t2 = await import("./generalizeOperator-VLMLRJH2.js"), { convertToSpatialReferenceUnit: o2, toLengthUnit: n2 } = await import("./unitConversion-6BOQ5QID.js");
  return (a, s, i, c) => (s = o2(n2(i), a.spatialReference, s), r(t2.execute(f(a), s, c)));
}), buffer: t("buffer", async () => {
  const e = await import("./bufferOperator-3CS44M7M.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-6BOQ5QID.js");
  return (o2, n2, a) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2));
}), geodesicBuffer: t("geodesicBuffer", async () => {
  const e = await import("./geodesicBufferOperator-Y26QU6PI.js"), { convert: t2, meters: r2, toLengthUnit: o2 } = await import("./unitConversion-6BOQ5QID.js");
  return await e.load(), (n2, a, s) => (a = t2(o2(s), r2, a), e.execute(n2, a));
}), offset: t("offset", async () => {
  const e = await import("./offsetOperator-QYIIGFNP.js"), { convertToSpatialReferenceUnit: t2, toLengthUnit: r2 } = await import("./unitConversion-6BOQ5QID.js");
  return (o2, n2, a, s) => (n2 = t2(r2(a), o2.spatialReference, n2), e.execute(o2, n2, s));
}), rotate: t("rotate", async () => {
  const t2 = await import("./@arcgis_core_geometry_operators_affineTransformOperator__js.js"), { default: o2 } = await import("./@arcgis_core_geometry_operators_support_Transformation.js");
  return (n2, a, s, i) => {
    const c = new o2().rotate(a, s, i);
    return r(t2.execute(f(n2), c));
  };
}), centroid: t("centroid", async () => {
  const t2 = await import("./centroidOperator-RL56OG6T.js");
  return (o2) => r(t2.execute(f(o2)));
}), labelPoint: t("labelPoint", async () => {
  const t2 = await import("./labelPointOperator-EE4UEY43.js");
  return (o2) => r(t2.execute(f(o2)));
}), simplify: t("simplify", () => import("./simplifyOperator-JRGTTMMY.js").then((e) => e.execute)), isSimple: t("isSimple", () => import("./simplifyOperator-JRGTTMMY.js").then((e) => e.isSimple)), convexHull: t("convexHull", () => import("./convexHullOperator-HWSY7YCJ.js").then((e) => e.execute)), getNearestCoordinate: t("getNearestCoordinate", async () => {
  const t2 = await import("./proximityOperator-DA4OX7WL.js");
  return (o2, n2, a) => {
    const s = t2.getNearestCoordinate(f(o2), f(n2), a);
    return { ...s, coordinate: r(s.coordinate) };
  };
}), getNearestVertex: t("getNearestVertex", async () => {
  const t2 = await import("./proximityOperator-DA4OX7WL.js");
  return (o2, n2) => {
    const a = t2.getNearestVertex(f(o2), f(n2));
    return { ...a, coordinate: r(a.coordinate) };
  };
}) };
function n(e, t2) {
  const r2 = o[e];
  return r2.loaded ? r2.execute.apply(void 0, t2) : r2.load().then(() => n(e, t2));
}
export {
  n as invokeGeometryOp
};
//# sourceMappingURL=operatorsWorker-KNLV7PZB.js.map
