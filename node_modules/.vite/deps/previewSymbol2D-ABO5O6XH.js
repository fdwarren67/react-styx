import {
  l
} from "./chunk-MAMI2IDV.js";
import {
  d,
  e,
  t
} from "./chunk-RRO6KNFV.js";
import {
  f,
  g,
  u as u2,
  y
} from "./chunk-GHPQVNNU.js";
import "./chunk-VBE5VFL5.js";
import {
  L
} from "./chunk-23WGP47N.js";
import {
  c
} from "./chunk-2TACZL27.js";
import {
  U,
  k
} from "./chunk-D7L2BYRU.js";
import "./chunk-TYJV2BHR.js";
import "./chunk-I6H2R562.js";
import "./chunk-FJTIPVNU.js";
import "./chunk-SXKP4T6J.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-4ANUERFT.js";
import "./chunk-C33DSFWF.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-W7QCICS6.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import {
  s as s2
} from "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import "./chunk-K7TZXQ7O.js";
import {
  u
} from "./chunk-FZPO5AYT.js";
import {
  h
} from "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import "./chunk-2FUEBHWI.js";
import "./chunk-VTWDBFQT.js";
import "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import "./chunk-6II7WQ2F.js";
import "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol2D.js
var f2 = "picture-fill";
var y2 = "picture-marker";
var w = "simple-fill";
var x = "simple-line";
var b = "simple-marker";
var v = "text";
var M = "Aa";
var S = t.size;
var z = t.maxSize;
var k2 = t.maxOutlineSize;
var L2 = t.lineWidth;
var C = 225;
var $ = document.createElement("canvas");
function j(t2, e2, i) {
  if ("polygon" === t2.type) {
    const o = t2.extent, n = 0 === o.width ? 1 : o.width, l2 = 0 === o.height ? 1 : o.height;
    t2 = U({ originPosition: "upperLeft", scale: [n / e2, l2 / i], translate: [o.xmin, o.ymax] }, {}, t2);
    let s3 = "";
    for (let e3 = 0; e3 < t2.rings.length; e3++) {
      const i2 = t2.rings[e3];
      for (let t3 = 0; t3 < i2.length; t3++) {
        const e4 = i2[t3][0], o2 = i2[t3][1];
        let n2 = "";
        0 === t3 ? (n2 = `M${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : t3 === i2.length - 1 ? (n2 = `l${e4.toString()} ${o2.toString()} Z`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : (n2 = `l${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2);
      }
    }
    return s3;
  }
  if ("polyline" === t2.type) {
    const o = t2.extent, n = 0 === o.width ? 1 : o.width, a = 0 === o.height ? 1 : o.height;
    t2 = k({ originPosition: "upperLeft", scale: [n / e2, a / i], translate: [o.xmin, o.ymax] }, {}, t2);
    let s3 = "";
    for (let e3 = 0; e3 < t2.paths.length; e3++) {
      const i2 = t2.paths[e3];
      for (let t3 = 0; t3 < i2.length; t3++) {
        const e4 = i2[t3][0], o2 = i2[t3][1];
        let n2 = "";
        0 === t3 ? (n2 = `M${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2) : (n2 = `l${e4.toString()} ${o2.toString()}`, "" !== s3 && (n2 = ` ${n2}`), s3 += n2);
      }
    }
    return s3;
  }
  return "";
}
function B(t2, e2) {
  const i = $.getContext("2d"), o = [];
  e2 && (e2.weight && o.push(e2.weight), e2.size && o.push(e2.size + "px"), e2.family && o.push(e2.family)), i.font = o.join(" ");
  const { width: n, actualBoundingBoxLeft: a, actualBoundingBoxRight: l2, actualBoundingBoxAscent: s3, actualBoundingBoxDescent: r } = i.measureText(t2);
  return { width: Math.ceil(Math.max(n, a + l2)), height: Math.ceil(s3 + r), x: Math.floor(a), y: Math.floor((s3 - r) / 2) };
}
function P(t2) {
  const e2 = t2 == null ? void 0 : t2.size;
  return { width: null != e2 && "object" == typeof e2 && "width" in e2 ? u(e2.width) : null, height: null != e2 && "object" == typeof e2 && "height" in e2 ? u(e2.height) : null };
}
async function U2(t2, e2) {
  const i = e2.fill, o = t2.color;
  if ("pattern" === (i == null ? void 0 : i.type) && o && t2.type !== f2) {
    const t3 = await f(i.src, o.toCss(true));
    i.src = t3, e2.fill = i;
  }
}
async function A(t2, e2, i, n) {
  var _a, _b, _c;
  if (!("font" in t2) || !t2.font || "text" !== e2.shape.type) return;
  try {
    await c(t2.font);
  } catch {
  }
  const { width: a, height: l2 } = P(n);
  if (!/[\uE600-\uE6FF]/.test(e2.shape.text)) {
    const { width: o, height: s3, x: r, y: h2 } = B(e2.shape.text, { weight: (_a = e2.font) == null ? void 0 : _a.weight, size: (_b = e2.font) == null ? void 0 : _b.size, family: (_c = e2.font) == null ? void 0 : _c.family });
    i[0] = a ?? o, i[1] = l2 ?? s3, e2.shape.x = r, e2.shape.y = h2;
    let c2 = "angle" in t2 ? t2.angle : null;
    if (null != (n == null ? void 0 : n.rotation) && (c2 = (c2 ?? 0) + n.rotation), c2) {
      const t3 = c2 * (Math.PI / 180), e3 = Math.abs(Math.sin(t3)), o2 = Math.abs(Math.cos(t3));
      i[1] = i[0] * e3 + i[1] * o2;
    }
  }
}
function E(t2, e2, i, o, a) {
  var _a;
  if (null != t2.haloColor && null != t2.haloSize) {
    a.masking ?? (a.masking = i.map(() => []));
    const l2 = u(t2.haloSize);
    o[0] += l2, o[1] += l2, i.unshift([{ ...e2, fill: null, stroke: { color: t2.haloColor, width: 2 * l2, join: "round", cap: "round" } }]), a.masking.unshift([{ shape: { type: "rect", x: 0, y: 0, width: o[0] + 2 * s2, height: o[1] + 2 * s2 }, fill: [255, 255, 255], stroke: null }, { ...e2, fill: [0, 0, 0, 0], stroke: null }]);
  }
  null == t2.backgroundColor && null == t2.borderLineColor || (o[0] += 2 * s2, o[1] += 2 * s2, i.unshift([{ shape: { type: "rect", x: 0, y: 0, width: o[0], height: o[1] }, fill: t2.backgroundColor, stroke: { color: t2.borderLineColor, width: u(t2.borderLineSize) } }]), (_a = a.masking) == null ? void 0 : _a.unshift([]));
}
function F(t2, e2) {
  return t2 > e2 ? "dark" : "light";
}
function Z(t2, e2) {
  var _a, _b, _c, _d, _e;
  const i = "number" == typeof (e2 == null ? void 0 : e2.size) ? e2 == null ? void 0 : e2.size : null, o = null != i ? u(i) : null, a = null != (e2 == null ? void 0 : e2.maxSize) ? u(e2.maxSize) : null;
  let l2 = "angle" in t2 ? t2.angle : null;
  null != (e2 == null ? void 0 : e2.rotation) && (l2 = (l2 ?? 0) + e2.rotation);
  const c2 = u2(t2);
  let m = y(t2);
  "dark" !== q(t2, 245) || (e2 == null ? void 0 : e2.ignoreWhiteSymbols) || (m = { width: 0.75, ...m, color: "#bdc3c7" });
  let p = null;
  const d2 = { shape: null, fill: c2, stroke: m, offset: [0, 0] };
  (m == null ? void 0 : m.width) && (m.width = Math.min(m.width, k2));
  const g2 = (m == null ? void 0 : m.width) || 0;
  let C2 = null != (e2 == null ? void 0 : e2.size) && (null == (e2 == null ? void 0 : e2.scale) || (e2 == null ? void 0 : e2.scale)), $2 = 0, U3 = 0, A2 = false;
  switch (t2.type) {
    case b: {
      const i2 = t2.style, { width: s3, height: r } = P(e2);
      let h2 = s3 === r && null != s3 ? s3 : null != o ? o : Math.min(u(t2.size), a || z);
      if (true === (e2 == null ? void 0 : e2.useMarkerSymbolSize) && null !== s3 && null !== r) {
        const e3 = Math.min(u(t2.size), a || z);
        h2 = e3 > s3 && e3 > r ? Math.min(s3, r) : e3;
      }
      switch ($2 = h2, U3 = h2, i2) {
        case "circle":
          d2.shape = { type: "circle", cx: 0, cy: 0, r: 0.5 * h2 }, C2 || ($2 += g2, U3 += g2);
          break;
        case "cross":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * U3] }, { command: "L", values: [$2, 0.5 * U3] }, { command: "M", values: [0.5 * $2, 0] }, { command: "L", values: [0.5 * $2, U3] }] };
          break;
        case "diamond":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * U3] }, { command: "L", values: [0.5 * $2, 0] }, { command: "L", values: [$2, 0.5 * U3] }, { command: "L", values: [0.5 * $2, U3] }, { command: "Z", values: [] }] }, C2 || ($2 += g2, U3 += g2);
          break;
        case "square":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, 0] }, { command: "L", values: [$2, U3] }, { command: "L", values: [0, U3] }, { command: "Z", values: [] }] }, C2 || ($2 += g2, U3 += g2), l2 && (A2 = true);
          break;
        case "triangle":
          d2.shape = { type: "path", path: [{ command: "M", values: [0.5 * $2, 0] }, { command: "L", values: [$2, U3] }, { command: "L", values: [0, U3] }, { command: "Z", values: [] }] }, C2 || ($2 += g2, U3 += g2), l2 && (A2 = true);
          break;
        case "x":
          d2.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, U3] }, { command: "M", values: [$2, 0] }, { command: "L", values: [0, U3] }] }, l2 && (A2 = true);
          break;
        case "path":
          d2.shape = { type: "path", path: t2.path || "" }, C2 || ($2 += g2, U3 += g2), l2 && (A2 = true), C2 = true;
      }
      break;
    }
    case x: {
      const { width: t3, height: i2 } = P(e2), n = g(m).reduce((t4, e3) => t4 + e3, 0), a2 = n && Math.ceil(L2 / n), l3 = i2 ?? o ?? g2, s3 = t3 ?? (n * a2 || L2);
      if (C2 = true, "polyline" === ((_a = e2 == null ? void 0 : e2.geometry) == null ? void 0 : _a.type) && ((_b = e2 == null ? void 0 : e2.geometry) == null ? void 0 : _b.extent)) {
        $2 = s3, U3 = i2 ?? $2;
        const t4 = 1e3, o2 = 0.15 * t4;
        p = [$2, U3], U3 = p[0] > p[1] ? t4 * p[1] / p[0] : t4, $2 = p[0] > p[1] ? t4 : t4 * p[0] / p[1], (m == null ? void 0 : m.width) && (m.width = m.width * t4 / (p[1] > p[0] ? p[1] : p[0]), m.width > o2 && (m.width = o2)), d2.shape = { type: "path", path: j(e2.geometry, $2, U3) };
      } else $2 = null != (e2 == null ? void 0 : e2.maxSize) ? Math.min(s3, e2.maxSize) : s3, U3 = l3, m && (m.width = l3), d2.shape = { type: "path", path: [{ command: "M", values: [l3 / 2, U3 / 2] }, { command: "L", values: [$2 - l3 / 2, U3 / 2] }] };
      break;
    }
    case f2:
    case w: {
      const t3 = "object" == typeof (e2 == null ? void 0 : e2.symbolConfig) && !!((_c = e2 == null ? void 0 : e2.symbolConfig) == null ? void 0 : _c.isSquareFill), { width: i2, height: n } = P(e2);
      $2 = !t3 && i2 !== n || null == i2 ? null != o ? o : S : i2, U3 = !t3 && i2 !== n || null == n ? $2 : n, C2 || ($2 += g2, U3 += g2), C2 = true, ((_d = e2 == null ? void 0 : e2.geometry) == null ? void 0 : _d.extent) && "polygon" === ((_e = e2 == null ? void 0 : e2.geometry) == null ? void 0 : _e.type) ? (p = [$2, U3], U3 = p[0] > p[1] ? 1e3 * p[1] / p[0] : 1e3, $2 = p[0] > p[1] ? 1e3 : 1e3 * p[0] / p[1], d2.shape = { type: "path", path: j(e2.geometry, $2, U3) }) : d2.shape = t3 ? { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [$2, 0] }, { command: "L", values: [$2, U3] }, { command: "L", values: [0, U3] }, { command: "L", values: [0, 0] }, { command: "Z", values: [] }] } : e.fill[0];
      break;
    }
    case y2: {
      const i2 = Math.min(u(t2.width), a || z), s3 = Math.min(u(t2.height), a || z), { width: r, height: h2 } = P(e2), c3 = r === h2 && null != r ? r : null != o ? o : Math.max(i2, s3), m2 = t2.width / t2.height;
      $2 = m2 <= 1 ? Math.ceil(c3 * m2) : c3, U3 = m2 <= 1 ? c3 : Math.ceil(c3 / m2), d2.shape = { type: "image", x: -Math.round($2 / 2), y: -Math.round(U3 / 2), width: $2, height: U3, src: t2.url || "" }, l2 && (A2 = true);
      break;
    }
    case v: {
      const i2 = t2, l3 = (e2 == null ? void 0 : e2.overrideText) || i2.text || M, s3 = i2.font, { width: r, height: h2 } = P(e2), c3 = null != h2 ? h2 : null != o ? o : Math.min(u(s3.size), a || z), { width: m2, height: u3 } = B(l3, { weight: s3.weight, size: c3, family: s3.family }), p2 = /[\uE600-\uE6FF]/.test(l3);
      $2 = r ?? (p2 ? c3 : m2), U3 = p2 ? c3 : u3;
      let g3 = 0.5 * (p2 ? c3 : u3);
      p2 && (g3 += 5), d2.shape = { type: "text", text: l3, x: i2.xoffset || 0, y: i2.yoffset || g3, align: "middle", alignBaseline: i2.verticalAlignment, decoration: s3 && s3.decoration, rotated: i2.rotated, kerning: i2.kerning }, d2.font = s3 && { size: c3, style: s3.style, decoration: s3.decoration, weight: s3.weight, family: s3.family };
      break;
    }
  }
  return { shapeDescriptor: d2, size: [$2, U3], outputSize: p, renderOptions: { node: e2 == null ? void 0 : e2.node, scale: C2, opacity: e2 == null ? void 0 : e2.opacity, rotations: [l2], useRotationSize: A2, effectView: e2 == null ? void 0 : e2.effectView, ariaLabel: e2 == null ? void 0 : e2.ariaLabel } };
}
async function D(t2, e2) {
  var _a, _b, _c, _d, _e;
  const { shapeDescriptor: o, size: n, renderOptions: a, outputSize: l2 } = Z(t2, e2);
  if (!o.shape) throw new s("symbolPreview: renderPreviewHTML2D", "symbol not supported.");
  await U2(t2, o), await A(t2, o, n, e2);
  const s3 = [[o]];
  if ("object" == typeof (e2 == null ? void 0 : e2.symbolConfig) && ((_a = e2 == null ? void 0 : e2.symbolConfig) == null ? void 0 : _a.applyColorModulation)) {
    const t3 = 0.6 * n[0];
    s3.unshift([{ ...o, offset: [-t3, 0], fill: d(o.fill, -0.3) }]), s3.push([{ ...o, offset: [t3, 0], fill: d(o.fill, 0.3) }]), n[0] += 2 * t3, a.scale = false;
  }
  "text" === t2.type && E(t2, o, s3, n, a);
  const r = l(s3, n, a);
  if (l2 && r) {
    const t3 = "img" === r.nodeName.toLowerCase() ? r : r.firstChild;
    "svg" === t3.nodeName.toLowerCase() && t3.setAttribute("viewBox", `0 0 ${n[0].toString()} ${n[1].toString()}`), t3.setAttribute("width", l2[0].toString()), t3.setAttribute("height", l2[1].toString()), l2.length > 2 && (t3.style.setProperty("padding-left", ((_b = l2[2]) == null ? void 0 : _b.toString()) + "px"), t3.style.setProperty("padding-right", ((_c = l2[2]) == null ? void 0 : _c.toString()) + "px"), t3.style.setProperty("padding-top", ((_d = l2[3]) == null ? void 0 : _d.toString()) + "px"), t3.style.setProperty("padding-bottom", ((_e = l2[3]) == null ? void 0 : _e.toString()) + "px"), t3.style.setProperty("box-sizing", "border-box"));
  }
  return r;
}
function q(i, o = C) {
  const n = u2(i), a = y(i), l2 = !n || "type" in n ? null : new h(n), h2 = (a == null ? void 0 : a.color) ? new h(a == null ? void 0 : a.color) : null, c2 = l2 ? F(L(l2), o) : null, m = h2 ? F(L(h2), o) : null;
  return m ? c2 ? c2 === m ? c2 : o >= C ? "light" : "dark" : m : c2;
}
export {
  q as getContrastingBackgroundTheme,
  Z as getRenderSymbolParameters,
  D as previewSymbol2D
};
//# sourceMappingURL=previewSymbol2D-ABO5O6XH.js.map
