import {
  n as n4
} from "./chunk-M76M42H4.js";
import {
  a as a4
} from "./chunk-N7FB6BVA.js";
import {
  T as T3
} from "./chunk-I2SHMCYI.js";
import "./chunk-36CN7JP2.js";
import "./chunk-WX3BOMD3.js";
import "./chunk-TSFKACKN.js";
import "./chunk-W5QWJI4E.js";
import {
  c as c3,
  c2 as c4,
  m as m4,
  u2 as u
} from "./chunk-YYDDGFL6.js";
import "./chunk-SNZZPKBU.js";
import "./chunk-6PQMUQJV.js";
import "./chunk-JDUGBJ57.js";
import "./chunk-3HA4XA2C.js";
import "./chunk-H2OC77GP.js";
import "./chunk-RDHJUEBL.js";
import {
  c as c2,
  d as d2,
  p as p3,
  v,
  z as z2
} from "./chunk-T5W3ZRGM.js";
import {
  F as F2,
  M as M2,
  N,
  T as T2,
  U as U2,
  b
} from "./chunk-6ZI2HC5K.js";
import {
  $ as $2,
  C,
  P as P2,
  c,
  d,
  j as j2,
  m as m3,
  q
} from "./chunk-WESTCUBG.js";
import {
  a as a2,
  n as n3
} from "./chunk-IZJWCIYF.js";
import {
  $,
  M,
  U,
  f,
  j,
  k
} from "./chunk-BG4U4RTY.js";
import {
  s as s3
} from "./chunk-D7L2BYRU.js";
import "./chunk-LMQPVKGX.js";
import {
  at
} from "./chunk-6D65DCMG.js";
import "./chunk-GTVVYAXM.js";
import "./chunk-XOXXDYBM.js";
import "./chunk-I6H2R562.js";
import "./chunk-T7CHWWE2.js";
import "./chunk-4ACM2XXN.js";
import "./chunk-VT63JL2L.js";
import "./chunk-WJNJ43ZU.js";
import "./chunk-MIW7M4LL.js";
import {
  f as f2
} from "./chunk-6W3XFTHW.js";
import {
  t
} from "./chunk-PHUXOQ5V.js";
import "./chunk-QAXPIBME.js";
import "./chunk-NUJWMWJZ.js";
import "./chunk-QAP2FVP7.js";
import {
  d as d3
} from "./chunk-6EREU4EG.js";
import {
  a as a3,
  l
} from "./chunk-ZXHHBJMH.js";
import "./chunk-5JWPKXQI.js";
import "./chunk-XAZEJYKE.js";
import "./chunk-62KPTW4J.js";
import "./chunk-UCDQUN5K.js";
import "./chunk-OQEC2EUK.js";
import "./chunk-RP6IGXYU.js";
import "./chunk-5T3XQRJL.js";
import "./chunk-MRPAGZVF.js";
import "./chunk-VIBOZNXV.js";
import "./chunk-HGWPGAUL.js";
import "./chunk-V3IZNRFE.js";
import "./chunk-D7XVYH42.js";
import "./chunk-HAYP5DZM.js";
import "./chunk-OMNXYZNG.js";
import "./chunk-GPMU6IW4.js";
import {
  p as p4
} from "./chunk-LTFI343D.js";
import "./chunk-FVMWI3UB.js";
import {
  b as b2,
  m as m5
} from "./chunk-4JVIG75S.js";
import {
  m as m6
} from "./chunk-HZLSEOMW.js";
import {
  R
} from "./chunk-L2AVI4MN.js";
import {
  p,
  p2,
  y
} from "./chunk-4JHPTLMD.js";
import {
  i
} from "./chunk-35I4PBUK.js";
import "./chunk-ZQMORW2K.js";
import "./chunk-OGPRAWXS.js";
import "./chunk-EGSJQZXU.js";
import "./chunk-7VGCZZPH.js";
import "./chunk-GNZ342SJ.js";
import "./chunk-EO3ETQWH.js";
import "./chunk-PMTDIWAP.js";
import "./chunk-ACBQ6NOA.js";
import "./chunk-QW7P5D76.js";
import "./chunk-RO66CZDO.js";
import "./chunk-KMVZXZBR.js";
import "./chunk-7HSZJLYU.js";
import "./chunk-BMGYJDE7.js";
import "./chunk-WHOXQQMB.js";
import "./chunk-YQH3DXBZ.js";
import "./chunk-T52X5K2I.js";
import "./chunk-VE2K63DA.js";
import "./chunk-5E5JYM5A.js";
import "./chunk-GSNLF6RP.js";
import "./chunk-LILYILCM.js";
import "./chunk-WBBL3X3F.js";
import "./chunk-OJGPUKVG.js";
import "./chunk-GFEMKR2U.js";
import "./chunk-G2OXL5Y3.js";
import "./chunk-B6ORYDBK.js";
import {
  b as b3
} from "./chunk-BLF64HON.js";
import "./chunk-I3JB2EVB.js";
import "./chunk-TCV7UF6X.js";
import "./chunk-BMNRD4FO.js";
import "./chunk-W7QCICS6.js";
import "./chunk-AYLNWVVJ.js";
import {
  F
} from "./chunk-PQVKYMOX.js";
import "./chunk-DCSYHXZG.js";
import "./chunk-ZSBMFGDQ.js";
import "./chunk-NAGFHISJ.js";
import "./chunk-QCS4ZI2R.js";
import "./chunk-2SOWSOAE.js";
import "./chunk-KSQSVLSQ.js";
import "./chunk-SPVEONZ2.js";
import {
  Fe,
  Ie,
  be,
  ge,
  we,
  xe
} from "./chunk-BMNDO4JW.js";
import "./chunk-RAVPBO4Z.js";
import {
  o
} from "./chunk-PHADC6NW.js";
import "./chunk-3ODJ3YKN.js";
import "./chunk-P6IUM5K3.js";
import "./chunk-KGTLNUPW.js";
import "./chunk-GY7XU54K.js";
import "./chunk-P4D4HTH2.js";
import "./chunk-GDR4JYWU.js";
import {
  m as m2
} from "./chunk-Y4AQXF4J.js";
import "./chunk-D3P3E2RE.js";
import {
  w
} from "./chunk-UKY33OJN.js";
import "./chunk-HAWCNM3C.js";
import "./chunk-BQYXRSVC.js";
import "./chunk-BJEQ2APY.js";
import "./chunk-WKNMEFRQ.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-CIALVDRG.js";
import "./chunk-N5E3DEQN.js";
import "./chunk-GTN3PVPB.js";
import "./chunk-BF5PIC2K.js";
import {
  r as r2
} from "./chunk-K7TZXQ7O.js";
import "./chunk-FZPO5AYT.js";
import "./chunk-5VM3BO4P.js";
import "./chunk-EYUJRAXJ.js";
import "./chunk-BDOGPNOY.js";
import "./chunk-552ZCNNH.js";
import "./chunk-XG7T2Y7N.js";
import "./chunk-SQOMDKJS.js";
import "./chunk-HB6TKF6E.js";
import "./chunk-OXPM753Y.js";
import "./chunk-N4U5VIP2.js";
import "./chunk-IVS2JCO6.js";
import "./chunk-4GOW35CM.js";
import "./chunk-TEJXT4W6.js";
import "./chunk-LW62SPEN.js";
import "./chunk-LSOJIRW6.js";
import "./chunk-FSFEOCO5.js";
import "./chunk-ZVIMKAJW.js";
import "./chunk-BIURGGHV.js";
import "./chunk-VSLEAHOZ.js";
import "./chunk-6K2FAOQG.js";
import "./chunk-N5DN7S3H.js";
import {
  P2 as P,
  g2 as g
} from "./chunk-BECTSF5P.js";
import "./chunk-FX46DC27.js";
import {
  S
} from "./chunk-2FUEBHWI.js";
import {
  m
} from "./chunk-VTWDBFQT.js";
import {
  a2 as a
} from "./chunk-BM4B3CH5.js";
import "./chunk-G2YC5GCV.js";
import "./chunk-GD5AHXAI.js";
import "./chunk-YWGYHRSH.js";
import "./chunk-DP2IAJQN.js";
import "./chunk-EAFC6V23.js";
import {
  T,
  h,
  n as n2,
  s as s2
} from "./chunk-SMH2GUF6.js";
import "./chunk-AZP4AFW7.js";
import {
  r
} from "./chunk-SCZRL2WP.js";
import {
  s
} from "./chunk-OSHCNHH7.js";
import "./chunk-7LCEUMDD.js";
import {
  n2 as n
} from "./chunk-6II7WQ2F.js";
import {
  G,
  has,
  z
} from "./chunk-L7QO6TDW.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/@arcgis/core/smartMapping/support/binningUtils.js
function i2(e2, i5) {
  if (!e2.view) throw new s(`${i5}:missing-parameters`, "'view' parameter is required for binning");
  if (e2.sqlExpression) throw new s(`${i5}:invalid-parameters`, "'sqlExpression' parameter is not supported for binning");
  if ("3d" === e2.view.type) throw new s(`${i5}:invalid-parameters`, "3d view is not supported for binning");
}

// node_modules/@arcgis/core/smartMapping/statistics/support/WorkerClient.js
var n5 = class _n {
  constructor() {
    this.connection = null;
  }
  async open(t3) {
    this.connection = await p4("statsWorker", { strategy: "distributed", signal: t3 });
  }
  destroy() {
    var _a;
    (_a = this.connection) == null ? void 0 : _a.close();
  }
  static getInstance() {
    return _n.instance || (_n.instance = new _n()), _n.instance;
  }
  async summaryStatistics(e2, n7) {
    if (!this.connection) throw new s("worker-client:summary-statistics", "connection is required");
    return this.connection.invoke("summaryStatistics", { attribute: e2, features: n7 });
  }
  async uniqueValues(e2, n7) {
    if (!this.connection) throw new s("worker-client:unique-values", "connection is required");
    return this.connection.invoke("uniqueValues", { attribute: e2, features: n7 });
  }
  async classBreaks(e2, n7) {
    if (!this.connection) throw new s("worker-client:class-breaks", "connection is required");
    return this.connection.invoke("classBreaks", { attribute: e2, features: n7 });
  }
  async histogram(e2, n7) {
    if (!this.connection) throw new s("worker-client:histogram", "connection is required");
    return this.connection.invoke("histogram", { attribute: e2, features: n7 });
  }
  async heatmapStatistics(e2, n7) {
    if (!this.connection) throw new s("worker-client:heatmap-statistics", "connection is required");
    return this.connection.invoke("heatmapStatistics", { attribute: e2, features: n7 });
  }
};

// node_modules/@arcgis/core/rest/query/executeQuery.js
async function f3(t3, o5, r5, e2) {
  return m7(o5, await c5(t3, o5, r5, e2), r5, e2);
}
async function c5(t3, o5, r5, e2) {
  var _a;
  const n7 = { ...e2 }, i5 = p5(o5, r5), u7 = null != ((_a = o5.outStatistics) == null ? void 0 : _a[0]), f4 = has("featurelayer-pbf-statistics"), c7 = !u7 || f4;
  let m10;
  if ("pbf" === (r5 == null ? void 0 : r5.format) && c7) try {
    m10 = await n4(t3, i5, n7);
  } catch (d7) {
    if ("query:parsing-pbf" !== d7.name) throw d7;
    r5.format = "json";
  }
  return "json" !== (r5 == null ? void 0 : r5.format) && c7 || (m10 = await a4(t3, i5, n7)), l2(r5 == null ? void 0 : r5.fieldsIndex, m10.fields), m10;
}
function l2(t3, o5) {
  if (null != t3 && null != o5) for (const r5 of o5) {
    const o6 = t3.get(r5.name);
    o6 && Object.assign(r5, o6.toJSON());
  }
}
async function m7(t3, r5, e2, n7) {
  var _a;
  const s7 = e2 == null ? void 0 : e2.infoFor3D;
  if (!d4(t3, s7) || null == s7 || !r5.assetMaps || !((_a = r5.features) == null ? void 0 : _a.length)) return d3.fromJSON(r5);
  const { meshFeatureSetFromJSON: a5 } = await h(import("./meshFeatureSet-DEZAS4GK.js"), n7);
  return a5(t3, s7, r5);
}
function p5(o5, s7) {
  let a5 = b2.from(o5);
  a5.sourceSpatialReference = a5.sourceSpatialReference ?? (s7 == null ? void 0 : s7.sourceSpatialReference) ?? null, ((s7 == null ? void 0 : s7.gdbVersion) || (s7 == null ? void 0 : s7.dynamicDataSource)) && (a5 = a5 === o5 ? a5.clone() : a5, a5.gdbVersion = o5.gdbVersion || s7.gdbVersion, a5.dynamicDataSource = o5.dynamicDataSource ? R.from(o5.dynamicDataSource) : s7.dynamicDataSource);
  const i5 = s7 == null ? void 0 : s7.infoFor3D;
  if (null != i5 && d4(o5, i5)) {
    a5 = a5 === o5 ? a5.clone() : a5, a5.formatOf3DObjects = null;
    const n7 = a3(i5), s8 = l(i5);
    for (const t3 of i5.queryFormats) {
      if (t3 === n7) {
        a5.formatOf3DObjects = t3;
        break;
      }
      t3 !== s8 || a5.formatOf3DObjects || (a5.formatOf3DObjects = t3);
    }
    if (!a5.formatOf3DObjects) throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
    if (null == a5.outFields || !a5.outFields.includes("*")) {
      a5 = a5 === o5 ? a5.clone() : a5, null == a5.outFields && (a5.outFields = []);
      const { originX: t3, originY: r5, originZ: e2, translationX: n8, translationY: s9, translationZ: u7, scaleX: f4, scaleY: c7, scaleZ: l5, rotationX: m10, rotationY: p9, rotationZ: d7, rotationDeg: y2 } = i5.transformFieldRoles;
      a5.outFields.push(t3, r5, e2, n8, s9, u7, f4, c7, l5, m10, p9, d7, y2);
    }
  }
  return a5;
}
function d4(t3, o5) {
  return null != o5 && true === t3.returnGeometry && "xyFootprint" !== t3.multipatchOption && !t3.outStatistics;
}

// node_modules/@arcgis/core/rest/generateRenderer.js
async function l3(t3, i5, a5, s7) {
  const l5 = f2(t3), { source: r5, checkValueRange: u7 } = i5, { classificationDefinition: c7 } = a5, f4 = { ...a5.toJSON(), f: "json" };
  let m10 = null;
  if (m10 = "class-breaks-definition" === (c7 == null ? void 0 : c7.type) ? c7.classificationField : c7 == null ? void 0 : c7.attributeField, r5) {
    const e2 = { source: r5 == null ? void 0 : r5.toJSON() };
    f4.layer = JSON.stringify(e2);
  }
  f4.classificationDef && (f4.classificationDef = JSON.stringify(f4.classificationDef));
  let p9 = { query: f4 };
  s7 && (p9 = { ...s7, ...p9 });
  const y2 = { url: l5.path, field: m10, checkValueRange: u7 }, d7 = l5.path + "/generateRenderer";
  return P(d7, p9).then((e2) => o2(y2, e2));
}
function o2(e2, t3) {
  const { field: n7, checkValueRange: l5, url: o5 } = e2, u7 = t3 == null ? void 0 : t3.data;
  if (!u7) return;
  if (!l5) {
    const e3 = r3(u7);
    return Promise.resolve(e3);
  }
  const c7 = new m6({ statisticType: "min", onStatisticField: n7 }), f4 = new m6({ statisticType: "max", onStatisticField: n7 }), m10 = new b2({ outStatistics: [c7, f4] });
  return f3(o5, m10).then((e3) => {
    const t4 = e3.features[0].attributes;
    let n8 = null, i5 = null;
    for (const a5 in t4) 0 === a5.toLowerCase().indexOf("min") ? n8 = t4[a5] : i5 = t4[a5];
    return r3(u7, n8, i5);
  });
}
function r3(e2, n7, i5) {
  if ("classBreaks" === e2.type) {
    const a6 = t(e2);
    return { classBreaks: a6.classBreakInfos.map((e3, t3) => (0 === t3 && null != n7 && (e3.minValue = n7), t3 === a6.classBreakInfos.length - 1 && null != i5 && (e3.maxValue = i5), { minValue: e3.minValue, maxValue: e3.maxValue, label: e3.label })), normalizationTotal: a6.normalizationTotal };
  }
  const { uniqueValueInfos: a5 } = e2;
  return { uniqueValues: (a5 == null ? void 0 : a5.map((e3, t3) => (0 === t3 && null != n7 && (e3.value = n7), t3 === a5.length - 1 && null != i5 && (e3.value = i5), { count: e3.count, value: e3.value, label: e3.label }))) ?? [] };
}

// node_modules/@arcgis/core/rest/support/GenerateRendererParameters.js
var t2 = class extends S {
  constructor(r5) {
    super(r5), this.classificationDefinition = null, this.where = null;
  }
};
r([m({ json: { name: "classificationDef", write: true } })], t2.prototype, "classificationDefinition", void 0), r([m({ type: String, json: { write: true } })], t2.prototype, "where", void 0), t2 = r([a("esri.rest.support.GenerateRendererParameters")], t2);
var i3 = t2;

// node_modules/@arcgis/core/rest/support/UniqueValueDefinition.js
var s4 = class extends S {
  constructor(t3) {
    super(t3), this.type = "unique-value-definition", this.attributeField = null, this.attributeField2 = null, this.attributeField3 = null, this.fieldDelimiter = null;
  }
  get uniqueValueFields() {
    const t3 = [];
    return this.attributeField && t3.push(this.attributeField), this.attributeField2 && t3.push(this.attributeField2), this.attributeField3 && t3.push(this.attributeField3), t3;
  }
};
r([r2({ uniqueValueDef: "unique-value-definition" })], s4.prototype, "type", void 0), r([m()], s4.prototype, "attributeField", void 0), r([m()], s4.prototype, "attributeField2", void 0), r([m()], s4.prototype, "attributeField3", void 0), r([m({ json: { write: true } })], s4.prototype, "fieldDelimiter", void 0), r([m({ json: { write: true } })], s4.prototype, "uniqueValueFields", null), s4 = r([a("esri.rest.support.UniqueValueDefinition")], s4);
var u2 = s4;

// node_modules/@arcgis/core/smartMapping/statistics/support/predominanceUtils.js
var e = "no_dominant_category";
function u3(n7) {
  return { expression: r4(n7, { returnFieldName: true, defaultValue: `'${e}'` }) };
}
function r4(e2, l5) {
  const { returnFieldName: u7, defaultValue: r5, layer: t3 } = l5, i5 = [];
  if (u7 && r5) {
    const n7 = e2.map((n8) => `${n8} <= 0`).join(" AND ");
    i5.push(`WHEN ${n7} THEN ${r5}`);
  }
  for (const o5 of e2) {
    const l6 = e2.reduce((n7, a5) => (o5 !== a5 && n7.push(`${o5} > ${a5}`), n7), []).join(" AND "), r6 = t3 && j(t3, o5), s7 = u7 && `'${o5}'` ? `'${o5}'` : r6 ? M(o5) : o5;
    i5.push(`WHEN ${l6} THEN ${s7}`);
  }
  return `CASE ${i5.join(" ")} ELSE ${r5 || "0"} END`;
}
function i4(n7) {
  return n7 && n7.map((n8) => `$feature["${n8}"];`).join("\n") + "\n" || "";
}
function o3(n7, a5 = false) {
  const e2 = n7.map((n8) => `"${n8}"`), l5 = "\n  if(value != null && value >= 0) {\n    if (totalValue == null) { totalValue = 0; }\n    totalValue = totalValue + value;\n  }\n  ";
  return `
  var fieldNames = [ ${e2.join(", ")} ];
  var numFields = ${e2.length};
  var maxValueField = null;
  var maxValue = -Infinity;
  var value, i, totalValue = null;

  for(i = 0; i < numFields; i++) {
    value = $feature[fieldNames[i]];

    if(value > 0) {
      if(value > maxValue) {
        maxValue = value;
        maxValueField = fieldNames[i];
      }
      else if (value == maxValue) {
        maxValueField = null;
      }
    }
    ${a5 ? l5 : ""}
  }
  `;
}
function s5(n7) {
  const a5 = o3(n7);
  return `
  ${i4(n7)}
  ${a5}
  return maxValueField;
  `;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/LayerAdapter.js
var p6 = class extends m2 {
  constructor(o5) {
    super(o5), this.adapterName = "layer-adapter";
  }
};
r([m({ readOnly: true })], p6.prototype, "adapterName", void 0), r([m({ constructOnly: true })], p6.prototype, "layer", void 0), r([m()], p6.prototype, "geometryType", void 0), r([m()], p6.prototype, "objectIdField", void 0), r([m()], p6.prototype, "supportsSQLExpression", void 0), r([m()], p6.prototype, "hasQueryEngine", void 0), r([m()], p6.prototype, "minScale", void 0), r([m()], p6.prototype, "maxScale", void 0), r([m()], p6.prototype, "fullExtent", void 0), p6 = r([a("esri.smartMapping.support.adapters.LayerAdapter")], p6);
var s6 = p6;

// node_modules/@arcgis/core/smartMapping/support/adapters/support/utils.js
var F3 = /_value$/i;
var w2 = Math.LOG10E;
var E = { SECOND: 1e3, MINUTE: 6e4, HOUR: 36e5 };
var S2 = 10;
function T4(e2) {
  return e2.map((e3) => e3.toJSON());
}
function V(e2, t3) {
  var _a;
  const n7 = [], l5 = e2.layer, i5 = "featureReduction" in l5 ? l5.featureReduction : null, o5 = "binning" === (i5 == null ? void 0 : i5.type), a5 = null != i5 && "fields" in i5 ? (_a = i5.fields) == null ? void 0 : _a.map((e3) => {
    var _a2;
    return (_a2 = e3.name) == null ? void 0 : _a2.toLowerCase();
  }).filter(Boolean) : [];
  if (!o5 || !t3) return n7;
  for (const r5 of t3) a5.includes(r5.toLowerCase()) || n7.push(r5);
  return n7;
}
function z3(e2, t3, n7) {
  var _a;
  const l5 = [];
  if (t3) for (const i5 of t3) {
    const t4 = e2.getField(i5);
    t4 && n7 && "availableFields" in n7 && !((_a = n7.availableFields) == null ? void 0 : _a.includes(t4.name)) && l5.push(t4.name);
  }
  return l5;
}
function $3(e2, t3) {
  var _a;
  const n7 = e2 && e2.features;
  if (0 === (n7 == null ? void 0 : n7.length)) return { avg: null, count: 0, max: null, median: null, min: null, nullcount: 0, stddev: null, sum: null, variance: null };
  const l5 = (_a = n7 == null ? void 0 : n7[0]) == null ? void 0 : _a.attributes, i5 = {};
  for (const o5 in l5) i5[o5.replace(F3, "").toLowerCase()] = l5[o5];
  return null != i5.totalcount && i5.totalcount >= i5.count && (i5.nullcount = i5.totalcount - i5.count), delete i5.totalcount, i5.min === i5.max && null != i5.min && null == i5.stddev && (i5.stddev = i5.variance = 0), t3 && (["min", "max", "avg", "stddev", "sum", "variance"].forEach((e3) => {
    null != i5[e3] && (i5[e3] = Math.ceil(i5[e3]));
  }), i5.min === i5.max && null != i5.min && (i5.avg = i5.min, i5.stddev = i5.variance = 0)), i5;
}
function C2(e2) {
  const t3 = [], n7 = e2.classBreaks, l5 = n7[0].minValue, i5 = n7[n7.length - 1].maxValue;
  n7.forEach((e3) => {
    t3.push([e3.minValue, e3.maxValue]);
  });
  const o5 = { field: e2.field, normalizationType: e2.normalizationType, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, layer: e2.layer };
  return { min: l5, max: i5, intervals: t3, sqlExpr: j3(o5), excludeZerosExpr: e2.where, normTotal: e2.normalizationTotal };
}
function j3(e2) {
  const { field: t3, normalizationType: n7, normalizationField: l5, normalizationTotal: i5, layer: o5 } = e2, a5 = j(o5, t3);
  let r5 = t3;
  return "percent-of-total" === n7 ? r5 = `((${a5 ? M(t3) : t3} / ${i5}) * 100)` : "log" === n7 ? r5 = `(log(${t3}) * ${w2})` : "field" === n7 ? r5 = `(${a5 ? M(t3) : t3} / ${l5})` : "natural-log" === n7 ? r5 = `(log(${a5 ? M(t3) : t3}))` : "square-root" === n7 && (r5 = `(power(${a5 ? M(t3) : t3}, 0.5))`), r5;
}
function q2(e2, t3) {
  let n7;
  if (t3 = t3.toLowerCase(), e2) {
    for (const l5 in e2) if (l5.toLowerCase() !== t3) {
      n7 = e2[l5];
      break;
    }
  }
  return n7;
}
function b4(e2, t3) {
  let n7;
  if (t3 = t3.toLowerCase(), e2) {
    for (const l5 in e2) if (l5.toLowerCase() === t3) {
      n7 = e2[l5];
      break;
    }
  }
  return n7;
}
function O(e2, t3, n7, l5, i5) {
  const o5 = {}, a5 = "countOFExpr";
  e2 && e2.features && e2.features.forEach((e3) => {
    const t4 = e3.attributes, n8 = q2(t4, a5), l6 = b4(t4, a5);
    null != n8 && null != l6 && 0 !== n8 && (o5[n8] = l6);
  });
  const r5 = [];
  return j2(t3, n7, l5).forEach((e3, t4) => {
    const n8 = (t4 + 1).toString();
    r5.push({ minValue: e3[0], maxValue: e3[1], count: o5.hasOwnProperty(n8) ? o5[n8] : 0 });
  }), { bins: r5, minValue: t3, maxValue: n7, normalizationTotal: i5 };
}
async function L(e2, n7) {
  const l5 = e2 && e2.features, { field: i5, field2: o5, field3: a5, fieldDelimiter: r5, layer: s7, view: u7, signal: c7, labels: m10 } = n7, f4 = `countOF${!(!i5 || !o5) ? "Expr" : i5 || "Expr"}`, p9 = {};
  let d7 = false;
  for (const t3 of l5) {
    const e3 = t3.attributes, n8 = b4(e3, f4);
    let l6 = i5 ? b4(e3, i5) : q2(e3, f4), s8 = o5 ? b4(e3, o5) : null, u8 = a5 ? b4(e3, a5) : null;
    null === l6 && 0 === n8 && (d7 = true), (null == l6 || "string" == typeof l6 && "" === l6.trim()) && (l6 = null), o5 && (null == s8 || "string" == typeof s8 && "" === s8.trim()) && (s8 = null), a5 && (null == u8 || "string" == typeof u8 && "" === u8.trim()) && (u8 = null);
    let c8 = l6;
    o5 && (c8 = `${m3(c8)}${r5}${m3(s8)}`, a5 && (c8 = `${c8}${r5}${m3(u8)}`)), null == p9[c8] ? p9[c8] = { count: n8, data: c8 } : p9[c8].count = p9[c8].count + n8;
  }
  if (i5 && d7) {
    const e3 = i5 + " is NULL";
    try {
      const t3 = await s7.queryFeatureCount({ whereClause: e3, view: u7, signal: c7 });
      return p9.null.count = p9.null.count + t3, R2(p9, m10);
    } catch {
      return s2(c7), R2(p9, m10);
    }
  }
  return R2(p9, m10);
}
function R2(e2, t3) {
  if (t3) for (const n7 in e2) e2[n7].label = t3[n7];
  return { count: e2 };
}
async function D(e2, t3, i5) {
  const o5 = e2 ? i5.getField(e2) : null, a5 = o5 ? i5.getFieldDomain(o5.name) : null;
  if (a5) return a5;
  const { uniqueValueInfos: r5 } = await i5.uniqueValues({ field: e2, sqlWhere: t3.sqlWhere, features: t3.features, useFeaturesInView: t3.useFeaturesInView, view: t3.view, signal: t3.signal }), s7 = r5.map((e3) => new p({ code: e3.value }));
  return new p2({ codedValues: s7 });
}
async function I(e2, t3) {
  if (!e2.returnAllCodedValues) return [];
  const { field: n7, field2: l5, field3: i5 } = e2;
  if (n7 && !l5) {
    const e3 = n7 ? t3.getField(n7) : null, l6 = e3 ? t3.getFieldDomain(e3.name) : null;
    return l6 ? [l6] : [];
  }
  const o5 = [];
  return n7 && (o5.push(D(n7, e2, t3)), l5 && (o5.push(D(l5, e2, t3)), i5 && o5.push(D(i5, e2, t3)))), Promise.all(o5);
}
function N2(e2, t3) {
  return k(e2, /* @__PURE__ */ new Date(0), t3, "milliseconds").sqlExpression;
}
function U3(e2, t3) {
  return `EXTRACT(${t3} FROM ${e2}) * ${E[t3]}`;
}
function M3(e2) {
  if (!e2) return null;
  return M(["HOUR", "MINUTE", "SECOND"].map((t3) => `(${U3(e2, t3)})`).join(" + "));
}
function B(e2) {
  var _a;
  return { viewingMode: "2d" === e2.type ? "map" : e2.viewingMode, scale: e2.scale, spatialReference: (_a = e2.spatialReference) == null ? void 0 : _a.toJSON() };
}
function Q(e2, t3) {
  const n7 = new Set(e2.map((e3) => e3.value)), l5 = t3.filter((e3) => !n7.has(e3));
  for (const i5 of l5) e2.push({ value: i5, count: 0 });
  e2.sort((e3, n8) => t3.indexOf(e3.value) - t3.indexOf(n8.value));
  for (const i5 of e2) i5.value === e && (i5.value = null);
  return { predominantCategoryInfos: e2 };
}
function P3(t3) {
  const n7 = "featureReduction" in t3 ? t3.featureReduction : null;
  return ((null != n7 && "fields" in n7 ? n7.fields : null) ?? []).map((e2) => {
    const n8 = W(e2, t3.fieldsIndex);
    return n8 ? new y({ type: n8, name: e2.name, alias: e2.alias }) : null;
  }).filter(G);
}
function W(e2, t3) {
  var _a, _b;
  switch (e2.statisticType) {
    case "avg":
    case "avg_angle":
      return "double";
    case "count":
      return "integer";
    case "min":
    case "max":
    case "sum":
      return e2.onStatisticField ? ((_a = t3.get(e2.onStatisticField)) == null ? void 0 : _a.type) ?? null : e2.onStatisticExpression ? "string" === e2.onStatisticExpression.returnType ? null : "double" : null;
    case "mode":
      return e2.onStatisticField ? ((_b = t3.get(e2.onStatisticField)) == null ? void 0 : _b.type) ?? null : e2.onStatisticExpression ? "string" === e2.onStatisticExpression.returnType ? "string" : "double" : null;
    default:
      return null;
  }
}
function _(e2, t3) {
  return $(t3) ? N2(e2, t3 == null ? void 0 : t3.name) : xe(t3) ? M3(t3 == null ? void 0 : t3.name) : null;
}
function k2(e2, t3, n7) {
  const { field: l5, normalizationType: i5, normalizationField: o5, normalizationTotal: s7, minValue: f4, maxValue: p9, filter: d7 } = t3, y2 = e2.supportsSQLExpression ? _(e2, n7) || t3.sqlExpression : null, g4 = j3({ field: l5, normalizationType: i5, normalizationField: o5, normalizationTotal: s7, layer: e2 }), h2 = y2 || g4, F4 = h2 ? N(h2, f4, p9) : null, w3 = F2({ field: l5, normalizationField: o5, normalizationType: i5 }), E3 = U2(t3.sqlWhere, w3), S5 = U2(E3, F4), T6 = d({ normalizationField: o5, normalizationType: i5, sqlExpression: y2, supportsSQLExpression: e2.supportsSQLExpression, minValue: f4, maxValue: p9 }), V4 = Fe(e2.getField(l5 ?? void 0)), { include: z4, exclude: $5 } = t3.outStatisticTypes || {}, C3 = c.filter((e3) => (!z4 || z4.includes(e3)) && (!$5 || !$5.includes(e3)) && ("nullcount" === e3 ? T6 : !V4 || "count" === e3)), q4 = e2.createQuery();
  return q4.where = U2(q4.where, S5), q4.sqlFormat = y2 ? "standard" : null, q4.outStatistics = C3.map((t4) => {
    const n8 = new m6();
    let l6 = null, i6 = null, o6 = `${t4}_value`;
    if ("variance" === t4) l6 = "var", i6 = h2;
    else if ("nullcount" === t4) {
      const t5 = e2.objectIdField;
      l6 = "count", i6 = t5 && e2.getField(t5) ? t5 : "1", o6 = "totalcount_value";
    } else "median" === t4 ? (l6 = "percentile-continuous", i6 = h2, n8.statisticParameters = { value: 0.5 }) : (l6 = t4, i6 = h2);
    return n8.statisticType = l6, n8.onStatisticField = i6, n8.outStatisticFieldName = o6, n8;
  }), A(q4, d7), q4;
}
function A(e2, t3) {
  t3 && (e2.geometry = t3.geometry, e2.spatialRelationship = t3.spatialRelationship);
}
function H(e2, t3) {
  const { field: n7, field2: l5, field3: i5, sqlExpression: o5 } = t3, a5 = !(!n7 || !l5), r5 = e2.createQuery();
  return r5.where = U2(r5.where, t3.sqlWhere), r5.sqlFormat = o5 ? "standard" : null, r5.outStatistics = [J(a5 ? null : n7, a5 ? "1" : o5)].filter(Boolean), r5.groupByFieldsForStatistics = [n7 || o5, l5, i5].filter(Boolean), A(r5, t3.filter), r5;
}
function J(e2, t3) {
  const n7 = "countOF" + (e2 || "Expr"), l5 = new m6();
  return l5.statisticType = "count", l5.onStatisticField = t3 ? "1" : e2, l5.outStatisticFieldName = n7, l5;
}
function Z(e2, t3, n7, l5 = S2, i5, o5, a5) {
  const { min: r5, max: s7, normTotal: u7, excludeZerosExpr: c7 } = t3, m10 = t3.intervals || j2(r5, s7, l5), f4 = t3.sqlExpr || n7;
  return G2(e2, m10, f4, c7, i5, o5, a5).then((e3) => ({ bins: e3.map((e4, t4) => ({ minValue: m10[t4][0], maxValue: m10[t4][1], count: "fulfilled" === e4.status ? e4.value : 0 })), minValue: r5, maxValue: s7, normalizationTotal: u7 }));
}
function G2(e2, t3, n7, l5, i5, o5, a5) {
  const r5 = [], s7 = t3.length;
  for (let u7 = 0; u7 < s7; u7++) {
    const e3 = U2(l5, U2(n7 + " >= " + t3[u7][0], null !== t3[u7][1] ? n7 + (u7 === s7 - 1 ? " <= " : " < ") + t3[u7][1] : ""));
    r5.push(e3);
  }
  return Promise.allSettled(r5.map((t4) => e2.queryFeatureCount({ whereClause: t4, view: i5, filter: o5, signal: a5 })));
}

// node_modules/@arcgis/core/smartMapping/support/adapters/support/histogramUtils.js
var V2 = "countOFExpr";
var j4 = "lowerBoundary";
var q3 = "upperBoundary";
function I2(i5, e2, t3) {
  const a5 = i5.valueExpression || i5.sqlExpression, r5 = i5.signal;
  if (!a5) {
    const { field: a6, normalizationType: o5, normalizationField: l5 } = i5, s7 = a6 ? e2.getField(a6) : null, u7 = $(s7) || xe(s7), m10 = { field: a6, normalizationType: o5, normalizationField: l5, normalizationTotal: t3, layer: e2 };
    return { sqlExpression: u7 ? _(e2, s7) : j3(m10), sqlWhere: u7 ? null : i5.sqlWhere || F2({ field: a6, normalizationType: o5, normalizationField: l5 }), filter: i5.filter, signal: r5 };
  }
  return { valueExpression: i5.valueExpression, sqlExpression: i5.sqlExpression, sqlWhere: i5.sqlWhere, filter: i5.filter, signal: r5 };
}
async function M4(i5, e2, n7) {
  const { field: t3, normalizationType: a5, normalizationField: r5, signal: o5 } = i5, l5 = F2({ field: t3, normalizationType: a5, normalizationField: r5 }), s7 = new i3({ classificationDefinition: q({ field: t3, normalizationType: a5, normalizationField: r5, classificationMethod: i5.classificationMethod, standardDeviationInterval: i5.standardDeviationInterval, definedInterval: i5.definedInterval, breakCount: i5.numBins || S2 }), where: U2(l5, n7) });
  return e2.generateRenderer(s7, o5).then((i6) => {
    const { normalizationTotal: n8, classBreaks: o6 } = i6;
    return C2({ field: t3, normalizationType: a5, normalizationField: r5, normalizationTotal: n8, classBreaks: o6, where: l5, layer: e2 });
  });
}
async function g2(e2, t3, a5, o5, d7) {
  const { field: p9, sqlExpression: f4, normalizationField: c7, classificationMethod: z4, normalizationType: v2 } = e2, T6 = p9 ? t3.getField(p9) : null, h2 = xe(T6), F4 = be(T6) || h2, B2 = e2.numBins || S2;
  if (F4) {
    if (v2 || z4) throw new s(`${t3.adapterName}:not-supported`, "NormalizationType and classificationMethod are not supported for date-only and time-only fields");
    const e3 = (o5 - a5) / B2 / 1e3, n7 = e3 / 86400;
    return new u({ field: p9, expression: f4, interval: { unit: h2 ? "seconds" : "days", value: Math.ceil(h2 ? e3 : n7) }, start: a5, end: o5 });
  }
  if ("defined-interval" === z4) return new c4({ field: p9, expression: f4, normalizationField: c7, normalizationTotal: d7, normalizationType: v2, interval: e2.definedInterval ?? Math.ceil((o5 - a5) / B2), start: v2 ? null : a5, end: v2 ? null : o5, normalizationMinValue: v2 ? a5 : null, normalizationMaxValue: v2 ? o5 : null });
  if ("manual" === z4) throw new s(`${t3.adapterName}:not-supported`, "Layer does not support manual classificationMethod");
  if ("natural-breaks" === z4 || "quantile" === z4 || "standard-deviation" === z4) {
    const n7 = j3({ field: p9, normalizationField: c7, normalizationTotal: d7, normalizationType: v2, layer: t3 }), r5 = null !== e2.minValue && null !== e2.maxValue ? N(n7, e2.minValue, e2.maxValue) : void 0, o6 = await M4(e2, t3, r5);
    if (!o6.intervals) throw new s(`${t3.adapterName}:invalid`, "Invalid intervals returned from generate renderer");
    const l5 = [a5, ...o6.intervals.map((i5) => i5[1])];
    return new m4({ field: v2 ? null : p9, expression: v2 ? n7 : f4, boundaries: l5 });
  }
  return new c3({ field: p9, normalizationField: c7, normalizationTotal: d7, normalizationType: v2, expression: f4, numBins: B2, start: v2 ? null : a5, end: v2 ? null : o5, normalizationMinValue: v2 ? a5 : null, normalizationMaxValue: v2 ? o5 : null });
}
function E2(i5, e2, n7, t3) {
  return null != n7 && null != t3 ? Promise.resolve({ min: n7, max: t3 }) : e2.summaryStatistics({ ...i5, outStatisticTypes: { include: ["min", "max"] } }).then((i6) => ({ min: i6.min, max: i6.max }));
}
async function b5(i5, n7, r5, l5) {
  const { field: s7, minValue: u7, maxValue: m10, filter: d7, view: f4 } = i5, y2 = s7 ? n7.getField(s7) : null, z4 = Ie(y2) || we(y2), v2 = I2(i5, n7, r5), { min: x, max: w3 } = await E2(v2, n7, u7, m10);
  if (null == x || null == w3) return { query: null, min: x, max: w3 };
  const T6 = new m6({ statisticType: "count", outStatisticFieldName: V2, onStatisticField: "1" }), F4 = U2(l5, v2.sqlWhere), B2 = "lowerBoundary", j6 = "upperBoundary", q4 = new T3({ binParameters: await g2(i5, n7, x, w3, r5), outStatistics: [T6], binOrder: i5.sortOrder, where: F4, lowerBoundaryAlias: B2, upperBoundaryAlias: j6, outTimeZone: (f4 == null ? void 0 : f4.timeZone) && z4 ? F(f4.timeZone) : null });
  return A(q4, d7), { query: q4, min: x, max: w3 };
}
function D2(i5, e2 = false) {
  if ("string" != typeof i5) return i5;
  return (e2 ? /* @__PURE__ */ new Date(`1970-01-01T${i5}Z`) : new Date(i5)).getTime();
}
function P4(i5, e2, t3) {
  const a5 = xe(e2);
  return { ...t3, bins: i5.features.map((i6) => ({ minValue: D2(i6.attributes[j4], a5), maxValue: D2(i6.attributes[q3], a5), count: i6.attributes[V2] })) };
}
function S3(i5, e2, n7) {
  const { valueExpression: t3, view: a5 } = i5, { featuresJSON: r5, graphics: o5, fieldInfos: l5 } = e2, s7 = { field: i5.field, valueExpression: t3, normalizationType: i5.normalizationType, normalizationField: i5.normalizationField, normalizationTotal: n7, minValue: i5.minValue, maxValue: i5.maxValue, standardDeviationInterval: i5.standardDeviationInterval, classificationMethod: i5.classificationMethod, numBins: i5.numBins };
  return t3 && a5 && (r5 || o5) && (s7.viewInfoParams = B(a5), s7.timeZone = a5.timeZone, s7.fieldInfos = l5), s7;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/InMemoryLayerAdapter.js
var $4 = 5;
var G3 = null;
var R3 = class extends s6 {
  constructor() {
    super(...arguments), this._hasLocalSource = false, this.adapterName = "in-memory-layer-adapter";
  }
  destroy() {
    var _a;
    (_a = this.workerClient) == null ? void 0 : _a.destroy();
  }
  async _waitForLayerViewUpdate(e2) {
    if (!e2) throw new s(`${this.adapterName}:insufficient-data", "layerView is required to fetch the features`);
    const t3 = new AbortController(), i5 = w(() => !e2.updating, t3.signal);
    await T(i5, 5e3, t3).catch((e3) => {
      throw n.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView."), e3;
    });
  }
  async _fetchFeatureSetFromMemory(e2, t3, a5) {
    const i5 = this.layer;
    if (this._hasLocalSource && "queryFeatures" in i5) return i5.queryFeatures(e2);
    if (!t3) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s7 = await t3.whenLayerView(this.layer);
    return await this._waitForLayerViewUpdate(s7), s7.queryFeatures(e2, { signal: a5 });
  }
  async _fetchFeaturesFromMemory(e2, t3, a5, i5) {
    const s7 = this.layer, o5 = "json" === i5;
    if (this._hasLocalSource && "queryFeatures" in s7) {
      const e3 = await s7.queryFeatures(t3);
      return o5 ? T4(e3.features) : e3.features;
    }
    if (await this._waitForLayerViewUpdate(e2), o5 && "queryFeaturesJSON" in e2 && e2.queryFeaturesJSON) {
      const { features: r5 } = await e2.queryFeaturesJSON(t3, { signal: a5 });
      return r5;
    }
    if (!("queryFeatures" in e2)) throw new s(`${this.adapterName}:not-supported`, "'queryFeatures' is not supported on the layerView");
    const n7 = await e2.queryFeatures(t3, { signal: a5 });
    return o5 ? T4(n7.features) : n7.features;
  }
  _fetchFeaturesForStats(e2, t3) {
    return U({ field: e2.field, field2: e2.field2, field3: e2.field3, normalizationField: e2.normalizationField, valueExpression: e2.valueExpression }).then((r5) => this.getSampleFeatures({ sampleSize: -1, view: e2.view, returnGeometry: e2.returnGeometry, filter: e2.filter, requiredFields: r5, signal: e2.signal }, t3));
  }
  async _summaryStatsFromClientQuery(e2, t3) {
    const { view: r5, signal: a5 } = e2, i5 = k2(this, e2, t3), s7 = await this._fetchFeatureSetFromMemory(i5, r5, a5), o5 = $3(s7, $(t3) || xe(t3));
    return C(o5, e2.outStatisticTypes);
  }
  async _getNormalizationTotalFromMemory(e2, t3, a5) {
    const { featuresJSON: i5, graphics: s7, layerView: o5, query: n7 } = t3, l5 = { include: ["sum"] }, u7 = (!i5 && !s7 && o5 && "querySummaryStatistics" in o5 ? await o5.querySummaryStatistics(n7, { field: e2 }, { signal: a5 }) : i5 ? await this.workerClient.summaryStatistics({ field: e2, outStatisticTypes: l5 }, i5) : await d2({ attribute: { field: e2, outStatisticTypes: l5 }, features: s7 ?? [] })).sum;
    if (null == u7) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return u7;
  }
  async _summaryStatsFromMemory(e2, t3) {
    const { view: r5, field: a5, valueExpression: i5, normalizationType: s7, signal: o5 } = e2, n7 = { field: a5, valueExpression: i5, normalizationType: s7, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, outStatisticTypes: e2.outStatisticTypes }, { featuresJSON: l5, graphics: u7, layerView: m10, query: y2, fieldInfos: c7 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "querySummaryStatistics" });
    return i5 && r5 && (l5 || u7) && (n7.fieldType = (t3 == null ? void 0 : t3.type) ? i.toJSON(t3.type) : null, n7.viewInfoParams = B(r5), n7.timeZone = r5.timeZone, n7.fieldInfos = c7), "percent-of-total" === s7 && null == e2.normalizationTotal && (n7.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: l5, graphics: u7, layerView: m10, query: y2 }, o5)), !l5 && !u7 && m10 && "querySummaryStatistics" in m10 ? m10.querySummaryStatistics(y2, n7, { signal: o5 }) : l5 ? this.workerClient.summaryStatistics(n7, l5) : d2({ attribute: n7, features: u7 });
  }
  async _getFilteredFeatures(e2, t3) {
    let r5 = [];
    if ("intersects" === (t3 == null ? void 0 : t3.spatialRelationship)) {
      const { intersect: a5 } = await import("./geometryEngineAsync-5BRIST4M.js"), i5 = null != t3.geometry ? t3.geometry : null;
      for (const t4 of e2) {
        const e3 = null != t4.geometry ? t4.geometry : null;
        if (e3 && i5) {
          await a5(e3, i5) && r5.push(t4);
        }
      }
    } else r5 = e2;
    return e2.length && "declaredClass" in e2[0] && "esri.Graphic" === e2[0].declaredClass ? { graphics: r5 } : { featuresJSON: r5 };
  }
  async _processStatsFromMemoryParams(e2) {
    const { features: t3, filter: r5 } = e2;
    if (t3 == null ? void 0 : t3.length) return this._getFilteredFeatures(t3, r5);
    const { view: a5, field: i5, field2: s7, field3: o5, normalizationField: n7, valueExpression: l5, layerViewFunc: u7, signal: m10 } = e2;
    let p9 = e2.returnGeometry;
    if (null == p9 && l5) {
      if (!G3) {
        const { arcadeUtils: e4 } = await o();
        G3 = e4;
      }
      const e3 = G3.hasGeometryOperations(l5);
      e3 && await G3.enableGeometryOperations(), p9 = e3;
    }
    let y2 = null, c7 = null, f4 = null, d7 = null, h2 = null;
    if (a5) try {
      const e3 = "subtype-sublayer" === this.layer.type ? this.layer.parent : this.layer;
      y2 = await a5.whenLayerView(e3), c7 = null != u7 && u7 in y2 && "function" == typeof y2[u7];
    } catch {
      c7 = false;
    }
    if (c7) try {
      await this._waitForLayerViewUpdate(y2);
      const e3 = await U({ field: i5, field2: s7, field3: o5, normalizationField: n7, valueExpression: l5 });
      z3(this, e3, y2).length ? c7 = false : (f4 = this.layer.createQuery(), f4.outFields = e3, f4.returnGeometry = false, A(f4, r5)), y2.suspended && (c7 = false);
    } catch {
      c7 = false;
    }
    return c7 || (d7 = await this._fetchFeaturesForStats({ field: i5, field2: s7, field3: o5, valueExpression: l5, normalizationField: n7, returnGeometry: p9, filter: r5, view: a5, signal: m10 }, "json"), h2 = (await U({ valueExpression: l5 })).map((e3) => {
      var _a;
      return (_a = this.getField(e3)) == null ? void 0 : _a.toJSON();
    }).filter(Boolean)), { layerView: y2, query: f4, featuresJSON: d7, fieldInfos: h2 };
  }
  async _uvFromClientQuery(e2, t3) {
    const { view: r5, signal: a5 } = e2, i5 = H(this, e2), s7 = await this._fetchFeatureSetFromMemory(i5, r5, a5), o5 = await L(s7, { layer: this, field: e2.field, field2: e2.field2, field3: e2.field3, fieldDelimiter: f, view: e2.view, signal: e2.signal });
    return $2(o5, t3, e2.returnAllCodedValues, f);
  }
  async _uvFromMemory(e2, t3) {
    const { view: r5, field: a5, valueExpression: i5, returnAllCodedValues: s7, signal: o5 } = e2, { featuresJSON: n7, graphics: l5, layerView: u7, query: m10, fieldInfos: p9 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryUniqueValues" }), y2 = { field: a5, field2: e2.field2, field3: e2.field3, fieldDelimiter: f, valueExpression: i5, domains: t3, returnAllCodedValues: s7 };
    return i5 && r5 && (n7 || l5) && (y2.viewInfoParams = B(r5), y2.timeZone = r5.timeZone, y2.fieldInfos = p9), !n7 && !l5 && u7 && "queryUniqueValues" in u7 ? u7.queryUniqueValues(m10, y2, { signal: o5 }) : n7 ? this.workerClient.uniqueValues(y2, n7) : p3({ attribute: y2, features: l5 });
  }
  _histogramForField(e2) {
    let t3 = null;
    return t3 = null != e2.minValue && null != e2.maxValue ? Promise.resolve({ min: e2.minValue, max: e2.maxValue }) : this.summaryStatistics({ ...e2, outStatisticTypes: { include: ["min", "max", "count"] } }).then((e3) => {
      if (!e3.count) throw new s(`${this.adapterName}:insufficient-data`, "Either the layer has no features or none of the features have data for the field");
      return { min: e3.min, max: e3.max };
    }), t3.then((t4) => Z(this, { min: t4.min, max: t4.max }, e2.field, e2.numBins ?? void 0, e2.view, e2.filter, e2.signal));
  }
  async _histogramFromQueryAttributeBinsFromMemory(e2) {
    const { field: t3, normalizationType: r5, signal: a5 } = e2, i5 = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryAttributeBins" }), { featuresJSON: s7, graphics: o5, layerView: n7, query: l5 } = i5, u7 = "percent-of-total" === r5 ? e2.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t3, i5, a5) : void 0;
    if (!n7 || !("queryAttributeBins" in n7) || s7 || o5) {
      const t4 = S3(e2, i5, u7);
      return s7 ? this.workerClient.histogram(t4, s7) : v({ attribute: t4, features: o5 });
    }
    const { query: m10, min: p9, max: y2 } = await b5(e2, this, u7, l5 == null ? void 0 : l5.where);
    if (!m10) return { bins: [], minValue: p9, maxValue: y2, normalizationTotal: u7 };
    const c7 = await n7.queryAttributeBins(m10, { signal: a5 });
    return P4(c7, t3 ? this.getField(t3) : null, { minValue: p9, maxValue: y2, normalizationTotal: u7 });
  }
  async _histogramFromMemory(e2) {
    const { field: t3, signal: r5 } = e2, a5 = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryHistogram" }), { featuresJSON: i5, graphics: s7, layerView: o5, query: n7 } = a5, l5 = "percent-of-total" === e2.normalizationType ? e2.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t3, a5, r5) : void 0, u7 = S3(e2, a5, l5);
    return !i5 && !s7 && o5 && "queryHistogram" in o5 ? o5.queryHistogram(n7, u7, { signal: r5 }) : i5 ? this.workerClient.histogram(u7, i5) : v({ attribute: u7, features: s7 });
  }
  _classBreaksFromInterpolation(e2) {
    const { minValue: t3, maxValue: r5 } = e2, a5 = e2.numClasses || $4, i5 = [], s7 = (r5 - t3) / a5;
    for (let l5 = 0; l5 < a5; l5++) {
      const e3 = t3 + l5 * s7;
      i5.push({ minValue: e3, maxValue: e3 + s7 });
    }
    i5[a5 - 1].maxValue = r5;
    const o5 = { classBreaks: i5, normalizationTotal: e2.normalizationTotal }, n7 = P2(o5, e2.classificationMethod);
    return Promise.resolve(n7);
  }
  async _classBreaksFromMemory(e2) {
    const { view: t3, field: r5, valueExpression: a5, signal: i5 } = e2, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5, fieldInfos: u7 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryClassBreaks" }), m10 = { field: r5, valueExpression: a5, normalizationType: e2.normalizationType, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, standardDeviationInterval: e2.standardDeviationInterval, classificationMethod: e2.classificationMethod, numClasses: e2.numClasses };
    return a5 && t3 && (s7 || o5) && (m10.viewInfoParams = B(t3), m10.timeZone = t3.timeZone, m10.fieldInfos = u7), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(r5, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5 }, i5)), !s7 && !o5 && n7 && "queryClassBreaks" in n7 ? n7.queryClassBreaks(l5, m10, { signal: i5 }) : s7 ? this.workerClient.classBreaks(m10, s7) : c2({ attribute: m10, features: o5 });
  }
  async _heatmapStatsFromMemory(e2) {
    var _a, _b;
    const { view: t3, field: r5, radius: a5, signal: s7 } = e2;
    n2(t3, "InMemoryLayerAdapter: must have a view");
    try {
      const r6 = await t3.whenLayerView(this.layer);
      if ("queryHeatmapStatistics" in r6 && !r6.updating && !e2.filter) return await r6.queryHeatmapStatistics({ field: e2.field, radius: e2.radius });
    } catch {
      s2(s7);
    }
    const { featuresJSON: n7, graphics: l5 } = await this._processStatsFromMemoryParams({ ...e2, returnGeometry: true }), u7 = new m5({ extent: t3.extent, tolerance: "2d" === t3.type ? t3.state.resolution : (_a = t3.pixelSizeAt) == null ? void 0 : _a.call(t3, t3.center) }), p9 = { field: r5, radius: a5, transform: s3(u7), spatialReference: (_b = t3.spatialReference) == null ? void 0 : _b.toJSON(), size: t3.size };
    return (n7 == null ? void 0 : n7.length) || (l5 == null ? void 0 : l5.length) ? n7 ? this.workerClient.heatmapStatistics(p9, n7) : z2({ attribute: p9, features: l5 }) : { min: null, max: null };
  }
  getField(e2 = "") {
    return this.layer.getField(e2);
  }
  getFieldUsageInfo(e2) {
    return this.getField(e2) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: true, supportsStatistics: true } : null;
  }
  getFieldDomain(e2, t3) {
    return this.layer.getFieldDomain(e2, t3);
  }
  createQuery() {
    return this.layer.createQuery();
  }
  async summaryStatistics(e2) {
    const { field: t3, valueExpression: a5, sqlExpression: i5, features: s7, view: o5 } = e2, n7 = t3 ? this.getField(t3) : null, l5 = !!a5, u7 = "3d" === (o5 == null ? void 0 : o5.type);
    if (!a5 && i5 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return l5 || s7 || u7 ? this._summaryStatsFromMemory(e2, n7) : this._summaryStatsFromClientQuery(e2, n7);
  }
  async uniqueValues(e2) {
    const { valueExpression: t3, sqlExpression: a5, features: i5, view: s7 } = e2, o5 = await I(e2, this), n7 = !!t3, l5 = "3d" === (s7 == null ? void 0 : s7.type);
    if (!t3 && a5 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return n7 || i5 || l5 ? this._uvFromMemory(e2, o5) : this._uvFromClientQuery(e2, o5);
  }
  async histogram(e2) {
    const { features: t3, valueExpression: a5, normalizationType: i5, sqlExpression: s7 } = e2, o5 = t3 || !!a5;
    if (!a5 && s7 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return o5 || i5 ? this._histogramFromMemory(e2) : this._histogramForField(e2);
  }
  async classBreaks(e2) {
    return false !== e2.analyzeData ? this._classBreaksFromMemory(e2) : this._classBreaksFromInterpolation(e2);
  }
  async queryFeatureCount(e2) {
    const { whereClause: t3, view: a5, signal: i5 } = e2;
    if (!a5) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s7 = this.layer.createQuery();
    s7.where = U2(s7.where, t3);
    const o5 = await a5.whenLayerView(this.layer);
    return await w(() => !o5.updating, i5), o5.queryFeatureCount(s7, { signal: i5 });
  }
  async generateRenderer(e2, t3) {
    throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation");
  }
  async predominantCategories(e2) {
    const { fields: t3, view: r5, signal: a5, filter: i5 } = e2, s7 = s5(t3), o5 = await this._uvFromMemory({ valueExpression: s7, view: r5, signal: a5, filter: i5 });
    return Q(o5.uniqueValueInfos, t3);
  }
  async heatmapStatistics(e2) {
    return this._heatmapStatsFromMemory(e2);
  }
  async getSampleFeatures(e2, a5) {
    const { view: i5, sampleSize: s7, requiredFields: o5, returnGeometry: n7, filter: l5, signal: u7 } = e2, m10 = this.layer.createQuery(), p9 = 1;
    if (m10.outSpatialReference = i5 == null ? void 0 : i5.spatialReference, m10.returnGeometry = !!n7, m10.outFields = o5, A(m10, l5), !i5) throw new s(`${this.adapterName}:not-supported`, "view is required to get sample features for Layer");
    const y2 = await i5.whenLayerView(this.layer);
    if (z3(this, o5, y2).length) throw new s(`${this.adapterName}:not-supported`, "Required fields need to be passed in the outFields for Layer");
    const c7 = await this._fetchFeaturesFromMemory(y2, m10, u7, a5), f4 = null != s7 && s7 > 0 && s7 <= c7.length ? s7 : c7.length;
    return z(c7, f4, p9);
  }
  load(e2) {
    const t3 = this.layer.load(e2).then(async (t4) => {
      var _a, _b, _c;
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = "stream" === t4.type || !!((_b = (_a = t4.capabilities) == null ? void 0 : _a.query) == null ? void 0 : _b.supportsSqlExpression), this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = "fullExtent" in t4 ? t4.fullExtent : (_c = t4.parent) == null ? void 0 : _c.fullExtent, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n5.getInstance(), await this.workerClient.open(e2.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], R3.prototype, "adapterName", void 0), r([m({ constructOnly: true })], R3.prototype, "layer", void 0), R3 = r([a("esri.smartMapping.support.adapters.InMemoryLayerAdapter")], R3);
var D3 = R3;

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerAdapter.js
var P5 = 5;
var W2 = 2e4;
var H2 = 4e5;
var Z2 = class extends D3 {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-adapter";
  }
  _isStatsSupportedOnService() {
    var _a, _b;
    const e2 = this.layer;
    if (!((_b = (_a = e2.capabilities) == null ? void 0 : _a.query) == null ? void 0 : _b.supportsStatistics) || "multipatch" === this.geometryType && !g(e2.url) && e2.version < 10.5) throw new s(`${this.adapterName}:not-supported`, "Layer does not support statistics query");
    return Promise.resolve();
  }
  _fetchFeaturesFromService(e2, t3) {
    return this.layer.queryFeatures(e2, { signal: t3 }).then((e3) => e3.features);
  }
  _fetchFeaturesJSONFromService(e2, t3) {
    return this._fetchFeaturesFromService(e2, t3).then(T4);
  }
  _summaryStatsFromGenRend(e2) {
    const t3 = e2.normalizationType, r5 = e2.normalizationField;
    return this.classBreaks({ field: e2.field, numClasses: P5, classificationMethod: "standard-deviation", standardDeviationInterval: 0.25, normalizationType: t3, normalizationField: "field" === t3 ? r5 : void 0, minValue: e2.minValue, maxValue: e2.maxValue, filter: e2.filter, signal: e2.signal }).then((t4) => {
      var _a;
      let r6, i5, s7;
      if ((_a = t4.classBreakInfos) == null ? void 0 : _a.some((e3) => (e3.hasAvg && (r6 = e3), !!r6)), r6) {
        const e3 = r6.maxValue - r6.minValue;
        i5 = r6.minValue + e3 / 2, s7 = 4 * e3;
      }
      const a5 = { min: t4.minValue, max: t4.maxValue, avg: i5, stddev: s7 };
      return C(a5, e2.outStatisticTypes);
    });
  }
  async _summaryStatsFromServiceQuery(e2, t3) {
    await this._isStatsSupportedOnService(), "percent-of-total" === e2.normalizationType && (e2.normalizationTotal = await this._getNormalizationTotal(e2.field, e2.normalizationType, e2.filter));
    const r5 = $(t3) || xe(t3), i5 = k2(this, e2, t3), s7 = await this.layer.queryFeatures(i5, { signal: e2.signal }), a5 = $3(s7, r5);
    return C(a5, e2.outStatisticTypes);
  }
  _uvFromGenRenderer(e2, t3) {
    const r5 = e2.field ?? void 0, i5 = new u2({ attributeField: r5 }), s7 = new i3({ classificationDefinition: i5 });
    return this.generateRenderer(s7, e2.signal).then((e3) => {
      const t4 = {}, i6 = this.getField(r5);
      return e3.uniqueValues.forEach((e4) => {
        let r6 = e4.value;
        null != r6 && "" !== r6 && ("string" != typeof r6 || "" !== r6.trim() && "<null>" !== r6.toLowerCase()) || (r6 = null), null == t4[r6] ? t4[r6] = { count: e4.count, data: ge(i6) && r6 ? Number(r6) : r6 } : t4[r6].count = t4[r6].count + e4.count;
      }), { count: t4 };
    }).then((r6) => $2(r6, [t3], e2.returnAllCodedValues));
  }
  async _uvFromServiceQuery(e2, t3) {
    return this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(H(this, e2), { signal: e2.signal })).then((t4) => L(t4, { layer: this, field: e2.field, field2: e2.field2, field3: e2.field3, fieldDelimiter: f, view: e2.view, signal: e2.signal })).then((r5) => $2(r5, t3, e2.returnAllCodedValues, f));
  }
  _getNormalizationTotal(e2, t3, r5, i5) {
    return e2 && "percent-of-total" === t3 ? this.summaryStatistics({ field: e2, outStatisticTypes: { include: ["sum"] }, filter: r5, signal: i5 }).then((e3) => e3.sum) : Promise.resolve(null);
  }
  _histogramForExpr(e2) {
    return this._getNormalizationTotal(e2.field, e2.normalizationType, e2.filter, e2.signal).then((t3) => {
      const r5 = I2(e2, this, t3);
      return E2(r5, this, e2.minValue, e2.maxValue).then((i5) => {
        const s7 = i5.min, a5 = i5.max;
        if (null == s7 || null == a5) return { bins: [], minValue: s7, maxValue: a5, normalizationTotal: t3 };
        const o5 = e2.numBins || S2, n7 = j2(s7, a5, o5), l5 = K(r5.sqlExpression, n7, null != e2.minValue && null != e2.maxValue), u7 = new m6({ statisticType: "count", outStatisticFieldName: "countOFExpr", onStatisticField: "1" }), m10 = this.layer.createQuery();
        return m10.where = U2(m10.where, r5.sqlWhere), m10.sqlFormat = "standard", m10.outStatistics = [u7], m10.groupByFieldsForStatistics = [l5], m10.orderByFields = [l5], A(m10, e2.filter), this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(m10, { signal: r5.signal })).then((e3) => O(e3, s7, a5, o5, t3));
      });
    });
  }
  async _histogramFromQueryAttributeBins(e2) {
    const { field: t3, normalizationType: r5, filter: i5, signal: s7 } = e2, a5 = await this._getNormalizationTotal(t3, r5, i5, s7), o5 = this.layer.createQuery(), { query: n7, min: l5, max: u7 } = await b5(e2, this, a5, o5 == null ? void 0 : o5.where);
    if (!n7) return { bins: [], minValue: l5, maxValue: u7, normalizationTotal: a5 };
    const m10 = await this.layer.queryAttributeBins(n7, { signal: s7 });
    return P4(m10, t3 ? this.getField(t3) : null, { minValue: l5, maxValue: u7, normalizationTotal: a5 });
  }
  _classBreaksFromGenRend(e2) {
    const { field: t3, normalizationType: r5, normalizationField: i5, normalizationTotal: s7, signal: a5 } = e2, o5 = F2({ field: t3, normalizationType: r5, normalizationField: i5 }), n7 = j3({ field: t3, normalizationType: r5, normalizationField: i5, normalizationTotal: s7, layer: this }), l5 = N(n7, e2.minValue, e2.maxValue), u7 = q({ field: t3, normalizationType: r5, normalizationField: i5, classificationMethod: e2.classificationMethod, standardDeviationInterval: e2.standardDeviationInterval, breakCount: e2.numClasses || P5 }), m10 = new i3({ classificationDefinition: u7 });
    return m10.where = U2(o5, l5), this.generateRenderer(m10, a5).then((t4) => P2(t4, e2.classificationMethod));
  }
  async summaryStatistics(e2) {
    const { field: t3, normalizationType: r5, valueExpression: a5, sqlExpression: o5, view: n7, features: u7, useFeaturesInView: m10 } = e2, c7 = t3 ? this.getField(t3) : null, h2 = $(c7) || xe(c7), p9 = a5 && !(o5 && this.supportsSQLExpression), d7 = this._hasLocalSource || u7 || m10, f4 = n7 && "3d" === n7.type;
    if (d7 || p9) return p9 || u7 || m10 || f4 ? this._summaryStatsFromMemory(e2, c7) : this._summaryStatsFromClientQuery(e2, c7);
    if (!this.supportsSQLExpression && (h2 || o5 || "natural-log" === r5 || "square-root" === r5)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return (r5 && !this.supportsSQLExpression ? this._summaryStatsFromGenRend(e2) : this._summaryStatsFromServiceQuery(e2, c7)).catch(() => (s2(e2.signal), this._summaryStatsFromMemory(e2, c7)));
  }
  async uniqueValues(e2) {
    const { valueExpression: t3, sqlExpression: r5, features: i5, useFeaturesInView: a5, signal: o5 } = e2, n7 = t3 && !(r5 && this.supportsSQLExpression), l5 = this._hasLocalSource || i5 || a5 || n7, u7 = e2.view, m10 = u7 && "3d" === u7.type, c7 = await I(e2, this);
    return l5 ? n7 || i5 || a5 || m10 ? this._uvFromMemory(e2, c7) : this._uvFromClientQuery(e2, c7) : this._uvFromServiceQuery(e2, c7).catch((t4) => (s2(o5), !e2.field || e2.field2 || e2.field3 || e2.filter ? t4 : this._uvFromGenRenderer(e2, c7[0]))).catch(() => (s2(o5), m10 ? this._uvFromMemory(e2, c7) : this._uvFromClientQuery(e2, c7)));
  }
  async histogram(e2) {
    var _a, _b;
    const { field: t3, normalizationType: r5, normalizationField: a5, classificationMethod: o5, view: n7, filter: u7, signal: m10 } = e2, c7 = t3 ? this.getField(t3) : null, h2 = $(c7) || xe(c7), p9 = e2.valueExpression || e2.sqlExpression, d7 = e2.valueExpression && !(e2.sqlExpression && this.supportsSQLExpression), f4 = this._hasLocalSource || e2.features || e2.useFeaturesInView || d7, y2 = this.supportsSQLExpression, F4 = !o5 || "equal-interval" === o5, g4 = e2.minValue, v2 = e2.maxValue, x = null != g4 && null != v2, _2 = e2.numBins || S2;
    if (f4) return this._histogramFromMemory(e2);
    if (((_b = (_a = this.layer.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQueryBins) && e2.useQueryAttributeBins) try {
      return await this._histogramFromQueryAttributeBins(e2);
    } catch {
      return s2(m10), this._histogramFromQueryAttributeBinsFromMemory(e2);
    }
    if ((p9 || y2) && F4) {
      if (!y2 && (p9 || "natural-log" === r5 || "square-root" === r5)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
      return this._histogramForExpr(e2);
    }
    if (h2 && F4) throw new s(`${this.adapterName}:not-supported`, "Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");
    return r5 || !F4 ? M4(e2, this).then((s7) => {
      if (!x) return Z(this, s7, t3, _2, n7, u7, m10);
      if (g4 > s7.max || v2 < s7.min) throw new s(`${this.adapterName}:insufficient-data`, "Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");
      if (F4) return Z(this, { min: g4, max: v2, sqlExpr: s7.sqlExpr, excludeZerosExpr: s7.excludeZerosExpr }, t3, _2, n7, u7, m10);
      {
        const i5 = { field: t3, normalizationType: r5, normalizationField: a5, normalizationTotal: s7.normTotal, layer: this }, o6 = j3(i5), l5 = N(o6, g4, v2);
        return M4(e2, this, l5).then((e3) => Z(this, e3, t3, _2, n7, u7, m10));
      }
    }) : this._histogramForField(e2);
  }
  async classBreaks(e2) {
    const t3 = false !== e2.analyzeData, r5 = this._hasLocalSource || e2.features || e2.useFeaturesInView || e2.valueExpression || e2.filter;
    if (t3 && r5) return this._classBreaksFromMemory(e2);
    return (t3 ? this._classBreaksFromGenRend(e2) : this._classBreaksFromInterpolation(e2)).catch(() => (s2(e2.signal), this._classBreaksFromMemory(e2)));
  }
  async queryFeatureCount(e2) {
    if (this._hasLocalSource) throw new s(`${this.adapterName}:not-supported`, "Layer does not support count query");
    const t3 = this.layer, r5 = t3.createQuery();
    return r5.where = U2(r5.where, e2.whereClause), A(r5, e2.filter), t3.queryFeatureCount(r5, { signal: e2.signal });
  }
  async generateRenderer(e2, t3) {
    var _a;
    const r5 = this.layer;
    if (this._hasLocalSource || r5.version < 10.1) throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");
    const s7 = r5.createQuery();
    return e2.where = U2(e2.where, s7.where), l3(((_a = r5.parsedUrl) == null ? void 0 : _a.path) ?? "", { source: r5.dynamicDataSource ?? void 0, gdbVersion: r5.gdbVersion ?? void 0 }, e2, { signal: t3 });
  }
  async predominantCategories(e2) {
    if (!this._hasLocalSource && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support advanced SQL expressions and standardized queries");
    const { fields: t3, view: r5, signal: s7, filter: a5 } = e2, o5 = s5(t3), n7 = u3(t3), l5 = r5 && this._hasLocalSource ? await this._uvFromMemory({ valueExpression: o5, view: r5, signal: s7, filter: a5 }) : await this._uvFromServiceQuery({ sqlExpression: n7.expression, valueExpression: o5, signal: s7, filter: a5 });
    return Q(l5.uniqueValueInfos, t3);
  }
  async getSampleFeatures(e2, i5) {
    var _a, _b;
    const { view: a5, requiredFields: o5, returnGeometry: n7, filter: l5, signal: u7 } = e2, m10 = e2.sampleSize;
    if (null == m10 || 0 === m10) return [];
    const c7 = this.layer.createQuery(), h2 = 1, p9 = "json" === i5;
    c7.outSpatialReference = a5 == null ? void 0 : a5.spatialReference, c7.returnGeometry = !!n7, c7.outFields = o5, A(c7, l5);
    let d7 = [], f4 = false;
    if (a5) try {
      const s7 = await a5.whenLayerView(this.layer);
      if (f4 = !z3(this, o5, s7).length, f4) {
        if (m10 >= 1 && !e2.filter && "getSampleFeatures" in s7) {
          await this._waitForLayerViewUpdate(s7);
          const e3 = await s7.getSampleFeatures({ minFeatureCount: m10, sampleSize: m10 });
          if (null != e3) return p9 ? e3 : e3.map((e4) => b3.fromJSON(e4));
        }
        if (d7 = await this._fetchFeaturesFromMemory(s7, c7, u7, i5), d7.length >= m10 && m10 > 0) return z(d7, m10, h2);
      }
    } catch (y2) {
      s2(u7);
    }
    try {
      if (this._hasLocalSource) return f4 ? d7 : p9 ? await this._fetchFeaturesJSONFromService(c7, u7) : await this._fetchFeaturesFromService(c7, u7);
      const t3 = await this.queryFeatureCount({ view: a5, filter: l5, signal: u7 }), i6 = this.layer.capabilities.query.maxRecordCount;
      let s7 = -1 === m10 ? t3 : m10;
      if (s7 = i6 && s7 > i6 ? i6 : s7, t3 <= d7.length || d7.length >= i6) return d7;
      if (c7.maxAllowableOffset = e2.resolution || (a5 ? a5.extent.width / a5.width / a5.scale : at(this.layer.spatialReference)) * H2, t3 <= s7) return p9 ? await this._fetchFeaturesJSONFromService(c7, u7) : await this._fetchFeaturesFromService(c7, u7);
      if (t3 <= W2) {
        const e3 = this.layer.createQuery();
        A(e3, l5);
        const t4 = await this.layer.queryObjectIds();
        return c7.objectIds = z(t4, s7, h2), p9 ? await this._fetchFeaturesJSONFromService(c7, u7) : await this._fetchFeaturesFromService(c7, u7);
      }
      return ((_b = (_a = this.layer.capabilities) == null ? void 0 : _a.query) == null ? void 0 : _b.supportsPagination) && (c7.num = Math.min(s7, W2)), p9 ? await this._fetchFeaturesJSONFromService(c7, u7) : await this._fetchFeaturesFromService(c7, u7);
    } catch (y2) {
      return s2(u7), d7;
    }
  }
  load(e2) {
    const t3 = this.layer.load(e2).then(async (t4) => {
      var _a, _b;
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = (_b = (_a = t4.capabilities) == null ? void 0 : _a.query) == null ? void 0 : _b.supportsSqlExpression, this._hasLocalSource = !t4.url && !!t4.source, this.hasQueryEngine = this._hasLocalSource, this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = t4.fullExtent, this.workerClient = n5.getInstance(), await this.workerClient.open(e2.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
function K(e2, t3, r5) {
  const i5 = [], s7 = t3.length;
  return t3.forEach((t4, a5) => {
    const [o5, n7] = t4;
    let l5 = null;
    l5 = 0 !== a5 || r5 ? a5 !== s7 - 1 || r5 ? U2(`${e2} >= ${o5}`, `${e2} ${a5 === s7 - 1 ? " <= " : " < "} ${n7}`) : `${e2} >= ${o5}` : `${e2} < ${n7}`, i5.push("WHEN (" + l5 + ") THEN " + (a5 + 1));
  }), ["CASE", i5.join(" "), "ELSE 0", "END"].join(" ");
}
r([m({ readOnly: true })], Z2.prototype, "adapterName", void 0), r([m({ constructOnly: true })], Z2.prototype, "layer", void 0), Z2 = r([a("esri.smartMapping.support.adapters.FeatureLayerAdapter")], Z2);
var X = Z2;

// node_modules/@arcgis/core/smartMapping/support/adapters/CSVLayerAdapter.js
var m8 = class extends X {
  constructor() {
    super(...arguments), this.adapterName = "csv-layer-adapter";
  }
  async _createGenerateRendererResult(e2, r5, i5, n7, l5) {
    const p9 = e2 == null ? void 0 : e2.features, c7 = p9 == null ? void 0 : p9.length;
    if (!c7) throw new s("csv-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    const m10 = T4(p9);
    let d7 = null;
    if ("percent-of-total" === n7) {
      if (d7 = (await this.workerClient.summaryStatistics({ field: r5 }, m10)).sum, null == d7) throw new s("csv-layer-adapter:invalid", "invalid normalizationTotal");
    }
    if ("class-breaks-definition" === (l5 == null ? void 0 : l5.type)) {
      const e3 = (await b({ field: r5, normalizationType: n7, normalizationField: i5, normalizationTotal: d7 }, m10)).filter((e4) => Number.isFinite(e4));
      return a2({ definition: l5, values: e3, normalizationTotal: d7 });
    }
    const f4 = (await b({ field: r5 }, m10)).filter((e3) => null != e3 && "string" == typeof e3 && "" !== e3.trim());
    return n3(f4);
  }
  generateRenderer(e2, t3) {
    const r5 = e2.classificationDefinition;
    let i5 = null, s7 = null, o5 = null;
    "class-breaks-definition" === (r5 == null ? void 0 : r5.type) ? (i5 = r5.classificationField, s7 = r5.normalizationField, o5 = r5.normalizationType) : i5 = r5 == null ? void 0 : r5.attributeField;
    const a5 = this.layer;
    return U({ field: i5, normalizationField: s7 }).then((l5) => {
      const p9 = a5.createQuery();
      return p9.returnGeometry = false, p9.outFields = l5, p9.where = U2(p9.where, e2.where), a5.queryFeatures(p9, { signal: t3 }).then((e3) => this._createGenerateRendererResult(e3, i5, s7, o5, r5));
    });
  }
  load(e2) {
    const t3 = this.layer.load(e2).then(async (t4) => {
      this.geometryType = t4.geometryType, this.objectIdField = t4.objectIdField, this.supportsSQLExpression = true, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n5.getInstance(), await this.workerClient.open(e2.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], m8.prototype, "adapterName", void 0), m8 = r([a("esri.smartMapping.support.adapters.CSVLayerAdapter")], m8);
var d5 = m8;

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerBinningAdapter.js
var N3 = class extends X {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-binning-adapter";
  }
  async _getNormalizationTotalFromMemory(e2, t3, r5) {
    const { featuresJSON: i5, graphics: s7, layerView: o5, query: n7 } = t3, l5 = { include: ["sum"] }, m10 = (!i5 && !s7 && o5 && "queryAggregateSummaryStatistics" in o5 ? await o5.queryAggregateSummaryStatistics(n7, { field: e2, outStatisticTypes: l5 }, { signal: r5 }) : i5 ? await this.workerClient.summaryStatistics({ field: e2 }, i5) : await d2({ attribute: { field: e2, outStatisticTypes: l5 }, features: s7 })).sum;
    if (null == m10) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return m10;
  }
  async _processStatsFromMemoryParams(e2) {
    const { features: t3, filter: r5 } = e2;
    if (t3 == null ? void 0 : t3.length) return this._getFilteredFeatures(t3, r5);
    const { view: i5, field: s7, field2: o5, field3: n7, normalizationField: l5, valueExpression: u7, returnGeometry: m10, layerViewFunc: p9, signal: g4 } = e2;
    let d7 = null, y2 = null, f4 = null, h2 = null, w3 = null;
    if (i5) try {
      if (d7 = await i5.whenLayerView(this.layer), y2 = null != p9 && p9 in d7 && "function" == typeof d7[p9], y2) {
        await this._waitForLayerViewUpdate(d7);
        const e3 = await U({ field: s7, field2: o5, field3: n7, normalizationField: l5, valueExpression: u7 });
        V(this, e3).length ? y2 = false : (f4 = "createAggregateQuery" in d7 ? d7.createAggregateQuery() : null, f4 ? (f4.outFields = e3, f4.returnGeometry = false, A(f4, r5)) : y2 = false), d7.suspended && (y2 = false);
      }
    } catch {
      y2 = false;
    }
    if (!y2 && (w3 = P3(this.layer).map((e3) => e3.toJSON()), h2 = await this._fetchFeaturesForStats({ field: s7, field2: o5, field3: n7, valueExpression: u7, normalizationField: l5, returnGeometry: m10, filter: r5, view: i5, signal: g4 }, "json"), !(h2 == null ? void 0 : h2.length))) throw new s(`${this.adapterName}:insufficient-data`, "No features are available to calculate statistics");
    return { layerView: d7, query: f4, featuresJSON: h2, fieldInfos: w3 };
  }
  async _summaryStatsFromMemory(e2, t3) {
    const { view: a5, field: r5, valueExpression: i5, normalizationType: s7, signal: n7 } = e2, l5 = { field: r5, valueExpression: i5, normalizationType: s7, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, outStatisticTypes: e2.outStatisticTypes }, { featuresJSON: m10, graphics: p9, layerView: g4, query: d7, fieldInfos: y2 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryAggregateSummaryStatistics" });
    return i5 && a5 && (m10 || p9) && (l5.fieldType = (t3 == null ? void 0 : t3.type) ? i.toJSON(t3.type) : null, l5.viewInfoParams = B(a5), l5.timeZone = a5.timeZone, l5.fieldInfos = y2), "percent-of-total" === s7 && null == e2.normalizationTotal && (l5.normalizationTotal = await this._getNormalizationTotalFromMemory(r5, { featuresJSON: m10, graphics: p9, layerView: g4, query: d7 }, n7)), !m10 && !p9 && g4 && "queryAggregateSummaryStatistics" in g4 ? g4.queryAggregateSummaryStatistics(d7, l5, { signal: n7 }) : m10 ? this.workerClient.summaryStatistics(l5, m10) : d2({ attribute: l5, features: p9 });
  }
  async _uvFromMemory(e2, t3) {
    const { view: a5, field: r5, valueExpression: i5, returnAllCodedValues: s7, signal: o5 } = e2, { featuresJSON: n7, graphics: l5, layerView: u7, query: p9, fieldInfos: g4 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryAggregateUniqueValues" }), d7 = { field: r5, field2: e2.field2, field3: e2.field3, fieldDelimiter: f, valueExpression: i5, domains: t3, returnAllCodedValues: s7 };
    return i5 && a5 && (n7 || l5) && (d7.viewInfoParams = B(a5), d7.timeZone = a5.timeZone, d7.fieldInfos = g4), !n7 && !l5 && u7 && "queryAggregateUniqueValues" in u7 ? u7.queryAggregateUniqueValues(p9, d7, { signal: o5 }) : n7 ? this.workerClient.uniqueValues(d7, n7) : p3({ attribute: d7, features: l5 });
  }
  async _histogramFromMemory(e2) {
    const { view: t3, field: a5, valueExpression: r5, signal: i5 } = e2, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5, fieldInfos: u7 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryAggregateHistogram" }), m10 = { field: a5, valueExpression: r5, normalizationType: e2.normalizationType, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, standardDeviationInterval: e2.standardDeviationInterval, classificationMethod: e2.classificationMethod, numBins: e2.numBins };
    return r5 && t3 && (s7 || o5) && (m10.viewInfoParams = B(t3), m10.timeZone = t3.timeZone, m10.fieldInfos = u7), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5 }, i5)), !s7 && !o5 && n7 && "queryAggregateHistogram" in n7 ? n7.queryAggregateHistogram(l5, m10, { signal: i5 }) : s7 ? this.workerClient.histogram(m10, s7) : v({ attribute: m10, features: o5 });
  }
  async _classBreaksFromMemory(e2) {
    const { view: t3, field: a5, valueExpression: r5, signal: i5 } = e2, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5, fieldInfos: u7 } = await this._processStatsFromMemoryParams({ ...e2, layerViewFunc: "queryAggregateClassBreaks" }), m10 = { field: a5, valueExpression: r5, normalizationType: e2.normalizationType, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, standardDeviationInterval: e2.standardDeviationInterval, classificationMethod: e2.classificationMethod, numClasses: e2.numClasses };
    return r5 && t3 && (s7 || o5) && (m10.viewInfoParams = B(t3), m10.timeZone = t3.timeZone, m10.fieldInfos = u7), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: s7, graphics: o5, layerView: n7, query: l5 }, i5)), !s7 && !o5 && n7 && "queryAggregateClassBreaks" in n7 ? n7.queryAggregateClassBreaks(l5, m10, { signal: i5 }) : s7 ? this.workerClient.classBreaks(m10, s7) : c2({ attribute: m10, features: o5 });
  }
  getField(e2 = "") {
    const t3 = P3(this.layer);
    return t3 == null ? void 0 : t3.find((t4) => t4.name.toLowerCase() === (e2 == null ? void 0 : e2.toLowerCase()));
  }
  getFieldUsageInfo(e2) {
    return this.getField(e2) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: false, supportsStatistics: true } : null;
  }
  getFieldDomain(e2, t3) {
    return null;
  }
  async summaryStatistics(e2) {
    const { field: t3 } = e2, r5 = t3 ? this.getField(t3) : null, i5 = $(r5) || xe(r5), s7 = e2.sqlExpression && !e2.valueExpression && !t3;
    if (i5 || s7) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._summaryStatsFromMemory(e2, r5);
  }
  async uniqueValues(e2) {
    const t3 = await I(e2, this);
    return this._uvFromMemory(e2, t3);
  }
  async histogram(e2) {
    const { field: t3 } = e2, r5 = t3 ? this.getField(t3) : null, i5 = $(r5) || xe(r5), s7 = e2.sqlExpression && !e2.valueExpression && !t3;
    if (i5 || s7) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._histogramFromMemory(e2);
  }
  async classBreaks(e2) {
    return (false !== e2.analyzeData ? this._classBreaksFromMemory(e2) : this._classBreaksFromInterpolation(e2)).catch(() => (s2(e2.signal), this._classBreaksFromMemory(e2)));
  }
  async queryFeatureCount(e2) {
    var _a;
    const t3 = await ((_a = e2.view) == null ? void 0 : _a.whenLayerView(this.layer));
    if (!t3 || !("queryAggregateCount" in t3) || !t3.queryAggregateCount) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(t3);
    const r5 = t3.createAggregateQuery();
    return r5.where = U2(r5.where, e2.whereClause), A(r5, e2.filter), t3.queryAggregateCount(r5, { signal: e2.signal });
  }
  generateRenderer(e2, t3) {
    throw new s(`${this.adapterName}:not-supported`, "'generateRenderer' is not supported.");
  }
  heatmapStatistics(e2) {
    throw new s(`${this.adapterName}:not-supported`, "'heatmapStatistics' is not supported.");
  }
  async predominantCategories(e2) {
    const { fields: t3, view: a5, signal: r5 } = e2, i5 = s5(t3), s7 = await this._uvFromMemory({ valueExpression: i5, view: a5, signal: r5 });
    return Q(s7.uniqueValueInfos, t3);
  }
  async getSampleFeatures(e2, r5) {
    const { view: i5, sampleSize: s7, requiredFields: o5, returnGeometry: n7, filter: l5, signal: u7 } = e2;
    if (!i5) throw new s(`${this.adapterName}:not-supported`, "'view' is required to get sample features for binning.");
    if ("3d" === i5.type) throw new s(`${this.adapterName}:not-supported`, "3d 'view' is not supported to get sample features for binning.");
    const m10 = await i5.whenLayerView(this.layer);
    if (!("queryAggregateJSON" in m10 && m10.queryAggregateJSON && "queryAggregates" in m10 && m10.queryAggregates)) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(m10);
    if (V(this, o5).length) throw new s(`${this.adapterName}:insufficient-data`, "Layer does not have required fields");
    const p9 = 1, g4 = "json" === r5, d7 = m10.createAggregateQuery();
    d7.outSpatialReference = i5 == null ? void 0 : i5.spatialReference, d7.returnGeometry = !!n7, d7.outFields = o5, A(d7, l5);
    const { features: y2 } = g4 ? await m10.queryAggregateJSON(d7, { signal: u7 }) : await m10.queryAggregates(d7, { signal: u7 });
    return y2.length && null != s7 && s7 > 0 && s7 <= y2.length ? z(y2, s7, p9) : y2;
  }
  load(e2) {
    const t3 = this.layer.load(e2).then(async (t4) => {
      this.geometryType = "polygon", this.objectIdField = null, this.supportsSQLExpression = false, this._hasLocalSource = false, this.hasQueryEngine = true, this.minScale = t4.minScale, this.maxScale = t4.maxScale, this.fullExtent = t4.fullExtent;
      const r5 = "featureReduction" in t4 ? t4.featureReduction : null;
      if ("binning" !== (r5 == null ? void 0 : r5.type) && "cluster" !== (r5 == null ? void 0 : r5.type)) throw new s(`${this.adapterName}:invalid-parameters`, `Feature reduction type ${r5 == null ? void 0 : r5.type} is not supported`);
      this.workerClient = n5.getInstance(), await this.workerClient.open(e2.signal);
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], N3.prototype, "adapterName", void 0), N3 = r([a("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")], N3);
var T5 = N3;

// node_modules/@arcgis/core/smartMapping/support/adapters/SceneLayerAdapter.js
var A2 = class extends s6 {
  constructor(e2) {
    super(e2), this._featureLayerAdapter = null, this.workerClient = null, this.adapterName = "scene-layer-adapter";
  }
  destroy() {
    var _a;
    (_a = this.workerClient) == null ? void 0 : _a.destroy();
  }
  _hasCachedStatistics(e2) {
    return this.layer.hasCachedStatistics(e2);
  }
  _updateQuery(e2, t3 = [], r5 = []) {
    if (!e2 || !r5.length) return e2;
    const a5 = this.layer.objectIdField, s7 = e2.clone(), i5 = t3.filter((e3) => {
      const t4 = this.layer.getField(e3);
      return !r5.includes(t4.name);
    }), o5 = i5.some((e3) => this.layer.getField(e3).name === a5);
    return s7.outFields = o5 ? i5 : [...i5, a5], s7;
  }
  async _fetchFeaturesFromMemory(e2, t3, r5) {
    if (!e2) throw new s("scene-layer-adapter:insufficient-data", "view is required to fetch the features from layerView");
    const n7 = await e2.whenLayerView(this.layer), l5 = new AbortController(), u7 = l5.signal, p9 = w(() => !n7.updating, u7);
    await T(p9, 5e3, l5);
    const m10 = z3(this, r5, n7);
    s2(u7);
    const c7 = this._updateQuery(t3, r5 ?? [], m10), d7 = await n7.queryFeatures(c7, { signal: u7 });
    s2(u7);
    const h2 = d7.features;
    return m10.length ? n7.whenGraphicAttributes(h2, m10) : h2;
  }
  async _fetchFeaturesJSONFromMemory(e2, t3, r5) {
    return this._fetchFeaturesFromMemory(e2, t3, r5).then(T4);
  }
  _fetchFeaturesForStats(e2, t3) {
    return U({ field: e2.field, normalizationField: e2.normalizationField, valueExpression: e2.valueExpression }).then((r5) => this.getSampleFeatures({ sampleSize: -1, view: e2.view, returnGeometry: e2.returnGeometry, requiredFields: r5, signal: e2.signal }, t3));
  }
  async _processStatsFromMemoryParams(e2) {
    const t3 = e2.features;
    if (t3 == null ? void 0 : t3.length) {
      return t3.length && "declaredClass" in t3[0] && "esri.Graphic" === t3[0].declaredClass ? { graphics: t3 } : { featuresJSON: t3 };
    }
    const { view: r5, field: s7, normalizationField: i5, valueExpression: o5, signal: n7 } = e2, l5 = await this._fetchFeaturesForStats({ field: s7, valueExpression: o5, normalizationField: i5, view: r5, signal: n7 }, null);
    if (!(l5 == null ? void 0 : l5.length)) throw new s("scene-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    return { graphics: l5 };
  }
  _getCachedStatistics(e2, t3) {
    const r5 = this.layer;
    return e2.valueExpression || e2.sqlExpression || e2.sqlWhere || e2.minValue || e2.maxValue ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")) : r5.queryCachedStatistics(t3 == null ? void 0 : t3.name, { signal: e2.signal }).then((e3) => {
      const t4 = e3.stats, { min: r6, max: a5, totalValuesCount: s7 } = t4;
      let { avg: i5, stddev: o5, sum: n7, variance: l5, count: u7 } = t4;
      return 0 === r6 && 0 === a5 || (i5 = 0 === i5 ? null : i5, n7 = 0 === n7 ? null : n7, o5 = 0 === o5 ? null : o5, l5 = 0 === l5 ? null : l5, u7 = 0 === u7 ? null : u7), null == u7 && (null != n7 && null != i5 ? u7 = Math.round(n7 / i5) : null != s7 && (u7 = s7)), { avg: i5, count: u7, max: a5, min: r6, stddev: o5, sum: n7, variance: l5 };
    });
  }
  async _getNormalizationTotal(e2, t3, r5) {
    const s7 = { include: ["sum"] }, i5 = (t3 ? await this.workerClient.summaryStatistics({ field: e2, outStatisticTypes: s7 }, t3) : await d2({ attribute: { field: e2, outStatisticTypes: s7 }, features: r5 })).sum;
    if (null == i5) throw new s("scene-layer-adapter:invalid", "invalid normalizationTotal");
    return i5;
  }
  async _getSummaryStatisticsFromMemory(e2, t3) {
    const { view: r5, field: a5, normalizationField: s7, valueExpression: i5 } = e2, { featuresJSON: o5, graphics: n7 } = await this._processStatsFromMemoryParams(e2), l5 = { field: a5, valueExpression: i5, normalizationType: e2.normalizationType, normalizationField: s7, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, outStatisticTypes: e2.outStatisticTypes };
    return e2.valueExpression && r5 && o5 && (l5.fieldType = (t3 == null ? void 0 : t3.type) ? i.toJSON(t3.type) : null, l5.viewInfoParams = B(r5), l5.timeZone = r5.timeZone), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (l5.normalizationTotal = await this._getNormalizationTotal(a5, o5, n7)), o5 ? this.workerClient.summaryStatistics(l5, o5) : d2({ attribute: l5, features: n7 });
  }
  _getCachedStatisticsForUniqueValues(e2, r5) {
    const s7 = this.layer, i5 = r5 == null ? void 0 : r5.name, o5 = r5 && e2.field ? this.getFieldDomain(e2.field) : null;
    return e2.valueExpression || e2.sqlExpression || e2.sqlWhere ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")) : s7.queryCachedStatistics(i5, { signal: e2.signal }).then((a5) => {
      var _a;
      const o6 = a5.stats;
      if (!o6.mostFrequentValues) throw new Error();
      const n7 = (_a = a5.labels) == null ? void 0 : _a.labels, l5 = {}, u7 = [], c7 = "countOF" + i5;
      o6.mostFrequentValues.forEach((e3) => {
        const a6 = new b3({ attributes: {} });
        a6.attributes[i5] = r5 && r5.name !== s7.objectIdField && (ge(r5) || $(r5)) ? Number(e3.value) : e3.value, a6.attributes[c7] = e3.count, u7.push(a6);
      }), n7 && n7.forEach((e3) => {
        l5[e3.value] = e3.label;
      });
      const d7 = new d3({ features: u7 });
      return L(d7, { layer: this, field: e2.field, labels: l5, view: e2.view, signal: e2.signal });
    }).then((t3) => $2(t3, [o5], e2.returnAllCodedValues));
  }
  async _getUniqueValuesFromMemory(e2, t3) {
    const { view: r5, field: a5, field2: s7, field3: i5, valueExpression: o5, returnAllCodedValues: n7 } = e2, l5 = { field: a5, field2: s7, field3: i5, fieldDelimiter: f, valueExpression: o5, domains: t3, returnAllCodedValues: n7 }, { featuresJSON: u7, graphics: p9 } = await this._processStatsFromMemoryParams(e2);
    return e2.valueExpression && r5 && u7 && (l5.viewInfoParams = B(r5), l5.timeZone = r5.timeZone), u7 ? this.workerClient.uniqueValues(l5, u7) : p3({ attribute: l5, features: p9 });
  }
  _getCachedStatisticsForHistogram(e2, t3) {
    const r5 = this.layer;
    return e2.valueExpression || e2.sqlExpression || e2.sqlWhere || e2.normalizationType ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")) : r5.queryCachedStatistics(t3 && t3.name, { signal: e2.signal }).then((t4) => {
      const r6 = t4.stats, { minValue: a5, maxValue: s7 } = e2, i5 = null != a5 ? a5 : r6.min, o5 = null != s7 ? s7 : r6.max, n7 = e2.numBins || 10, l5 = j5(r6.histogram, i5, o5, n7);
      return O(l5, i5, o5, n7);
    });
  }
  async _getClassBreaksFromMemory(e2) {
    const { view: t3, field: r5, normalizationField: a5, valueExpression: s7 } = e2, { featuresJSON: i5, graphics: o5 } = await this._processStatsFromMemoryParams(e2), n7 = { field: r5, valueExpression: s7, normalizationType: e2.normalizationType, normalizationField: a5, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, standardDeviationInterval: e2.standardDeviationInterval, classificationMethod: e2.classificationMethod, numClasses: e2.numClasses };
    return e2.valueExpression && t3 && i5 && (n7.viewInfoParams = B(t3), n7.timeZone = t3.timeZone), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (n7.normalizationTotal = await this._getNormalizationTotal(r5, i5, o5)), i5 ? this.workerClient.classBreaks(n7, i5) : c2({ attribute: n7, features: o5 });
  }
  async _getHistogramFromMemory(e2) {
    const { view: t3, field: r5 } = e2, { featuresJSON: a5, graphics: s7 } = await this._processStatsFromMemoryParams(e2), i5 = { field: r5, valueExpression: e2.valueExpression, normalizationType: e2.normalizationType, normalizationField: e2.normalizationField, normalizationTotal: e2.normalizationTotal, minValue: e2.minValue, maxValue: e2.maxValue, standardDeviationInterval: e2.standardDeviationInterval, classificationMethod: e2.classificationMethod, numBins: e2.numBins };
    return e2.valueExpression && t3 && a5 && (i5.viewInfoParams = B(t3), i5.timeZone = t3.timeZone), "percent-of-total" === e2.normalizationType && null == e2.normalizationTotal && (i5.normalizationTotal = await this._getNormalizationTotal(r5, a5, s7)), a5 ? this.workerClient.histogram(i5, a5) : v({ attribute: i5, features: s7 });
  }
  getField(e2) {
    return this.layer.getField(e2 ?? "");
  }
  getFieldUsageInfo(e2) {
    const t3 = this.getField(e2);
    if (!t3) return null;
    const r5 = this.layer.getFieldUsageInfo(t3.name);
    return { supportsLabelingInfo: r5.supportsLabelingInfo, supportsPopupTemplate: r5.supportsPopupTemplate, supportsRenderer: r5.supportsRenderer, supportsLayerQuery: r5.supportsLayerQuery, supportsStatistics: true };
  }
  getFieldDomain(e2, t3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.getFieldDomain(e2, t3) : null;
  }
  createQuery() {
    return this.layer.createQuery();
  }
  summaryStatistics(e2) {
    const t3 = this.getField(e2.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.summaryStatistics(e2);
    if (e2.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t3 == null ? void 0 : t3.name) ? this._getCachedStatistics(e2, t3).catch(() => (s2(e2.signal), this._getSummaryStatisticsFromMemory(e2, t3))) : this._getSummaryStatisticsFromMemory(e2, t3);
  }
  async uniqueValues(e2) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.uniqueValues(e2);
    if (e2.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const t3 = await I(e2, this), { field: r5, field2: s7 } = e2, o5 = r5 && s7, n7 = this.getField(r5);
    return !o5 && n7 && this._hasCachedStatistics(n7.name) ? this._getCachedStatisticsForUniqueValues(e2, n7).catch(() => (s2(e2.signal), this._getUniqueValuesFromMemory(e2, t3))) : this._getUniqueValuesFromMemory(e2, t3);
  }
  histogram(e2) {
    const t3 = this.getField(e2.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.histogram(e2);
    if (e2.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return t3 && this._hasCachedStatistics(t3.name) ? this._getCachedStatisticsForHistogram(e2, t3).catch(() => (s2(e2.signal), this._getHistogramFromMemory(e2))) : this._getHistogramFromMemory(e2);
  }
  classBreaks(e2) {
    const t3 = this.getField(e2.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.classBreaks(e2);
    if (e2.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t3 == null ? void 0 : t3.name) ? Promise.reject(new s("scene-layer-adapter:not-supported", "Cached stats not supported")) : this._getClassBreaksFromMemory(e2);
  }
  queryFeatureCount(e2) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.queryFeatureCount(e2) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support count query"));
  }
  generateRenderer(e2, t3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.generateRenderer(e2, t3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support generateRenderer operation"));
  }
  heatmapStatistics(e2) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.heatmapStatistics(e2) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"));
  }
  async predominantCategories(e2) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.predominantCategories(e2);
    throw new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support predominantCategories");
  }
  async getSampleFeatures(e2, t3) {
    if (e2.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const { view: s7, sampleSize: o5, requiredFields: n7, returnGeometry: l5, signal: u7 } = e2, p9 = 1, m10 = "json" === t3, c7 = this.createQuery();
    c7.outFields = n7, c7.returnGeometry = !!l5, c7.where = null, c7.num = o5;
    let d7 = [];
    try {
      if (d7 = m10 ? await this._fetchFeaturesJSONFromMemory(s7, c7, n7) : await this._fetchFeaturesFromMemory(s7, c7, n7), d7.length && null != o5 && o5 > 0 && o5 <= d7.length) return z(d7, o5, p9);
    } catch (y2) {
      s2(u7);
    }
    let h2 = null;
    if (this._featureLayerAdapter) {
      const r5 = { ...e2 };
      delete r5.view, h2 = await this._featureLayerAdapter.getSampleFeatures(r5, t3);
    }
    return (h2 == null ? void 0 : h2.length) ? h2 : z(d7, d7.length, p9);
  }
  load(e2) {
    const t3 = this.layer.load(e2).then(async (t4) => {
      this.workerClient = n5.getInstance(), await this.workerClient.open(e2.signal);
      const r5 = t4.associatedLayer;
      if (this.geometryType = t4.geometryType, null != r5) {
        this._featureLayerAdapter = new X({ layer: r5 });
        return this._featureLayerAdapter.load(e2).then(() => {
          this.objectIdField = this._featureLayerAdapter.objectIdField, this.supportsSQLExpression = this._featureLayerAdapter.supportsSQLExpression, this.minScale = this._featureLayerAdapter.minScale, this.maxScale = this._featureLayerAdapter.maxScale, this.fullExtent = this._featureLayerAdapter.fullExtent;
        });
      }
      this.objectIdField = t4.objectIdField, this.supportsSQLExpression = false, this.hasQueryEngine = false, this.fullExtent = t4.fullExtent;
    });
    return this.addResolvingPromise(t3), Promise.resolve(this);
  }
};
function j5(e2, r5 = e2.minimum, a5 = e2.maximum, s7) {
  const i5 = [];
  for (let t3 = 0; t3 < s7; t3++) i5[t3] = 0;
  const o5 = e2.counts.length, n7 = e2.minimum, l5 = e2.maximum;
  for (let t3 = 0; t3 < o5; t3++) {
    const u8 = (t3 + 0.5) / o5, p9 = ((1 - u8) * n7 + u8 * l5 - r5) / (a5 - r5) * s7;
    p9 >= 0 && p9 <= s7 && (i5[p9 === s7 ? s7 - 1 : Math.floor(p9)] += e2.counts[t3]);
  }
  const u7 = [];
  return i5.forEach((e3, r6) => {
    const a6 = new b3({ attributes: {} });
    a6.attributes.EXPR_1 = r6 + 1, a6.attributes.countOFExpr = e3, u7.push(a6);
  }), new d3({ features: u7 });
}
r([m({ readOnly: true })], A2.prototype, "adapterName", void 0), r([m({ constructOnly: true })], A2.prototype, "layer", void 0), A2 = r([a("esri.smartMapping.support.adapters.SceneLayerAdapter")], A2);
var V3 = A2;

// node_modules/@arcgis/core/smartMapping/support/adapters/PointCloudLayerAdapter.js
var o4 = class extends V3 {
  constructor(e2) {
    super(e2), this.adapterName = "point-cloud-layer-adapter";
  }
  getField(e2) {
    return this.layer.fieldsIndex.get(e2 ?? "");
  }
  getFieldUsageInfo(e2) {
    const r5 = this.getField(e2);
    if (!r5) return null;
    const t3 = this._hasCachedStatistics(r5.name);
    return { supportsLabelingInfo: t3, supportsPopupTemplate: t3, supportsRenderer: t3, supportsLayerQuery: false, supportsStatistics: t3 };
  }
  getFieldDomain() {
    return null;
  }
  load(e2) {
    const r5 = this.layer.load(e2).then(() => {
      this.geometryType = "point", this.objectIdField = null, this.supportsSQLExpression = false, this.hasQueryEngine = false;
    });
    return this.addResolvingPromise(r5), Promise.resolve(this);
  }
};
r([m({ readOnly: true })], o4.prototype, "adapterName", void 0), o4 = r([a("esri.smartMapping.support.adapters.PointCloudLayerAdapter")], o4);
var p7 = o4;

// node_modules/@arcgis/core/smartMapping/support/adapters/StreamLayerAdapter.js
var c6 = class extends D3 {
  constructor() {
    super(...arguments), this.adapterName = "stream-layer-adapter";
  }
  async _summaryStatsFromClientQuery(t3, r5) {
    var _a;
    const { signal: s7, view: a5 } = t3, c7 = k2(this, t3, r5);
    c7.outStatistics = (_a = c7.outStatistics) == null ? void 0 : _a.filter((t4) => "totalcount_value" !== t4.outStatisticFieldName);
    const u7 = await this._fetchFeatureSetFromMemory(c7, a5, s7), l5 = $3(u7, $(r5) || xe(r5));
    return C(l5, t3.outStatisticTypes);
  }
};
r([m({ readOnly: true })], c6.prototype, "adapterName", void 0), c6 = r([a("esri.smartMapping.support.adapters.StreamLayerAdapter")], c6);
var u4 = c6;

// node_modules/@arcgis/core/smartMapping/support/adapters/support/layerUtils.js
var l4;
!function(e2) {
  e2[e2.CatalogLayer = 0] = "CatalogLayer", e2[e2.CatalogFootprintLayer = 1] = "CatalogFootprintLayer", e2[e2.CSVLayer = 2] = "CSVLayer", e2[e2.FeatureLayer = 3] = "FeatureLayer", e2[e2.GeoJSONLayer = 4] = "GeoJSONLayer", e2[e2.KnowledgeGraphSublayer = 5] = "KnowledgeGraphSublayer", e2[e2.OGCFeatureLayer = 6] = "OGCFeatureLayer", e2[e2.OrientedImageryLayer = 7] = "OrientedImageryLayer", e2[e2.ParquetLayer = 8] = "ParquetLayer", e2[e2.PointCloudLayer = 9] = "PointCloudLayer", e2[e2.SceneLayer = 10] = "SceneLayer", e2[e2.StreamLayer = 11] = "StreamLayer", e2[e2.SubtypeGroupLayer = 12] = "SubtypeGroupLayer", e2[e2.SubtypeSublayer = 13] = "SubtypeSublayer", e2[e2.WFSLayer = 14] = "WFSLayer";
}(l4 || (l4 = {}));
var u5 = { [l4.CatalogLayer]: { adapter: X, type: "catalog", label: "CatalogLayer" }, [l4.CatalogFootprintLayer]: { adapter: X, type: "catalog-footprint", label: "CatalogFootprintLayer" }, [l4.CSVLayer]: { adapter: d5, type: "csv", label: "CSVLayer" }, [l4.FeatureLayer]: { adapter: X, type: "feature", label: "FeatureLayer" }, [l4.GeoJSONLayer]: { adapter: X, type: "geojson", label: "GeoJSONLayer" }, [l4.KnowledgeGraphSublayer]: { adapter: X, type: "knowledge-graph-sublayer", label: "KnowledgeGraphSublayer" }, [l4.OGCFeatureLayer]: { adapter: D3, type: "ogc-feature", label: "OGCFeatureLayer" }, [l4.OrientedImageryLayer]: { adapter: X, type: "oriented-imagery", label: "OrientedImageryLayer" }, [l4.ParquetLayer]: { adapter: X, type: "parquet", label: "ParquetLayer" }, [l4.PointCloudLayer]: { adapter: p7, type: "point-cloud", label: "PointCloudLayer" }, [l4.SceneLayer]: { adapter: V3, type: "scene", label: "SceneLayer" }, [l4.StreamLayer]: { adapter: u4, type: "stream", label: "StreamLayer" }, [l4.SubtypeGroupLayer]: { adapter: X, type: "subtype-group", label: "SubtypeGroupLayer" }, [l4.SubtypeSublayer]: { adapter: X, type: "subtype-sublayer", label: "SubtypeSublayer" }, [l4.WFSLayer]: { adapter: X, type: "wfs", label: "WFSLayer" } };
var n6 = [l4.CatalogLayer, l4.CatalogFootprintLayer, l4.CSVLayer, l4.FeatureLayer, l4.GeoJSONLayer, l4.KnowledgeGraphSublayer, l4.OGCFeatureLayer, l4.OrientedImageryLayer, l4.ParquetLayer, l4.PointCloudLayer, l4.SceneLayer, l4.StreamLayer, l4.SubtypeGroupLayer, l4.SubtypeSublayer, l4.WFSLayer];
var S4 = [l4.CatalogFootprintLayer, l4.CSVLayer, l4.FeatureLayer, l4.GeoJSONLayer, l4.KnowledgeGraphSublayer, l4.OGCFeatureLayer, l4.OrientedImageryLayer, l4.ParquetLayer, l4.SceneLayer, l4.StreamLayer, l4.SubtypeGroupLayer, l4.SubtypeSublayer, l4.WFSLayer];
var d6 = [l4.CSVLayer, l4.FeatureLayer, l4.GeoJSONLayer, l4.OGCFeatureLayer, l4.KnowledgeGraphSublayer, l4.OrientedImageryLayer, l4.ParquetLayer, l4.StreamLayer, l4.WFSLayer];
function b6(e2) {
  return e2.map((e3) => u5[e3].label);
}
function m9(e2, a5 = n6, t3) {
  if (e2 instanceof s6) return e2;
  const o5 = g3(e2, a5);
  return o5 ? t3 ? new T5({ layer: e2 }) : new o5({ layer: e2 }) : null;
}
function g3(e2, a5 = n6) {
  let r5 = null;
  return a5.some((a6) => {
    const t3 = e2.type === u5[a6].type;
    return t3 && (r5 = u5[a6].adapter), t3;
  }), r5;
}

// node_modules/@arcgis/core/smartMapping/statistics/uniqueValues.js
async function u6(u7) {
  if (!(u7 == null ? void 0 : u7.layer) || !u7.field && !u7.valueExpression) throw new s("unique-values:missing-parameters", "'layer' and 'field' or 'valueExpression' parameters are required");
  const p9 = u7.valueExpression || u7.sqlExpression, f4 = p9 && !u7.sqlExpression;
  if (p9) {
    if (f4) {
      if (!u7.view) throw new s("unique-values:missing-parameters", "View is required when 'valueExpression' is specified");
    } else if (!u7.valueExpression) throw new s("unique-values:missing-parameters", "'valueExpression' parameters are required");
  }
  u7.forBinning && i2(u7, "unique-values");
  const { layer: m10, ...d7 } = u7, v2 = u7.forBinning ? d6 : n6, w3 = m9(m10, v2, u7.forBinning);
  if (!w3) throw new s("unique-values:invalid-parameters", "'layer' must be one of these types: " + b6(v2).join(", "));
  const c7 = { layerAdapter: w3, ...d7 }, q4 = null != c7.signal ? { signal: c7.signal } : null;
  await w3.load(q4);
  const x = await U({ field: c7.field, field2: c7.field2, field3: c7.field3, valueExpression: c7.valueExpression }), y2 = T2(w3, x, "unique-values:invalid-parameters");
  if (y2) throw y2;
  c7.filter && !c7.filter.spatialRelationship && (c7.filter.spatialRelationship = "intersects");
  const E3 = M2(c7.filter, "summary-statistics:invalid-parameters");
  if (E3) throw E3;
  return c7;
}
async function p8(e2) {
  const { layerAdapter: i5, ...s7 } = await u6(e2);
  return i5.uniqueValues(s7);
}
export {
  p8 as default
};
//# sourceMappingURL=uniqueValues-WXFI7TSR.js.map
