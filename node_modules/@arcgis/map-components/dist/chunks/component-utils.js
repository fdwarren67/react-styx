/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
v4.32.14 */
function P(e, i) {
  Array.isArray(i) ? e._watchHandles = [...e._watchHandles, ...i] : e._watchHandles.push(i);
}
function p(e) {
  e.el.childElem && (e.el.childElem.ownedBy = e.el);
  const i = h(e);
  if (!i) {
    const t = y(e.referenceElement);
    if (!t) {
      g(e);
      return;
    }
    return f(t, e, !0), t;
  }
  return w(i, e.el.parent) || (e.el.parent = i, i.tagName.toLowerCase() === "arcgis-expand" ? v(i, e) : i.tagName.toLowerCase() === "arcgis-placement" ? C(i, e) : f(i, e, !1)), i;
}
function h({ el: e }) {
  for (let i = e.parentElement; i; i = i?.parentElement ?? null) {
    if (c.has(i.tagName.toLowerCase()))
      return i;
    if ("ownedBy" in i && i.ownedBy instanceof HTMLElement && c.has(i.ownedBy.tagName.toLowerCase()))
      return i.ownedBy;
  }
}
const c = /* @__PURE__ */ new Set([
  "arcgis-map",
  "arcgis-scene",
  "arcgis-link-chart",
  "arcgis-expand",
  "arcgis-placement"
]);
function w(e, i) {
  if (e !== i)
    return !1;
  const t = e.tagName.toLowerCase();
  return t === "arcgis-expand" || t === "arcgis-placement";
}
function l(e, i, t = "arcgisReady") {
  const r = e;
  if (typeof r.view?.ready == "boolean")
    i(r.view);
  else {
    let s = function(d) {
      d.target === e && (l(e, i, t), e.removeEventListener(t, s));
    };
    e.addEventListener(t, s);
  }
}
const v = (e, i) => l(e, (t) => {
  i.el.childElem && e.content != null && e.content.append(i.el.childElem), e.expandIcon = i.icon || i.widget?.icon || e.expandIcon, i.position = e.position, i.el.view = t;
}), C = (e, i) => l(e, (t) => {
  i.el.childElem && i.el.append(i.el.childElem), i.position = e.position, i.el.view = t;
}), f = (e, i, t) => l(
  e,
  (r) => {
    t ? g(i) : i.el.childElem && E(e, i), i.el.view = r;
  },
  "arcgisViewReadyChange"
);
function E(e, i) {
  const t = i.el.childElem ?? i.el, r = [...e.children], s = {};
  for (const a of r) {
    const n = a.getAttribute("position") ?? "manual";
    s[n] ??= [], s[n].push({ child: a, position: n, index: r.indexOf(a) });
  }
  const d = s[i.position ?? "manual"]?.findIndex(({ child: a }) => a === i.el), o = e.view.ui;
  o.remove(t), o.add(t, { position: i.position, index: d });
}
function L(e) {
  let i = !1, t = e.el.view;
  const r = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e.el), "view") ?? {
    get: () => t,
    set: (s) => t = s
  };
  Object.defineProperty(e.el, "view", {
    get: r.get.bind(e.el),
    set: (s) => {
      r.set.call(e.el, s), s && !i && (i = !0, e.arcgisReady.emit());
    },
    configurable: !0,
    enumerable: !0
  }), t && (e.el.view = t);
}
function x(e) {
  return e == null || e === "";
}
function H(e, i) {
  return i != null && e?.position === i.position && e?.heading === i.heading && e?.tilt === i.tilt && e?.fov === i.fov;
}
function N(e, i) {
  return i === void 0 || e?.targetGeometry !== i?.targetGeometry || e?.rotation !== i?.rotation || e?.scale !== i?.scale;
}
function O(e, i) {
  return u(i?.center, e);
}
function u(e, i) {
  if (typeof i == "string")
    return u(e, i.split(",").map(Number));
  if (!e)
    return i;
  if (Array.isArray(i)) {
    const t = i[0], r = i[1], s = i.length > 2 ? i[2] : void 0;
    if (t !== e.longitude || r !== e.latitude || s !== e.z)
      return i;
  } else if (i && !e?.equals(i))
    return i;
}
async function S(e, i) {
  i != null && (typeof i == "string" ? e.el.view = await b(i) : e.widget && (e.el.view = i.view));
}
async function b(e) {
  const i = y(e);
  return await new Promise((t) => {
    typeof i?.view?.ready == "boolean" ? t(i.view) : i && i.addEventListener("arcgisViewReadyChange", () => t(i.view), { once: !0 });
  });
}
function g(e) {
  e.el.childElem && (e.el.shadowRoot ?? e.el).append(e.el.childElem);
}
function y(e) {
  return typeof e != "string" ? e ?? void 0 : (e.includes("#") || e.includes(".") || e.includes("[") ? void 0 : document.querySelector(`#${e}`)) ?? document.querySelector(e) ?? void 0;
}
export {
  p as a,
  P as b,
  H as c,
  L as d,
  O as e,
  x as f,
  N as i,
  u as p,
  S as r
};
