import { proxyExports as l, watch as h } from "@arcgis/components-controllers";
import { AccessorController as m } from "@arcgis/components-controllers/accessor";
import { a as o } from "./component-utils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
v4.32.14 */
const u = (n, e) => (i, t) => d(i, n, t);
class p extends m {
  hostConnected() {
    this.component.manager.loadedCalled && o(this.component);
  }
  async hostLoad() {
    await super.hostLoad(), !this.component.manager.destroyed && this._watchMetaProperties();
  }
  hostLoaded() {
    const { el: e } = this.component, i = e.shadowRoot?.firstElementChild ?? e.firstElementChild ?? void 0;
    e.childElem = i ?? e.childElem;
    let t = !1;
    const s = this.component.el.view;
    Object.defineProperty(this.component.el, "view", {
      get: () => this._instance.view,
      set: (c) => {
        const a = this.component.el.view, r = c;
        this._instance.view = r, this._instance.map = r?.map, this._watchViewDestroy(), this.component.requestUpdate("view", a), c && !t && (t = !0, this.component.arcgisReady.emit());
      },
      configurable: !0,
      enumerable: !0
    }), s && (this._instance.view = s), this.component.el.isConnected && (o(this.component), this._watchViewDestroy());
  }
  hostDisconnected() {
    typeof this.component.el.childElem == "object" && this.component.el.view?.ui?.remove(this.component.el.childElem);
  }
  hostDestroy() {
    super.hostDestroy(), this._watchViewDestroyHandle?.remove();
  }
  _watchMetaProperties() {
    h(this.component, "position", (e) => {
      this.component.el.childElem != null && typeof e == "string" && o(this.component);
    }), h(this.component, "referenceElement", () => o(this.component));
  }
  /**
   * Destroy the component if view gets destroyed.
   *
   * When view is destroyed, component disconnect is triggered, which will
   * destroy the component in 1s but that can be too late, because in the
   * meanwhile, a watcher on the widget/viewModel instance may get triggered,
   * and throw an error if it's not able to access this.view.map or etc
   * (happens in VersionManagementViewModel for example).
   *
   * We can't check for this in disconnectedCallback though as, if the entire
   * component tree is removed, the disconnect for the component will be
   * triggered before that of arcgis-map, so the view might not be destroyed
   * yet at that point.
   */
  _watchViewDestroy() {
    this._watchViewDestroyHandle?.remove(), this._watchViewDestroyHandle = this.reactiveUtils.when(
      () => this.component.el.view?.destroyed === !0,
      () => void this.component.destroy().catch(console.error),
      { sync: !0 }
    );
  }
}
const d = l(p);
export {
  u as m
};
